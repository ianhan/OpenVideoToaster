head	1.16;
access;
symbols;
locks; strict;
comment	@*@;


1.16
date	97.05.14.11.25.35;	author Holt;	state Exp;
branches;
next	1.15;

1.15
date	97.04.03.16.26.12;	author Holt;	state Exp;
branches;
next	1.14;

1.14
date	97.03.26.16.32.20;	author Holt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.05.16.41.54;	author Hayes;	state Exp;
branches;
next	1.12;

1.12
date	97.02.05.16.32.53;	author Hayes;	state Exp;
branches;
next	1.11;

1.11
date	97.01.09.14.14.15;	author Holt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.19.17.07.26;	author Holt;	state Exp;
branches;
next	1.9;

1.9
date	96.12.09.17.37.38;	author Holt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.16.10.24.09;	author Holt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.25.17.22.16;	author Holt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.02.14.46.40;	author Holt;	state Exp;
branches;
next	1.5;

1.5
date	95.11.21.11.30.42;	author Flick;	state Exp;
branches;
next	1.4;

1.4
date	95.11.13.13.59.41;	author Flick;	state Exp;
branches;
next	1.3;

1.3
date	95.10.10.01.36.41;	author Flick;	state Exp;
branches;
next	1.2;

1.2
date	95.09.07.09.21.51;	author Flick;	state Exp;
branches;
next	1.1;

1.1
date	95.08.15.16.47.10;	author Flick;	state Exp;
branches;
next	1.0;

1.0
date	95.05.04.17.17.45;	author Flick;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


1.16
log
@small changes only.
@
text
@/*********************************************************************\
*
* $AmiShar.c - Amiga(or Host)/Flyer shared RAM interface functions$
*
* $Id: amishar.c,v 1.15 1997/04/03 16:26:12 Holt Exp Holt $
*
* $Log: amishar.c,v $
*Revision 1.15  1997/04/03  16:26:12  Holt
*debug off
*
*Revision 1.14  1997/03/26  16:32:20  Holt
*added more High Speed multi-block read/write code.
*
*Revision 1.13  1997/02/05  16:41:54  Hayes
*Turned off Debugging
*
*Revision 1.12  1997/02/05  16:32:53  Hayes
*Changed FileSeek_cmd to handle 64-bit file sizes
*
*Revision 1.11  1997/01/09  14:14:15  Holt
*interim SRAM fixes
*
*Revision 1.10  1996/12/19  17:07:26  Holt
*added FileExtend which extends a file without writing data to it.
*
*Revision 1.9  1996/12/09  17:37:38  Holt
*turned off debuging.
*
*Revision 1.8  1996/07/16  10:24:09  Holt
*added more audio env. support.
*
*Revision 1.7  1996/06/25  17:22:16  Holt
*made numerous changes to audio envelopes support
*
*Revision 1.6  1996/04/02  14:46:40  Holt
**** empty log message ***
*
*Revision 1.5  1995/11/21  11:30:42  Flick
*Now used for Flyer AND Phoenix builds, has opt. stuff for Phx-only
*
*Revision 1.4  1995/11/13  13:59:41  Flick
*New fn 'ExtraErrInfo' for planting extra error info into SharedCtrl struct
*ActsReset is now a stub.  'CallMod' changed to 'RunTest'.
*
*Revision 1.3  1995/10/10  01:36:41  Flick
*DeFrag, EndSequence, CopyFile commands all tie-in HostAbort to their functions, command structure
*now includes "Progress" field, for someday doing a gas guage to show progress (ready to go now)
*Play1Clip now updates LastFieldDone when done, so does DoSearch
*
*Revision 1.2  1995/09/07  09:21:51  Flick
*SCSI R/W tests now multitask and run at pri 5
*(release 4.06)
*
*Revision 1.1  1995/08/15  16:47:10  Flick
*First release (4.05)
*
*Revision 1.0  1995/05/04  17:17:45  Flick
*FirstCheckIn
*
*
* Copyright (c) 1995 NewTek, Inc.
* Confidental and Proprietary. All rights reserved. 
*
*	05/03/95		Marty	created
\*********************************************************************/

#define	LOCALDEBUG		0			// Debugging switch for this module only

#define	VERBOSE			0

#include <Types.h>
#include <Flyer.h>
#include <Errors.h>
#include <Exec.h>
#include <Acts.h>
#include <AmiShar.h>
#include <FileSys.h>
#include <Hard.h>
#include <Debug.h>

#include <string.h>			// SAS include

#include <proto.h>
#include <AmiShar.ps>

#ifdef PHXCODE
static UBYTE PlayClipAuto(UBYTE chan,UBYTE drive,char *clipname,BOOL sync,ULONG field,ULONG fields,UWORD volramp);
#endif

extern const ULONG SRAMbase;			// Base of shared SRAM memory map


// Amiga/Flyer shared RAM command area
struct COMMANDS	* const cmd = (struct COMMANDS *) CMDBASE;

BOOL	FullyUp;

#if DBUGON
#if VERBOSE
/* Flyer Control Command Names (debugging only) */
char *OpcodeNames[] = {
	"NIL",
	"Firmware",
	"RunTest",	//"CallMod",
	"PgmFPGA",
	"SbusW",
	"SbusR",
	"CpuWrite",
	"CpuRead",
	"GetFieldClock",
	"FirInit",
	"FirXchg",
	"LoadFirMap",
	"DSPboot",
	"CpuDma",
	"VidParam",
	"PlayMode",
	"RecordMode",
	"NoMode",
	"ToasterMux",
	"InputSelect",
	"Termination",
	"SearchArgs",
	"DoSearch",
	"Play1Clip",
	"FlyerRecord",
	"ChangeAudio",
	"GetSMPTE",
	"NewHeadList",
	"EndHeadList",
	"AddClipHead",
	"VoidHead",
	"KillAllHeads",
	"AudEnvelope",								/*"???",*/
	"ScsiInit",
	"ScsiInitChan",
	"FindDrives",
	"CopyData",
	"SCSIcall",
	"ReadCapac",
	"Read10",
	"Write10",
	"FSinfo",
	"FSlocate",
	"FreeGrip",
	"CopyGrip",
	"???",
	"Parent",
	"???",
	"FSdirlist",
	"FileInfo",
	"FileOpen",
	"FileClose",
	"FileSeek",
	"FileRead",
	"FileWrite",
	"CreateDir",
	"FSdelete",
	"FSrename",
	"FSrenamedisk",
	"FSformat",
	"DeFrag",
	"FSsetbits",
	"FSsetdate",
	"FSsetcomment",
	"WriteProt",
	"???",
	"CreateFile",
	"CopyFile",
	"DebugFlags",
	"SetFloobyDust",
	"ReadTest",
	"WriteTest",
	"Suicide",
	"ScsiDirect",
	"???",
	"OpenWrFld",
	"CloseField",
	"???",
	"???",
	"???",
	"???",
	"GetCompInfo",
	"SetTimeClock",
	"StripAudio",
	"WriteCalib",
	"ReadCalib",
	"EEwrite",
	"EEread",
	"ActsReset",
	"SetClockFreq",
	"LoadVid",
	"SetDevice",
	"???",
	"TBC",
	"NewCutList",
	"AddSubClip",
	"MakeSubClips",
	"CODEC",
	"NewSequence",
	"AddSequenceClip",
	"EndSequence",
	"PlaySequence",
	"GetSetOptions",
	"LocateField",
	"CacheTest",
	"FileExtend",
	"FileHSRead",
	"FileHSWrite",
};
#endif
#endif



#define	NewCmd(cmdptr)		((UWORD)(((UWORD)((struct CMDHDR *)cmdptr)->opcode) & (UWORD)0xC000) == (UWORD)0x4000)


#if DBUGON
/*
 *  CommandDone - Mark command in SRAM as done
 */
void static CommandDone(APTR ptr)
{
	register struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;

	UWORD	opcode,newcode;

	/* Split up to prevent asynchronous errors in debugging output */

	opcode = cmdptr->opcode;

	newcode = opcode | 0xC000;
#if VERBOSE
//	print(DB_INTERP,"(%s,%b) * ",OpcodeNames[newcode & 0x3FFF],cmdptr->error);
#else
//	print(DB_INTERP,"%b,%b*",newcode & 0x3FFF,cmdptr->error);
#endif
	cmdptr->opcode = newcode;

//	cmdptr->opcode |= 0xC000;
}
#else
#define	CommandDone(cmdptr)		(((struct CMDHDR *)cmdptr)->opcode |= (UWORD)0xC000)
#endif


/*
 *  CommandBusy - Mark command in SRAM as busy processing
 */
void static CommandBusy(APTR ptr)
{
	register struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;
	UWORD	opcode;

	opcode = cmdptr->opcode;

	cmdptr->opcode = (opcode & 0x3FFF) | 0x8000;
	cmdptr->error	= ERR_OKAY;							// No error by default
}



/*
 *	Null_cmd - Do-nothing command
 */
void static __regargs Null_cmd(APTR ptr)
{
// Guts go here
}


/*
 * Unknown - Handle unknown command
 */
void static Unknown(APTR ptr)
{
	struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;

	cmdptr->error = ERR_BADCOMMAND;					// Don't understand!

//	DBUG(print(DB_ALWAYS,"Unknown command:%w\n",cmdptr->opcode);)
}


/*
 *	Suicide_cmd - Shut down Flyer
 */
void Suicide_cmd(APTR ptr)
{
	struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;
	ULONG		timeout;

//	CommandBusy(ptr);			/* Mark command as in progress (DONE FOR ME ALREADY NOW) */

//	KillVideo();				/* Shut down video engines if running */


//	DBUG(print(DB_ALWAYS,"Bye");)

	CommandDone(ptr);			/* Mark command as done */

	timeout = 0;
	/* Wait until library clears out command */
	while ((cmdptr->opcode & 0xC000) != 0x0000)
	{
		if (++timeout > 100000)
		{
			//DBUG(print(DB_ALWAYS,"Timeout!!");)
			break;
		}
	}

	ColdBoot();				/* Reboot Flyer */
}


/*
 *	FSinfo_cmd - Stub for FSinfo
 */
void static FSinfo_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		ULONG	infoptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FSinfo(
		cmdptr->drive,
		(struct FlyerVolInfo *)(cmdptr->infoptr + SRAMbase)	// Address of data structure
	);
}


/*
 *	FileInfo_cmd - Stub for FileInfo
 */
void static FileInfo_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	volptr;
		ULONG	infoptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	struct FlyerVolume	*volume;

	volume = (struct FlyerVolume *)(cmdptr->volptr + SRAMbase);

	cmdptr->error = FileInfo(
		volume->v_SCSIdrive,
		NULL,
		(char *)(volume->v_Name + SRAMbase),				// Get address of name
		(struct ClipInfo *)(cmdptr->infoptr + SRAMbase)	// Get address of data structure
	);
}


/*
 *	FSlocate_cmd - Stub to FSlocate
 */
void static FSlocate_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION			*action;
	FlyerVolume		*volume;
	GRIP				*newgrip,*oldgrip;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	oldgrip = (GRIP *)action->a_Grip;

	cmdptr->error = FS_Locate(
		volume->v_SCSIdrive,
		oldgrip,
		action->a_Access,
		(char *)(volume->v_Name + SRAMbase),	// Get address of name
		&newgrip,
		&action->a_StartBlk
	);

	action->a_Grip = (ULONG)newgrip;
}


/*
 *	FreeGrip_cmd - Stub to FreeGrip
 */
void static FreeGrip_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FreeGrip(cmdptr->drive,cmdptr->grip);
}


/*
 *	CopyGrip_cmd - Stub to CopyGrip
 */
void static CopyGrip_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
		GRIP	*_newgrip;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = CopyGrip(
		cmdptr->drive,
		cmdptr->grip,
		&cmdptr->_newgrip
	);
}


/*
 *	FSdirlist_cmd - Stub to FSdirlist
 */
void static FSdirlist_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
		ULONG	infoptr;
		UBYTE	firstflg;
		UBYTE	fsonlyflg;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error= DirList(
		cmdptr->drive,
		cmdptr->grip,
		(struct ClipInfo *)(cmdptr->infoptr + SRAMbase),	// Addr of data structure
		cmdptr->firstflg,
		(cmdptr->fsonlyflg == 0)?TRUE:FALSE						// Extra?
	);
}


/*
 *	Parent_cmd - Stub for Parent
 */
void static Parent_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
		GRIP	*_newgrip;
		ULONG	_block;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = Parent(
		cmdptr->drive,
		cmdptr->grip,
		&cmdptr->_newgrip,
		&cmdptr->_block
	);
}


/*
 *	CopyFile_cmd - Stub for CopyFile
 */
void static CopyFile_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;			// Used to abort copy
		UBYTE	error;
		ULONG	srcvolptr;
		ULONG	dstvolptr;
		BOOL	verify;
		UBYTE	pad1;
		UWORD	pad2;
		ULONG	pad3[3];
		ULONG	progress;	// 0.32 fraction for how complete so far
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	FlyerVolume	*srcvol,*dstvol;

	srcvol	= (FlyerVolume *)(cmdptr->srcvolptr + SRAMbase);
	dstvol	= (FlyerVolume *)(cmdptr->dstvolptr + SRAMbase);

	cmdptr->error = CopyFile(
		srcvol->v_SCSIdrive,							// Source drive
		(char *)(srcvol->v_Name + SRAMbase),	// Source name
		dstvol->v_SCSIdrive,							// Dest drive
		(char *)(dstvol->v_Name + SRAMbase),	// Dest name
		&cmdptr->cont);								// Host Abort input
}


/*
 *	CreateFile_cmd - Stub for CreateFile
 */
void static CreateFile_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	volptr;		// Drive and name to make
		ULONG	size;			// Requested size (blocks)
		ULONG	__start;		// Allocated data area
		ULONG	fragbytes;	// Residual bytes over 'size' blocks
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	FlyerVolume	*vol;
	ULONG	blocks;

	vol	= (FlyerVolume *)(cmdptr->volptr + SRAMbase);
	blocks = cmdptr->size;

	if (cmdptr->fragbytes != 0)				// 1 more block if there are residual bytes
		blocks++;

	cmdptr->error = CreateFile(
		vol->v_SCSIdrive,							// Drive
		(char *)(vol->v_Name + SRAMbase),	// Get address of name
		blocks,										// Blocks to contain (rounded up)
		cmdptr->fragbytes,						// Bytes in addition to 'Blocks' above
		&cmdptr->__start
	);
}


/*
 *	FSsetbits_cmd - Stub for FSsetbits
 */
void static FSsetbits_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
		ULONG	bits;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FSsetbits(
		cmdptr->drive,
		cmdptr->grip,
		cmdptr->bits
	);
}


/*
 *	FSsetcomment_cmd - Stub for FSsetcomment
 */
void static FSsetcomment_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
		ULONG	comment;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FSsetcomment(
		cmdptr->drive,
		cmdptr->grip,
		(char *)(cmdptr->comment + SRAMbase)		// Get address of comment
	);
}


/*
 *	FileOpen_cmd - Stub to FileOpen
 */
void static FileOpen_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION	*action;
	FlyerVolume	*volume;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	action->a_reserved0[1] = 0x22222222;
	action->a_reserved1[0] |= 0x100;

	cmdptr->error = FileOpen(
		volume->v_SCSIdrive,
		(GRIP *)action->a_Grip,
		(char *)(volume->v_Name + SRAMbase),		// Get address of name
		action->a_Access,
		&action->a_FileID,
		&action->a_StartBlk
	);
}


/*
 *	FileClose_cmd - Stub to FileClose
 */
void static FileClose_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		APTR	fileid;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FileClose(
		cmdptr->drive,
		cmdptr->fileid
	);
}


/*
 *	FileSeek_cmd - Stub to FileSeek
 */
void static FileSeek_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad1a;
		UBYTE	drive;
		UBYTE	mode;
		UBYTE	pad2;
		APTR	fileid;
		ULONG	newpos_ext;
		ULONG	newpos;
		ULONG	_oldpos_ext;
		ULONG	_oldpos;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FileSeek(
		cmdptr->drive,
		cmdptr->fileid,
		cmdptr->mode,
		cmdptr->newpos_ext,
		cmdptr->newpos,
		&cmdptr->_oldpos_ext,
		&cmdptr->_oldpos
	);
//	DBUG(print(DB_FILESYS,"err = %b, Oldpos = %l\n",cmdptr->error,cmdptr->_oldpos);)
}


/*
 *	FileRead_cmd - Stub to FileRead
 */
void static FileRead_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		APTR	fileid;
		ULONG	length;
		ULONG	buff;
		ULONG	_actual;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FileRead(
		cmdptr->drive,
		cmdptr->fileid,
		cmdptr->length,
		(APTR)(cmdptr->buff + SRAMbase),		// Get address of buffer
		&cmdptr->_actual
	);
}


/*
 *	FileWrite_cmd - Stub to FileWrite
 */
void static FileWrite_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		APTR	fileid;
		ULONG	length;
		ULONG	buff;
		ULONG	_actual;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FileWrite(
		cmdptr->drive,
		cmdptr->fileid,
		cmdptr->length,
		(APTR)(cmdptr->buff + SRAMbase),		// Get address of buffer
		&cmdptr->_actual
	);
}



/*
 *	CreateDir_cmd - Stub to CreateDir
 */
void static CreateDir_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION	*action;
	FlyerVolume	*volume;
	GRIP	*newgrip;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	cmdptr->error = CreateDir(
		volume->v_SCSIdrive,
		(GRIP *)action->a_Grip,
		(char *)(volume->v_Name + SRAMbase),	// Get address of name
		&newgrip
	);
	action->a_Grip = (ULONG)newgrip;
}


/*
 *	FSdelete_cmd - Stub to FSdelete
 */
void static FSdelete_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION	*action;
	FlyerVolume	*volume;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	cmdptr->error = Delete(
		volume->v_SCSIdrive,
		(GRIP *)action->a_Grip,
		(char *)(volume->v_Name + SRAMbase)		// Get address of name
	);
}


/*
 *	FSrename_cmd - Stub to FSrename 
 */
void static FSrename_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	actptr;
		GRIP	*newgrip;
		ULONG	newfname;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION	*action;
	FlyerVolume	*volume;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	cmdptr->error = Rename(
		volume->v_SCSIdrive,
		(GRIP *)action->a_Grip,
		(char *)(volume->v_Name + SRAMbase),	// Old name
		cmdptr->newgrip,
		(char *)(cmdptr->newfname + SRAMbase)	// New name
	);
}


/*
 *	FSrenamedisk_cmd - Stub to FSrenamedisk
 */
void static FSrenamedisk_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		ULONG	filename;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = RenameDisk(
		cmdptr->drive,
		(char *)(cmdptr->filename + SRAMbase)		// Get address of name
	);
}


/*
 *	FSformat_cmd - Stub to FSformat
 */
void static FSformat_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		ULONG	volname;
		struct FlyerDate stamp;
		ULONG	blocks;
		BYTEBITS	flags;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = Format(
		cmdptr->drive,
		(char *)(cmdptr->volname + SRAMbase),	// Volume name
		&cmdptr->stamp,
		cmdptr->blocks,
		cmdptr->flags
	);
}


/*
 *	FSsetdate_cmd - Stub for FSsetdate
 */
void static FSsetdate_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		GRIP	*grip;
		ULONG	days;
		ULONG	mins;
		ULONG	ticks;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = SetDate(
		cmdptr->drive,
		cmdptr->grip,
		cmdptr->days,
		cmdptr->mins,
		cmdptr->ticks
	);
}


/*
 *	WriteProt_cmd - Stub: Test/set state of write protect flag for drive
 */
void static WriteProt_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		UBYTE	value;
		UBYTE	setit;
	};
//// Currently unimplemented
//	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

//	WriteProt(cmdptr->chan,cmdptr->value,cmdptr->setit);
}


/*
 *	DebugFlags_cmd - Stub for DebugFlags
 */
void static DebugFlags_cmd(APTR ptr)
{
#if DEBUG
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		LONGBITS	flags;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = DebugFlags(cmdptr->flags);
#endif
}


/*
 *	GetSetOptions_cmd - Stub for GetSetOptions
 */
void static GetSetOptions_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		LONGBITS	flags;
		UBYTE		setit;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = GetSetOptions(&cmdptr->flags,cmdptr->setit);
}


/*
 * SbusW_cmd - Stub for SbusW
 */
void static SbusW_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	addr;
		UBYTE	data;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = SbusW(cmdptr->addr,cmdptr->data);

	DBUG(
		while (cmdptr->cont != 0)
			cmdptr->error = SbusW(cmdptr->addr,cmdptr->data);
	)
}


/*
 * SbusR_cmd - Stub for SbusR
 */
void static SbusR_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	addr;
		UBYTE	_data;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	DBUG(
		while (cmdptr->cont != 0)
			cmdptr->error = SbusR(cmdptr->addr, &cmdptr->_data);	// Keep reading serial bus
	)
	cmdptr->error = SbusR(cmdptr->addr, &cmdptr->_data);
}


/*
 *	WriteCalib_cmd - Stub for WriteCalib
 */
void static WriteCalib_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		UWORD		item;
		UWORD		value;
		UBYTE		saveit;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = WriteCalib(
		cmdptr->item,
		cmdptr->value,
		cmdptr->saveit
	);
}


/*
 *	ReadCalib_cmd - Stub for ReadCalib
 */
void static ReadCalib_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		UWORD		item;
		UWORD		_value;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = ReadCalib(
		cmdptr->item,
		&cmdptr->_value
	);
}


/*
 *	VidParam_cmd - Stub for VidParam
 */
void static VidParam_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		vchan;			// OBSOLETE!
		UBYTE		mintol;
		UBYTE		maxtol;
		UBYTE		freq;
		UWORD		vmaxlen;
		UWORD		vlength;
		UBYTE		firset;
		UBYTE		special;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = VidParam(
		cmdptr->mintol,
		cmdptr->maxtol,
		cmdptr->freq,
		cmdptr->vmaxlen,
		cmdptr->vlength,
		cmdptr->firset,
		cmdptr->special
	);
}


/*
 * SearchArgs_cmd - Stub for SearchArgs
 */
void static SearchArgs_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
		UBYTE		flag;
//Eliminated under exec
//		UBYTE		__state;
//		ULONG		__index;
//		ULONG		__maxfld;
//		BYTEBITS	__flags;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = SearchArgs(
		(ACTION *)(cmdptr->actptr + SRAMbase),		// Action structure
		cmdptr->flag
	);
}


/*
 *	DoSearch_cmd - Stub for DoSearch
 */
void static DoSearch_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	struct	ACTION	*act;

	act = (ACTION *)(cmdptr->actptr + SRAMbase);		// Get action structure

	cmdptr->error = DoSearch(act);						// Action structure

	// Update LastFieldDone for folks who don't know what they just asked for!
	if (cmdptr->error == ERR_OKAY)
	{
		if (act->a_Flags & AF_VIDEO)
			act->a_LastFieldDone = act->a_VidStartField;
		else if (act->a_Flags & (AF_AUDIOL | AF_AUDIOR))
			act->a_LastFieldDone = act->a_AudStartField;
	}
}


/*
 *	LocateField_cmd - Stub for LocateField
 */
void static LocateField_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = LocateField(
		(ACTION *)(cmdptr->actptr + SRAMbase)		// Action structure
	);
}


/*
 *	Play1Clip_cmd - Stub for Play1Clip
 */
void static Play1Clip_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	struct	ACTION	*act;

	act = (ACTION *)(cmdptr->actptr + SRAMbase);		// Get action structure

	cmdptr->cont = 2;		// Not timely anymore, but at least let'em know we started

	cmdptr->error = Play1Clip(
		act,									// Action structure
		TRUE,									// Play synchronous (wait for complete)
		&cmdptr->cont,						// Tie-in host abort input
		&act->a_LastFieldDone			// Tie-in
	);

	// Correct LastFieldDone based on where started
	if (cmdptr->error == ERR_OKAY)
	{
		if (act->a_Flags & AF_VIDEO)
			act->a_LastFieldDone += act->a_VidStartField;
		else if (act->a_Flags & (AF_AUDIOL | AF_AUDIOR))
			act->a_LastFieldDone += act->a_AudStartField;
	}
}


/*
 *	FlyerRecord_cmd - Stub for FlyerRecord
 */
void static FlyerRecord_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FlyerRecord(
		(ACTION *)(cmdptr->actptr + SRAMbase),		// Action structure
		&cmdptr->cont										// Continue flag
	);
}


/*
 *	SetTimeClock_cmd - Stub for SetTimeClock
 */
void static SetTimeClock_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		days;
		ULONG		minutes;
		ULONG		ticks;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = SetTimeClock(
		cmdptr->days,
		cmdptr->minutes,
		cmdptr->ticks
	);
}


/*
 *	DeFrag_cmd - Stub for DeFrag
 */
void static DeFrag_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		pad1;
		UBYTE		drive;
		UWORD		pad2;
		ULONG		pad3[5];
		ULONG		progress;	// 0.32 fraction for how complete so far
	};

	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = DeFrag(
		cmdptr->drive,
		&cmdptr->cont				// If this goes FALSE, abort defrag
	);
}


/*
 * PgmFPGA_cmd - Stub for PgmFPGA
 */
void static PgmFPGA_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	addr;
		ULONG	length;
		UBYTE	chipnumber;
		BOOL	dual;
		UBYTE	chiprev;
	};

	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = PgmFPGA(
		(APTR)(cmdptr->addr+SRAMbase),		// Address of data
		cmdptr->length,
		cmdptr->chipnumber,
		cmdptr->dual,
		cmdptr->chiprev
	);
}


/*
 *	LoadFirMap_cmd - Stub for LoadFirMap
 */
void static LoadFirMap_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	bank;
		UBYTE	scale;
		UBYTE	shape;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = LoadFirMap(
		cmdptr->bank,
		cmdptr->scale,
		cmdptr->shape
	);
}


/*
 * DSPboot_cmd - Stub for DSPboot
 */
void static DSPboot_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		ULONG	addr;
		ULONG	length;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = DSPboot(
		(APTR)(cmdptr->addr+SRAMbase),
		cmdptr->length
	);
}


/*
 * CpuWrite_cmd - Write data to memory
 */
void static CpuWrite_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UWORD	*addr;
		UWORD	data;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	*cmdptr->addr = cmdptr->data;				// Write (WORD) data to Memory
}


/*
 * CpuRead_cmd - Read data from memory
 */
void static CpuRead_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UWORD	*addr;
		UWORD	_data;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->_data = *cmdptr->addr;		// Store (WORD) data in command
}


/*
 * SetClockFreq_cmd - Stub for SetClockFreq
 */
void static SetClockFreq_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	clock;
		UBYTE	pad2;
		ULONG	freq;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = SetClockFreq(
		cmdptr->clock,
		cmdptr->freq
	);
}


/*
 * ToasterMux_cmd - Stub for ToasterMux
 */
void static ToasterMux_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	input3;
		UBYTE	input4;
		UBYTE	preview;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = ToasterMux(
		cmdptr->input3,
		cmdptr->input4,
		cmdptr->preview
	);
}


/*
 * InputSelect_cmd - Stub for InputSelect
 */
void static InputSelect_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	source;
		UBYTE	sync;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = InputSelect(
		cmdptr->source,
		cmdptr->sync
	);
}


/*
 * Termination_cmd - Stub for Termination
 */
void static Termination_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	flags;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = Termination(cmdptr->flags);
}


/*
 * FirInit_cmd - Stub for FirInit
 */
void static FirInit_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UWORD	data0;
		UWORD	data1;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	FirInit(
		cmdptr->data0,
		cmdptr->data1
	);
}


/*
 * FirXchg_cmd - Stub for FirXchg
 */
void static FirXchg_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		setnum;
		UBYTE		readflag;
		UBYTE		prepost;
		UBYTE		pad2;
		struct FIRSET	data;		// 8 coefs/scale
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FirXchg(
		cmdptr->setnum,
		cmdptr->readflag,
		cmdptr->prepost,
		&cmdptr->data
	);
}


/*
 *	GetCompInfo_cmd - Stub for GetCompInfo
 */
void static GetCompInfo_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		drive;
		UBYTE		field;
		ULONG		lba;
		ULONG		vciptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = GetCompInfo(
		cmdptr->drive,
		cmdptr->field,
		cmdptr->lba,
		(struct VidCompInfo *)(cmdptr->vciptr + SRAMbase)	// VidCompInfo structure
	);
}


/*
 *	NewCutList_cmd - Stub for NewCutList
 */
void static NewCutList_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
		BYTEBITS	operflags;			// Operation flags
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION		*action;
	FlyerVolume	*volume;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	cmdptr->error = NewCutList(
		volume->v_SCSIdrive,								// Drive which contains clip to cut
		(char *)(volume->v_Name + SRAMbase),		// Name of clip to cut
		cmdptr->operflags
	);
}


/*
 *	AddSubClip_cmd - Stub for AddSubClip
 */
void static AddSubClip_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		drive;
		BYTEBITS	CAFflags;		// From ca_Flags
		UWORD		refnum;
		ULONG		startfld;
		ULONG		numflds;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = AddSubClip(
		cmdptr->drive,
		cmdptr->CAFflags,
		cmdptr->refnum,
		cmdptr->startfld,
		cmdptr->numflds
	);
}


/*
 *	MakeSubClips_cmd - Make sub-clips
 */
void static MakeSubClips_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		doit;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = MakeSubClips(cmdptr->doit);
}


/*
 *	SetDevice_cmd - Stub for SetDevice
 */
void static SetDevice_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		port;
		UBYTE		type;
		UBYTE		make;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = SetDevice(
		cmdptr->port,
		cmdptr->type,
		cmdptr->make
	);
}


/*
 *	NewHeadList_cmd - Stub for NewHeadList
 */
void static NewHeadList_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = NewHeadList();
}


/*
 *	EndHeadList_cmd - Stub for EndHeadList
 */
void static EndHeadList_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		doit;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = EndHeadList(cmdptr->doit);
}


/*
 *	AddClipHead_cmd - Stub for AddClipHead
 */
void static AddClipHead_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION		*action;
	FlyerVolume	*volume;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	cmdptr->error = AddClipHead(
		volume->v_SCSIdrive,								// Drive that contains
		(char *)(volume->v_Name + SRAMbase),		// Name of clip
		action->a_VidStartField,
		action->a_VidFieldCount,
		action->a_AudStartField,
		action->a_AudFieldCount
	);
}



/*
 *	KillAllHeads_cmd - Stub for KillAllHeads
 */
void static KillAllHeads_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = KillAllHeads();
}


/*
 *	AudEnvelope - Add an audio envelope to proceding clip
 */
void static AudEnvelope(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
	};

	//DBUG(print(DB_INTERP,"AddAudEnvelope:\n");)
				
}




/*
 *  ScsiDirect_cmd - Stub for ScsiDirect
 */
void static ScsiDirect_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		drive;
		UBYTE		pad;
		ULONG		infoptr;
//		SCSIKEY	__skey;
//		UBYTE		__state;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = ScsiDirect(
		cmdptr->drive,
		(struct SCSIcmd *)(cmdptr->infoptr + SRAMbase)		// SCSIcmd structure
	);
}


/*
 *	OpenWrFld_cmd - Stub for OpenWrFld
 */
void static OpenWrFld_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
		ULONG		cmpinfptr;
		ULONG		field;
		BYTEBITS	mode;
		UBYTE		pad;
		ULONG		_refnum;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	ACTION	*action;
	FlyerVolume	*volume;

	action = (ACTION *)(cmdptr->actptr + SRAMbase);	// Get ptr to action structure
	volume = (FlyerVolume *)(action->a_Volume + SRAMbase);

	cmdptr->error = OpenWrFld(
		volume->v_SCSIdrive,													// Drive number
		(char *)(volume->v_Name + SRAMbase),							// File name
		(GRIP *)action->a_Grip,												// Grip (???)
		(struct VidCompInfo *)(cmdptr->cmpinfptr + SRAMbase),		// VidCompInfo structure
		&cmdptr->field,			// Read & possible modified!
		cmdptr->mode,
		&cmdptr->_refnum
	);
}


/*
 *	CloseField_cmd - Stub for CloseField
 */
void static CloseField_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		refnum;
		UBYTE		wrote;			// Wrote some data?
		UBYTE		pad;
		ULONG		finalptr;		// LBA just past field data
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = CloseField(
		cmdptr->refnum,
		cmdptr->wrote,
		cmdptr->finalptr
	);
}



/*
 *	EEwrite_cmd - Stub for EEwrite
 */
void static EEwrite_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		UBYTE		addr;
		UBYTE		pad2;
		UWORD		data;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = EEwrite(
		cmdptr->addr,
		cmdptr->data
	);
}


/*
 *	EEread_cmd - Stub for EEread
 */
void static EEread_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		UBYTE		addr;
		UBYTE		pad2;
		UWORD		_data;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = EEread(
		cmdptr->addr,
		&cmdptr->_data
	);
}


/*
 *	ReadTest_cmd - Stub for ReadTest
 */
void static ReadTest_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		UBYTE		pad2;
		UBYTE		drive;
		ULONG		lba;
		ULONG		length;
		ULONG		repeat;
		UBYTE		flag;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = ReadTest(
		cmdptr->drive,
		cmdptr->lba,
		cmdptr->length,
		cmdptr->repeat,
		cmdptr->flag
	);
}


/*
 *	GetFieldClock_cmd - Stub for GetFieldClock
 */
void static GetFieldClock_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		_clock;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->_clock = GetFieldClock();

	//DBUG(printchar(DB_VIDEO2,(cmdptr->_clock & 3)+'0'+5);)
}


/*
 *	PlayMode_cmd - Stub for PlayMode
 */
void static PlayMode_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
	};

	PlayMode();
}


/*
 *	RecordMode_cmd - Stub for RecordMode
 */
void static RecordMode_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
	};

	RecordMode();
}


/*
 * ScsiInitChan_cmd - Stub for ScsiInitChan
 */
void static ScsiInitChan_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		UBYTE		pad2;
		UBYTE		drive;
	};

	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = ScsiInitChan(
		cmdptr->drive >> 3				// Get channel number from drive
	);
}


/*
 * ScsiInit_cmd - Stub for ScsiInit
 */
void static ScsiInit_cmd(APTR ptr)
{
	ScsiInit();									// Master SCSI Init
}


/*
 * FindDrives_cmd - Find responding drives on Scsi bus
 */
void FindDrives_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad1;
		UBYTE		error;
		UBYTE		pad1a;
		UBYTE		drive;
		UBYTE		drvbits;
		UBYTE		pad2;
		UBYTE		versions[8];
		UBYTE		lengths[8];
	};

	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
	UBYTE	chan;

	chan = cmdptr->drive >> 3;				// Get channel from drive
	if (chan < NUMSCSICHANS)
	{
		// Find Drives
		cmdptr->drvbits = FindDrives(
			chan,
			&cmdptr->versions[0],
			&cmdptr->lengths[0]
		);
	}
	else
		cmdptr->error = ERR_BADPARAM;				// Set Error code
}


/*
 *	NewSequence_cmd - Stub for NewSequence
 */
void static NewSequence_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = NewSequence();
}


/*
 *	AddSequenceClip_cmd - Stub for AddSequenceClip
 */
void static AddSequenceClip_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		actptr;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = AddSequenceClip(
		(ACTION *)(cmdptr->actptr + SRAMbase)		// Get ptr to action structure
	);
}


/*
 * AddAudEKey_cmd -- SRAM STUB FOR GETTING AUDIO ENVELOPE KEY. 
 */
void AddAudEKey_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		time;
		ULONG		durr;
		UWORD		Flags;
		UWORD		VOL1;
		UWORD		VOL2;
		WORD		PAN1;	
		WORD		PAN2;	
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	//DBUG(print(DB_SEQ,"time=%l durr=%l flags=%w vol1=%w vol2=%w pan1=%w pan2=%w \n",
	//				cmdptr->time,cmdptr->durr,cmdptr->Flags,cmdptr->VOL1,cmdptr->VOL2,
	//				cmdptr->PAN1,cmdptr->PAN2);)
	
	cmdptr->error = AddAudEKey(cmdptr->time,
						 				cmdptr->durr,
										cmdptr->Flags,
										cmdptr->VOL1,
										cmdptr->VOL2,
										cmdptr->PAN1,
										cmdptr->PAN2);
	
}


/*
 *	EndSequence_cmd - Stub for EndSequence
 */
void static EndSequence_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		UBYTE		doit;
		UBYTE		pad1;
		UWORD		pad2;
		ULONG		pad3[5];
		ULONG		progress;	// 0.32 fraction for how complete so far
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = EndSequence(
		cmdptr->doit,
		&cmdptr->cont		// Host abort input
	);
}


/*
 *	PlaySequence_cmd - Stub for PlaySequence
 */
void static PlaySequence_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		basetime;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = PlaySequence(cmdptr->basetime);
}


/*
 *	CacheTest_cmd - Help Host test for cache problems with Flyer's shared RAM
 */
void static CacheTest_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		cont;
		UBYTE		error;
		ULONG		skip[6];
		ULONG		value;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;
//	ULONG		*value;

//	value = (ULONG *)SRAMbase;

	cmdptr->value = 0xFEEDF00D;

	Disable();

	// Busy wait is okay here, since this is only done at init time, and we want our
	// latency to be as low as possible
	while (cmdptr->cont) {}

	cmdptr->value = 0x12345678;

	Enable();
}


/*
 *	ActsReset_cmd - Stub for Reset parameters
 */
void static ActsReset_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD		opcode;
		UBYTE		pad;
		UBYTE		error;
		ULONG		flags;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	ActsReset(cmdptr->flags);
}

/*
 * FileExtend_cmd - Test to tryout new HP-file io code.
 */
void static FileExtend_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	pad2;
		UBYTE	drive;
		APTR	fileid;
		ULONG	length;
	};
	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;

	cmdptr->error = FileExtend(
		cmdptr->drive,
		cmdptr->fileid,
		cmdptr->length
	);
}



/*
 * FileHSRead_cmd - Test to tryout new HS-file IO code.
 */
void static FileHSRead_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	WFLAG;
		UBYTE	drive;
		APTR	fileid;
		ULONG	Start_Blk;
		ULONG	Blk_Count;		//should max out at about 96blocks = 48K
		ULONG	buff;
	};

	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;


	//print(DB_FILESYS,"HS - buff: %l\n",cmdptr->buff);
	
	

	cmdptr->error = FileHSWrite(
		cmdptr->drive,
		cmdptr->fileid,
		cmdptr->Start_Blk,
		cmdptr->Blk_Count,
		(APTR)(cmdptr->buff + SRAMbase),
		cmdptr->WFLAG
	);
}




/*
 * FileHSWrite_cmd - Test to tryout new HS-file IO code.
 * Why not do both? read and write with same code?! (DEH 2/18/97)	
 */
void static FileHSWrite_cmd(APTR ptr)
{
	struct CMD_ORG {
		UWORD	opcode;
		UBYTE	cont;
		UBYTE	error;
		UBYTE	WFLAG;
		UBYTE	drive;
		APTR	fileid;
		ULONG	Start_Blk;
		ULONG	Blk_Count;		//should max out at about 96blocks = 48K
		ULONG buff;
	};

	register struct CMD_ORG *cmdptr = (struct CMD_ORG *)ptr;


	//print(DB_FILESYS,"HS - buff: %l\n",cmdptr->buff);



	cmdptr->error = FileHSWrite(
		cmdptr->drive,
		cmdptr->fileid,
		cmdptr->Start_Blk,
		cmdptr->Blk_Count,
		(APTR)(cmdptr->buff + SRAMbase),
		cmdptr->WFLAG
	);
}



/* Flyer Control Command Vectors */
struct FuncEntry	FuncTable[] = {
	FALSE,0,Null_cmd,
	FALSE,0,Firmware,
	FALSE,0,RunTest_cmd,		// CallMod
	FALSE,0,PgmFPGA_cmd,
	FALSE,0,SbusW_cmd,
	FALSE,0,SbusR_cmd,
	FALSE,0,CpuWrite_cmd,
	FALSE,0,CpuRead_cmd,
	FALSE,0,GetFieldClock_cmd,
	FALSE,0,FirInit_cmd,
	FALSE,0,FirXchg_cmd,
	FALSE,0,LoadFirMap_cmd,
	FALSE,0,DSPboot_cmd,
	FALSE,0,CpuDma_cmd,
	FALSE,0,VidParam_cmd,
	FALSE,0,PlayMode_cmd,
	FALSE,0,RecordMode_cmd,
	FALSE,0,NoMode_cmd,
	FALSE,0,ToasterMux_cmd,
	FALSE,0,InputSelect_cmd,
	FALSE,0,Termination_cmd,
	FALSE,0,SearchArgs_cmd,
	FALSE,0,DoSearch_cmd,
	TRUE ,3,Play1Clip_cmd,
	TRUE ,0,FlyerRecord_cmd,	// Must run at pri 0 until it quits hogging CPU
	FALSE,0,ChangeAudio,
	FALSE,0,GetSMPTE,
	FALSE,0,NewHeadList_cmd,
	FALSE,0,EndHeadList_cmd,
	FALSE,0,AddClipHead_cmd,
	FALSE,0,VoidHead,
	FALSE,0,KillAllHeads_cmd,
	FALSE,0,AddAudEKey_cmd,						//AudEnvelope,Unknown, AUDCTRL 
	FALSE,0,ScsiInit_cmd,
	FALSE,0,ScsiInitChan_cmd,
	FALSE,0,FindDrives_cmd,
	FALSE,0,CopyData_cmd,
	FALSE,0,SCSIcall,
	FALSE,0,ReadCapac,
	FALSE,0,Read10,
	FALSE,0,Write10,
	FALSE,0,FSinfo_cmd,
	FALSE,0,FSlocate_cmd,
	FALSE,0,FreeGrip_cmd,
	FALSE,0,CopyGrip_cmd,
	FALSE,0,Unknown,			/* CMPGRIPS */
	FALSE,0,Parent_cmd,
	FALSE,0,Unknown,			/* EXAMINE */
	FALSE,0,FSdirlist_cmd,
	FALSE,0,FileInfo_cmd,
	FALSE,0,FileOpen_cmd,
	FALSE,0,FileClose_cmd,
	FALSE,0,FileSeek_cmd,
	FALSE,0,FileRead_cmd,
	FALSE,0,FileWrite_cmd,
	FALSE,0,CreateDir_cmd,
	FALSE,0,FSdelete_cmd,
	FALSE,0,FSrename_cmd,
	FALSE,0,FSrenamedisk_cmd,
	FALSE,0,FSformat_cmd,
	FALSE,0,DeFrag_cmd,
	FALSE,0,FSsetbits_cmd,
	FALSE,0,FSsetdate_cmd,
	FALSE,0,FSsetcomment_cmd,
	FALSE,0,WriteProt_cmd,
	FALSE,0,Unknown,			/* FSCHGMODE */
	FALSE,0,CreateFile_cmd,
	FALSE,0,CopyFile_cmd,
	FALSE,0,DebugFlags_cmd,
	FALSE,0,SetFloobyDust,
	TRUE,5,ReadTest_cmd,
	TRUE,5,WriteTest_cmd,
	FALSE,0,Suicide_cmd,
	TRUE,0,ScsiDirect_cmd,
	FALSE,0,Unknown,	/* (1,Clip.OpenRdFld), */
	FALSE,0,OpenWrFld_cmd,
	FALSE,0,CloseField_cmd,
	FALSE,0,Unknown,	/* (1,Clip.ReadLine), */
	FALSE,0,Unknown,	/* (1,Clip.WriteLine), */
	FALSE,0,Unknown,	/* (1,Clip.SetFillColor), */
	FALSE,0,Unknown,	/* (1,Clip.SkipLines), */
	FALSE,0,GetCompInfo_cmd,
	FALSE,0,SetTimeClock_cmd,
	FALSE,0,StripAudio_cmd,
	FALSE,0,WriteCalib_cmd,
	FALSE,0,ReadCalib_cmd,
	FALSE,0,EEwrite_cmd,
	FALSE,0,EEread_cmd,
	FALSE,0,ActsReset_cmd,
	FALSE,0,SetClockFreq_cmd,
	FALSE,0,LoadVid,
	FALSE,0,SetDevice_cmd,
	FALSE,0,Unknown,				// SelfTest
	FALSE,0,TBC_cmd,
	FALSE,0,NewCutList_cmd,
	FALSE,0,AddSubClip_cmd,
	FALSE,0,MakeSubClips_cmd,
	FALSE,0,CODEC_cmd,
	FALSE,0,NewSequence_cmd,
	FALSE,0,AddSequenceClip_cmd,
	FALSE,0,EndSequence_cmd,
	FALSE,0,PlaySequence_cmd,
	FALSE,0,GetSetOptions_cmd,
	FALSE,0,LocateField_cmd,
	FALSE,0,CacheTest_cmd,
	FALSE,0,FileExtend_cmd,
	FALSE,0,FileHSRead_cmd,
	FALSE,0,FileHSWrite_cmd,

};
#define	FUNCTABENTRIES	(sizeof(FuncTable)/sizeof(struct FuncEntry))


/*****************************/
/*   Main Interpreter Loop   */
/*****************************/

/*
 *	CommandWrapper - Wrapper to perform a command as its own task
 */
void static __asm CommandWrapper(register __d0 APTR ptr)
{
	struct CMDHDR	*cmdptr;
	ULONG		opcode;
	OPSPROC	func;

	cmdptr = (struct CMDHDR *)ptr;
	opcode = cmdptr->opcode & 0x3FFF;

	func = FuncTable[opcode].fn;

	func(cmdptr);				/* Perform the command! */
	CommandDone(cmdptr);		/* Mark command as done */

//	DBUG(print(DB_INTERP,"*Dead*");)
}



/*
 *  MainLoop - the main Flyer command loop
 */
void MainLoop(void)
{
static const UBYTE LED_ScannerData[] = {
	0x01, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02
};

	struct COMMAND	*cmdptr;
	struct FuncEntry *infoptr;
	OPSPROC	func;
	ULONG		opcode;
	UBYTE		ndx;
	ULONG		back = 0;
	UBYTE		image,curimage=99;

#define	SPAWNSTACKSIZE	1024

	//DBUG(print(DB_ALWAYS,"--main loop--\n");)

	CommandDone(&cmd->slot[0]);		// Tell caller "done" - I'm running

#ifdef PHXCODE
	if (DIP_SignOn & DIPswitches())
		PlayClipAuto(0,0,"SignOn_clip",TRUE,0,0,3);
#endif

	//DBUG(print(DB_ALWAYS,"Memory free in pool = %l\n",MemCheck());)

	for (;;)
	{
		//print(DB_INTERP," ÐONT PANIC \N");		//testing 
		//AudEnvelope(cmdptr);							//testing

		DBUG(WatchReset();)		// Watch for Reset DIP -- DEBUGGING ONLY!!!

		cmdptr = &cmd->slot[0];
		for (ndx=NUMCMDSLOTS; ndx ;ndx--,cmdptr++)
		{
#ifdef PHXCODE
			HonorSerCmd();			// Check if serial command has arrived
#endif

			if (NewCmd(cmdptr))
			{
				//DBUG(print(DB_INTERP,"Cmd:%w-- ",((struct CMDHDR *)cmdptr)->opcode);)
				//print(DB_INTERP,"Cmd:%w-- ",((struct CMDHDR *)cmdptr)->opcode);

				opcode = ((struct CMDHDR *)cmdptr)->opcode & 0x3FFF;
				if (opcode < FUNCTABENTRIES)
				{
					infoptr = &FuncTable[opcode];

					CommandBusy(cmdptr);			// Mark command as in progress
#if VERBOSE
					//DBUG(print(DB_INTERP,"%s",OpcodeNames[opcode]);)
#endif

					if (infoptr->spawn)			// Spawn a separate task for this?
					{
#if VERBOSE
						//DBUG(printchar(DB_INTERP,'+');)
#endif
						StartTask((PROC)&CommandWrapper,infoptr->pri,SPAWNSTACKSIZE,
							(ULONG)cmdptr,"Shell");
					}
					else
					{
#if VERBOSE
						DBUG(printchar(DB_INTERP,'>');)
#endif
						func = infoptr->fn;
						func((struct CMDHDR *)cmdptr);		// Perform the command!
						CommandDone(cmdptr);						// Mark command as done
					}
				}
				else
				{
					Unknown(cmdptr);
					CommandDone(cmdptr);		/* Mark command as done */
				}
			}	// If
		}	// For


		if (FullyUp)			// Can we play with LED's now?
		{
			back++;
			image = LED_ScannerData[(back>>9)&7];
//			image = LED_ScannerData[(back>>2)&7];

//			image = 0;		// Kill it for now!

			// Only write to LED hardware when a change is required
			if (image != curimage)
			{
				ClrLEDs(image ^ 0x3F);
				SetLEDs(image);
				curimage = image;
			}
		}

		// This causes slow response from high-volume stuff like FileSystem
		// How can we do this and still respond quickly?
//		Delay(2);

	} /* FOREVER */
}


/*
 * ShowHostCrash - Do what's needed to show host that we crashed!
 */
void ShowHostCrash(void)
{
	struct COMMAND	*slot;
	int	i;

	slot = &cmd->slot[0];
	for (i=NUMCMDSLOTS;i;i--,slot++)
	{
		((struct CMDHDR *)slot)->error = ERR_CRASH;		// Show error!
		CommandDone(slot);				// Free all commands
	}
}


/*
 * CheckHostReset - Reset if instructed by host
 */
void CheckHostReset(void)
{
	struct COMMAND	*slot;
	int	i;

	slot = &cmd->slot[0];
	for (i=NUMCMDSLOTS;i;i--,slot++)
	{
		if (((struct CMDHDR *)slot)->opcode == 0x4048)
		{
			//DBUG(print(DB_ALWAYS,"Quitting\n");)
			Suicide_cmd((APTR)slot);
		}
	}
}


/************* Amiga/Flyer shared control structure (extra error info) ***************/
//	/* Amiga/Flyer shared control structure */
extern struct SHAREDCTRLSTRUCT *SharedCtrl;

void ExtraErrInfo(UBYTE error, ULONG id, ULONG inc)
{
	if (SharedCtrl->SeqError == ERR_OKAY)		// Only record 1st error
	{
		SharedCtrl->SeqError = error;
		SharedCtrl->UserID = id;
	}

	// If our type of error recorded, run up the tally
	if (SharedCtrl->SeqError == error)
		SharedCtrl->MoreInfo += inc;
}



#ifdef PHXCODE
/*
 * PlayClipAuto - Play a clip
 */
static UBYTE PlayClipAuto(	UBYTE chan,
									UBYTE drive,
									char *clipname,
									BOOL sync,
									ULONG	field,
									ULONG fields,
									UWORD	volramp)
{
	ACTION	action;
	struct FlyerVolume	volume;


	//DBUG(print(DB_GEN,"PlayClipAuto '%s'\n",clipname);)

	memset(&volume,0,sizeof(FlyerVolume));
	volume.v_Name = ((ULONG)clipname) - SRAMbase;		// Make offset
//	volume.v_Board = 0;
	volume.v_SCSIdrive = drive;
//	volume.v_Flags = 0;

	memset(&action,0,sizeof(ACTION));
	action.a_Volume = ((ULONG)&volume) - SRAMbase;		// Make offset
	action.a_Channel = chan;
	action.a_VidStartField = action.a_AudStartField = field;
	action.a_VidFieldCount = action.a_AudFieldCount = fields;
	action.a_VolSust1 = action.a_VolSust2 = 0xFFFF;
	action.a_Flags = AF_VIDEO | AF_AUDIOL | AF_AUDIOR;
	action.a_PermissFlags = APF_STEALOURVIDEO | APF_KILLOTHERVIDEO;
	action.a_AudioPan1 = 0x7FFF;
	action.a_AudioPan2 = -0x8000;
	action.a_VolAttack = volramp;
	action.a_VolDecay = volramp;

	return(Play1Clip(&action,sync,NULL,NULL));
}
#endif
@


1.15
log
@debug off
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.14 1997/03/26 16:32:20 Holt Exp Holt $
d8 3
d69 1
a69 1
#define	VERBOSE			1
d235 1
a235 1
	print(DB_INTERP,"(%s,%b) * ",OpcodeNames[newcode & 0x3FFF],cmdptr->error);
d237 1
a237 1
	print(DB_INTERP,"%b,%b*",newcode & 0x3FFF,cmdptr->error);
d282 1
a282 1
	DBUG(print(DB_ALWAYS,"Unknown command:%w\n",cmdptr->opcode);)
d299 1
a299 1
	DBUG(print(DB_ALWAYS,"Bye");)
d309 1
a309 1
			DBUG(print(DB_ALWAYS,"Timeout!!");)
d1723 1
a1723 1
	DBUG(print(DB_INTERP,"AddAudEnvelope:\n");)
d1901 1
a1901 1
	DBUG(printchar(DB_VIDEO2,(cmdptr->_clock & 3)+'0'+5);)
d2054 3
a2056 3
	DBUG(print(DB_SEQ,"time=%l durr=%l flags=%w vol1=%w vol2=%w pan1=%w pan2=%w \n",
					cmdptr->time,cmdptr->durr,cmdptr->Flags,cmdptr->VOL1,cmdptr->VOL2,
					cmdptr->PAN1,cmdptr->PAN2);)
d2202 1
a2202 1
	print(DB_FILESYS,"HS - buff: %l\n",cmdptr->buff);
d2240 1
a2240 1
	print(DB_FILESYS,"HS - buff: %l\n",cmdptr->buff);
d2416 1
a2416 1
	DBUG(print(DB_ALWAYS,"--main loop--\n");)
d2425 1
a2425 1
	DBUG(print(DB_ALWAYS,"Memory free in pool = %l\n",MemCheck());)
d2444 1
a2444 1
				print(DB_INTERP,"Cmd:%w-- ",((struct CMDHDR *)cmdptr)->opcode);
d2453 1
a2453 1
					DBUG(print(DB_INTERP,"%s",OpcodeNames[opcode]);)
d2459 1
a2459 1
						DBUG(printchar(DB_INTERP,'+');)
d2538 1
a2538 1
			DBUG(print(DB_ALWAYS,"Quitting\n");)
d2580 1
a2580 1
	DBUG(print(DB_GEN,"PlayClipAuto '%s'\n",clipname);)
@


1.14
log
@added more High Speed multi-block read/write code.
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.13 1997/02/05 16:41:54 Hayes Exp Holt $
d8 3
d64 1
a64 1
#define	LOCALDEBUG		1			// Debugging switch for this module only
@


1.13
log
@Turned off Debugging
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.12 1997/02/05 16:32:53 Hayes Exp Hayes $
d8 3
d61 1
a61 1
#define	LOCALDEBUG		0			// Debugging switch for this module only
d63 1
a63 1
#define	VERBOSE			0
d2185 1
a2185 1
		UBYTE	pad2;
d2191 1
a2192 1
	};
d2195 6
a2200 1
	cmdptr->error = FileHSRead(
d2205 2
a2206 1
		cmdptr->buff
d2215 1
d2223 1
a2223 1
		UBYTE	pad2;
d2228 2
a2229 1
		ULONG	buff;
a2230 1
	};
d2233 5
d2243 2
a2244 1
		cmdptr->buff
a2249 1

d2357 4
a2360 1
	FALSE,0,FileExtend_cmd
@


1.12
log
@Changed FileSeek_cmd to handle 64-bit file sizes
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.11 1997/01/09 14:14:15 Holt Exp Hayes $
d8 3
d58 1
a58 1
#define	LOCALDEBUG		1			// Debugging switch for this module only
@


1.11
log
@interim SRAM fixes
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.10 1996/12/19 17:07:26 Holt Exp Holt $
d8 3
d667 1
d669 1
d678 1
d680 1
@


1.10
log
@added FileExtend which extends a file without writing data to it.
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.9 1996/12/09 17:37:38 Holt Exp Holt $
d8 3
d52 1
a52 1
#define	LOCALDEBUG		0			// Debugging switch for this module only
d193 2
d736 1
a2153 1

d2160 62
@


1.9
log
@turned off debuging.
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.8 1996/07/16 10:24:09 Holt Exp Holt $
d8 3
d189 1
d2132 25
d2264 2
a2265 1
	FALSE,0,CacheTest_cmd
@


1.8
log
@added more audio env. support.
@
text
@d5 1
a5 1
* $Id: AMISHAR.C,v 1.7 1996/06/25 17:22:16 Holt Exp Holt $
d7 4
a10 1
* $Log: AMISHAR.C,v $
d12 1
a12 1
*make meany changes to support audio envelopes
d46 1
a46 1
#define	LOCALDEBUG		1			// Debugging switch for this module only
d48 1
a48 1
#define	VERBOSE			1
@


1.7
log
@make meany changes to support audio envelopes
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.6 1996/04/02 14:46:40 Holt Exp Holt $
d7 4
a10 1
* $Log: amishar.c,v $
d2013 1
a2013 1
		UWORD		durr;
d2017 2
a2018 2
		UWORD		PAN1;	
		UWORD		PAN2;	
d2022 1
a2022 1
	DBUG(print(DB_SEQ,"time=%l durr=%w flags=%w vol1=%w vol2=%w pan1=%w pan2=%w \n",
d2024 1
a2024 1
cmdptr->PAN1,cmdptr->PAN2);)
@


1.6
log
@*** empty log message ***
@
text
@d5 1
a5 1
* $Id: AmiShar.c,v 1.5 1995/11/21 11:30:42 Flick Exp Holt $
d7 4
a10 1
* $Log: AmiShar.c,v $
d2001 34
d2157 1
a2157 1
	FALSE,0,AudEnvelope,				/*Unknown,*/			/* AUDCTRL */
@


1.5
log
@Now used for Flyer AND Phoenix builds, has opt. stuff for Phx-only
@
text
@d5 1
a5 1
* $Id: AmiShar.c,v 1.4 1995/11/13 13:59:41 Flick Exp Flick $
d8 3
d37 1
a37 1
#define	LOCALDEBUG		0			// Debugging switch for this module only
d39 1
a39 1
#define	VERBOSE			0
d104 1
a104 1
	"???",
d774 1
a774 1
 *	FSrename_cmd - Stub to FSrename
d1675 18
d2120 1
a2120 1
	FALSE,0,Unknown,			/* AUDCTRL */
d2255 3
d2269 2
a2270 1
//				DBUG(print(DB_INTERP,"Cmd:%w-- ",((struct CMDHDR *)cmdptr)->opcode);)
@


1.4
log
@New fn 'ExtraErrInfo' for planting extra error info into SharedCtrl struct
ActsReset is now a stub.  'CallMod' changed to 'RunTest'.
@
text
@d3 1
a3 1
* $AmiShar.c - Amiga/Flyer shared RAM interface functions$
d5 1
a5 1
* $Id: AmiShar.c,v 1.3 1995/10/10 01:36:41 Flick Exp Flick $
d8 4
d48 1
a48 1
//#include <string.h>			// SAS include
d53 4
d2225 5
d2239 4
d2362 43
@


1.3
log
@DeFrag, EndSequence, CopyFile commands all tie-in HostAbort to their functions, command structure
now includes "Progress" field, for someday doing a gas guage to show progress (ready to go now)
Play1Clip now updates LastFieldDone when done, so does DoSearch
@
text
@d5 1
a5 1
* $Id: AmiShar.c,v 1.2 1995/09/07 09:21:51 Flick Exp Flick $
d8 5
d63 1
a63 1
	"CallMod",
d2040 17
d2061 1
a2061 1
	FALSE,0,CallMod,
d2147 1
a2147 1
	FALSE,0,ActsReset,
d2151 1
a2151 1
	FALSE,0,Unknown,			/* SELFTEST */
d2326 18
@


1.2
log
@SCSI R/W tests now multitask and run at pri 5
(release 4.06)
@
text
@d5 1
a5 1
* $Id: AmiShar.c,v 1.1 1995/08/15 16:47:10 Flick Exp Flick $
d8 4
d25 1
a25 1
#define	LOCALDEBUG		1			// Debugging switch for this module only
d159 2
d455 1
a455 1
		UBYTE	cont;
d460 4
d476 1
a476 1
		cmdptr->verify);								// (unused)
a1079 5
//Eliminated under Exec
//		ULONG		__frame;
//		UBYTE		__state;
//		UBYTE		__machnum;
//		UBYTE		__audchan;
d1082 5
d1088 8
a1095 3
	cmdptr->error = DoSearch(
		(ACTION *)(cmdptr->actptr + SRAMbase)		// Action structure
	);
d1130 1
d1132 2
d1137 4
a1140 2
		(ACTION *)(cmdptr->actptr + SRAMbase),		// Action structure
		TRUE													// Play synchronous (wait for complete)
d1142 9
d1206 1
a1206 1
		UBYTE		pad2;
d1208 3
d1973 4
d1980 4
a1983 1
	cmdptr->error = EndSequence(cmdptr->doit);
@


1.1
log
@First release (4.05)
@
text
@d5 1
a5 1
* $Id: amishar.c,v 1.0 1995/05/04 17:17:45 Flick Exp Flick $
d7 4
a10 1
* $Log: amishar.c,v $
d46 1
a46 1
BOOL	SweeperEnbl;
d2068 2
a2069 2
	FALSE,0,ReadTest_cmd,
	FALSE,0,WriteTest_cmd,
d2071 1
a2071 1
	FALSE,0,ScsiDirect_cmd,
d2206 1
a2206 1
		if (SweeperEnbl)			// Can we play with LED's now?
@


1.0
log
@FirstCheckIn
@
text
@d5 1
a5 1
* $Id$
d7 3
a9 1
* $Log$
d11 1
d18 3
a20 1
#define	LOCALDEBUG		0			// Debugging switch for this module only
a36 1

a37 1
//extern struct TaskCtrl	*MainTask;
a39 1

d45 110
a154 8

/*
 *  ValidCmd - Process or Ignore current command
 */
BOOL static ValidCmd(APTR ptr)
{
	register struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;
	UWORD	temp;
a155 6
	temp = cmdptr->opcode & 0xC000;
	if ((temp == 0x4000) || (temp == 0x8000))
		return TRUE;
	else
		return FALSE;
}
a156 7
/*
 *  NewCmd - Check for newly posted command
 */
BOOL static NewCmd(APTR ptr)
{
	register struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;
	UWORD	temp;
d158 1
a158 6
	temp = cmdptr->opcode & (UWORD)0xC000;
	if (temp == (UWORD)0x4000)
		return TRUE;
	else
		return FALSE;
}
d161 1
a161 19
#if 0
/*
 *  InProg - Check for cmd in progress
 */
BOOL InProg(APTR ptr)
{
	register struct CMDHDR *cmdptr = (struct CMDHDR *)ptr;
	UWORD	temp;

	temp = cmdptr->opcode & (UWORD)0xC000;
	if (temp == (UWORD)0x8000)
		return TRUE;
	else
		return FALSE;

}
#endif


d169 1
a169 2
#if DBUGON
	UWORD	newcode;
d172 9
a180 2
	newcode = cmdptr->opcode | 0xC000;
	print(DB_INTERP,"(%w)err=%b ",newcode,cmdptr->error);
d182 3
d186 1
a186 1
	cmdptr->opcode |= 0xC000;
a187 1
}
d196 3
d200 1
a200 1
	cmdptr->opcode = (cmdptr->opcode & 0x3FFF) | 0x8000;
d205 1
d207 1
a207 1
 *	Null - Do-nothing command
d209 1
a209 1
void static Null(APTR ptr)
a213 7
/*
 *	Dummy - Do-nothing command
 */
UBYTE static Dummy(APTR ptr,APTR *reply)
{
	return(ERR_OKAY);
}
d222 1
a222 1
	cmdptr->error = ERR_BADCOMMAND;	/* Don't understand */
d247 4
a250 2
	while ((cmdptr->opcode & 0xC000) != 0x0000) {
		if (++timeout > 100000) {
d322 1
a322 1
	GRIP				*newgrip;
d327 2
d331 1
a331 1
		(GRIP *)action->a_Grip,
d426 1
d433 2
a434 1
		&cmdptr->_newgrip
d477 1
a477 1
		ULONG	size;			// Requested size
d479 1
a479 1
//		Could add 'fragbytes' here to make non-blk-aligned files
d483 1
d486 4
d494 2
a495 1
		cmdptr->size,
d567 3
d575 2
a576 1
		&action->a_FileID
d629 1
a629 1
	DBUG(print(DB_FILESYS,"err = %b, Oldpos = %l\n",cmdptr->error,cmdptr->_oldpos);)
a851 1

d893 18
d1082 1
a1082 1
 *	FlyerPlay_cmd - Stub for FlyerPlay
d1084 1
a1084 1
void static FlyerPlay_cmd(APTR ptr)
d1094 1
a1094 1
	cmdptr->error = FlyerPlay(
d1101 22
d1136 2
a1137 1
		(ACTION *)(cmdptr->actptr + SRAMbase)		// Action structure
d1172 1
a1172 1
		UBYTE		go;
d1182 1
a1182 1
		&cmdptr->go				// If this goes FALSE, abort defrag
d1675 1
a1675 1
		cmdptr->field,
d1879 2
a1880 1
	if (chan < NUMSCSICHANS) {
d1893 100
d1995 105
a2099 98
	Null,
	Firmware,
	CallMod,
	PgmFPGA_cmd,
	SbusW_cmd,
	SbusR_cmd,
	CpuWrite_cmd,
	CpuRead_cmd,
	GetFieldClock_cmd,
	FirInit_cmd,
	FirXchg_cmd,
	LoadFirMap_cmd,
	DSPboot_cmd,
	CpuDma_cmd,
	VidParam_cmd,
	PlayMode_cmd,
	RecordMode_cmd,
	NoMode_cmd,
	ToasterMux_cmd,
	InputSelect_cmd,
	Termination_cmd,
	SearchArgs_cmd,
	DoSearch_cmd,
	FlyerPlay_cmd,
	FlyerRecord_cmd,
	ChangeAudio,
	GetSMPTE,
	NewHeadList_cmd,
	EndHeadList_cmd,
	AddClipHead_cmd,
	VoidHead,
	KillAllHeads_cmd,
	Unknown,			/* AUDCTRL */
	ScsiInit_cmd,
	ScsiInitChan_cmd,
	FindDrives_cmd,
	CopyData_cmd,
	SCSIcall,
	ReadCapac,
	Read10,
	Write10,
	FSinfo_cmd,
	FSlocate_cmd,
	FreeGrip_cmd,
	CopyGrip_cmd,
	Unknown,			/* CMPGRIPS */
	Parent_cmd,
	Unknown,			/* EXAMINE */
	FSdirlist_cmd,
	FileInfo_cmd,
	FileOpen_cmd,
	FileClose_cmd,
	FileSeek_cmd,
	FileRead_cmd,
	FileWrite_cmd,
	CreateDir_cmd,
	FSdelete_cmd,
	FSrename_cmd,
	FSrenamedisk_cmd,
	FSformat_cmd,
	DeFrag_cmd,
	FSsetbits_cmd,
	FSsetdate_cmd,
	FSsetcomment_cmd,
	WriteProt_cmd,
	Unknown,			/* FSCHGMODE */
	CreateFile_cmd,
	CopyFile_cmd,
	DebugFlags_cmd,
	SetFloobyDust,
	ReadTest_cmd,
	WriteTest_cmd,
	Suicide_cmd,
	ScsiDirect_cmd,
	Unknown,	/* (1,Clip.OpenRdFld), */
	OpenWrFld_cmd,
	CloseField_cmd,
	Unknown,	/* (1,Clip.ReadLine), */
	Unknown,	/* (1,Clip.WriteLine), */
	Unknown,	/* (1,Clip.SetFillColor), */
	Unknown,	/* (1,Clip.SkipLines), */
	GetCompInfo_cmd,
	SetTimeClock_cmd,
	StripAudio_cmd,
	WriteCalib_cmd,
	ReadCalib_cmd,
	EEwrite_cmd,
	EEread_cmd,
	ActsReset,
	SetClockFreq_cmd,
	LoadVid,
	SetDevice_cmd,
	Unknown,			/* SELFTEST */
	TBC_cmd,
	NewCutList_cmd,
	AddSubClip_cmd,
	MakeSubClips_cmd,
	CODEC_cmd
d2109 22
d2139 1
a2139 1
	struct CMDHDR	*cmdptr;
d2141 2
a2143 2
	UWORD		opcode;
	OPSPROC	func;
d2145 3
a2147 1
	UBYTE		image;
d2155 15
a2169 2
	for (;;) {
		WatchReset();		// Watch for Reset DIP -- DEBUGGING ONLY!!!
d2171 4
a2174 2
		for (ndx=0;ndx<NUMCMDSLOTS;ndx++) {
			cmdptr = (struct CMDHDR *)&cmd->slot[ndx];
d2176 17
a2192 19
			if (ValidCmd(cmdptr)) {
				DBUG(
					if (NewCmd(cmdptr))
						print(DB_INTERP,"Cmd:%w-- ",cmdptr->opcode);
				)

				opcode = cmdptr->opcode & 0x3FFF;

				if (opcode < FUNCTABENTRIES) {
					infoptr = &FuncTable[opcode];

					func = infoptr->fn;
//					if (infoptr->std == 1) {
						CommandBusy(cmdptr);		/* Mark command as in progress */
						func(cmdptr);				/* Perform the command! */
						CommandDone(cmdptr);		/* Mark command as done */
//					}
//					else
//						func(cmdptr);				/* Perform the command! */
d2194 2
a2195 1
				else {
d2199 2
a2200 2
			} /* If */
		} /* For */
d2203 2
a2204 1
		if (SweeperEnbl) {			// Can we play with LED's now?
d2206 12
a2217 3
			image = LED_ScannerData[(back>>7)&7];
			ClrLEDs(image ^ 0x3F);
			SetLEDs(image);
d2219 5
d2237 2
a2238 1
	for (i=NUMCMDSLOTS;i;i--,slot++) {
d2254 4
a2257 2
	for (i=NUMCMDSLOTS;i;i--,slot++) {
		if (((struct CMDHDR *)slot)->opcode == 0x4048) {
@
