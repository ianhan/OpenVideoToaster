*** DigiPaint 3.0 *** main.asm module
*** This program was written by Jamie Purdon (Cleveland, Ohio) for
*** NewTek (Topeka, Kansas) to market as an upgrade to DigiPaint.
*** This program's (this section and all modules on disk) code (ALL forms) is
***	Copyright © 1989  by  Jamie D. Purdon  (Cleveland, Ohio)
*** Versions delivered to NewTek and mass marketted are ALSO
***	Copyright © 1989  by  NewTek  (Topeka, Kansas)

NOTICE:	dc.b $0a,0,0,0 ;just lf ;$0d	;just lf,cr
NOTICELen	equ *-NOTICE

HIPRI	set 1 ;1=workbench 2=better/best?
MINHT	set 20	;minimum picture ht

MAXWT	set 768 ;MAR91 was 736 ;JULY051990;was 378
MAXHT	set 480

;MAXTICKTIME	set 60+20	;1.333 seconds
MAXTICKTIME	set 30	;.5 seconds

	xdef _main		;startup.o 'jsr's here
	xdef AutoMove		;moves the bigpicture based on mouse
	xdef CheckIDCMP		;returns zero//NULL if no mesg
	xdef CloseBigPic
	xdef CloseScreenRoutine
	xdef CloseWindowRoutine
	xdef CloseWindowAndScreen
	xdef cva2i ;a0=string, returns d0=#, a0 just past # (DESTROYS D1)
	xdef DoAction		;arg d0=action code
	xdef DoInlineAction	;arg longword inline before caller's rts
	xdef EndIDCMP	;turn off messages (only, don't close window etc)
	xdef ExecSetTaskPri	;argD0=new priority, returns d0=old pri !messes up A0
	xdef FixInterLace	;iffload, after automove call, gadgetrtns//undo
	xdef KeyRoutine	;only called by 'CANCEL-CHECK-GLUE' code
	xdef key_rtn_dn
	xdef key_rtn_lt
	xdef key_rtn_rt
	xdef key_rtn_up
	xdef skey_rtn_dn
	xdef skey_rtn_lt
	xdef skey_rtn_rt
	xdef skey_rtn_up
	xdef OpenBigPic		;alloc's chip, opens 'bigpicture' screen
	xdef ResetIDCMP		;sets up normal idcmp message events
	xdef ReturnMessage	;EVERYONE goes thru HERE for idcmp "ReplyMsg"s
	xdef ScanIDCMP	;d1=i'class to look for, returns ZERO found, notequal for notfnd
	xdef ResetPriority
	xdef ForceDefaultPriority	;mousertns...force 'foregrnd'
	;xdef SetDefaultPriority	;setsit to zero, if not background
	xdef SetHigherPriority	;generally quicker, for long stuff (noone?)
	xdef SetLowerPriority	;checkcancel, canceler.o, uses this

	include "ps:basestuff.i"
	include "exec/types.i"
;	include "lotsa-includes.i"
	include "intuition/intuition.i"
	;;include "intuition/intuitionbase.i"	;ib_activewindow
	include "exec/memory.i" ;needed for AllocMem requirements
	include "exec/ports.i"
	include "libraries/dosextens.i" ;for pr_{Process} structure
	include "graphics/gfxbase.i"
	include	"ps:minimalrex.i"

;	;INCLUDE "EXEC/LISTS.I"		;for paintinstinct.i
; STRUCTURE	MLH,0
;	APTR	MLH_HEAD
;	APTR	MLH_TAIL
;	APTR	MLH_TAILPRED
;	LABEL	MLH_SIZE
;
;	INCLUDE "PS:INSTINCT.I"	;TOASTER INCLUDE
;TOASTGLUE.asm...LateMay1990....is only "instinct" reference....


GWIDCMP   set MENUVERIFY!MENUPICK!MOUSEMOVE!GADGETDOWN!GADGETUP!RAWKEY

GWIDCMP	set GWIDCMP!MOUSEBUTTONS	;to handle 'brush sizer'

TOOLIDCMP set MOUSEBUTTONS!MOUSEMOVE!GADGETUP

BPIDCMP   set MOUSEBUTTONS!MOUSEMOVE!RAWKEY	;ACTIVEWINDOW
	;note: see main.key.i for...
	;bigpic rawkeys only good when in 'special' modes, line,rect,etc

	;note: want(?) 'rawkeys' on hamtools so can 'close toolbox' for picking

	xref IntServer_
	xref Ticker_
	include "exec/interrupts.i"
	include "hardware/intbits.i"
	include "hardware/custom.i"

	xref ActionCode_
	xref BB_BitMap_
	xref BigNewScreen_
	xref BigNewWindow_
	xref BigPicHt_
	xref BigPicWt_
	xref BigPicWt_W_
	xref bmhd_pageheight_
	xref bmhd_pagewidth_
	xref bmhd_rastheight_
	xref bmhd_rastwidth_
	xref bmhd_xaspect_
	xref bmhd_yaspect_
	xref bytes_per_row_
	xref bytes_row_less1_
	xref CAMG_
	xref CPUnDoBitMap_
	xref SwapBitMap_
	xref DirNameLen_	;var. program name, 1st part is dirname
	xref dosCmdLen_		;scratch.o 2 longwords for len, adr
	xref FileHandle_
	xref FilenameBuffer_
	xref FirstScreen_
	xref FlagBitMapSaved_	;automove uses this to see if go slow
	xref FlagCutPaste_
	xref FlagDisplayBeep_
	xref FlagFrbx_
	xref FlagLace_
	xref FlagLaceNEW_
	xref FlagMagnifyStart_
	xref FlagNeedIntFix_	;interlace fixzit, handled by msg code
	xref FlagNeedMagnify_
	xref FlagNeedMakeScr_
	xref FlagNeedShowPaste_	;need 'new' brush display
	xref FlagNeedRepaint_
	xref FlagNeedText_	;if scrollvport get called, redisplay coords
	xref FlagNeedGadRef_	;need gadget refresh?
	xref FlagOpen_
	xref FlagPick_
	xref FlagQuit_
	xref FlagRedrawPal_	;used by/for openhamtools
	xref FlagRefHam_
	xref FlagRepainting_
	xref FlagSingleBit_	;indicates 'single bitplane undo' of cutpaste
	xref FlagSizer_
	xref GWindowPtr_	;gadgets window on HIRES screen
	xref Initializing_	;(103*$01000000) ;error103,nomemory ;0=no,-1=yes
	;2.0;xref lwords_row_less1_
	xref MsgPtr_
	xref MScreenPtr_	;magnify screen
	xref MWindowPtr_	;magnify window (blown up pic) on mag scr
	xref NewSizeX_
	xref NewSizeY_
	xref NormalWidth_
	xref NormalHeight_
	xref OnlyPort_		;this is a STRUCT on the basepage
	xref OSKillNest_	;main.o;nest/unnest kill en/disable overscan
	xref our_task_
	xref PasteBitMap_
	xref PasteMaskBitMap_
	xref pixels_row_less1_
	xref PlaneSize_	;number of bytes in a bitplane (8000 or 16000)
	xref ProgNameLen_	;word size
	xref ProgNamePtr_	;ptr to ascii, now (SCANNABLE FOR DIR)
	xref ProgramNameBuffer_	;<=60 bytes filled in by main.cmd.i (@ end)
	xref RastPortPtr_	;RastPort for this window
	xref RememberKey_
	xref saveexecwindow_	;JULY07
	xref SBMPlane1_
	xref ScreenBitMap_
	xref ScreenBitMap_Planes_
	xref ScreenPtr_
	xref startup_taskpri_
	xref UnDoBitMap_
	xref UnDoBitMap_Planes_
	xref TextAttr_
	xref ToolBitMap_
	xref ToolWindowPtr_	;gadgets window on ham tool screen
	xref TScreenPtr_
	xref Where_We_Came_From_
	;xref WindowIDCMP_
	xref WindowPtr_
	xref words_row_less1_
	xref XAspect_
	xref XTScreenPtr_
	xref Zeros_

	xref _WBenchArgName_

;port=INITPORTE(),exec
;D0		   A6	;<<== returns	;z=error
INITPORTE:	MACRO
		moveq	#-1,D0
		CALLIB	Exec,AllocSignal  ;D0=return'd signal NUMBER
		tst.l	D0	;-1 indicates bad signal (neg/minus)
		bpl.s	cp_sigok
cp_nomemory:	moveq	#0,D0
		bra.s	end_initp		rts

cp_sigok:	move.b	D0,MP_SIGBIT(a2)
		move.b	#PA_SIGNAL,MP_FLAGS(a2)
		;move.b	#PA_IGNORE,MP_FLAGS(a2)	;dont take time to signal
		move.b	#NT_MSGPORT,LN_TYPE(a2)
		clr.b	LN_PRI(a2)	;port struct = lnode+portstuff+mlist
		move.l	our_task_(BP),MP_SIGTASK(a2) ;our_task setup in startup
		lea	MP_MSGLIST(a2),A0  ;Point to list header
		NEWLIST	A0		;Init new list macro
		move.l	a2,D0		;ensure non-zero return flag
end_initp:
	ENDM	;	rts

 xref StdOut_
PRTMSG:	MACRO ;areg-ptr-to-message,#len-of-msg
	move.l	\1,-(sp)	;adr of name
	CALLIB	DOS,Output	;get file handle, already open (cli window)
	move.l	(sp)+,d2	;d2=original string arg
	move.l	D0,StdOut_(BP)
	move.l	D0,-(sp)	;save 'stdout' file handle
	beq.s	nofileh\@	;noprint if no stdout (run from wbench?)
	move.l	D0,d1		;d1=output file handle
	moveq.l	#\2,d3		;d2=length of string
	CALLIB	SAME,Write	;>>>print it

	move.l	(sp),d1		;d1=output file handle
	lea	NOTICE(pc),a2
	move.l	a2,d2		;d2='cr,lf,...'
	moveq.l	#1,d3	;#NOTICELen,d3	;d3=length of 'cr,lf...'
	CALLIB	SAME,Write	;>>>print it

nofileh\@:
	lea	4(sp),sp
	ENDM

;**** CODE START ****;

	cnop 0,4	;longword align so no-one comp-lains


StartQuitting:	;FlagToasterAlive is valid
		;ToasterMsgPtr is null or valid
		;if toastmsgptr <> 0, then message is valid
		;we could have a SELECT or an UNLOAD pending...

;KLUDGE,WANT?;JULY071990;	cmp.l	#1,ToasterCMD_(BP)	;unload?
;KLUDGE,WANT?;JULY071990;	beq.s	no_force_copper
;KLUDGE,WANT?;JULY071990;	xjsr	ForceToastCopper	;ensure "toaster black screen"
;KLUDGE,WANT?;JULY071990;no_force_copper:

;JULY141990;	move.l	TempScreenPtr_(BP),d0
;JULY141990;	beq.s	9$
;JULY141990;	move.l	d0,a0
;JULY141990;	CALLIB	Intuition,CloseScreen
;JULY141990;	clr.l	TempScreenPtr_(BP)
;JULY141990;9$
	;;;bsr	KillMyLevel6		;spurious code killer

	xjsr	SafeEndFonts	;textstuff.o...might clear quit flag
	;tst.b FlagQuit_(BP) ;start quitting AFTER msg queue empties
	bne	EventLoop	;restart if subr SafeEndFonts "not ok"

	bsr	EndIDCMP		;stop intui-msgs NOW
	bsr	SetDefaultPriority	;close @ "normal" speed
	xjsr	CloseSkinny		;window, if any, for rgb # display
	xjsr	EndMagnify		;DOmagnify.o
	xjsr	RemoveXGadgets		;so cant gadget click while printer wait

	;;;xjsr	DebugMe1	;**************
	;;;bsr	debugavail	;**************

	xjsr	Close_Load_File		;cancel fileSAVE iif/when quitting

	;;;xjsr	DebugMe2	;**************
	;;;bsr	debugavail	;**************


Abort:
;	move.l	our_task_(BP),A0
;	move.l	saveexecwindow_(BP),d0
;	beq.s	1$
;	move.l	d0,pr_WindowPtr(A0)	;for system requesters
;1$
	xjsr	AbortPrint		;printrtns.o
	xjsr	EndPrint
	xjsr	EndPrintGads		;AUG221990....calls Free12bitprint

	xjsr	ForceToastCopper	;ToastGlue.asm...kill display ASAP...24JAN92

	bsr	CloseBigPic

	;;;xjsr	DebugMe3	;**************
	;;;bsr	debugavail	;**************

		;toaster/switcher restart....clear these too
	clr.L	LastM_Window_(BP)
	clr.L	FirstScreen_(BP)
;july051990;	xjsr	FreeDetTable	;lookup table....
	;;;;xjsr	DebugMe5	;**************
	xjsr	FreePaste	;brush		;memories.o
	;;;;xjsr	DebugMe5	;**************

	xjsr	FreeAltPaste	;swap brush	;memories.o
	;;;;xjsr	DebugMe5	;**************
	;;;;bsr	debugavail	;**************

	xjsr	FreeUnDo		;get ridda the 'old' one
	;;;;xjsr	DebugMe1	;**************
	;;;;bsr	debugavail	;**************

	cmp.l	#1,ToasterCMD_(BP)	;=#1=unload
	beq.s	free_allatonce		;july121990

	xjsr	FreeFillTbl	;mousertns.asm, 'table of colors' for flood fill, AUG301990
	xjsr	FreeSwap	;swap scr	;memories.o

		;flag all lines as "to be rendered" AUG301990 unload, de-select, whatever...
	xref	SolLineTable_
	lea	SolLineTable_(BP),a0
	bsr	FreeOneVariable		;resets so "all lines are replotted" in composite

	;;;;xjsr	DebugMe3	;**************
	;;;;bsr	debugavail	;**************
	;;;;xjsr	DebugMe
;;;  ifc 't','f'	;july08,1990.....let remember struct take care of this...
	;might want to save RGB buffers in-between runs...
	;xjsr	FreeRGB		;big picture	;rgbrtns
	;NOTE: need to "Freergb" because it could've come from ToasterChip...
	;NEWER NOTE: "allocrgb" forces "not from toaster chip"

	xref FlagKeep24_	;don't delete 24 bit buffers from toaster/switcher
	tst.b FlagKeep24_(BP)	;don't delete 24 bit buffers from toaster/switcher
	bne.s	24$
	;;;xjsr	DebugMe4	;**************
	;;;bsr	debugavail	;**************

  IFD DEBUGGER
	xjsr	debugCRLF		;debugme.asm
	xjsr	DebugMe10
	xjsr	checkavail		;debugme.asm
	xjsr	debugCRLF		;debugme.asm
  ENDC
	xjsr	FreeRGB		;big picture	;rgbrtns
	;;;xjsr	DebugMe5	;**************
	;;;bsr	debugavail	;**************
	;;;xjsr	DebugMe

  IFD DEBUGGER
	xjsr	debugCRLF		;debugme.asm
	xjsr	DebugMe11
	xjsr	checkavail		;debugme.asm
	xjsr	debugCRLF		;debugme.asm
  ENDC
	xjsr	FreeUnDoRGB	;undo		;rgbrtns (hang onto undo, too)
  IFD DEBUGGER
	xjsr	debugCRLF		;debugme.asm
	xjsr	DebugMe12
	xjsr	checkavail		;debugme.asm
	xjsr	debugCRLF		;debugme.asm
  ENDC
24$	
;;;  endc
	;;;xjsr	DebugMe6	;**************
	;;;bsr	debugavail	;**************
	;;;xjsr	DebugMe
free_allatonce:
	xjsr	FreeBUPImagery	;free chip used by BUP 2way slider imagery AUG301990
	xjsr	FreeTwoXImagery	;AUG301990
	xjsr	EndMenu			;gadgetrtns.o
	xjsr	CloseConsoleBase	;printrtns.o
	xjsr	DeleteDirsaveLock	;dirrtns.o;delete "parent"/old lock
	xjsr	DeleteNotFontDir	;dirrtns.o, digipaint pi
	xjsr	CleanupDirRemember	;dirtns.o, clear saved "dir" fib's
	xjsr	CleanupDiskObject	;iconstuff.o
Abort_nomem:
	;;;bsr	debugavail	;**************

	;xjsr	CloseDefaultFont		;defaultfont.asm...JULY221990
	;xjsr	CloseDefaultFontW		;defaultfont.asm...JULY251990
	;JULY261990....close fonts AFTER windows closed...

		;JULY07
;;;;;might need;	move.l	our_task_(BP),A0
;	move.l	saveexecwindow_(BP),d0
;	beq.s	1$
;	move.l	d0,pr_WindowPtr(A0)	;for system requesters
;1$
	;may1990';move.l	saveexecwindow_(BP),pr_WindowPtr(A0)

	xjsr	GoodByeHamTool		;ham palette

	tst.b	FlagToasterAlive_(BP)
	bne.s	nowbtoast
	CALLIB	Intuition,OpenWorkBench	;open it BEFORE closing all scrs
	xjsr	FreeUnDoRGB	;MAR91
	xjsr	FreeRGB		;MAR91

nowbtoast:
	xjsr	GoodByeToolWindows	;tool.o close hires and ham palette

	;;;;xjsr	DebugMe5	;**************
	;;;;bsr	debugavail	;**************


		;FORCE 'free-all/FreeRemember upon unload'
	tst.b FlagToasterAlive_(BP) ;no toaster msg?...
	beq.s	freenotoast		;...free all, bye bye.
	cmp.l	#1,ToasterCMD_(BP)	;=#1=unload = last command msg?
	bne.s	dontfreeeverything
freenotoast:
	;;;;xjsr	DebugMe6	;**************
	;;;;bsr	debugavail	;**************

  IFD DEBUGGER
	xjsr	debugCRLF		;debugme.asm
	xjsr	DebugMe1
	xjsr	checkavail		;debugme.asm
	xjsr	debugCRLF		;debugme.asm
  ENDC

		;close default fonts (AFTER windows/screens closed)
	xjsr	CloseDefaultFont		;defaultfont.asm...JULY221990
	;;AUG091990;;xjsr	CloseDefaultFontW		;defaultfont.asm...JULY251990

	xjsr	FreeAllMemory		;memories.o, frees RememberKey list

  IFD DEBUGGER
	xjsr	debugCRLF		;debugme.asm
	xjsr	DebugMe2
	xjsr	checkavail		;debugme.asm
	xjsr	debugCRLF		;debugme.asm
  ENDC

	move.l	our_task_(BP),A0
	move.l	saveexecwindow_(BP),pr_WindowPtr(A0)	;MAY1990
dontfreeeverything:

	;;;;xjsr	DebugMe7	;**************
	;;;;bsr	debugavail	;**************

	bsr	OffInt		;remove interrupt server
	tst.b	FlagToasterAlive_(BP) ;no toaster msg?...
	beq.s	abort_toaster		;no toaster/switcher...no cmd
	cmp.l	#1,ToasterCMD_(BP)	;=#1=unload
	bne	waitonswitcher	;startup.asm does the toaster-replymsg

abort_toaster:
		;default....
	move.l	startup_taskpri_(BP),D0
	bsr	ExecSetTaskPri

	lea	OnlyPort_(BP),a1
	CALLIB	Exec,RemPort	;remove our 'only' message port
	lea	OnlyPort_(BP),a1

	moveq	#0,D0
	move.b	MP_SIGBIT(a1),D0
	CALLIB	SAME,FreeSignal	;a6=execbase

	;;;xjsr	DebugMe8	;**************
	;;;xjsr	DebugMe8	;**************
	;;;xjsr	DebugMe		;**************
	;;;bsr	debugavail	;**************

abort_portdone:

;KLUDGE,WANT?;JULY071990;	move.l	startup_taskpri_(BP),D0
;KLUDGE,WANT?;JULY071990;	bsr	ExecSetTaskPri

;KLUDGE,WANT?;JULY071990;	xjsr	CleanupMemory
  IFD DEBUGGER
	xjsr	CloseDebug		;july081990
  ENDC
;;	xjsr	CloseDebug	;debugme.asm KLUDGEOUT AUG221990

	move.l	Where_We_Came_From_(BP),a7	;fix stack back to entry point
	;SEP101990;move.b  Initializing_(BP),D0	;system error code return (103nomem)
	;SEP101990;ext.w	d0
	;SEP101990;ext.l	d0
	moveq	#0,d0		;SEP101990
	move.b  Initializing_(BP),D0	;system error code return (103nomem)
	rts				;for good.(whew!).(return to startup.)

ForcedPortName:	dc.b 'DigiPaint',0
		dcb.b 32-9,0	;use 32 as max port name len, if file-zapping
	cnop 0,2	;ensure that code is word-aligned
ForcedProgName:	dc.b 'ToasterPaint',0	;AUG141990
		dcb.b 32-12,0	;use 32 as max port name len, if file-zapping
	cnop 0,2	;ensure that code is word-aligned


_main:	move.l	a7,Where_We_Came_From_(BP)	;save our stack

	bsr	SetDefaultPriority	;main.o;returns old pri in D0 !messes up A0/D0
	move.l	D0,startup_taskpri_(BP) ;restore original pri when done
	bsr	ExecSetTaskPri		;restore original pri "now", too
	move.b	#103,Initializing_(BP)	;error103,nomemory
	xjsr	InitScratch		;scratch.o

	;xjsr	DebugMe7	;**************
	;;;bsr	debugavail	;**************

	;compositepaint;....*do* print out
	;november1990;PRTMSG NOTICE,NOTICELen		;version #, CopyRight to cli(if any) output

	lea	OnlyPort_(BP),a2
	INITPORTE		;sets A6:=execbase, gets signal, inits portA2
	beq	abort_portdone
	lea	(a2),a1			;port (again, for adding)
	;AUG081990;lea	ProgramNameBuffer_(BP),a0	;port name is now program name
	lea	ForcedPortName(pc),a0	;force PORT name 2b 'DigiPaint'
	move.l	A0,LN_NAME(a1)		;broadcast our port name now...
	CALLIB	SAME,AddPort		;"hey system, *here* I am!"


	;xjsr	DebugMe8	;**************
	;;;bsr	debugavail	;**************


		;FORCE setup only upon "load" or no-toaster
	move.l	ToasterMsgPtr_(BP),d0	;nasty, toaster msg there yet?
	beq.s	domaincmd		;toaster's not there, no message
	;move.l	d0,a0
	;move.l	MN_SIZE(a0),d0	;FBC_command...0=load, 1=unload, 2=select
	move.l	ToasterCMD_(BP),d0
	cmp.l	#1,d0		;=#1=unload?
	bne	nomaincmd	;setup only done once...?
domaincmd:
	include "ps:main.cmd.i"	;setup ScreenHeight,FlagLace,bmhd_w/h,ns_VMode
nomaincmd:

;SEP101990;		;SEP081990.....non-standalone....
;SEP101990;	tst.b	FlagToasterAlive_(BP)
;SEP101990;	bne.s	notstandalone
;SEP101990;	tst.b	FlagCapture_(BP)
;SEP101990;	beq	Abort_nomem
;SEP101990;notstandalone:



		;KLUDGE....
	;xjsr	SupBottomAscii ;showtxt.o ;rtns a0=already sup text bottom row
	;move.b	#$0a,46(a0)
	;move.b	#$0d,47(a0)
	;PRTMSG a0,80 		;version #, CopyRight to cli(if any) output

	include "ps:main.toast.i"	;determine if toaster "there"...


		;if NOT from switcher, load fonts
	tst.b	FlagToasterAlive_(BP)
	bne.s	waitonswitcher
	xjsr	OpenDefaultFont		;defaultfont.asm...JULY221990
	bne	Abort_nomem
	;;AUG091990;xjsr	OpenDefaultFontW	;white font,defaultfont.asm...JULY2521990
	;;AUG091990;bne	Abort_nomem



waitonswitcher:
	tst.b	FlagToasterAlive_(BP)
	beq.s	notoastnow

  IFD DEBUGGER
	xjsr	DebugMe	;prints out bitmaps
  ENDC
	jsr	ToasterWait	;0=load, 1=unload, 2=select

	tst.l	d0
	bne.s	notzeroload

	;'LOAD' MESSAGE FROM SWITCHER
	;toaster-mode only, load default pictures ASAP, before ToasterChip/SELECT usage...
	moveq	#0,d0
	BSR	TErrorStuff	;setup error code

	xjsr	OpenDefaultFont		;defaultfont.asm...JULY221990
	bne	cant_find_fonts ;mem
	;;AUG091990;xjsr	OpenDefaultFontW	;white font,defaultfont.asm...JULY2521990
	;;AUG091990;;bne	Abort_nomem
	beq	okfonts
cant_find_fonts:
	move.l	#1,ToasterErrorCount_(BP)	;couldn't find font(s)
	;;;bra	Abort_nomem
okfonts:



	bra.s	waitonswitcher	;0=load.....only "do" something at unload/select

notzeroload:
	cmp.l	#1,d0		;unload?
	bne.s	checkbumsel
	st	FlagQuit_(BP)
	;no workie...;bsr	BlueScreen	;set screen colors to 'bluish' in-between (NOT black!)
	bsr	ToasterReply	;JULY071990....toaster waits until paint process dies
				;...before unloadseg'ing
	bra	StartQuitting	;abort_toaster	;die....Abort
checkbumsel:
	cmp.l	#2,d0		;=selected? (bummer...to soon...)
	bne.s	waitonswitcher
	sf	FlagQuit_(BP)	;QUIT status was set "last time run"...
	;hang onto select message;jsr	ToasterReply	;main.toast.i
	st	Initializing_(BP)	;digipaint 'startup' conditions...
	xref	FlagCDet_		;calls for 'createdetermine' call
	st	FlagCDet_(BP) ;NeedCreateDetermine_(BP)	;resets up palette...
notoastnow:

	;st	FlagQuit_(BP)	;KLUDGE....july051990
	;bra	StartQuitting	;KLUDGE....july051990

	;move.l	#BPIDCMP,WindowIDCMP_(BP)	;STARTUP/default

	;bsr	debugavail	;**************
	;xjsr	DebugMe		;**************

	;;;xjsr	DebugMe9	;**************
	;;;bsr	debugavail	;**************

		;disable system ("insert disk...")requesters...JULY06
	tst.l	saveexecwindow_(BP)
	bne.s	windowptrsaved
	move.l	our_task_(BP),A0		;startup.o
	move.l	pr_WindowPtr(A0),D0		;current/original err screen
	move.l	D0,saveexecwindow_(BP)		;...restore it later
	move.l	#-1,pr_WindowPtr(A0)		;no window now, auto-cancels
windowptrsaved:

	;	;KLUDGE
	;;;;xjsr	DebugMe1
	;	move.l	#MEMF_CHIP,d1
	;	CALLIB	Exec,AvailMem
	;;;;xjsr	debug_print_longword
	;	move.l	#MEMF_FAST,d1
	;	CALLIB	Exec,AvailMem
	;;;;xjsr	debug_print_longword

	moveq	#0,d0		;july051990
	BSR	TErrorStuff	;setup error code
	BSR	TErrorNoMemory	;setup "unload me, slice!" in SELECT message
	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg

	;xjsr	DebugMe1
	;;;bsr	debugavail
  IFC 't','f'
	xjsr	OpenDefaultFont		;defaultfont.asm...JULY221990
	bne	Abort_nofont ;mem
	;;AUG091990;xjsr	OpenDefaultFontW	;white font,defaultfont.asm...JULY2521990
	;;AUG091990;;bne	Abort_nomem
	beq	okfonts
Abort_nofont:
	move.l	#1,ToasterErrorCount_(BP)	;couldn't find font(s)
	bra	Abort_nomem
okfonts:
  ENDC
	xjsr	ForceToolWindow  ;first time open tool windows, disabled 'idcmp
	tst.l	GWindowPtr_(BP)		;hires gadget window get opened?
	beq	Abort_nomem
	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg

	;xjsr	DebugMe2
	;;;bsr	debugavail

	CALLIB	Intuition,CloseWorkBench	;explicit call, here

	bsr OnInt ;adds vertb intserver, do after ProgNamePtr setup in main.cmd

	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg
	;;xjsr	DebugMe3
	;;;;bsr	debugavail

	xjsr	AllocDetermineTable	;memories.asm;getitifwedonthave it
	beq	Abort_nomem

;	move.l	our_task_(BP),A0		;startup.o
;	move.l	pr_WindowPtr(A0),D0		;current/original err screen
;	move.l	D0,saveexecwindow_(BP)		;...restore it later
;	move.l	GWindowPtr_(BP),pr_WindowPtr(A0) ;hires screen for SYSTEM MSGS

	xjsr	InitShortMulTable	;memories.o, shortmultable for paintcode
	beq	Abort_nomem
	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg
	;xjsr	DebugMe4
	;;;;bsr	debugavail

	st	FlagNeedHiresAct_(BP)
	bsr	ReallyActivate		;only if not background...

	xjsr	SetAltPointerWait	;1st time//startup sup 'sleepycloud'

	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg
	bsr	ResetIDCMP		;pointer? yea? idcmp too...

	;xjsr	DebugMe5
	;;;;bsr	debugavail


;works 2 here;	st	FlagQuit_(BP)	;KLUDGE....july051990
;works 2 here;	bra	StartQuitting	;KLUDGE....july051990


	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg
	xjsr	_Aoff_rx		;gadgetrtns.o

	BSR	TErrorInc	;d'bugger, incs error # for toaster/select msg
	tst.b	FlagToasterAlive_(BP)	;july071990....dont do this twice...
	bne.s	diddflt
	xjsr	_Dflt_rx		;gadgetrtns.o, loads default pictures
diddflt:
	BSR	TErrorInc	;#8;d'bugger, incs error # for toaster/select msg
	;xjsr	DebugMe6
	;;;;bsr	debugavail

		;did the picture get loaded?...if not...bye! 
	xref PicFilePtr_	;hp.gads, the entire file, in memory
	tst.l	PicFilePtr_(BP)	;hp.gads, the entire file, in memory
	beq	StartQuitting


	BSR	TErrorInc	;#9;d'bugger, incs error # for toaster/select msg

	;	;DO "BOOT" STUFF BEFORE PICTURE LOAD...MAY'90
	;xjsr	CreateDetermine		;displays new pallette, too
	;xjsr	BeginMenu	;'pmcl' a-code needs menu on hires
	;bsr	DoInlineAction
	;dc.w	'Pm'
	;dc.w	'cl'		;Paint Mode CLear
	;move.l	#'Boot',d0	;d0=LONG # (equiv 4 ascii) ('boot' code(s))
	;bsr	ZipKeyFileAction ;main.key.i, reads keyfile for startup cond

	move.w	#MAXWT,BigPicWt_W_(BP)
	move.w	#MAXHT,BigPicHt_(BP)



;works;	st	FlagQuit_(BP)	;KLUDGE....july051990
;works;	bra	StartQuitting	;KLUDGE....july051990


	move.l	#'BOOT',d0	;d0=LONG # (equiv 4 ascii) ('boot' code(s))
	bsr	ZipKeyFileAction ;main.key.i, reads keyfile for startup cond

		;SEP101990.....non-standalone....
	tst.b	FlagToasterAlive_(BP)
	bne.s	notstandalone
	tst.b	FlagCapture_(BP)
	;beq	StartQuitting	;Abort_nomem
	bne.s	notstandalone	;ok to continue
	move.B	#218,Initializing_(BP)	;ERROR_DEVICE_NOT_MOUNTED	EQU	218
	bra	StartQuitting
notstandalone:


;?;	st	FlagQuit_(BP)	;KLUDGE....july051990
;?;	bra	StartQuitting	;KLUDGE....july051990


	BSR	TErrorInc	;#10;d'bugger, incs error # for toaster/select msg
	;xjsr	DebugMe7
	;;;;bsr	debugavail

	move.l	_WBenchArgName_(BP),d1
	beq.s	startupname			;no wbarg (ascii ptr)
	move.l	d1,a1
	lea	FilenameBuffer_(BP),a2
	xjsr	copy_string_a1_to_a2	;copy wbench's filename to gadget buffer
	
startupname:

	moveq	#0,d0			;move.l	#'Opsc',d0
	lea	FilenameBuffer_(BP),a0
	tst.b	(A0)			;ascii string? "have a filename"?
	sne	FlagOpen_(BP)		;yes/no set/clear "file open" status
	beq.s	1$			;HAVE filename?...if so, load it
	xjsr	ForceAmigaCopper ;IntuitionRtns.asm, kill toaster's copper list...
	bsr	DoInlineAction	
	dc.w	'Ok'
	dc.w	'ls'
1$:
	BSR	TErrorInc	;#11;d'bugger, incs error # for toaster/select msg
	;xjsr	DebugMe8
	;;;;bsr	debugavail

;	tst.b	FlagQuit_(BP)
;	beq.s	999$
;;;;	xjsr	DebugMe12
;999$


	;bsr	debugavail	;**************
	;xjsr	DebugMe		;**************


;;	xjsr	OpenDebug	;debugme.asm KLUDGEOUT AUG221990


  IFD DEBUGGER	;basestuff.i
		;kludgey...comment out....debug tool
	bra.s	skipavail

	xdef debugavail
debugavail:
	xref debug_handle	;absolute ref, debugme.asm
	movem.l	d0-d4/a0-a6,-(sp)
	xjsr	OpenDebug	;debugme.asm
	move.l	debug_handle,d3
	bne.s	gotoutput
	CALLIB DOS,Output	;get file handle, already open
	move.l d0,d3		;get ready to write to it
gotoutput:
	beq.s	doneavail	;no handle (d3)
	lea	CmdString(pc),a0
	move.l	a0,d1		;d1=string to execute
	moveq	#0,d2		;d2=input
	;;;move.l	StdOut_(BP),d3	;d3=output
	CALLIB	DOS,Execute
	xjsr	GraphicsWaitBlit	;wait for cli to display (memories.asm)
doneavail:
	movem.l	(sp)+,d0-d4/a0-a6
	rts
CmdString:	dc.b	'Avail',0
	cnop	0,2
skipavail:
  ENDC ;ifd DEBUGGER

;works;	st	FlagQuit_(BP)	;KLUDGE....july051990
;works;	bra	StartQuitting	;KLUDGE....july051990

*** main loop ***;GRAND MAIN HIGHEST TOTAL UPPERMOST TOP BIGGEST LOOP START
	;"action"s have the highest "priority" in the digipaint paradigm
	;...handle all "waiting to be done" actions before any msgs
	;...btw:msgs usually just set up an 'action code'

restart_if_msg:	MACRO	;quick check, any msgs?, if so go get
	;lea	OnlyPort_(BP),a0
 	;lea	MP_MSGLIST(a0),a1
	;cmpa.l	8(a1),a1
	;bne	trymsg
	bsr	reloop_if_msg
	ENDM

	;xjsr	DebugMe1
	;;;xjsr	DebugMe1

  IFD DEBUGGER
	xjsr	DebugMe	;kludge, of cours
  ENDC

	BSR	TErrorRunOk		;clear out "unload me" status
	bra.s	EventLoop

reloop_if_msg:	;bsr here...
	move.l	(sp)+,a6		;very temporary, pop subr rtn

	tst.l	ActionCode_(BP)		;restart if any routine left another
	bne.s	EventLoop		;...action code 2b done...SEP061990

	lea	OnlyPort_(BP),a0
 	lea	MP_MSGLIST(a0),a1
	cmpa.l	8(a1),a1
	bne.s	trymsg	;event loop
	jmp	(a6)	;"return from subr"

EventLoop:
	lea	ActionCode_(BP),a0
	move.l	(a0),d0			;do 'actions' until none indicated
	beq.s	trymsg			;no action, go do message
	moveq	#0,d1
	xref	ThisActionCode_		;02FEB92
	xref	LastActionCode_		;02FEB92
	cmp.l	#'Move',ThisActionCode_(BP)
	beq.s	1$			;skip 'move' action codes...
	move.l	ThisActionCode_(BP),LastActionCode_(BP)	;02FEB92...ref'd by GadgetRtns for 'Ccto' 2.0 bug
1$	move.l	(a0),ThisActionCode_(BP)	;02FEB92...ref'd by GadgetRtns for 'Ccto' 2.0 bug
	move.l	d1,(a0)			;clears ActionCode_(BP)
	bsr	DoAction

	;;;xjsr	GraphicsWaitBlit	;MAY1990 KLUDGE..."judicious use..."


trymsg:
;	;bug fix to prevent "quitting" from hanging DigiView 
;	;...while DigiView is sending a picture
;	tst.b	FlagQuit_(BP)
;	beq.s	1$
;	clr.b	ProgramNameBuffer_(BP)	;port name = program name
;1$

	;;;bsr	SetMyLevel6		;do this OFTEN

	bsr	CheckIDCMP		;check msg port
	beq.s	nomsg
gotmsg:	bsr	Process_IDCMP_Mesg	;grand master msg handler
	bra.s	EventLoop		;RESTART MAIN LOOP
nomsg:
;;;;;;;;	bsr ReallyActivate	;activate hires (ifneeded) asap, helps w/Clbx AUG231990

	xref	FlagNeedAutoMove_	;18DEC91....input handler/mousemove generator/main loop
	lea	FlagNeedAutoMove_(BP),a0
	tst.b	(a0)			;flag set by input handler
	beq.s	no_handlermove
	sf	(a0)
	xjsr	AutoMouseMove
no_handlermove:


;;;;;; xjsr DebugPrint12	;prints 15 longwords of Print12Ptr_ structure ;KLUDGE, AUG221990

;aug011990;		;handle "always render" mode....AUG011990
;aug011990;	xref	SolLineTable_
;aug011990;	tst.l	SolLineTable_(BP)	;any lines to be rendered?
;aug011990;	beq.s	norender
;aug011990;	xref FlagAlwaysRender_
;aug011990;	tst.b	FlagAlwaysRender_(BP)
;aug011990;	beq.s	norender
;aug011990;	move.l	#'Vwco',ActionCode_(BP)	;view composite action code
;aug011990;	bra.s	EventLoop
;aug011990;norender:

  IFC 't','f' ;AUG161990

		;handle 'auto-draw' of airbrush
	xref LastDrawX_
	xref LastDrawY_
	xref MyDrawX_
	xref MyDrawY_
	tst.b	FlagDoAir_(BP)
	beq.s	noairnow
	;sf	FlagDoAir_(BP)
	subq.B	#1,FlagDoAir_(BP)
	move.l	#'Move',ActionCode_(BP)	;"spatter"s another air-brush-drop
	move.w	LastDrawX_(BP),MyDrawX_(BP)	;..circctr, linest, rect1crnr
	move.w	LastDrawY_(BP),MyDrawY_(BP)
	bra.s	EventLoop
noairnow:
  ENDC ;AUG161990

	;;;BRA	StartQuitting	;KLUDGE.......COMPOSITE PAINT

		;empty msg queue, start doing "slower" things
	tst.b	FlagQuit_(BP)	;start quitting AFTER msg queue empties
	beq.s	008$
	xjsr	SafeEndFonts	;textstuff.o...might clear quit flag
	;july051990;tst.b	FlagQuit_(BP)	;start quitting AFTER msg queue empties
	;july051990;bne	StartQuitting
	bsr	CheckIDCMP		;check msg port
	bne.s	gotmsg			;re-loop
	bra	StartQuitting
008$

		;open "bigpic" screen, but only "upon conditions"
	tst.l	ScreenPtr_(BP)		;big painting picture still there?
	bne.s	afterFORCEscreen	;not when already have a bigpic
	tst.b	FlagSizer_(BP)
	bne.s	afterFORCEscreen	;not when "screen sizer" active
	tst.W	FlagOpen_(BP)		;filerequester? (load/save/font/brush)
	bne.s	afterFORCEscreen	;not when file request "open"
	;AUG281990;tst.w	FlagViewComp_(BP)
	;AUG281990;bne.s	afterFORCEscreen	;not when file request "open"
	move.l	#'Opsc',ActionCode_(BP)	;if 'opsc' no go, then sups sizer mode
	bra	EventLoop
afterFORCEscreen:


  IFC 't','f' ;02FEB92....helps w/pick color sprite colors on a 68000

		;handle "autoscroll" of "bigpicture"
	bsr	AutoMove	;move//scroll bigpic
;;;  ifc 't','f' ;NO NEED SUNDAY MAY13'90....since automove is now signal'd
	tst.b	FlagNeedIntFix_(BP) ;did picture-move-scroll happen?
	beq.s	noscr		;skip scrol-loop, didnt/not scrolling
	xjsr	DoMinDisplayText ;showtxt.o, minimum timered text
	bsr	FixInterLace
	bra	EventLoop	;RESTART...handles menus,ptr,etc(scrolling)
noscr:
  ENDC ;IFC 't','f' ;02FEB92....helps w/pick color sprite colors on a 68000
	;SUNDAY MAY13...NO NEED SINCE MAIN.KEY.I fixes scroll speed stuff..
	;clr.w	ScrollSpeedX_(BP)	;STOP scrolling
	;clr.w	ScrollSpeedY_(BP)
;;;  endc

	xjsr	CheckKillMagnify
	xjsr	CheckBegMagnify	;begin magnify
	restart_if_msg

	xjsr	ReDoHires	;hires display, gadget update/refresh

;		;draw circles, etc asap after scrolling....;;AUG111990
;	restart_if_msg
;	tst.b	FlagNeedRepaint_(BP)
;	beq.s	noquickdraw
;	xjsr	DoSpecialMode	;drawb.mode.i, drawbrush.asm
;noquickdraw:
;no....follow the philosophy...let everything happen first...
	;06DEC91;restart_if_msg		;AUG111990...

  IFC 't','f' ;causes sizer to flash continously in 1x+continuous render modes
	;09DEC91...bugfix for brush sizer not displaying in continuous render mode
	xref	FlagAlwaysRender_	;09DEC91
	xref	FlagUpdateCG_		;09DEC91
	tst.b	FlagAlwaysRender_(BP)
	beq.s	notalways
	st	FlagUpdateCG_(BP)	;set when need update of brush sizer 08DEC91...FOR 1x mode?
	;movem.l	d0-d7/a0-a5,-(sp)
	;bsr	UpdateCustomGads	;main loop/gadget refresh for custom gadgets
	;movem.l	(sp)+,d0-d7/a0-a5
notalways:
  ENDC ;IFC 't','f' ;causes sizer to flash continously in 1x+continuous render modes


	;09DEC91...done later;xjsr	UpdateCustomGads	;customgads.asm, brush sizer
	;09DEC91...done later;restart_if_msg		;06DEC91
	;;;xjsr	DoMinDisplayText ;showtxt.o, minimum timered text DIGIPAINT PI MAY 1990

;;;  IFC 't','f' ;KLUDGE,WANT;
;JULY141990;		;digipaint pi
;JULY141990;		;help out 'menu display routines' re: temp screen
;JULY141990;	move.l	TempScreenPtr_(BP),d0
;JULY141990;	beq.s	99$
;JULY141990;	move.l	d0,a0
;JULY141990;	CALLIB	Intuition,CloseScreen
;JULY141990;	clr.l	TempScreenPtr_(BP)
;JULY141990;	bsr	RestoreTopBar		;put back 'saved data' from top of pic
;JULY141990;	lea	Temp10Data_(BP),a0
;JULY141990;	xjsr	FreeOneVariable		;memories.o
;JULY141990;99$:	restart_if_msg
;;;  ENDC

	;;;;xjsr	DebugMe1

		;INITIALIZING/STARTUP stuff
	tst.l	ScreenPtr_(BP)	;bigpic?
	beq	after_inittime	;bigpic not opened yet
	tst.b	Initializing_(BP)
	beq	after_inittime	;not sup time
	clr.b	Initializing_(BP)	;ALRIGHT!

	xjsr	SupBottomAscii ;showtxt.o ;rtns a0=already sup text bottom row
	;JULY311990;move.b	#$0a,46(a0)
	;JULY311990;move.b	#$0d,47(a0)
	;AUG081990;move.b	#$0a,48(a0)
	;AUG081990;move.b	#$0d,49(a0)
	;DEC90;move.b	#$0a,28(a0)	;cr
	;DEC90;move.b	#$0d,29(a0)	;..lf, after "name"
	;DEC90;move.b	#$0a,58(a0)	;cr
	;DEC90;move.b	#$0d,59(a0)	;..lf, after "copyright"
 	move.b	#$0a,32(a0)	;cr
	;move.b	#$0d,29(a0)	;..lf, after "name"
	move.b	#$0a,60(a0)	;cr
	;move.b	#$0d,59(a0)	;..lf, after "copyright"

	;AUG081990;PRTMSG a0,80 		;version #, CopyRight to cli(if any) output
	PRTMSG a0,81 		;version #, CopyRight to cli(if any) output

		;DO "BOOT" STUFF BEFORE PICTURE LOAD...MAY'90
	;;;;xjsr	DebugMe2

	xjsr	CreateDetermine		;displays new pallette, too
	;;;;xjsr	DebugMe3
	xjsr	BeginMenu	;'pmcl' a-code needs menu on hires

	;;;;xjsr	DebugMe4

	bsr	DoInlineAction
	dc.w	'Pm'
	dc.w	'cl'		;Paint Mode CLear
	move.l	#'Boot',d0	;d0=LONG # (equiv 4 ascii) ('boot' code(s))
	bsr	ZipKeyFileAction ;main.key.i, reads keyfile for startup cond
	;;;;xjsr	DebugMe5

	bra	EventLoop
after_inittime:

	;;;;xjsr	DebugMe6

	xjsr	OpenHamTools	;reserve the memory (pmcl wants hamtools?)
	;;;;xjsr	DebugMe7

	restart_if_msg

		;ARRANGE SCREENS
	xjsr	ScreenArrange		;gadgetrtns.o (call b4 displaybeep)
	restart_if_msg

	xjsr	ForceAmigaCopper ;IntuitionRtns.asm, kill toaster's copper list...

	;;;;xjsr	DebugMe8

	xjsr	AproPointer		;appropriate hires ptr bgadrtns.asm
	xjsr	UpdateCustomGads	;customgads.asm, brush sizer 09DEC91
	xjsr	FixPointer		;helps out 'customized brush'
	restart_if_msg

	xjsr	HiresColorsOnly		;pointers.o, sup colors on hires
	restart_if_msg			;02FEB92
	xjsr	UseColorMap		;(pointers.o, for now)
	restart_if_msg


;	tst.b	FlagDisplayBeep_(BP)
;	beq.s	dontbeep
;	sf	FlagDisplayBeep_(BP)	;so dont happen 2x
;	suba.l	a0,a0		
;	CALLIB	Intuition,DisplayBeep
;	restart_if_msg
;dontbeep:
	xjsr	IntuDisplayBeep	;intuitionrtns.asm

	bsr	ResetIDCMP	;change idcmp ONLY when no msgs (or new scr)
	bsr ReallyActivate	;activate hires (ifneeded) asap, helps w/Clbx
	restart_if_msg
	xjsr	SupHamGads	;tool.code.i, add gadgets to hamtools
	restart_if_msg

	lea	FlagRedrawPal_(BP),a0
	tst.b	(a0)
	beq.s	easetc
	sf	(a0)
	xjsr	RedrawPalette	;tool.code.i,refreshes needed hamtool gads
	restart_if_msg
easetc:

		;update rgb sliders on hamtools
	lea	FlagRefHam_(BP),a0
	tst.b	(a0)			;asking for new colormaps?
	beq.s	earefh			;...nope.
	;;;sf	(a0)			;clear flag so don't reset cmaps again
	sf	FlagRefHam_(BP)		;flag so dont happen 2x
	xjsr	UpdatePalette		;showpal.o, show rgb sliders, cbrites
	restart_if_msg
	xjsr	DoMinDisplayText	;showtxt.o, min'timered text
	restart_if_msg			;msg after showtxt? (sys uses 756bytes)
earefh:

	xjsr	DoShowPaste	;cutpaste.o, TIMERED shows cutout brush
		;show magnify asap...in 'mintimered loop'..
	tst.l	PasteBitMap_Planes_(BP)	;carrying a brush?
	beq.s	379$
	xjsr	DoMagnify ;min'timer'd...(this one's for draw/cut-ing)..."faster"
379$
	restart_if_msg

	move.b	FlagSingleBit_(BP),d0	;cutpaste/blits/only 1 bitplane up?
	or.b	FlagNeedShowPaste_(BP),d0 ;need 'new' brush display
	beq.s	oknosho
	xjsr	ReallyShowPaste		;NON timer'd brush display (c/b SLOW)
oknosho:

	xjsr	DoSpecialMode	;drawb.mode.i, (rectangle, circle, line, curve)
	xjsr	DoMinDisplayText ;showtxt.o, minimum timered text
	xjsr	DoMinMagnify	;min'timer'd...(this one's for draw/cut-ing)
	restart_if_msg		;check for msg AFTER text, palette update

	xjsr	ReallyDoMagnify		;force magnify display
	xjsr	ReallyDisplayText	;force text display (clrs FlagNeedText)
	bsr	FixInterLace		;slow?
	restart_if_msg

	tst.b	FlagRefHam_(BP)	;openhamtool just happen?
	bne	EventLoop
	xjsr	ShowPalette	;showpal.o, checks/clears FlagNeedShowPal
	restart_if_msg		;check for msg AFTER text, palette update

	bsr	ResetPriority	;(showpaste//blits?...coulda upped it)
	restart_if_msg

	;xref	FlagWholeHam_		;'main loop' handles this flag -> Wham.asm
	;lea	FlagWholeHam_(BP)
	xjsr	WholeHam		;redo's ham display, if possible

	xjsr	ViewPage	;viewpage.o, only does it if flag set
	bne.s	afterwait	;happen'd...restart (ViewPage contains a Wait)

	xref	FlagViewComp_		;view composite...
;;  IFC 't','f' ;KLUDGE,WANT,*NEED*
		;display/update composite "view" (newcode)
	tst.l	FileHandle_(BP)		;*only* reason a file would be open,
	bne.s	96$ ;compositerender		;here, is when rendering->framestore file
	tst.W	FlagOpen_(BP)		;AUG241990...no rendering if in file requester
	bne.s	98$			;....eliminates 're-render' of whole screen
	lea	FlagViewComp_(BP),a0
	tst.w	(a0) ;FlagViewComp_(BP)	;view composite...
	beq.s	98$
	;NOPE....ACTION CODE Shcf CLEARS THIS;clr.w	(a0) ;FlagViewComp_(BP)
96$:	;compositerender:

		;AUG281990
	xref FlagPick_
	tst.b	FlagPick_(BP)
	bne.s	98$		;no rendering while picking a color...

;AUG281990LATE;		;AUG281990
;AUG281990LATE;		;ok, want to show toast/custom copper list....
;AUG281990LATE;		;but "stall" in case the user is just moving the mouse, etc.
;AUG281990LATE;
;AUG281990LATE;	;ONE SECOND;move.w	#6-1,d2	;6 1/10s of a second to stall...
;AUG281990LATE;	move.w	#2-1,d2	;1/3 second stall....
;AUG281990LATE;97$	moveq	#10,d0	;dos arg is in ticks (1/60 or 1/50 of a second)
;AUG281990LATE;	moveq	#10,d1
;AUG281990LATE;	CALLIB	DOS,Delay
;AUG281990LATE;	restart_if_msg
;AUG281990LATE;	dbf	d2,97$

	xjsr	CustomCopper	;copper.o
	bra.s	afterwait
98$
;;  ENDC
	tst.l	PasteBitMap_Planes_(BP)	;27JAN92
	beq.s	nodouble		;*always* free the doublebuffer 27JAN92
	move.l	our_task_(BP),a0 ;ptr to task(|process) structure
	tst.b	LN_PRI(a0)	;BYTE LN_PRI in task struct already?
	bpl.s	yesalive
nodouble:
	xjsr	FreeDouble	;kills//frees chipmem copy of picture
yesalive:

	xjsr	ActivateText	;only happens upon apro' conditions

	restart_if_msg		;june01,1990, switcher does weird things 2nd time run?


		;handle "always render" mode....AUG011990
	xref FlagAlwaysRender_
	tst.b	FlagAlwaysRender_(BP)
	beq.s	norender
	xjsr	DetermineRender		;composite.asm
	beq.s	norender

  ifc 't','f' ;removed NOV91
		;AUG281990
		;ok, want to show toast/custom copper list....
		;but "stall" in case the user is just moving the mouse, etc.
	;ONE SECOND;move.w	#6-1,d2	;6 1/10s of a second to stall...
	move.w	#2-1,d2	;1/3 second stall....
97$	moveq	#10,d0	;dos arg is in ticks (1/60 or 1/50 of a second)
	moveq	#10,d1
	CALLIB	DOS,Delay
	restart_if_msg
	dbf	d2,97$
  endc ;ifc 't','f' ;removed NOV91

	move.l	#'Vwco',ActionCode_(BP)	;view composite action code
	bra	EventLoop
norender:

	;;;;xjsr	DebugMe7	;**************
	;;;;bsr	debugavail	;**************

	;29JAN92;moveq	#-1,D0		;indicate signal set of all//any
	;29JAN92;CALLIB	Exec,Wait

	moveq	#4-3,d0
	moveq	#4-3,d1
	CALLIB	DOS,Delay

	;30JAN92;xjsr	DebugMe		;30JAN92
	;30JAN92;	;29JAN92...Debug only....
	;30JAN92;moveq	#-1,D0		;indicate signal set of all//any
	;30JAN92;CALLIB	Exec,Wait
	;30JAN92;;xjsr	DebugChipmem	;debugme.asm


	bsr	NoSignalAutoMove ;main.key.i ;only called after a "wait" in main loop

	;;xref FlagDoAir_		;handled by interrupt routine (main.int.i)
	;tst.b	FlagDoAir_(BP)
	;beq.s	afterwait
	;sf	FlagDoAir_(BP)
	;;;move.l	#'Move',ActionCode_(BP)	;"spatter"s another air-brush-drop
	;;;xjsr	Move_entry	;MouseRtns.asm, "spatter" another drop

	;KLUDGE OUT;xjsr	DrawBrush	;DrawBrush.asm, "spatter" another drop

afterwait:

	xref RemagTick_
	xref ShowPasteTick_
	xref RetextTick_
	move.l	Ticker_(BP),d0		;'clocktime'
	move.l	d0,RemagTick_(BP)	;reset 'clock's so
	move.l	d0,ShowPasteTick_(BP)	;...'natural' priority happens...
	move.l	d0,RetextTick_(BP)	;...can then call domintext b4 showpaste

	bra	EventLoop


 xdef ReallyActivate	;only xref'd by repaint/scratch.o
ReallyActivate:

	xjsr	AreWeAlive
	beq.s	noneedact			;no window, cant activate it

	lea	FlagNeedHiresAct_(BP),a0
	tst.b	(a0)
	beq.s	noneedact			;no window, cant activate it
	sf	(a0)				;clear flag, "doing" it

	move.l	LastM_Window_(BP),d0
	beq.s	001$
	cmp.l	GWindowPtr_(BP),d0		;already active ?
	beq.s	noneedact
001$
	move.l	GWindowPtr_(BP),D0
	beq.s	noneedact			;no window, cant activate it
	;;;move.l	d0,LastM_Window_(BP)		;kludgey but needed....(?)

	move.l	IntuitionLibrary_(BP),a6
	move.l	d0,a0				;a0=hires window
	;JMPLIB	SAME,ActivateWindow	
	xjmp	IntuActivateWindow		;IntuitionRtns.asm
noneedact:
	rts

  ifc 't','f' ;;no workie...;
BlueScreen:	;set screen colors to 'bluish' in-between (NOT black!)
hardwareblue:	set	$0030

	move.w	#hardwareblue,d0
	move.l	#_custom+color00,a0
	moveq	#16-1,d1
bluesloop:
	move.w	d0,(a0)+
	dbf	d1,bluesloop
	RTS
  endc
	include "ps:main.msg.i"	;CheckIDCMP,Process,Return
	include "ps:main.key.i"	;RawKeyRoutine (AutoMove too)
	include "ps:main.int.i"	;interrupt server (decrements "Ticker_(BP)")
	;;;include "ps:main.level6.i"

	;#1=OK=wbench,#3=SEEMS TO WORK,#4=Rexx,#5=trackdisk,console.device

SetHigherPriority:	xjsr	AreWeAlive
			beq.s	prirts		;background....

ForceHigherPriority:	moveq	#HIPRI,D0
			bra.s	ExecSetTaskPri

SetLowerPriority:	moveq	#-1,D0
			bra.s	ExecSetTaskPri

ResetPriority:	;set to default if 'foreground', nochg if bkgnd
	move.l	our_task_(BP),a1	;ptr to our task(|process) structure
	cmp.b	#HIPRI,LN_PRI(a1)	;BYTE LN_PRI in task struct already?
	beq.s	SetDefaultPriority	;at highest?, then 'go normal'

	;no need;move.l	IntuitionLibrary_(BP),a1
	;;;move.l	ib_FirstScreen(a1),d0
	;move.l	ib_ActiveWindow(a6),d0		;hires already active?
	move.l	FirstScreen_(BP),d0	;managed by IntuitionRtns.asm ;ib_FirstScreen(a1),d0

	beq.s	prirts	;wha?
	;;cmp.l	XTScreenPtr_(BP),d0	;hires screen in front?
	cmp.l	GWindowPtr_(BP),d0
	beq.s	SetDefaultPriority	;yup...come alive
prirts:	rts

ForceDefaultPriority:	;xdef'd for mousertns
SetDefaultPriority:	moveq	#0,D0	;we FORCE this
			;bra.s	ExecSetTaskPri

ExecSetTaskPri:	;D0=new desired priority, returns OLD pri in D0, !messes up A0/D0
	move.l	our_task_(BP),a0	;ptr to our task(|process) structure
	cmp.b	LN_PRI(a0),D0		;BYTE LN_PRI in task struct already?
	beq.s	aatpri			;already at priority, dont_call_exec

	movem.l	d1/a1/A6,-(sp)
	move.l	a0,a1 ;our_task_(BP),a1	;ptr to our task(|process) structure
	CALLIB	Exec,SetTaskPri
	movem.l	(sp)+,d1/a1/A6

aatpri:	rts

	;ConVertAscii2Integer:
	;-skips digits after decimal point
	;-no negative #s, result must be WORD size....64k-1

cva2i:	;a0=point to string, returns d0=#, a0 advanced just past # (DESTROYS D1)
	;"suitably" commented out to 1) NOT ALLOW NEGATIVE, 2) MAX=64K-1(?)
	move.l	d3,-(sp)
	moveq	#0,d0		;d0=result to build, start with zero
	moveq	#0,d1		;clear upper bytes
	moveq	#10,d3		;assume BASE 10

cva_findstart:
	move.b	(a0)+,d1	;get characters from start
	beq	bodyDone
	cmp.b	#$0a,d1
	beq	err_cvaout
	cmp.b	#'.',d1		;DOT endzittoo
	beq	skipfrac	;bodyDone	;boom
	; cmpi.b	#'0',d1
	; beq.s	cva_findstart	;chuck initial zeros
	cmpi.b	#' ',d1
	beq.s	cva_findstart	;chuck initial blanks
	cmpi.b	#'x',d1		;check for hex forms
	beq.s	initialHex
	cmpi.b	#'$',d1	
	beq.s	initialHex
	bra.s	cva_ck1st
initialHex:
	move.w	#16,d3		;show base of 16, preserving minus

bodyStr:
	move.b	(a0)+,d1	;get next character
bodyConvert:
	beq	bodyDone	;null @ end of string?
	cmp.b	#' ',d1		;blank endzittoo
	beq	bodyDone
	cmp.b	#'/',d1		;slash is a delimiter, too
	beq	bodyDone
	cmp.b	#'.',d1		;DOT endzittoo
	beq.s	skipfrac	;bodyDone
cva_ck1st:
	cmp.b	#$0d,d1		;cr?
	beq	bodyDone
	cmp.b	#$0a,d1		;lf?
	beq	bodyDone
	cmp.b	#$09,d1		;tab?
	beq.s	bodyDone
				;prob'ly have a valid digit, shift accum
	mulu	d3,d0		;result=result*base
	cmpi.b	#'0',d1
	blt.s	badChar
	cmpi.b	#'9',d1
	bgt.s	perhapsHex
	subi.b	#'0',d1
	add.W	d1,d0		;binary value now, accum.
	bra.s	bodyStr		;go get another char

perhapsHex:
	cmp.w	#16,d3		;working in hex (base 16) now?
	bne.s	badChar
	cmpi.b	#'A',d1
	blt.s	badChar
	cmpi.b	#'F',d1
	bgt.s	perhapsLCHex
	subi.b	#'A'-10,d1
	add.w	d1,d0
	bra.s	bodyStr

perhapsLCHex:
	cmpi.b	#'a',d1
	blt.s	badChar
	cmpi.b	#'f',d1
	bgt.s	badChar
	subi.b	#'a'-10,d1
	add.w	d1,d0		;binary, accum.
	bra.s	bodyStr

badChar:
	tst.l	d0		;if we already have a #...
	bne.s	enda_cva2i	;... end on non-# char
err_cvaout:
	moveq	#-1,d0		;else flag error as minus
	bra.s	enda_cva2i
skipfrac:		;done scanning, found a 'dot'...skip fract digits
	move.b	(a0)+,d1
	beq.s	bodyDone	;null @ end of string?
	cmp.b	#' ',d1		;blank endzittoo
	beq.s	bodyDone
	cmp.b	#'.',d1		;DOT endzittoo
	beq.s	skipfrac	;bodyDone
	cmp.b	#$0d,d1		;cr?
	beq.s	bodyDone
	cmp.b	#$0a,d1		;lf?
	beq.s	bodyDone
	cmp.b	#$09,d1		;tab?
	beq.s	bodyDone
	cmp.b	#'/',d1		;slash ok too
	;beq.s	bodyDone
	bne.s	skipfrac
bodyDone:
enda_cva2i:
	move.l	(sp)+,d3
	tst.l	d0	;be nice, test for minus after subr call for errchk
	rts	;cva2i

	;note: for TABLE BELOW, UnDoBitMap FAST MEM WANTED alloc'd 1st
	;note: ...this should help when you say 'fastmemfirst','digipaint'
	;DEPTH,BasePageADDRESS,type#0=CHIP,#1=FAST,#-1=NONE(listend),#-2=NONE
BitMap_Data:
	dc.w 6,ScreenBitMap_,0		;visible work screen
	dc.w 2,BB_BitMap_,0		;drawing mask SECOND BITPLANE IS TMPRAS
	dc.w 6,CPUnDoBitMap_,-1 	;6 plane brush picture (NOT ALLOCATED)
	dc.w 6,SwapBitMap_,-1		;alternate (NOT ALLOCATED)
	dc.w -1				;-1 indicates "END OF LIST"

OpenBigPic:	;opens screen & window as per scratch var specs- messes with-a4
	;args are: NewSizeX_(BP),NewSizeY_(BP),FlagLaceNEW_(BP),

		;prevent 'cli startup' with ODD # lines...mustbe EVEN
	lea	NewSizeY_(BP),a0
	move.w	(a0),d0
	addq.w	#1,d0
	and.w	#~1,d0	;remove bottom ("odd") bit
	move.w	d0,(a0)	;NewSizeY

		;ensure 32<=x<=1024,   y<=1024
	move.w	#1024,d1
	cmp.w	d1,d0		;y max?
	bcs.s	10$
	move.w	d1,d0 ;(a0)	;ymax=1024
10$	moveq	#MINHT,d2		;min y
	cmp.w	d2,d0
	bcc.s	11$
	move.w	d2,d0
11$	move.w	d0,(a0)	;newsizeY

	lea	NewSizeX_(BP),a0
	move.w	(a0),d0
	add.w	#32-1,d0	;round up, even longwords...
	and.w	#~(32-1),d0
	;moveq	#32,d2
	;cmp.w	d2,d0	;<32?
	;bcc.s	2$
	;move.w	d2,d0	;x=32
2$
	cmp.w	d1,d0	;<1024?
	bcs.s	3$
	move.w	d1,d0
3$	move.w	d0,(a0)	;newsizeX
	

		;ask "delete swap screen?"
	;tst.b	FlagToasterAlive_(BP)
	;bne.s	onoswap
	tst.l	Datared_(BP)	;rgb mode? ....JULY191990
	bne.s	onoswap		;then don't delete the swap 

	lea	SwapBitMap_(BP),a0
	tst.l	bm_Planes(a0)
	beq.s	onoswap
	move.w	(a0),d0			;bm_BytesPerRow(a0),d0
	asl.w	#3,d0			;=pixels per row
	cmp.w	NewSizeX_(BP),d0
	bne.s	askdel
	move.w	bm_Rows(a0),d0
	cmp.w	NewSizeY_(BP),d0
	beq.s	onoswap
askdel:	xjsr	AskDelSwapRtn
	bne.s	godelswap	;ok...go delete swap (continue like norm)
		;else, user said "no! cancel size chg...no delete swap"
	tst.L	ScreenPtr_(BP)	;ok, then, HAVE a screen?
	bne	obp_sup_end	;openbigpic, setup end.....all set now?
		;...simply sup NEWSIZE x,y to be same as swap
	lea	SwapBitMap_(BP),a0
	move.w	(a0),d0			;bm_BytesPerRow(a0)
	asl.w	#3,d0			;=pixels per row
	move.w	d0,NewSizeX_(BP)
	move.w	bm_Rows(a0),NewSizeY_(BP)
	bra.s	onoswap
		;delete swap screen since it's a different ht/wt than new
godelswap:
	xjsr	FreeSwap
onoswap:
	bsr	CloseBigPic	;closes screen, kill chip bitmap+2brush bitplanes
	xjsr	ByeByeWorkBench	;memories.o
	xjsr	CleanupMemNoWb	;cleans up, but doesnt force flag closewb

	tst.l	FileHandle_(BP)	;file open?
	bne.s	5$		;yes file open...else sup bmhd_xaspect
	moveq	#10,d0		;lores aspect
	tst.b	FlagLaceNEW_(BP)
	beq.s	3$
	add.w	d0,d0		;hires aspect (=20)
3$	move.w	d0,bmhd_xaspect_(BP)

5$	move.b	FlagLaceNEW_(BP),FlagLace_(BP)

	moveq	#0,D0			;global vars from BMHD_rastwidth/height
	move.w	NewSizeX_(BP),d0	;bmhd_rastwidth_(BP),D0
	add.w	#$1f,D0			;round up to longword
	and.w	#~$1f,D0
	move.l	D0,BigPicWt_(BP)
	subq.l	#1,D0
	move.l	D0,pixels_row_less1_(BP)

	asr.w	#3,D0			;/8 converts pixels to bytes
	move.l	D0,bytes_row_less1_(BP)	;#bytes -1 for 'dbxx' loops
	;2.0;move.w	d0,d1
	;2.0;asr.w	#2,d1
	;2.0;move.w	d1,lwords_row_less1_(BP) ;#longwords  -1 for 'dbxx' loops

	addq.l	#1,D0
	move.l	D0,bytes_per_row_(BP)
	move.l	D0,d1			;used INAMOMENT for planesize calc
	asr.w	#1,D0			;/2 converts BYTEsperrow to WORDsperrow
	subq.w	#1,D0
	move.l	D0,words_row_less1_(BP)

	move.w	NewSizeY_(BP),d2	;bmhd_rastheight_(BP),d2
	move.w	d2,BigPicHt_(BP)	;global BITMAP HT really RASTHEIGHT
	mulu	d2,d1			;* bytes_per_row
	move.l	d1,PlaneSize_(BP)	;used "everywhere"

		;INTERPRET BMHD X ASPECT -->> turn on interlace?
	sf	FlagLace_(BP)
	moveq	#0,d0
	tst.b	FlagLaceNEW_(BP)
	bne.s	saylace
	moveq	#10,d1			;build aspect ratio in d1, d0=work
	move.B	bmhd_xaspect_(BP),d0	;5,10,20
	beq.s	golores			;ZERO aspect?
	cmp.b	#5,d0
	bne.s	nhires
golores	moveq	#10,d0			;hires goes to lores ham FOR MY SCREENS
nhires:	cmp.b	#20,d0
	bne.s	nhamlace
saylace	moveq	#20,d1
	st	FlagLaceNEW_(BP)
nhamlace:
	move.W	d1,XAspect_(BP)

		;ensure SCREEN(not bitmap) not bigger than 'normal' (booo....)
	move.L	BigPicWt_(BP),d1	;'desired width' (elim page junk?)
	move.w	BigPicHt_(BP),d2
	move.w	NormalWidth_(BP),d3
	move.w	NormalHeight_(BP),d4
	tst.b	FlagLaceNEW_(BP)
	beq.s	1$
	add.w	d4,d4
1$	cmp.w	#600,d4
	bcs.s	2$
	asr.w	#1,d4		;=ht/2
	and.w	#$7fff,d4	;top bit rolls down a zero if loop here
	bra.s	1$
2$
	cmp.w	d3,d1	;normal width,desired width
	bcs.s	5$	;normal>desired, ok to use smaller (?) yes
	move.w	d3,d1	;d3<=d1, use 'normal' width
5$
	cmp.w	d4,d2	;normal ht, desired ht
	bcs.s	6$	;branch when d4>d2
	move.w	d4,d2	;d4<=d2, use 'normal' (not bitmap, which is taller) ht
6$
	move.w	d1,bmhd_pagewidth_(BP)	;re-save bmhd 'page' fields after adj'
	move.w	d2,bmhd_pageheight_(BP)

	move.L	#V_HAM!V_LACE,d3	;lores screen mode
	st	FlagLaceNEW_(BP)
;	tst.b	FlagLaceNEW_(BP)
;	bne	101$
;	or.w	#V_LACE,d3		;modes + I'LACE
101$:
	lea	BigNewScreen_(BP),A0	;A0=newscreen struct for 'big picture'
	clr.w	ns_TopEdge(a0)		;digipaint pi
	move.w	d1,ns_Width(a0)
	move.w	d2,ns_Height(a0)
	move.w	d3,ns_ViewModes(a0)	;zap NewScreen struct
	move.L	d3,CAMG_(BP)
	move.b	FlagLaceNEW_(BP),FlagLace_(BP)

	;initialize & alloc 'primary' bitmaps/planes
	lea	BitMap_Data(pc),a3  	;A3 := data table for init function
init_one_map:
	movem.l	Zeros_(BP),D0/d1/d2
	move.w	(a3)+,D0		;number of bitplanes -or- endoflist

	bmi.s	end_ibm			;end of list (-1), leave w/notzeroflag
	moveq	#0,d1			;d1 using LONG MODE ensures bp offset ok
	move.w	(a3)+,d1		;address-base-offset
	cmp.w	#BB_BitMap_,d1	;drawing mask,2bitplane, initbitmap with 1
	bne.s	1$
	subq.w	#1,d0		;reduce bitplane count for InitBitMap purposes
1$
	lea	0(BP,d1.L),A0		;A0 bitmap struct Graphics Arg
	lea	bm_Planes(A0),a2	;A2 BitMap -> bm_Planes{table.of.addrs}
	tst.l	(a2)			;ALREADY have bitplane(s)?
	bne.s	end_this_bitmap		;...skip if already alive

	move.L	BigPicWt_(BP),d1	;"working bitmap" size
	moveq	#0,d2
	move.W	BigPicHt_(BP),d2	;bmhd_rastheight_(BP),d2
	CALLIB	Graphics,InitBitMap

	cmpi.w	#-1,(a3)		;our "type"
	beq.s	end_this_bitmap  	;-1 from table means "init only"

	;a2="pointer to table of bitplane addresses" a3=input/build spec
	move.w	-4(a3),d3		;# planes (1st entry eachrecordintable)
	subq.w	#1,d3			;for dbf loop (# WAS used by initbitmap)
alloc_planes:
	move.l	PlaneSize_(BP),D0	;type zero is "normal" bitmap dimensions
	cmpi.w	#1,(a3)			;alloc type from table
	bne.s	gchip
	xjsr	IntuitionAllocMain	;memories.o;fast prefer'd else chip
	bra.s	gmem
gchip:	xjsr	IntuitionAllocChipJunk	;memories.o;preserves reg d1
gmem:	beq.s	end_ibm			;no mem? stop init of all remaining
	move.l	D0,(a2)+		;extra lines display cut/paste stuff
	move.l	d0,a0		;address to clear
	xjsr	ClearPlaneA0	;strokeB.o, clearzit
	dbf	d3,alloc_planes

end_this_bitmap:
	lea	2(a3),a3	;skip planesize, prep re-loop next bitmap
	bra.s	init_one_map
end_ibm:	;"end of init'g bitmaps from table" ZERO/minus flag set

	beq	bummout		;couldn't get required bitmaps
	xjsr	AllocUnDo	;1st time?
	beq	bummout
	xjsr	EnsureExtraChip	;yeas, this chops up chip on a lowmem
	beq	bummout		;after "all the above"...notnuff chip for system

justopenscreen:
	xjsr	InitBitPlanes	;Scratch.o;inits rastports, too
9$
	lea	BigNewScreen_(BP),A0	;A0=NEWSCREEN STRUCT FOR OPENBIGSCREEN
	move.w	#6,ns_Depth(A0)		;width, ht already setup earlier?
	move.b	#1,ns_BlockPen(A0)

;SEP131990;sctype set CUSTOMSCREEN!CUSTOMBITMAP!SCREENQUIET ;!SCREENBEHIND
sctype set CUSTOMSCREEN!CUSTOMBITMAP!SCREENQUIET ;26FEB92; !SCREENBEHIND

;SEP131990;	move.l	a0,-(sp)
;SEP131990;
;SEP131990;	tst.b	FlagToasterAlive_(BP)
;SEP131990;	beq.s	001$			;no toaster? do old way
;SEP131990;	move.w	#0,d0	;*want* screen-in-front...helps w/copper list... SCREENBEHIND,d0
;SEP131990;		;july101990....from switcher, open screens in FRONT (?)
;SEP131990;
;SEP131990;	;;move.w	#SCREENBEHIND,d0	;bigpic 'behind' when from toaster
;SEP131990;	bra.s	002$
;SEP131990;
;SEP131990;
;SEP131990;001$:	xjsr	AreWeAlive
;SEP131990;	seq	d0		;if background (pri=-1) then d0=-1
;SEP131990;	ext.w	d0		;=0foreground or -1bkgnd
;SEP131990;	and.w	#SCREENBEHIND,d0
;SEP131990;002$	or.w	#sctype,d0
;SEP131990;	move.l	(sp)+,a0	;uck, short term stack clup
;SEP131990;	move.w	d0,ns_Type(A0)

	move.w	#sctype,ns_Type(A0)	;SEP131990;

	lea	TextAttr_(BP),a1	;fontname, ht, style
	move.l	a1,ns_Font(A0)

	lea	ProgramNameBuffer_(BP),a1
	move.l	a1,ns_DefaultTitle(A0)

	lea	ScreenBitMap_(BP),a1
	
	move.w	#384,ns_Width(a0)	;Force this to do the right thing
	move.w	#480,ns_Height(a0)
	
	move.w	#-36,ns_LeftEdge(a0)	;-36 looks allright
	move.w	#-41,ns_TopEdge(a0)

	
	move.l	a1,ns_CustomBitMap(A0)
	CALLIB	Intuition,OpenScreen

	move.l	D0,ScreenPtr_(BP)	;save pointer to new screen
	beq	bummout			;no screen?

	;JULY141990;xjsr	ForceAmigaCopper	;JULY13,1990

 	xref FlagColorMap_
	st	FlagColorMap_(BP)

		;july051990...kills size change...but...
	tst.l	Datared_(BP)	;rgb buffers, already?
	bne.s	123$		;bugfix...july171990...;beq.s	123$
	movem.w	Zeros_(BP),d0/d1
	movem.w	NewSizeX_(BP),d0/d1
	xjsr	AllocRGB
	beq	bummout			;no rgb buffer(s)?
	xjsr	AllocUnDoRGB		;JULY131990
	beq	bummout			;no undo-rgb buffer(s)?

	;;;xjsr	DebugMe10
	;;;bsr	debugavail
123$:	

		;do asap(?), elim "workbench blue"
	xjsr	HiresColorsOnly		;pointers.o, sup colors on hires
	xjsr	UseColorMap		;(pointers.o, for now)

	move.l	ScreenPtr_(BP),A2	;bigpic
	move.l	A2,A0			;ScreenPtr
	moveq	#0,D0			;false argument
	CALLIB	Intuition,ShowTitle	;hides the Screen title bar

;RmbTrap		equ $00010000	;Catching RMB events as button on bigpic
;Nocarerefresh	equ $00020000!SIMPLE_REFRESH
mywinf	equ	BORDERLESS!REPORTMOUSE!NOCAREREFRESH!RMBTRAP

		;open WINDOW on bigpic screen
	lea	BigNewWindow_(BP),A0		;STRUCTURE NewWindow
	move.l	ScreenPtr_(BP),A2		;bigpic

	move.b	#1,nw_DetailPen(A0)		;textpen for system requests
	move.w	sc_Width(a2),nw_Width(A0)	;A2 still=screenptr
	move.w	sc_Height(a2),nw_Height(A0)
	move.l	a2,nw_Screen(A0)
	move.w	#CUSTOMSCREEN,nw_Type(A0)
	move.L	#mywinf,nw_Flags(A0)
	CALLIB	SAME,OpenWindow
	move.l	D0,WindowPtr_(BP)	;pointer to newly opened window
	beq	bummout			;Abort with ZERO set, not everyone alive
	move.l	D0,A0

	bsr	AdjustWinMsgQue	;2.0....APR91

	tst.b	Initializing_(BP)
	bne.s	getnewu

	lea	UnDoBitMap_(BP),a0	;a0=from normal undo (fastramifpossible)
	lea	ScreenBitMap_(BP),a1	;a1=to visible screen
	xjsr	Crit			;copy odd/diff shaped undo -> screen
	;;;xjsr	DebugMe12
	;;;xjsr	DebugMe12
	;;;xjsr	DebugMe12
	;;;xjsr	DebugMe
	;;;bsr	debugavail
	xjsr	FreeUnDo		;get ridda the 'old' one
	;;;bsr	debugavail
	xjsr	FreeUnDoRGB		;if any...LATEMAY1990
	;;;xjsr	DebugMe
getnewu:
	sf	FlagBitMapSaved_(BP)	;forces saveundo to work
	xjsr	SaveUnDo		;allocs undo bitmap as neede

	;;;;xjsr	DebugMe1
	;;;;bsr	debugavail

obp_sup_end:	;openbigpic, setup end.....bra's here from 'delete swap?'
	tst.l	UnDoBitMap_Planes_(BP)	;normal undo alloc'd?(fastramifpossible)
	beq.s	bummout			;no undo->go closebigpic

	xref FlagToolWindow_
	st	FlagToolWindow_(BP)
	st	FlagFrbx_(BP)	;ask for screen arrange
	st	FlagColorMap_(BP)

	;;;xjsr	DebugMe

	moveq	#-1,d0		;set 'ne' flag, "ok" ending, did/had pic
	rts
bummout:			;bummount-bigpic didnt open
	bsr.s	skipundosave ;fixes BUG with sizer "losing picture" JULY01
	st	FlagToolWindow_(BP)
	st	FlagFrbx_(BP)	;ask for screen arrange
	;;;xjsr	DebugMe
	moveq	#0,d0		;returns flagset for didnt/couldnt open screen
zzrts:	rts

AdjustWinMsgQue:	;2.0....APR91	;a0=window ptr
	movem.l	d0/d1/a0/a1/a6,-(sp)
	move.l	IntuitionLibrary_(BP),a6
	cmp.W	#36,LIB_VERSION(a6)
	bcs.s	9$			;workbench 2.0 or newer?
	moveq	#30,d0			;30 extra messages...(assume 1/2 second for 68000 copy)
	jsr	$FFFFfe0e(a6)		;SetMouseQueue...intuition 2.0

9$	movem.l	(sp)+,d0/d1/a0/a1/a6
	RTS


CloseBigPic:			;note: does not delete "undobitmap"
	xjsr	ForceToastCopper	;JULY13,1990.....moved *here* 29JAN92

	xjsr	SafeEndFonts		;JULY03 kludgy but needed ?...fixes mem loss?
	xjsr	GoodByeHamTool		;close hamtools

	tst.l	ScreenPtr_(BP)	;screen open'd?
	beq.s	cbp_freedata	;no scr?
	xjsr	UnShowPaste	;remove brush from screen
	xjsr	FreeDouble	;double bitmap (if any)
	xjsr	CopyScreenSuper	;visible//chip -> undo//fastifpossible
	xjsr	FreeDouble	;chip ram double buffer (when "chip rich")
	xjsr	FreeCPUnDo	;'extra' copy used while showing brush
skipundosave:

		;help prevent the leading cause of screen loss...
	tst.l	UnDoBitMap_Planes_(BP)	;normal undo alloc'd?(fastramifpossible)
	bne.s	okhaveundo
	xref DefaultX_	;sizer vars...."restore" undo?
	xref DefaultY_
	moveq	#0,d0
	moveq	#0,d1
	movem.W	DefaultX_(BP),d0/d1
	move.L	d0,BigPicWt_(BP)
	move.w	d1,BigPicHt_(BP)
	mulu	d0,d1
	move.l	d1,PlaneSize_(BP)	;used "everywhere"
	beq.s	okhaveundo		;oops? bomb-pruf?
	xjsr	AllocUnDo
	tst.l	UnDoBitMap_Planes_(BP)	;normal undo alloc'd?(fastramifpossible)
	beq.s	okhaveundo		;really, didn't get the ram, no copy
	lea	ScreenBitMap_(BP),a0	;a0=FROM visible screen
	lea	UnDoBitMap_(BP),a1	;a1=TO normal undo (fastramifpossible)
	xjsr	Crit			;copy odd/diff shaped undo -> screen
	xjsr	InitSizer		;since HAD NO UNDO, came from sizer(?)
okhaveundo:


	lea	WindowPtr_(BP),A0	;point to variable on basepage
	lea	ScreenPtr_(BP),A1	;big picture (if any)
	bsr	CloseWindowAndScreen

	;29JAN92;xjsr	ForceToastCopper	;JULY13,1990

cbp_freedata:

	lea	ScreenBitMap_(BP),a3	;FREE SCREEN (CHIP) BITPLANE MEMORY
	lea	bm_Planes(a3),a3
	moveq	#6-1,d3		;d3=loopcounter, a3=ptr to bitplane addresses
freescreen:			;note:freeonevar is ok to call if vardata=0
	lea	(a3),A0		;"address of bitplane data"
	bsr.s	free1v
	lea	4(a3),a3	;pointer to next bitplane adr in bitmap struct
	dbf	d3,freescreen

	;;;xjsr	DebugMe8
	;;;xjsr	DebugMe8
	;;;xjsr	DebugMe8
	;;;xjsr	DebugMe

	lea	BB_BitMap_(BP),A0	;drawing mask
	lea	bm_Planes(A0),A0	;a0=points "right at variable" to free
	bsr.s	free1v			;free var (a0=adr), rtns a0 same
	addq.l	#4,a0			;2nd bitplane, 'tmpras' usage
free1v:			;A0=Address of variable to free, RETURNS a0 unmolested
	xjmp	FreeOneVariable	;memories.o, frees from remember list


CloseWindowRoutine:
	move.l	(A0),D0
	beq.s	eawini		;no window, outta here
	clr.l	(A0)		;clear var windowptr_(bp)
	move.l	D0,A0

	xjsr	ReturnMessages	;a0=windowptr  (destroys d0/d1/a1)
		;scans the 'input message list' and ReplyMsg's all
		;the msgs for window a0 (for use just before CloseWindow)

	clr.l	wd_UserPort(A0)		;NEVER let intwit delete *my* port....
	CALLIB	Intuition,CloseWindow
	xjmp	GraphicsWaitBlit	;wait! for closewindow's blit...

eawini:	rts


CloseWindowAndScreen:	;a0=window variable a1=screen variable
			;doesn't really closewindow, lets closescreen do it
  IFC 't','f' ;kludge, want...
	move.l	(A1),D0		;no screen pointed to, anyway?
	beq.s	after_scr2back

	movem.l	a0/a1,-(sp)
	move.l	d0,a0		;a0=screenptr for ->back
	xjsr	IntuScreenToBack	;CALLIB	Intuition,ScreenToBack
	movem.l	(sp)+,a0/a1
after_scr2back:
  ENDC
	move.l	a1,-(sp)
	bsr	CloseWindowRoutine
	move.l	(sp)+,a0

CloseScreenRoutine:	;A0=address of screen var
	move.l	(A0),D0			;no screen pointed to, anyway?
	beq	zzrts
	clr.l	(A0)			;clear'd var. sez "it's gone now"
	move.l	D0,A0			;A0=screenptr

		xref FirstScreen_
	cmp.l	FirstScreen_(BP),a0	;AUG161990...helps with "whoo" + filerequester bug?
	bne.s	99$
	;clr.l	FirstScreen_(BP)
	move.l	(a0),FirstScreen_(BP)	;point to "next" screen
99$:

	JMPLIB	Intuition,CloseScreen
	;rts
***
	dc.l	'JAMI'!$80818283
	dc.l	'E PU'!$84858687
	dc.l	'RDON'!$88898A8B
***
   END
