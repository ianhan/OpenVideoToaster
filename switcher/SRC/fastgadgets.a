********************************************************************
* fastgadgets.a
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
* $Id: fastgadgets.a,v 2.118 1996/02/08 13:24:10 Holt Exp $
*
* $Log: fastgadgets.a,v $
*Revision 2.118  1996/02/08  13:24:10  Holt
*made on changes just needed to use debugging here.
*
*Revision 2.117  1995/09/07  15:17:45  Holt
*-------------
*Fixed bug allowing update of some FG durring effects
*
*Revision 2.116  1995/08/18  16:27:51  Holt
*added functions to put up/down clapboard in lum buss.
*
*Revision 2.115  1995/07/05  15:06:24  Flick
*Added FGC_InterpTagsCommand -- looks at tags and updates fg->SymbolFlags
*
*Revision 2.114  1995/03/18  00:52:54  pfrench
*Now pushing function ptr on stack for select messages
*
*Revision 2.113  1995/03/04  14:09:11  CACHELIN4000
*Attempt to track down AlphaKey prob. in ReDoDisplay... no luck
*
*Revision 2.112  1995/02/24  14:24:41  pfrench
*Added extra call to refresh background color popup
*
*Revision 2.111  1995/02/18  05:42:31  Kell
*REMOVED SENDPROJECTEDITRENDERMESSAGE FROM ImageryOff().  NEED TO FIX THIS!
*ReDoDisplay now respects TB_Flags() imagery on/off bit.
*
*Revision 2.110  1995/02/17  15:41:50  Kell
*Prevents editor from rendering during Anims or other times Imagery if Off.
*
*Revision 2.109  1995/02/16  20:30:40  Kell
*CancelCG now does a KillAlphaKey.
*
*Revision 2.108  1995/02/10  15:20:56  Kell
**** empty log message ***
*
*Revision 2.107  1995/02/09  09:59:21  Kell
*New Queue FGC command
*
*Revision 2.106  1995/01/04  16:21:59  Kell
*Debugs
*
*Revision 2.105  1994/12/23  15:18:53  Kell
**** empty log message ***
*
*Revision 2.104  1994/12/23  03:46:31  Kell
*New Debugs.
*
*Revision 2.103  1994/12/22  18:44:36  Holt
**** empty log message ***
*
*Revision 2.102  1994/12/09  22:22:40  Kell
*Removed saving private LUT croutons and CG books during project saves.
*
*Revision 2.101  1994/12/06  07:13:03  Kell
*New ApplyTags2Lists function.  New 4.0 Project file format.
*
*Revision 2.100  1994/11/23  16:35:05  Kell
*New  FGC_FCount & UnSavable Commands.
*
*Revision 2.99  1994/11/11  10:16:35  Kell
*Better DEBUGs on the FGC_xxxxCommands()s.
*
*Revision 2.98  1994/11/04  08:45:06  Kell
*New function for determining which slices are loaded. = WhatSlicesLoaded()
*
*Revision 2.97  1994/11/04  03:32:12  Kell
*Now stashes LoadedSlices during Project Load.
*
*Revision 2.96  1994/11/02  08:01:42  Kell
*Changed FGC_LoadCommand so it's the same as all the other FGC_xxxxCommands.
*
*Revision 2.95  1994/11/02  05:28:50  Kell
*Added InstallAVEI after FGC_Unload to dump slices on project load.
*
*Revision 2.94  1994/11/01  23:16:54  Kell
*Fixed FGC_LoadCommand bug that was causing Crouton load errors.
*
*Revision 2.93  1994/10/12  00:19:22  Kell
*DefaultProject (and CurrentProject??) file can now be in the Switcher_Support drawer.
*
*Revision 2.92  1994/10/06  19:29:59  Kell
*Fixed GetLongValue not returning 0 on errors.
*
*Revision 2.91  1994/10/05  05:47:47  Kell
*Renamed some functions such as
*Renamed MakeTagListsOld to MakeTagListsSaved
*Because I now make the distiction between Edited and New items.
*Now using both TAGCTLR_NEW and TAGCTRL_UNSAVED flags.
*MoveValue2Tag now doen't update the UNSAVED flag if no change in data.
*Now Duplicating croutons keeps unsaved tags in all duplicates.
*
*Revision 2.90  1994/09/23  08:26:49  Kell
*Once again fixed a bug with FrameStore Device name length in projects.
*
*Revision 2.89  1994/09/21  19:24:54  Kell
*Saved projects now put in the correct length for the FS Device.
*
*Revision 2.88  1994/09/14  00:16:01  Kell
*Removed drawing NumPad area island box.
*
*Revision 2.87  1994/09/08  19:17:38  Kell
*New  FGC_UpdateTag/TagInfo commands.
*AddValue2FGtags function new.
*
*Revision 2.86  1994/09/02  08:31:03  Kell
*The SendFGCcommand functions now support the new non-requester error system.
*
*Revision 2.85  1994/08/30  19:10:01  Kell
*Little more debug messages.
*
*Revision 2.84  1994/08/03  06:38:08  Kell
*Added AddString2FGtags function.
*Now saves newer version project file (with type/version given per entry)
*
*Revision 2.83  1994/07/27  19:27:04  Kell
**** empty log message ***
*
*Revision 2.82  1994/07/22  19:29:55  Kell
*Removed croutonhandler stuff for a new code module
*
*Revision 2.81  94/07/08  01:45:13  Kell
*Fixed FrameHandler during sequencing, so it now does ToPrvw on Select.
*
*Revision 2.80  94/07/07  22:47:31  Kell
*Fixed FrameHandler so it supplies a correct ->FG on the FGC_xxxCommand calls
*
*Revision 2.79  94/07/07  02:30:59  Kell
**** empty log message ***
*
*Revision 2.78  94/07/06  19:46:52  Kell
**** empty log message ***
*
*Revision 2.77  94/07/01  12:40:49  Kell
*New  FGC_Obutton, Mbutton and Pbutton commands.
*Frame handler now checks state of Main or Prvw when doing FGC_ToMain / ToPrvw
*More work on the Clip handler.  Currently it's broken !!!!!!
*
*Revision 2.76  94/06/04  03:49:59  Kell
*RedoDisplay honors Editor better.
*FrameHandler routines better support TOPRVW, TOMAIN, and lock FREEZE.
*Project loading requesters now support "Skip" to avoid muli-errors.
*
*Revision 2.75  94/05/27  17:16:31  Kell
*Fixed the frame load bug when re-selecting.
*
*Revision 2.74  94/05/24  21:53:25  Kell
*Switcher no longer can display the ToolBox FGs, or Grid buttons,
*when Redoing the Display.  Also, Clearing the ToolBox area is now dead.
*DoHiliteSelect & Remove functions removed.  Now uses Editor.
*LoadFastG and LoadDefaultCrouton (with its DefaultCrouton FG data)
*have been removed.  Newer code in CroutonLoad.a handle these things.
*Many FGC_....Commands rename to this new naming convention.
*Now uses the Default Fade Crouton fade data in switcher.a instead
*of duping the fade algorithmic equations here.
*FrameHandler totally rewritten to honor FGC_TOMAIN, FGC_TOPRVW etc.
*InsertTB(), DeleteTB(), UpDateFC(), and PlaceTBFG() function removed.
*These were old functions used in Speires unused project editor.
*
*Revision 2.73  94/04/25  14:34:38  Kell
*Changes to ClipHandlers to que up clips & load stills during sequencing
*using the new PostNAB methods of Select & Auto.
*
*Revision 2.72  94/03/31  13:18:52  Kell
*Improvements to internal Clip/Control/Framestore croutons for NAB 94.
*
*Revision 2.71  94/03/19  13:10:39  Kell
*New Control type for live video sources
*
*Revision 2.70  94/03/19  09:08:57  Kell
*Put in Take/Fade handling
*
*Revision 2.69  94/03/19  00:35:42  Kell
*Fixed some effects control panels
*ci switcher.a
*
*Revision 2.68  94/03/18  17:19:50  Kell
*Clip playing now supports variable length Duration.
*
*Revision 2.67  94/03/18  09:18:37  Kell
*Better timing on DHD clips
*
*Revision 2.66  94/03/17  09:42:19  Kell
*Fixed Frameload crouton from rendering to wrong bank.
*Now grid buttons should accidentally render w/ editor up.
*
*Revision 2.65  94/03/16  10:49:47  Kell
*New fields to keep track of Frames counts on all speeds
*
*Revision 2.64  94/03/15  23:47:45  Kell
*Added code for SendFGC2Crouton routine.
*
*Revision 2.62  94/03/15  14:25:34  Kell
*Moved some crouton loading/saving/freeing stuff to croutonload.a
*Finished Read/Write/New Project.  And DefaultProject stuff.
*Now support multiple projects at once.
*
*Revision 2.61  94/03/11  20:53:21  Kell
*Hack for stillstore croutons.
*
*Revision 2.59  94/03/08  06:18:07  Kell
*Now CloseAuxLib happens in UnloadFastG instead of higher up.
*
*Revision 2.57  94/03/06  16:47:27  Kell
*Now saving all registers on more functions.  Moved some functions
*to the new CroutonLoad.a file.
*
*Revision 2.55  94/02/17  12:31:27  Kell
*New Search4StuctTag stuff
*
*Revision 2.53  94/02/07  15:57:37  Kell
*Various changes to support the new 4.0 croutons & projects.
*Added new tag list handling routines.
*
*Revision 2.52  94/01/08  01:45:12  Kell
*Now allows for the crouton to specify AddOnSize during project loading.
*
*Revision 2.45  93/12/01  01:44:10  Turcotte
*Changed WriteProject ReadProject to take a filename.
*
*Revision 2.39  93/06/05  07:42:33  Kell
*
*UpdateSoundImage() a bit more killed.
*
*Revision 2.35  93/05/29  04:17:18  Kell
*Update/Redraw display now handles the long FX comment.
*
*Revision 2.34  93/05/27  04:31:31  Kell
*Project loading/saving now supports an extended area beyond the end of the FGS structure.  We will currently use this for long comments (20 char).
*
*Revision 2.29  93/05/21  02:27:34  Kell
*Now prevents selection of Zero speeds, allows locking out speeds.
*
*Revision 2.25  93/05/14  17:59:25  Kell
*Reversed YES / NO on Continue Project Load ? requester.
*
*Revision 2.22  93/05/12  09:02:24  Kell
*Reworked Effect loading error requester logic.
*Make functions for FGC_LOAD, UNLOAD, SELECT etc.
*Made function for loading Auxlibs for a crouton.
*
*Revision 2.20  93/05/06  04:14:39  Kell
*Selected croutons now stuff the TB_FCount.. fields correctly if variable duration.
*
*Revision 2.19  93/05/06  03:11:57  Kell
*Now stuffs TB_NumFrames... fields and handles variable FCounts.
*
*Revision 2.12  93/04/17  10:21:09  Kell
*Put hack code in ImageryOn() to avoid too many On calls.
*
*Revision 2.8  93/03/10  05:34:11  Kell
*Some changes involving Ma
*MAXDISPLAYDEPTH
*
*Revision 2.6  93/02/13  14:15:19  Kell
*Fixed short branch
*
*Revision 2.5  93/01/21  04:17:34  Turcotte
*Changes for new Grids
*
*Revision 2.3  92/12/08  16:42:21  Finch
*Added saving of D0-D1/A0-A1 on entry/exit.
*
*Revision 2.2  92/09/18  03:37:37  Kell
*Modified Draw/Comp/Clear/Save/Load FastGList routines to never
*render to more than 2 planes.  To support the new 2 field user interface.
*
*Revision 2.1  92/09/12  02:05:03  Kell
*Replaced Disable & Enable Calls.
*
*********************************************************************
*+*******
*+
*+ FastGadgets
*+
*+ This file contains ToasterBase library routines, mostly for manipulating
*+ the FastGadget system, but also has a few high level routines primarily
*+ to support the interface/switcher display.
*+
*+*******

*====	Needed include files and constants.


XJSR	MACRO
	XREF	\1
	JSR	\1
	ENDM

	INCLUDE	'assembler.i'
;;	include	"RAM:conditional.i"
	INCLUDE	'intuition/intuition.i'
	INCLUDE	'libraries/dosextens.i'
	INCLUDE	'exec/interrupts.i'
	INCLUDE	'exec/memory.i'
	include 'exec/execbase.i'
	INCLUDE	'devices/trackdisk.i'
	INCLUDE	'instinct.i'
	INCLUDE	'elh.i'			; Addendum 11/2/89:
	INCLUDE	'vtdebug.i'
	INCLUDE	'frameio.i'
	INCLUDE 'hardware/custom.i'
	INCLUDE 'custom.i'
	INCLUDE 'serialdebug.i'

	INCLUDE	"lib/intuition_lib.i"
	INCLUDE	"lib/graphics_lib.i"
	INCLUDE	"lib/exec_lib.i"
	INCLUDE	"lib/dos_lib.i"


;SERDEBUG	set	1

	XREF	_ToasterBase
	XREF	ABS_TB_Hilightoff

;;DBRPE		SET	1	;Debug LoadProjEntry
;;DBWPE		SET	1	;Debug WriteProjEntry
;;DBGLTS		SET	1	;Debug GetSizeOfNewItems
;;DBDHLS	SET	1	;Debug DoHiLiteSelect
;;DBSFC		SET	1	;Debug StuffFCount
;;DBSNF		SET	1	;Debug StuffNumFrames

;;DBTAG		SET	1	;Debug Tag stuff
;;ANI2L		SET	1	;Debug AddNewItems2Lists
;;DBSEAR	SET	1	;Debug SearchTags stuff
;;DBNWP		SET	1	;Debug NewWriteProject
;;DBPETAGS	set	1

;;DBFGC	set	1	;Debug FGC_xxxxCommands
;;DBDISP	set	1	;Debug ReDoDisplay

*-----------------------------------------------
DEBUG	EQU	1			; define this equate as non-0 if you
*					; want to prevent the generation of
*					; ELH code in the source module

*====	Start of executable code.

* a0->LockBuffer
* returns Z flag if OK
GetLong	MACRO
	XJSR	ReadBufferedLong
	bne.w	\1
	endm

	SECTION	FastGadgetsCode,CODE

*************************************************************************
* void DrawTriMark(->CroutonFG, ->Window, ->Requester)
*			a0	   a1		a2
*
* Put a flashing triangle marker in the upper left corner
* of a ToolBox Crouton.  Assumes the Crouton is deselected.
* Also, for the Switcher it assumes you are in a Forbid, SoftSpriteOff state.
* All registers preserved.
*************************************************************************
	XDEF	DrawTriMark

DrawTriMark:
	movem.l	d0-d1/a0-a1,-(sp)
	move.l	FG_Offset(a0),d0
	add.l	#288,d0

	XREF	TriMarkFG
	lea	TriMarkFG,a0
	move.l	d0,FG_Offset(a0)

	moveq	#1,d0			; render the FastGadget
	moveq	#0,d1
	jsr	DrawFastGList
	movem.l	(sp)+,d0-d1/a0-a1
	rts

*+*******
*+
*+ CompFastGList
*+
*+ This function uses the 680X0 processor to complement the BitMap images of
*+ a list of FastGadget structures, which are a superset mutation of a Gadget
*+ structure.
*+
*+ void CompFastGList( Count, Offset, FastGadget, Window, Requester );
*+                      D0     D1      A0          A1      A2
*+
*+ LONG Count:
*+   Low unsigned 16 bits are used as a maximum count of FastGadget
*+   structures to complement. Zero denotes a count of 65536.
*+ LONG Offset:
*+   Caller specified byte offset to be added to position of FastGadget image
*+   in the BitMap destination. This field is not checked for WORD boundry
*+   alignment.
*+ APTR FastGadget:
*+   Pointer to list of FastGadgets to be complemented.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget list. It is assumed
*+   that the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget list. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the first
*+   FastGadget in the specified list. It is assumed that the offset formed
*+   from this requester will be WORD boundry aligned. This pointer will be
*+   ignored if the FastGadget list is not tethered to a requester.
*+
*+ Notes:
*+   There is no support for GIMMEZEROZERO FastGadgets or FastGadgets linked
*+   to a screen, they must be tethered to a window directly, or indirectly
*+   via a requester. Trashes D0,D1,A0,A1, and the condition codes. This
*+   function assumes EVERYTHING is in order and ready to go. Bad vibes can
*+   occur in your system if the FastGadget list specified is not a true
*+   FastGadget list, but contains one or more regular Gadgets. FastGadgets
*+   can be processed by Intuition Gadget handling functions since the Gadget
*+   structure subset will have no imagery selected, but the reverse is not
*+   true.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment.
*+
*+*******

	IFNE	_CCODE

	XDEF	_CompFastGList
_CompFastGList:
	SAVE1	a2
	movem.l	8(sp),d0/d1/a0-a2
	CALL.s	CompFastGList
	REST1	a2
	rts

	ENDC

	XDEF	CompFastGList
CompFastGList:	; Count, Offset, FastGadget, Window, Requester
*                  D0     D1      A0          A1      A2


	movem.l	d0-d1/a0-a1,-(sp)
	bsr	CompHiLite
	CALLTL	DrawFastGList

	movem.l	(sp)+,d0-d1/a0-a1
	rts


CompHiLite
	movem.l	d0-d2/a0-a1,-(sp)
	subq.w	#1,d0

1$	tst.w	FG_HiLiteMask(a0)
	beq.s	2$
	clr.w	FG_HiLiteMask(a0)
	bra.s	3$
2$
	move.b	FG_HiLiteVal(a0),d2
	move.b	d2,FG_HiLiteMask(a0)
	move.b	d2,FG_HiLiteMask+1(a0)
3$

	move.l	(a0),d1
	move.l	d1,a0
	dbeq	d0,1$

	movem.l	(sp)+,d0-d2/a0-a1
	rts

 ifeq 1

	SAVE	d2-d6/a2-a5		; save work registers
	CLEAR	d2			; assure longword usable
	move.w	wd_TopEdge(a1),d3	; form offset from window position
	mulu	#DISPLAYWIDTH/8,d3	; and add it to offset parameter
	move.w	wd_LeftEdge(a1),d2
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1
	btst.b	#4,gg_GadgetType(a0)	; are these FastGadgets tethered to a
*					; requester?
	beq.s	10$			; if not - skip on
	move.w	rq_TopEdge(a2),d3	; form additional offset from
	mulu	#DISPLAYWIDTH/8,d3	; requester position
	move.w	rq_LeftEdge(a2),d2	; and add it to offset total
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1

10$:
	move.l	wd_WScreen(a1),a1		; BitMap for this window
	lea	sc_BitMap+bm_Planes(a1),a1	; point at BitMap planes
	subq.w	#1,d0				; form FastGadget count
	moveq	#-1,d2				; XOR mask for complement

20$:
	lea	FG_WWidth(a0),a2	; first get placement control:
	movem.w	(a2)+,d3-d5		; word width, height, modulus
	move.l	(a2),d6			; offset within container

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2-a5		; bitplane destination pointers
	movem.l	(a1),a2-a3		; bitplane destination pointers

	add.l	d1,d6			; accumulate all offsets
	add.l	d6,a2			; offset bitplane pointers
	add.l	d6,a3

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d6,a4
;;	add.l	d6,a5

30$:
	move.w	d3,d6			; setup line word counter

40$:
	eor.w	d2,(a2)+		; complement image in the bitplanes
	eor.w	d2,(a3)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	eor.w	d2,(a4)+
;;	eor.w	d2,(a5)+
	dbf	d6,40$			; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a3

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a4
;;	add.w	d5,a5
	dbf	d4,30$			; reloop till all lines are done

	move.l	(a0),d3			; address next FastGadget to
*					; complement
	beq.s	50$			; if no more - exit
	move.l	d3,a0
	dbf	d0,20$			; complement another FastGadget till
*					; count out or no more

50$:
	REST	d2-d6/a2-a5		; restore work registers
	rts
 endc


*******************************************
*
* Put clapboard on lum-dv buffer
* Toggle
*
*	ClapBoarddv(DV#,Boolboad)
*		    d0  d1	
*
*
*******************************************
	xref	LKRDV0_FG
	xdef	ClapBoarddv
ClapBoarddv:
	movem.l	d0-d3/a0-a6,-(sp)
	DUMPREG	<D0 BUFFER, D1 BOOL>
	lea	LKRDV0_FG,a0		;1st dv gadget on luma row
	tst.b	d0
	beq	1$
	move.l	(a0),a0			;next gadget
1$	move.l	FG_PTRTable(a0),a1	;get ptr table
	move.w	#0,FG_PTRIndex(A0)

	tst.b	d1
	beq	2$
	lea	4(a1),a1
	move.w	#1,FG_PTRIndex(A0)

2$	move.l	(a1),FG_Data(a0)

	GET.l	TB_LumKeyFGL,d0		; do LumKey row
	beq.s	.NoLumKeyFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList
.NoLumKeyFGs
	movem.l	(sp)+,d0-d3/a0-a6
	rts



*******************************************
*
* Put clapboard on lum-dv buffer
* Toggle
*
*	clearClapBoarddv(DV#,Boolboad)
*		    d0  d1	
*
*
*******************************************
	xdef	ClearBoarddv
ClearBoarddv:
	movem.l	d0-d3/a0-a6,-(sp)
	DUMPMSG	<ClearBoardDV>
	lea	LKRDV0_FG,a0		;1st dv gadget on luma row
	move.l	(a0),a2			;next gadget
	move.l	FG_PTRTable(a0),a1	;get ptr table
	move.w	#0,FG_PTRIndex(a0)
	move.l	(a1),FG_Data(a0)

	move.l	FG_PTRTable(a2),a1	;get ptr table
	move.w	#0,FG_PTRIndex(a2)
	move.l	(a1),FG_Data(a2)

	GET.l	TB_LumKeyFGL,d0		; do LumKey row
	beq.s	.NoLumKeyFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList
.NoLumKeyFGs
	movem.l	(sp)+,d0-d3/a0-a6
	rts



*+*******
*+
*+ ClearFastGList
*+
*+ This function uses the 680X0 processor to clear the BitMap images of
*+ a list of FastGadget structures, which are a superset mutation of a Gadget
*+ structure.
*+
*+ void ClearFastGList( Count, Offset, FastGadget, Window, Requester );
*+                       D0     D1      A0          A1      A2
*+
*+ LONG Count:
*+   Low unsigned 16 bits are used as a maximum count of FastGadget
*+   structures to clear. Zero denotes a count of 65536.
*+ LONG Offset:
*+   Caller specified byte offset to be added to position of FastGadget image
*+   in the BitMap destination. This field is not checked for WORD boundry
*+   alignment.
*+ APTR FastGadget:
*+   Pointer to list of FastGadgets to be cleared.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget list. It is assumed
*+   that the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget list. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the first
*+   FastGadget in the specified list. It is assumed that the offset formed
*+   from this requester will be WORD boundry aligned. This pointer will be
*+   ignored if the FastGadget list is not tethered to a requester.
*+
*+ Notes:
*+   There is no support for GIMMEZEROZERO FastGadgets or FastGadgets linked
*+   to a screen, they must be tethered to a window directly, or indirectly
*+   via a requester. Trashes D0,D1,A0,A1, and the condition codes. This
*+   function assumes EVERYTHING is in order and ready to go. Bad vibes can
*+   occur in your system if the FastGadget list specified is not a true
*+   FastGadget list, but contains one or more regular Gadgets. FastGadgets
*+   can be processed by Intuition Gadget handling functions since the Gadget
*+   structure subset will have no imagery selected, but the reverse is not
*+   true.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment.
*
*+ Addendum 3/11/91:
*+   This function now clears the FG area to the background color specified
*+   by TB_BGColor. This now makes this routine dependent on having A5 point
*+   to ToasterBase. Because of the alternating copper lists making up
*+   Toaster interfaces such as the Switcher, there can be only 4 TB_BGColor
*+   specifications: 0,5,10, and 15. (If not any of these - defaults to 0)
*+
*+   NOTE: SKELL 9/18/92 Since we've gone to 2 planes we now support
*+   TB_BGColors of 0,1,2,3 !!!!
*+*******

	IFNE	_CCODE

	XDEF	_ClearFastGList
_ClearFastGList:
	SAVE1	a2
	movem.l	8(sp),d0/d1/a0-a2
	CALL.s	ClearFastGList
	REST1	a2
	rts

	ENDC

	XDEF	ClearFastGList
ClearFastGList:	; Count, Offset, FastGadget, Window, Requester
*                  D0     D1      A0          A1      A2
	SAVE	d2-d7/a2-a5		; save work registers
	CLEAR	d2			; assure longword usable
	move.w	wd_TopEdge(a1),d3	; form offset from window position
	mulu	#DISPLAYWIDTH/8,d3	; and add it to offset parameter
	move.w	wd_LeftEdge(a1),d2
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1
	btst.b	#4,gg_GadgetType(a0)	; are these FastGadgets tethered to a
*					; requester?
	beq.s	10$			; if not - skip on
	move.w	rq_TopEdge(a2),d3	; form additional offset from
	mulu	#DISPLAYWIDTH/8,d3	; requester position
	move.w	rq_LeftEdge(a2),d2	; and add it to offset total
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1

10$:
	move.l	wd_WScreen(a1),a1		; BitMap for this window
	lea	sc_BitMap+bm_Planes(a1),a1	; point at BitMap planes
	subq.w	#1,d0				; form FastGadget count
	CLEAR	d2				; get cache values
	moveq	#-1,d7

* HACKED TO SUPPORT THE NEW 2 PLANE BGCOLORS, SKELL 9/18/92
	GET.w	TB_BGColor,d3		; get background color
	beq.s	20$			; and jump to appropriate handler
;;	cmp.b	#5,d3
	cmp.b	#1,d3
	beq.s	200$
;;	cmp.b	#10,d3
	cmp.b	#2,d3
	beq	2000$
;;	cmp.b	#15,d3
	cmp.b	#3,d3
	beq	20000$

20$:
	lea	FG_WWidth(a0),a2	; first get placement control:
	movem.w	(a2)+,d3-d5		; word width, height, modulus
	move.l	(a2),d6			; offset within container

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2-a5		; bitplane destination pointers
	movem.l	(a1),a2-a3		; bitplane destination pointers

	add.l	d1,d6			; accumulate all offsets
	add.l	d6,a2			; offset bitplane pointers
	add.l	d6,a3

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d6,a4
;;	add.l	d6,a5

30$:
	move.w	d3,d6			; setup line word counter

40$:
	move.w	d2,(a2)+		; clear image in the bitplanes
	move.w	d2,(a3)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d2,(a4)+
;;	move.w	d2,(a5)+
	dbf	d6,40$			; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a3
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,30$			; reloop till all lines are done

	move.l	(a0),d3			; address next FastGadget to
*					; clear
	beq.s	50$			; if no more - exit
	move.l	d3,a0
	dbf	d0,20$			; another FastGadget till
*					; count out or no more

50$:
	REST	d2-d7/a2-a5		; restore work registers
	rts

200$:
	lea	FG_WWidth(a0),a2	; first get placement control:
	movem.w	(a2)+,d3-d5		; word width, height, modulus
	move.l	(a2),d6			; offset within container

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2-a5		; bitplane destination pointers
	movem.l	(a1),a2-a3		; bitplane destination pointers

	add.l	d1,d6			; accumulate all offsets
	add.l	d6,a2			; offset bitplane pointers
	add.l	d6,a3
	add.l	d6,a4
	add.l	d6,a5

300$:
	move.w	d3,d6			; setup line word counter

400$:
	move.w	d7,(a2)+		; clear image in the bitplanes
	move.w	d2,(a3)+
* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d7,(a4)+
;;	move.w	d2,(a5)+
	dbf	d6,400$			; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a3
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,300$			; reloop till all lines are done

	move.l	(a0),d3			; address next FastGadget to
*					; clear
	beq.s	500$			; if no more - exit
	move.l	d3,a0
	dbf	d0,200$			; another FastGadget till
*					; count out or no more

500$:
	REST	d2-d7/a2-a5		; restore work registers
	rts

2000$:
	lea	FG_WWidth(a0),a2	; first get placement control:
	movem.w	(a2)+,d3-d5		; word width, height, modulus
	move.l	(a2),d6			; offset within container

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2-a5		; bitplane destination pointers
	movem.l	(a1),a2-a3		; bitplane destination pointers

	add.l	d1,d6			; accumulate all offsets
	add.l	d6,a2			; offset bitplane pointers
	add.l	d6,a3
	add.l	d6,a4
	add.l	d6,a5

3000$:
	move.w	d3,d6			; setup line word counter

4000$:
	move.w	d2,(a2)+		; clear image in the bitplanes
	move.w	d7,(a3)+
* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d2,(a4)+
;;	move.w	d7,(a5)+
	dbf	d6,4000$		; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a3
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,3000$		; reloop till all lines are done

	move.l	(a0),d3			; address next FastGadget to
*					; clear
	beq.s	5000$			; if no more - exit
	move.l	d3,a0
	dbf	d0,2000$		; another FastGadget till
*					; count out or no more

5000$:
	REST	d2-d7/a2-a5		; restore work registers
	rts

20000$:
	lea	FG_WWidth(a0),a2	; first get placement control:
	movem.w	(a2)+,d3-d5		; word width, height, modulus
	move.l	(a2),d6			; offset within container

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2-a5		; bitplane destination pointers
	movem.l	(a1),a2-a3		; bitplane destination pointers

	add.l	d1,d6			; accumulate all offsets
	add.l	d6,a2			; offset bitplane pointers
	add.l	d6,a3
	add.l	d6,a4
	add.l	d6,a5

30000$:
	move.w	d3,d6			; setup line word counter

40000$:
	move.w	d7,(a2)+		; clear image in the bitplanes
	move.w	d7,(a3)+
* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d7,(a4)+
;;	move.w	d7,(a5)+
	dbf	d6,40000$		; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a3
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,30000$		; reloop till all lines are done

	move.l	(a0),d3			; address next FastGadget to
*					; clear
	beq.s	50000$			; if no more - exit
	move.l	d3,a0
	dbf	d0,20000$		; another FastGadget till
*					; count out or no more

50000$:
	REST	d2-d7/a2-a5		; restore work registers
	rts

*+*******
*+
*+ MouseFastGList
*+
*+ Using the X and Y mouse coordinates (relative to the containing Window)
*+ this routine will determine if the mouse is positioned over a FastGadget
*+ as specified from the FastGadgetList.
*+
*+ LONG MouseFastGList( Count, MouseX, MouseY, FastGadget, Requester );
*+  D0                   D0     D1      D2      A0          A1
*+
*+ LONG Count:
*+   Max count of the number of FastGadgets that will be processed from the
*+   specified FastGadget list. A 0 denotes 65536.
*+ LONG MouseX:
*+   Low 16 bits represents the X position of the Mouse within the containing
*+   Window of the FastGadgets.
*+ LONG MouseY:
*+   Low 16 bits represents the Y position of the Mouse within the containing
*+   Window of the FastGadgets.
*+ APTR FastGadget:
*+   Pointer to a list of FastGadgets to be searched through.
*+ APTR Requester:
*+   Pointer to a Requester attached to the containing Window which will be
*+   assumed to contain the FastGadgets if the first FastGadget in the list
*+   specified is attached to a Requester. It is ignored otherwise.
*+
*+ Notes:
*+   D0 will be returned with a pointer to the FastGadget the mouse is
*+   currently positioned over, or NULL if none. The Z flag will be returned
*+   appropriately set. Trashes D1 and A0. This routine is not really
*+   restricted to just FastGadgets, it can be used with standard Gadgets
*+   as well.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment.
*+
*+ Addendum:
*+ (8/9/89)
*+   This function will now check a FastGadget for mouse positioning only if
*+   its FG_MouseFlag flag is NULL. If a FastGadget is not checked for mouse
*+   position due to the FG_MouseFlag being non-NULL, it still is counted
*+   and pertinent to the Count parameter specified.
*+
*+*******

	IFNE	_CCODE

	XDEF	_MouseFastGList
_MouseFastGList:
	movem.l	4(sp),d0-d2/a0/a1

	ENDC

	XDEF	MouseFastGList
MouseFastGList:	; Count, MouseX, MouseY, FastGadget, Requester
*                  D0     D1      D2      A0          A1
	SAVE	d2-d6			; save work registers
	subq.w	#1,d0			; form count into counter
	btst.b	#4,gg_GadgetType(a0)	; this FastGadget (and all the
*					; FastGadgets behind it) attached to
*					; a requester?
	beq.s	10$			; if not - skip on
	sub.w	rq_LeftEdge(a1),d1	; else re-adjust MouseX and MouseY
	sub.w	rq_TopEdge(a1),d2

10$:
	tst.b	FG_MouseFlag(a0)	; FastGadget enabled for mouse?
	bne.s	20$			; if not - skip on
	movem.w	gg_LeftEdge(a0),d3-d6	; get all select box parameters
	cmp.w	d3,d1			; MouseX before LeftEdge?
	bcs.s	20$			; yup - not selected
	add.w	d3,d5			; else form RightEdge
	cmp.w	d1,d5			; MouseX after RightEdge?
	bcs.s	20$			; yup - not selected
	cmp.w	d4,d2			; MouseY before TopEdge?
	bcs.s	20$			; yup - not selected
	add.w	d4,d6			; else form BottomEdge
	cmp.w	d2,d6			; MouseY after BottomEdge?
	bcs.s	20$			; yup - not selected
	move.l	a0,d0			; else return pointer to selected
	REST	d2-d6			; FastGadget
	rts				; and return to caller

20$:
	move.l	(a0),d3			; get next FastGadget
	beq.s	30$			; if there is no more - jump out
	move.l	d3,a0			; else address next FastGadget
	dbf	d0,10$			; reloop if no FastGadget count out

30$:
	CLEAR	d0			; denote no FastGadget selected
	REST	d2-d6			; restore work registers
	rts				; return to caller

*+*******
*+
*+ CompBoolSelect
*+
*+ This function simulates with the FastGadget assumed selected, an Intuition
*+ boolean gadget that has the RELEASEVERIFY option set. Highlighting is
*+ done by complementing the imagery.
*+
*+ LONG CompBoolSelect( FastGadget, Window, Requester );
*+  D0                   A0          A1      A2
*+
*+ APTR FastGadget:
*+   Pointer to the FastGadget to be monitored for selection.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget. It is assumed that
*+   the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the FastGadget.
*+   It is assumed that the offset formed from this requester will be WORD
*+   boundry aligned. This pointer will be ignored if the FastGadget is not
*+   tethered to a requester.
*+
*+ Notes:
*+   This routine modifies then monitors the IDCMP coming from the specified
*+   Window, takes care of highlighting/de-highlighting the specified
*+   FastGadget, then finally returns to the caller with D0 containing the
*+   address of the FastGadget and the Z flag reset if the FastGadget was
*+   selected, or NULL and the Z flag set if the FastGadget was not selected.
*+   ToasterBase is needed in A5 for controlling the SoftSprite and for
*+   TB_SYSBase and TB_ITUBase. This function can still operate outside of
*+   the interface/switcher display system. Trashes D1,A0, and A1.
*+
*+ Addendum 5/8/90:
*+   Added Switcher floppy disk updating system to this routine.
*+ Addendum 9/11/90:
*+   Added checking code to try to catch situations where this routine has
*+   managed to miss the left mouse button release intended to be processed
*+   by this routine. This causes the ugly scenario where this routine is
*+   still waiting for a left mouse button up when in fact the left mouse
*+   button is currently up!
*+
*+*******

	IFNE	_CCODE

	XDEF	_CompBoolSelect
_CompBoolSelect:
	SAVE	a2/a5
	movem.l	12(sp),a0-a2
	lea	_ToasterBase,a5
	CALL.s	CompBoolSelect
	REST	a2/a5
	rts

	ENDC

	XDEF	CompBoolSelect
CompBoolSelect:	; entry: FastGadget, Window, Requester
*                         A0          A1      A2
	SAVE	d2-d5/a3/a4/a6		; save work registers
	move.l	a0,a4			; FastGadget pointer to safe reg
	move.l	a1,a3			; Window pointer to safe reg

	GET.l	TB_SYSBase,a6		; first keep others from playing
	CALLROM	Forbid

*					; start rodent messages along with
*					; rodent buttons
	move.w	wd_MouseX(a3),d3	; first sneak a copy of where the
	move.w	wd_MouseY(a3),d2	; rodent is now for startup

	or.l	#REPORTMOUSE,wd_Flags(a3)	; rodent moves in Window
	move.l	wd_IDCMPFlags(a3),d5		; save old IDCMP flags
	move.l	#MOUSEMOVE+MOUSEBUTTONS+DISKINSERTED+DISKREMOVED,d0
	move.l	a3,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; allow others to play
	CALLROM	Permit


	CLEAR	d4			; flag FastGadget as non-selected
*					; now monitor the IDCMP ourselves
	move.l	#10<<16+10,-(sp)	; place countout and reset value
*					; for CheckLMB() - Addendum 9/11/90:
	bra	.SneakIn		; but first sneak in a fake rodent
*					; move to kick of the FastGadget
*					; selection process

.WaitForIDCMP
	move.l	wd_UserPort(a3),a0
	CALLROM	WaitPort

.NextIDCMP:
	move.l	wd_UserPort(a3),a0
	CALLROM	GetMsg
	move.l	d0,d0
	bne.s	.ReadyIDCMP		; ...if more IDCMP to do

	CALL	CheckLMB		; check state of LMB
	beq.s	.WaitForIDCMP		; ...if properly down
	bpl.s	.NextIDCMP		; ...if up but not counted out
	bra	.ShortCircuit		; ...if up and counted out

.ReadyIDCMP
	move.l	d0,a1			; address IDCMP message
	move.l	im_Class(a1),d0		; get IDCMP type class

	cmp.l	#DISKINSERTED,d0	; Addendum 5/8/90: disk update system
	beq.s	.DoDiskChange		; - note that WE WILL be on an active
	cmp.l	#DISKREMOVED,d0		; interface display
	bne.s	.NoDiskChange

.DoDiskChange:
	CALLROM	ReplyMsg		; reply to the message

	CALL	FloppyDiskQuery		; anything happen with the floppies?
	beq.s	.NextIDCMP		; nope....

	CALL	FloppyInOut		; else refresh the floppy system
	CALL	UpDateFC		; assure Switcher FC updated

	GET.l	TB_Window,a0		; check for Config Slice and if its
	move.l	wd_FirstGadget(a0),a0	; up - update its Project FC

	cmp.w	#'CF',gg_GadgetID(a0)
	bne.s	.CheckSwitcher

	CALLROM	Forbid
	XCALL	SoftSpriteOff
	move.l	a4,d2
	XREF	MTSliceDataPool
	lea	MTSliceDataPool,a4
	moveq	#-1,d0
	XCALL	UpDatePJFC
	move.l	d2,a4
	XCALL	SoftSpriteOn
	pea	.NextIDCMP(pc)
	JUMPROM	Permit

.CheckSwitcher:
	cmp.w	#'SW',gg_GadgetID(a0)	; are we in the Switcher interface
	bne	.NextIDCMP		; if not - nothing more to do

	pea	.NextIDCMP(pc)		; update and display refresh
	bra	UpdateDisplay		; on the Switcher interface

.NoDiskChange:
	cmp.l	#MOUSEMOVE,d0		; rodent move IDCMP message?
	bne.s	.TryButtons		; nope - skip out
	move.w	im_MouseX(a1),d3	; else get rodent coordinates
	move.w	im_MouseY(a1),d2
	CALLROM	ReplyMsg		; reply to the message

.SneakIn:
	move.l	a4,a0			; check to see if rodent is over
	move.l	a2,a1
	move.w	d3,d1			; the selected FastGadget
	moveq	#1,d0
	CALL	MouseFastGList

	cmp.l	d0,d4			; is there a state change?
	beq	.NextIDCMP		; if not - skip
	move.l	d0,d4			; else save the state
	CALLROM	Forbid			; disable tasking
	XCALL	SoftSpriteOff		; turn the SoftSprite off
	moveq	#1,d0			; complement the FastGadget
	CLEAR	d1
	move.l	a4,a0
	move.l	a3,a1
	CALL	CompFastGList
	XCALL	SoftSpriteOn		; turn the SoftSprite on
	CALLROM	Permit			; enable tasking again
	bra	.NextIDCMP		; done - go get some more

.TryButtons:
	cmp.l	#MOUSEBUTTONS,d0	; rodent buttons message?
	bne.s	.SwallowIt		; nope - skip on
	cmp.w	#SELECTUP,im_Code(a1)	; left mouse button up?
	bne.s	.SwallowIt		; if not - ignore it
	CALLROM	ReplyMsg		; else reply to the message
*					; restore window flags and
*					; IDCMP to what they were

.ShortCircuit:
	lea	4(sp),sp		; remove count parameters
	CALLROM	Forbid			; keep others from playing

	and.l	#~REPORTMOUSE,wd_Flags(a3)
	move.l	d5,d0
	move.l	a3,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; allow others to play again
	CALLROM	Permit

	cmp.l	a4,d4			; rodent still over FastGadget?
	beq.s	.SelectTrue		; if it is - denote it
	CLEAR	d0			; else denote no select
*					; (clear D0 and set Z flag)
	bra.s	.Exit			; jump to exit

.SelectTrue:
	move.l	a4,d0			; denote a select (FastGadget
*					; address in D0 and Z flag reset)

.Exit:
	REST	d2-d5/a3/a4/a6		; restore work registers
	rts				; and return with D0 and Z flag
*					; setup accordingly

.SwallowIt:
	CALLROM	ReplyMsg		; reply to the message (ignore it)
	bra	.NextIDCMP		; done - go get some more

*+*******
*+
*+ ImageBoolSelect
*+
*+ This function simulates with the FastGadget assumed selected, an Intuition
*+ boolean gadget that has the RELEASEVERIFY option set. Highlighting is done
*+ by selecting alternate imagery.
*+
*+ LONG ImageBoolSelect( FalseIndex, TrueIndex,
*+  D0                    D0          D1
*+                       FastGadget, Window, Requester );
*+                        A0          A1      A2
*+
*+ LONG FalseIndex:
*+   16 bit value to be used to index the non-selected image.
*+   Assumed to be a positive word value even after multiplied by 4 for
*+   table indexing.
*+ LONG TrueIndex:
*+   16 bit value to be used to index the selected image.
*+   Assumed to be a positive word value even after multiplied by 4 for
*+   table indexing.
*+ APTR FastGadget:
*+   Pointer to the FastGadget to be monitored for selection.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget. It is assumed that
*+   the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the FastGadget.
*+   It is assumed that the offset formed from this requester will be WORD
*+   boundry aligned. This pointer will be ignored if the FastGadget is not
*+   tethered to a requester.
*+
*+ Notes:
*+   This routine modifies then monitors the IDCMP coming from the specified
*+   Window, takes care of highlighting/de-highlighting the specified
*+   FastGadget, then finally returns to the caller with D0 containing the
*+   address of the FastGadget and the Z flag reset if the FastGadget was
*+   selected, or NULL and the Z flag set if the FastGadget was not selected.
*+   ToasterBase is needed in A5 for controlling the SoftSprite and for
*+   TB_SYSBase and TB_ITUBase. This function can still operate outside of
*+   the interface/switcher display system. Trashes D1,A0, and A1.
*+
*+ Addendum 5/8/90:
*+   Added Switcher floppy disk updating system to this routine.
*+ Addendum 9/11/90:
*+   Added checking code to try to catch situations where this routine has
*+   managed to miss the left mouse button release intended to be processed
*+   by this routine. This causes the ugly scenario where this routine is
*+   still waiting for a left mouse button up when in fact the left mouse
*+   button is currently up!
*+
*+*******

	IFNE	_CCODE

	XDEF	_ImageBoolSelect
_ImageBoolSelect:
	SAVE	a2/a5
	movem.l	12(sp),d0/d1/a0-a2
	lea	_ToasterBase,a5
	CALL.s	ImageBoolSelect
	REST	a2/a5
	rts

	ENDC

	XDEF	ImageBoolSelect
ImageBoolSelect:	; entry: FalseIndex, TrueIndex,
*                                 D0          D1
*			;        FastGadget, Window, Requester
*                                 A0          A1      A2
	SAVE	d2-d7/a3/a4/a6		; save work registers
	move.l	a0,a4			; FastGadget pointer to safe reg
	move.l	a1,a3			; Window pointer to safe reg
	move.l	d0,d6			; FalseIndex to safe reg
	move.l	d1,d7			; TrueIndex to safe reg

	GET.l	TB_SYSBase,a6		; keep others from playing
	CALLROM	Forbid

*					; start rodent messages along with
*					; rodent buttons
	move.w	wd_MouseX(a3),d3	; first sneak a copy of where the
	move.w	wd_MouseY(a3),d2	; rodent is now for startup

	or.l	#REPORTMOUSE,wd_Flags(a3)	; rodent moves in Window
	move.l	wd_IDCMPFlags(a3),d5		; save old IDCMP flags
	move.l	#MOUSEMOVE+MOUSEBUTTONS+DISKINSERTED+DISKREMOVED,d0
	move.l	a3,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; allow others to play again
	CALLROM	Permit

	CLEAR	d4			; flag FastGadget as non-selected
	move.l	#10<<16+10,-(sp)	; place countout and reset value
*					; for CheckLMB() - Addendum 9/11/90:
	bra	.SneakIn		; but first sneak in a fake rodent
*					; move to kick of the FastGadget
*					; selection process

.WaitForIDCMP
	move.l	wd_UserPort(a3),a0
	CALLROM	WaitPort

.NextIDCMP:
	move.l	wd_UserPort(a3),a0
	CALLROM	GetMsg
	move.l	d0,d0
	bne.s	.ReadyIDCMP		; ...if more IDCMP to do

	CALL	CheckLMB		; check state of LMB
	beq.s	.WaitForIDCMP		; ...if properly down
	bpl.s	.NextIDCMP		; ...if up but not counted out
	bra	.ShortCircuit		; ...if up and counted out

.ReadyIDCMP
	move.l	d0,a1			; address IDCMP message
	move.l	im_Class(a1),d0		; get IDCMP type class

	cmp.l	#DISKINSERTED,d0	; Addendum 5/8/90: disk update system
	beq.s	.DoDiskChange		; - note that WE WILL be on an active
	cmp.l	#DISKREMOVED,d0		; interface display
	bne.s	.NoDiskChange

.DoDiskChange:
	CALLROM	ReplyMsg		; reply to the message

	CALL	FloppyDiskQuery		; anything happen with the floppies?
	beq.s	.NextIDCMP		; nope....

	CALL	FloppyInOut		; else refresh the floppy system
	CALL	UpDateFC		; assure Switcher FC updated

	GET.l	TB_Window,a0		; check for Config Slice and if its
	move.l	wd_FirstGadget(a0),a0	; up - update its Project FC

	cmp.w	#'CF',gg_GadgetID(a0)
	bne.s	.CheckSwitcher

	CALLROM	Forbid
	XCALL	SoftSpriteOff
	move.l	a4,d2
	XREF	MTSliceDataPool
	lea	MTSliceDataPool,a4
	moveq	#-1,d0
	XCALL	UpDatePJFC
	move.l	d2,a4
	XCALL	SoftSpriteOn
	pea	.NextIDCMP(pc)
	JUMPROM	Permit

.CheckSwitcher:
	cmp.w	#'SW',gg_GadgetID(a0)	; are we in the Switcher interface
	bne	.NextIDCMP		; if not - nothing more to do

	pea	.NextIDCMP(pc)		; update and display refresh
	bra	UpdateDisplay		; on the Switcher interface

.NoDiskChange:
	cmp.l	#MOUSEMOVE,d0		; rodent move IDCMP message?
	bne.s	.TryButtons		; nope - skip out
	move.w	im_MouseX(a1),d3	; else get rodent coordinates
	move.w	im_MouseY(a1),d2
	CALLROM	ReplyMsg		; reply to the message

.SneakIn:
	move.l	a4,a0			; check to see if rodent is over
	move.l	a2,a1
	move.w	d3,d1			; the selected FastGadget
	moveq	#1,d0
	CALL	MouseFastGList

	cmp.l	d0,d4			; is there a state change?
	beq	.NextIDCMP		; if not - skip
	move.l	d6,d1			; else first assue a false state
	move.l	d0,d4			; save the new state
	beq.s	.DisplayIt		; if it was false - OK - jump on
	move.l	d7,d1			; else assume a true state

.DisplayIt:
	move.w	d1,FG_PTRIndex(a4)	; place new index value -
*					; NO CHECK FOR VALID SIZE!!
	add.w	d1,d1			; form true table index
	add.w	d1,d1
	move.l	FG_PTRTable(a4),a0	; get pointer placed for new
	move.l	0(a0,d1.w),FG_Data(a4)	; FastGadget image
	CALLROM	Forbid			; disable tasking
	XCALL	SoftSpriteOff		; turn the SoftSprite off
	moveq	#1,d0			; redraw the FastGadget
	CLEAR	d1
	move.l	a4,a0
	move.l	a3,a1
	CALL	DrawFastGList
	XCALL	SoftSpriteOn		; turn the SoftSprite on
	CALLROM	Permit			; enable tasking again
	bra	.NextIDCMP		; done - go get some more

.TryButtons:
	cmp.l	#MOUSEBUTTONS,d0	; rodent buttons message?
	bne.s	.SwallowIt		; nope - skip on
	cmp.w	#SELECTUP,im_Code(a1)	; left mouse button up?
	bne.s	.SwallowIt		; if not - ignore it
	CALLROM	ReplyMsg		; else reply to the message
*					; restore window flags and
*					; IDCMP to what they were

.ShortCircuit:
	lea	4(sp),sp		; remove count parameters
	CALLROM	Forbid			; keep others from playing

	and.l	#~REPORTMOUSE,wd_Flags(a3)
	move.l	d5,d0
	move.l	a3,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; allow others to play again
	CALLROM	Permit

	cmp.l	a4,d4			; rodent still over FastGadget?
	beq.s	.SelectTrue		; if it is - denote it
	CLEAR	d0			; else denote no select
*					; (clear D0 and set Z flag)
	bra.s	.Exit			; jump to exit

.SelectTrue:
	move.l	a4,d0			; denote a select (FastGadget
*					; address in D0 and Z flag reset)

.Exit:
	REST	d2-d7/a3/a4/a6		; restore work registers
	rts				; and return with D0 and Z flag
*					; setup accordingly

.SwallowIt:
	CALLROM	ReplyMsg		; reply to the message (ignore it)
	bra	.NextIDCMP		; done - go get some more

*+*******
*+
*+ HiLiteBoolSelect
*+
*+ This function simulates with the FastGadget assumed selected, an Intuition
*+ boolean gadget that has the RELEASEVERIFY option set. Highlighting is
*+ done by the special hi-lighting system.
*+
*+ LONG HiLiteBoolSelect( FastGadget, Window, Requester );
*+  D0                     A0          A1      A2
*+
*+ APTR FastGadget:
*+   Pointer to the FastGadget to be monitored for selection.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget. It is assumed that
*+   the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the FastGadget.
*+   It is assumed that the offset formed from this requester will be WORD
*+   boundry aligned. This pointer will be ignored if the FastGadget is not
*+   tethered to a requester.
*+
*+ Notes:
*+   This routine modifies then monitors the IDCMP coming from the specified
*+   Window, takes care of highlighting/de-highlighting the specified
*+   FastGadget, then finally returns to the caller with D0 containing the
*+   address of the FastGadget and the Z flag reset if the FastGadget was
*+   selected, or NULL and the Z flag set if the FastGadget was not selected.
*+   ToasterBase is needed in A5 for controlling the SoftSprite and for
*+   TB_SYSBase and TB_ITUBase. This function can still operate outside of
*+   the interface/switcher display system. Trashes D1,A0, and A1.
*+
*+ Addendum 9/7/89:
*+   This function was added to complement the other xxxxBoolSelect functions
*+   according to the various highlighting systems available through the
*+   FastGadget system.
*+
*+ Addendum 5/8/90:
*+   Added Switcher floppy disk updating system to this routine.
*+ Addendum 9/11/90:
*+   Added checking code to try to catch situations where this routine has
*+   managed to miss the left mouse button release intended to be processed
*+   by this routine. This causes the ugly scenario where this routine is
*+   still waiting for a left mouse button up when in fact the left mouse
*+   button is currently up!
*+
*+*******

	IFNE	_CCODE

	XDEF	_HiLiteBoolSelect
_HiLiteBoolSelect:
	SAVE	a2/a5
	movem.l	12(sp),a0-a2
	lea	_ToasterBase,a5
	CALL.s	HiLiteBoolSelect
	REST	a2/a5
	rts

	ENDC

	XDEF	HiLiteBoolSelect
HiLiteBoolSelect:	; entry: FastGadget, Window, Requester
*                                 A0          A1      A2
	SAVE	d2-d5/a3/a4/a6		; save work registers
	move.l	a0,a4			; FastGadget pointer to safe reg
	move.l	a1,a3			; Window pointer to safe reg

	GET.l	TB_SYSBase,a6		; first keep others from playing
	CALLROM	Forbid

*					; start rodent messages along with
*					; rodent buttons
	move.w	wd_MouseX(a3),d3	; first sneak a copy of where the
	move.w	wd_MouseY(a3),d2	; rodent is now for startup

	or.l	#REPORTMOUSE,wd_Flags(a3)	; rodent moves in Window
	move.l	wd_IDCMPFlags(a3),d5		; save old IDCMP flags
	move.l	#MOUSEMOVE+MOUSEBUTTONS+DISKINSERTED+DISKREMOVED,d0
	move.l	a3,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; allow others to play
	CALLROM	Permit


	CLEAR	d4			; flag FastGadget as non-selected
*					; now monitor the IDCMP ourselves
	move.l	#10<<16+10,-(sp)	; place countout and reset value
*					; for CheckLMB() - Addendum 9/11/90:
	bra	.SneakIn		; but first sneak in a fake rodent
*					; move to kick of the FastGadget
*					; selection process

.WaitForIDCMP
	move.l	wd_UserPort(a3),a0
	CALLROM	WaitPort

.NextIDCMP:
	move.l	wd_UserPort(a3),a0
	CALLROM	GetMsg
	move.l	d0,d0
	bne.s	.ReadyIDCMP		; ...if more IDCMP to do

	CALL	CheckLMB		; check state of LMB
	beq.s	.WaitForIDCMP		; ...if properly down
	bpl.s	.NextIDCMP		; ...if up but not counted out
	bra	.ShortCircuit		; ...if up and counted out

.ReadyIDCMP
	move.l	d0,a1			; address IDCMP message
	move.l	im_Class(a1),d0		; get IDCMP type class

	cmp.l	#DISKINSERTED,d0	; Addendum 5/8/90: disk update system
	beq.s	.DoDiskChange		; - note that WE WILL be on an active
	cmp.l	#DISKREMOVED,d0		; interface display
	bne.s	.NoDiskChange

.DoDiskChange:
	CALLROM	ReplyMsg		; reply to the message

	CALL	FloppyDiskQuery		; anything happen with the floppies?
	beq.s	.NextIDCMP		; nope....

	CALL	FloppyInOut		; else refresh the floppy system
	CALL	UpDateFC		; assure Switcher FC updated

	GET.l	TB_Window,a0		; check for Config Slice and if its
	move.l	wd_FirstGadget(a0),a0	; up - update its Project FC

	cmp.w	#'CF',gg_GadgetID(a0)
	bne.s	.CheckSwitcher

	CALLROM	Forbid
	XCALL	SoftSpriteOff
	move.l	a4,d2
	XREF	MTSliceDataPool
	lea	MTSliceDataPool,a4
	moveq	#-1,d0
	XCALL	UpDatePJFC
	move.l	d2,a4
	XCALL	SoftSpriteOn
	pea	.NextIDCMP(pc)
	JUMPROM	Permit

.CheckSwitcher:
	cmp.w	#'SW',gg_GadgetID(a0)	; are we in the Switcher interface
	bne	.NextIDCMP		; if not - nothing more to do

	pea	.NextIDCMP(pc)		; update and display refresh
	bra	UpdateDisplay		; on the Switcher interface

.NoDiskChange:
	cmp.l	#MOUSEMOVE,d0		; rodent move IDCMP message?
	bne.s	.TryButtons		; nope - skip out
	move.w	im_MouseX(a1),d3	; else get rodent coordinates
	move.w	im_MouseY(a1),d2
	CALLROM	ReplyMsg		; reply to the message

.SneakIn:
	move.l	a4,a0			; check to see if rodent is over
	move.l	a2,a1
	move.w	d3,d1			; the selected FastGadget
	moveq	#1,d0
	CALL	MouseFastGList

	cmp.l	d0,d4			; is there a state change?
	beq	.NextIDCMP		; if not - skip
	move.l	d0,d4			; else save the state
	beq.s	.NoHiLite		; if not hi-lighted - skip on
	move.b	FG_HiLiteVal(a4),d0	; else get hilite mask and place it
	move.b	d0,FG_HiLiteMask(a4)
	move.b	d0,FG_HiLiteMask+1(a4)
	bra.s	.Render

.NoHiLite:
	move.w	d0,FG_HiLiteMask(a4)

.Render:
	CALLROM	Forbid			; disable tasking
	XCALL	SoftSpriteOff		; turn the SoftSprite off
	moveq	#1,d0			; render the FastGadget
	CLEAR	d1
	move.l	a4,a0
	move.l	a3,a1
	CALL	DrawFastGList
	XCALL	SoftSpriteOn		; turn the SoftSprite on
	CALLROM	Permit			; enable tasking again
	bra	.NextIDCMP		; done - go get some more

.TryButtons:
	cmp.l	#MOUSEBUTTONS,d0	; rodent buttons message?
	bne.s	.SwallowIt		; nope - skip on
	cmp.w	#SELECTUP,im_Code(a1)	; left mouse button up?
	bne.s	.SwallowIt		; if not - ignore it
	CALLROM	ReplyMsg		; else reply to the message
*					; restore window flags and
*					; IDCMP to what they were

.ShortCircuit:
	lea	4(sp),sp		; remove count parameters
	CALLROM	Forbid			; keep others from playing

	and.l	#~REPORTMOUSE,wd_Flags(a3)
	move.l	d5,d0
	move.l	a3,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; allow others to play again
	CALLROM	Permit

	cmp.l	a4,d4			; rodent still over FastGadget?
	beq.s	.SelectTrue		; if it is - denote it
	CLEAR	d0			; else denote no select
*					; (clear D0 and set Z flag)
	bra.s	.Exit			; jump to exit

.SelectTrue:
	move.l	a4,d0			; denote a select (FastGadget
*					; address in D0 and Z flag reset)

.Exit:
	REST	d2-d5/a3/a4/a6		; restore work registers
	rts				; and return with D0 and Z flag
*					; setup accordingly

.SwallowIt:
	CALLROM	ReplyMsg		; reply to the message (ignore it)
	bra	.NextIDCMP		; done - go get some more

*****************************************************************************
*
* LONG CheckLMB( CurrentCount, ResetCount );
*  D0             ( (SP+4) )   ( (SP+6) )
* (32)               (16)         (16)
*
* This function check the left mouse button hardware state with the following
* results and action:
* D0 =  0 if the LMB is down - the CurrentCount is reset with ResetCount
* D0 =  1 if the LMB is up and CurrentCount = CurrentCount-1 is not zero -
*         there will also be a 1/25 second delay using Delay() before
*         returning to caller
* D0 = -1 if the LMB is up and CurrentCount = CurrentCount-1 is zero.
*
* Trashes D1,A0,A1. The condition codes are set to the result in D0. Requires
* a pointer to ToasterBase in A5. This is a PRIVATE function to support
* CompBoolSelect(), ImageBoolSelect(), and HiLiteBoolSelect() only.
*
*****************************************************************************

CheckLMB:
	btst.b	#6,$BFE001		; check LMB state
	bne.s	.ButtonUp

	move.w	6(sp),4(sp)		; button down - reset CurrentCount
	CLEAR	d0			; D0 = 0
	rts

.ButtonUp:
	subq.w	#1,4(sp)		; CurrentCount = CurrentCount-1
	bne.s	.NotCountedOut

	moveq	#-1,d0			; denote LMB up and counted out
	rts

.NotCountedOut:
	SAVE1	a6			; delay 1/25 second
	GET.l	TB_DOSBase,a6
	moveq	#2,d1
	CALLROM	Delay
	REST1	a6

	moveq	#1,d0			; denote LMB up and not counted out
	rts

*+*******
*+
*+ ReDoDisplay
*+
*+ This routine remakes the entire interface display then resets the
*+ TB_CleanUp flag in the ToasterBase structure to denote everything is
*+ currently updated. All pending changes to certain FastGadget systems
*+ imagery are made and the re-display will incorporate these changes.
*+
*+ void ReDoDisplay();
*+
*+ Notes:
*+   When making this call, it is assumed that you really needed a total
*+   display refresh. Because of the overhead of this function, it is urged
*+   that function code routines that alter the interface/switcher display
*+   in small ways other than the changes made to certain FastGadget systems
*+   known by the interface/switcher (which can be handled by UpdateDisplay)
*+   update the display as neccessary themselves without resorting to this
*+   monstrocity. This function is 100% tied to the Video Toaster system and
*+   requires that A5 point to the ToasterBase structure on entry. Trashes
*+   D0,D1,A0,A1, and the condition codes. Returns nothing.
*+
*+ Addendum 10/11/89:
*+   This routine uses the FGC_UPDATE system to update certain known about
*+   FastGadgets systems. This also includes updating those FastGadget
*+   system's TB_xxxPri fields in ToasterBase.
*+ Addendum 12/6/90:
*+   Added a check of the new TB_Flags field to see if the IMAGERY_ONOFF_BIT
*+   is set. If set, this routine will not render.
*+
*+*******

	IFNE	_CCODE

	XDEF	_ReDoDisplay
_ReDoDisplay:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ReDoDisplay
	REST1	a5
	rts

	ENDC

	XDEF	ReDoDisplay
ReDoDisplay:
	DEBUGMSG DBDISP, <ReDoDisplay>
	btst.b	#4,TB_DisplayRenderMode(a5)	;are we in sequence
	bne	1$
	bsr	ReDoSwitcher

	tst.b	TB_Flags(a5)	;#IMAGERY_ONOFF_BIT
	bmi.s	1$		;jump if don't want any imagery

	btst.b	#7,TB_DisplayRenderMode(a5)	;is Editor in control of top ?
	beq	1$				;Jump if editor not present (e.g. Setup Slice)

	move.l	d0,-(sp)
;*+ Does this new trick cause keys to pop back on... probably
	XJSR	SendProjectEditRenderMessage	;assume Editor loaded = CurrentDepth
;*+ Apparently not... commented it out and it still pops back on...
; drat... maybe ReDoDisplay is not the problem after all.

	DEBUGMSG DBDISP, <\ReDoDisplay>
	move.l	(sp)+,d0
1$	rts


	XDEF	ReDoSwitcher
ReDoSwitcher:
	SAVE	d0-d7/a0-a6		; save work registers

	move.l	sp,a4			; save current stack position

	DEBUGMSG DBDISP, <ReDoSwitcher>
	lea	.MainUp(pc),a6		; update Main row
	moveq	#7-1,d1
	GET.w	TB_MainPri,d2
	GET.w	TB_MainSec,d3
	DEA	TB_MainFGL,a1
	bra	DoBitFieldFGs

.MainUp:
	PUT.w	TB_MainSec(a5),TB_MainPri

	lea	.PrvwUp(pc),a6		; update Preview row
	moveq	#7-1,d1
	GET.w	TB_PrvwPri,d2
	GET.w	TB_PrvwSec,d3
	DEA	TB_PrvwFGL,a1
	bra	DoBitFieldFGs

.PrvwUp:
	PUT.w	TB_PrvwSec(a5),TB_PrvwPri

	lea	.LumKeyUp(pc),a6	; update LumKey row
	moveq	#7-1,d1
	GET.w	TB_LumKeyAPri,d2
	GET.w	TB_LumKeyASec,d3
	DEA	TB_LumKeyFGL,a1
	bra	DoBitFieldFGs

.LumKeyUp:
	PUT.w	TB_LumKeyASec(a5),TB_LumKeyAPri

	move.l	a4,sp			; restore stack
*					; (removes FG address parameters)

	GET.w	TB_ClipAPri,d0		; update Clip A FG
	cmp.w	TB_ClipASec(a5),d0
	beq.s	.NoClipAUp0
	GET.l	TB_ClipFGL,d0
	beq.s	.NoClipAUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoClipAUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoClipAUp1:
	PUT.w	TB_ClipASec(a5),TB_ClipAPri

.NoClipAUp0:

;;	GET.w	TB_ClipBPri,d0		; update Clip B FG
;;	cmp.w	TB_ClipBSec(a5),d0	; Addendum 1/5/90: removed
;;	beq.s	.NoClipBUp0
;;	DEA	TB_ClipFGL,a0
;;	moveq	#1,d0
;;	CALL	IndexFastG
;;	beq.s	.NoClipBUp1
;;	move.l	d0,a0
;;	move.l	FG_Function(a0),d0
;;	beq.s	.NoClipBUp1
;;	SAVE1	a5
;;	move.l	a5,-(sp)
;;	move.l	a0,-(sp)
;;	move.l	#FGC_UPDATE,-(sp)
;;	move.l	d0,a0
;;	jsr	(a0)
;;	lea	12(sp),sp
;;	REST1	a5
;;
;;.NoClipBUp1:
;;	PUT.w	TB_ClipBSec(a5),TB_ClipBPri
;;
;;.NoClipBUp0:

	GET.w	TB_KeyModePri,d0	; update Clip Key Mode FG
	cmp.w	TB_KeyModeSec(a5),d0	; Addendum 1/5/90:
	beq.s	.NoKeyModeUp0
	DEA	TB_ClipFGL,a0
	moveq	#CLIPMODEID,d0
	CALL	IndexFastG
	beq.s	.NoKeyModeUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoKeyModeUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoKeyModeUp1:
	PUT.w	TB_KeyModeSec(a5),TB_KeyModePri

.NoKeyModeUp0:

	GET.w	TB_TValSec,d0		; Addendum 2/5/90: TBEFX indicator -
	beq.s	10$			; updates on 0 and 511
	eor.w	#511,d0
	sne.b	d0
10$:
	GET.w	TB_TValPri,d1
	beq.s	20$
	eor.w	#511,d1
	sne.b	d1
20$:
	eor.b	d0,d1
	beq.s	.NoTBEFXUp
	DEA	TB_TBarFGL,a0
	moveq	#TBEFXID,d0
	CALL	IndexFastG
	beq.s	.NoTBEFXUp
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoTBEFXUp
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoTBEFXUp:

	GET.w	TB_TValPri,d0		; update T-Bar
	cmp.w	TB_TValSec(a5),d0
	beq.s	.NoTValUp0
	GET.l	TB_TBarFGL,d0
	beq.s	.NoTValUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoTValUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoTValUp1:
	PUT.w	TB_TValSec(a5),TB_TValPri

.NoTValUp0:

	GET.w	TB_FCountModePri,d0	; update SMF buttons
	cmp.w	TB_FCountModeSec(a5),d0
	bne.s	.NeedFCountModeUpdate

	GET.w	TB_FCountPri,d0		; update Frame Count
	cmp.w	TB_FCountSec(a5),d0
	beq.s	.NoFCountUp0

.NeedFCountModeUpdate
	GET.l	TB_FMCountFGL,d0
	beq.s	.NoFCountUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoFCountUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoFCountUp1:
	PUT.w	TB_FCountModeSec(a5),TB_FCountModePri
	PUT.w	TB_FCountSec(a5),TB_FCountPri

.NoFCountUp0:

	GET.w	TB_NumPadPri,d0		; update Numeric Pad FG
	cmp.w	TB_NumPadSec(a5),d0
	beq.s	.NoNumPadUp0
	GET.l	TB_NumPadFGL,d0
	beq.s	.NoNumPadUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoNumPadUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoNumPadUp1:
	PUT.w	TB_NumPadSec(a5),TB_NumPadPri

.NoNumPadUp0:

	GET.w	TB_VideoFlagPri,d0	; update Freeze/Live video state FG
	cmp.w	TB_VideoFlagSec(a5),d0
	beq.s	.NoVideoUp0
	DEA	TB_TransFGL,a0
	moveq	#FRLVID,d0
	CALL	IndexFastG
	beq.s	.NoVideoUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoVideoUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoVideoUp1:
	PUT.w	TB_VideoFlagSec(a5),TB_VideoFlagPri

.NoVideoUp0:

	GET.w	TB_KeyGenPri,d0		; computer gened keymask state FG
	cmp.w	TB_KeyGenSec(a5),d0
	beq.s	.NoKeyGenUp0
	DEA	TB_LumKeyFGL,a0
	moveq	#SCOMPKEY,d0
	CALL	IndexFastG
	beq.s	.NoKeyGenUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoKeyGenUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoKeyGenUp1:
	PUT.w	TB_KeyGenSec(a5),TB_KeyGenPri

.NoKeyGenUp0:



	CALLTL	UpdateSoundImage



	tst.b	TB_Flags(a5)		; Addendum 12/6/90: If rendering by
	bmi	.BigSkip1		; this routine has been disabled -
*					; skip on

	GET.l	TB_SYSBase,a6
	CALLROM	Forbid

	XCALL	SoftSpriteOff

	XCALL	ClearToastDisplay	; clear the Toaster display to
*					; specified background color

*---	Perform background rendering - if any


	move.l	#POSX_SUPERIMPOSE,d0
	move.l	#POSY_SUPERIMPOSE,d1
	move.l	#171,d2
	move.l	#50,d3
	CALLTL	DrawBorderBox

;;	move.l	#POSX_NUMPAD,d0
;;	move.l	#POSY_NUMPAD,d1
;;	move.l	#171,d2
;;	move.l	#78,d3
;;	CALLTL	DrawBorderBox


	DEA	TB_TBarFGL,a0		; do T-Bar background
	moveq	#2,d0			; changed to do BG FGs past new
	CALL	IndexFastG		; TB EFX LED -> Addendum 12/11/89:
	beq.s	.NoTBarFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoTBarFGs:
	DEA	TB_FMCountFGL,a0	; do Frame Count background
	moveq	#3,d0
	CALL	IndexFastG
	beq.s	.NoFMCountFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoFMCountFGs:

	DEA	TB_NumPadFGL,a0		; do Numeric KeyPad background
;	moveq	#6,d0
	CLEAR	d0
	CALL	IndexFastG
	beq.s	.NoNumPadFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList
.NoNumPadFGs:

	DEA	TB_ClipFGL,a0		; do Clip background
	moveq	#2,d0
	CALL	IndexFastG
	beq.s	.NoClipFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoClipFGs:

*******************************************************
	IFD	CRAP1	;Only the ProjEditor knows how to render the ToolBox

*+	tst.b	TB_DisplayRenderMode(a5)
*+	bmi.s	.notoolbox
*+
*+*---	Now complete the picture with all the foreground rendering.
*+
*+	GET.l	TB_ToolBoxPTR,a0	; do current ToolBox FGs
*+	move.l	(a0),d0
*+	beq.s	.NoTBFGs
*+	move.l	d0,a0
*+	CLEAR	d0
*+	CLEAR	d1
*+	GET.l	TB_Window,a1
*+	CALL	DrawFastGList
*+
*+.NoTBFGs:
*+	GET.l	TB_ToolBoxPTR,a0	; also fill in vacancies in grid
*+	CALL	ToolBoxFill		; Addendum 2/12/90:

	ENDC	;CRAP1
*******************************************************8

.notoolbox
	GET.l	TB_SliceFGL,d0		; do Slice row
	beq.s	.NoSliceFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoSliceFGs:
	GET.l	TB_LumKeyFGL,d0		; do LumKey row
	beq.s	.NoLumKeyFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoLumKeyFGs:
	GET.l	TB_MainFGL,d0		; do Main row
	beq.s	.NoMainFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoMainFGs:
	GET.l	TB_PrvwFGL,d0		; do Preview row
	beq.s	.NoPrvwFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoPrvwFGs:

*----------------------------
	IFD	CRAP2		;Grid buttons obsolete for 4.0
*+	tst.b	TB_DisplayRenderMode(a5)
*+	bmi.s	.NoGridSelFGs
*+
*+	GET.l	TB_GridSelFGL,d0	; do ToolBox Grid select row
*+	beq.s	.NoGridSelFGs
*+	move.l	d0,a0
*+	CLEAR	d0
*+	CLEAR	d1
*+	GET.l	TB_Window,a1
*+	CALL	DrawFastGList
	ENDC	;CRAP2
*----------------------------

.NoGridSelFGs:
	GET.l	TB_TransFGL,d0		; do Transition FGs
	beq.s	.NoTransFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoTransFGs:
	GET.l	TB_TBarFGL,d0		; do T-Bar
	beq.s	.NoTBarFG		; Addendum 12/11/89: and TB EFX LED
	move.l	d0,a0
	moveq	#2,d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoTBarFG:
	GET.l	TB_FMCountFGL,d0	; do Frame Count
	beq.s	.NoFMCountFG
	move.l	d0,a0
	moveq	#3,d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoFMCountFG:
	GET.l	TB_NumPadFGL,d0		; do Numeric FGs
	beq	.NoNumPadFG
	move.l	d0,a0
	moveq	#5,d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

*-- Refresh special string gadget/FG of the Numeric FG system -
*-- Addendum 10/17/89:
*-- Addendum 3/2/90: Now implemented as an update system


.BigSkip1:

 ifeq 1			;This Intuition gadget is no longer rendered

	DEA	TB_NumPadFGL,a0
	moveq	#FCMNTID,d0
	CALL	IndexFastG
	beq.s	.NoNumPadFG
	move.l	d0,a2
	GET.l	TB_FCStringSec,a0
	GET.l	TB_FCString,a1
	CALL	STRcmp
	beq.s	.NoNumPadChng
	CALL	STRcopy

.NoNumPadChng:
	tst.b	TB_Flags(a5)		; Addendum 12/6/90:
	bmi.s	.BigSkip2

	move.l	a2,a0
	CALL	RefreshFCString
 endc

.NoNumPadFG:
	tst.b	TB_Flags(a5)		; Addendum 12/6/90:
	bmi.s	.BigSkip2

	GET.l	TB_ClipFGL,d0		; do Clip Level FGs
	beq.s	.NoClipFG2
	move.l	d0,a0
	moveq	#2,d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoClipFG2:
	GET.l	TB_MiscFGL,d0		; do Clip Level FGs
	beq.s	.NoMiscFGs
	move.l	d0,a0
	CLEAR	d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList

.NoMiscFGs:
	XJSR	PrintComment
	XJSR	PrintClip
	XJSR	PrintAutoSpeed
   	XJSR	PrintBGColor
	XJSR	PrintFXComment

	XCALL	SoftSpriteOn

	CALLROM	Permit

	clr.w	TB_CleanUp(a5)		; denote that the interface display
*					; is now refreshed and current

.BigSkip2:
	REST	d0-d7/a0-a6		; restore work registers
	rts				; and return to caller

*+*******
*+
*+ DoBitFieldFGs
*+
*+ This is a completely internal routine for ReDoDisplay and UpdateDisplay.
*+ It for submitting FGC_UPDATE commands to those changed FastGadgets of
*+ FastGadget systems that rely on bit field positions within their
*+ respective TB_xxxPri and TB_xxxSec fields for denoting changes to their
*+ FastGadgets within their FastGadget lists. In addition to submitting
*+ FGC_UPDATEs to changed FGs, the address of each changed FG is also placed
*+ on the stack so that the caller may later display just those FGs that
*+ were changed.
*+
*+*******

DoBitFieldFGs:
* Entry: Return address in A6
*        Number of bit fields - 1 in D1
*        TB_xxxPri in D2
*        TB_xxxSec in D3
*        FastGadgetList in A1
*
* Trashes all registers but A4,A5,A6 and the condition codes. The stack may
* be altered

	eor.b	d2,d3			; get mask of FG bits that
*					; have changed
	beq.s	.Exit			; if nothing to change - early exit

	CLEAR	d2			; start at bit position 0

.Loop:
	move.l	(a1),d0			; any more FGs to do?
	beq.s	.Exit			; nope - exit

	move.l	d0,a1			; address next FG
	btst.l	d2,d3			; is there a change to be made to
*					; this particular FG
	beq.s	.Continue		; if not - skip on

	move.l	FG_Function(a1),d0	; else get function to call
	beq.s	.Continue		; if non - skip on

	SAVE	d1-d3/a1/a4-a6		; call the FG with an FGC_UPDATE
	move.l	a5,-(sp)
	move.l	a1,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	d1-d3/a1/a4-a6

	move.l	a1,-(sp)		; save address of the FG changed
*					; on the stack

.Continue:
	addq.w	#1,d2			; bump up bit position mask
	dbf	d1,.Loop		; reloop till done

.Exit:
	jmp	(a6)			; return to caller

*+***************************************************************************
*+
*+ ReDoAllButtonRows
*+
*+ This function updates the imagery and renders all of buttons needing
*+ change on the overlay, main, and preview rows of the Switcher interface
*+ display.
*+
*+ void ReDoAllButtonRows();
*+
*+ Notes: Trashes D0,D1,A0,A1, and the codition codes. Returns nothing.
*+   Requires a pointer to ToasterBase in A5. It is assumed that you are at
*+   the Switcher interface display since this routine will render in the
*+   display. Also the TB_xxxx Pri and Sec fields of each row will be
*+   updated reflecting the new display.
*+
*+ Addendum 9/5/90:
*+   Added checking so that rendering does not occur unless the Switcher
*+   interface is up.
*+ Addendum 9/12/90:
*+   The code now saves all registers.
*+
*+***************************************************************************

	IFNE	_CCODE

	XDEF	_ReDoAllButtonRows
_ReDoAllButtonRows:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ReDoAllButtonRows
	REST1	a5
	rts

	ENDC

	XDEF	ReDoAllButtonRows
ReDoAllButtonRows:
	SAVE	d0-d7/a0-a6		; save work registers

	CLEAR	d0			; place stack end delimeter
	SAVE1	d0

	lea	.MainUp(pc),a6		; update Main row
	moveq	#7-1,d1
	GET.w	TB_MainPri,d2
	GET.w	TB_MainSec,d3
	DEA	TB_MainFGL,a1
	bra	DoBitFieldFGs

.MainUp:
	PUT.w	TB_MainSec(a5),TB_MainPri

	lea	.PrvwUp(pc),a6		; update Preview row
	moveq	#7-1,d1
	GET.w	TB_PrvwPri,d2
	GET.w	TB_PrvwSec,d3
	DEA	TB_PrvwFGL,a1
	bra	DoBitFieldFGs

.PrvwUp:
	PUT.w	TB_PrvwSec(a5),TB_PrvwPri

	lea	.LumKeyUp(pc),a6	; update LumKey row
	moveq	#7-1,d1
	GET.w	TB_LumKeyAPri,d2
	GET.w	TB_LumKeyASec,d3
	DEA	TB_LumKeyFGL,a1
	bra	DoBitFieldFGs

.LumKeyUp:
	PUT.w	TB_LumKeyASec(a5),TB_LumKeyAPri

	GET.l	TB_Window,a0		; determine if the Switcher screen
	move.l	wd_FirstGadget(a0),a0	; is up
	cmp.w	#'SW',gg_GadgetID(a0)
	beq.s	.DoRendering		; ...if on Switcher screen

.EmptyLoop:
	tst.l	(sp)+			; clean off the stack
	bne.s	.EmptyLoop

	bra.s	.ExitQ			; and exit

.DoRendering:
	GET.l	TB_SYSBase,a6		; now render the button row changes
	CALLROM	Forbid
	XCALL	SoftSpriteOff

.Loop:
	move.l	(sp)+,d0
	beq.s	.ExitLoop
	move.l	d0,a0
	moveq	#1,d0
	CLEAR	d1
	GET.l	TB_Window,a1
;;	move.l	d1,a2
	CALL	DrawFastGList
	bra.s	.Loop

.ExitLoop:
	XCALL	SoftSpriteOn
	CALLROM	Permit

.ExitQ:
	REST	d0-d7/a0-a6		; restore work registers
	rts

*+*******
*+
*+ TrapSetAPenCode
*+
*+ This code is completely internal to the interface/switcher code entity.
*+ It allows for the trapping of the SetAPen function so that the string
*+ gadget FG system of the NumPad FastGadget system could be made to work
*+ in the interface/switcher toaster environment. It simply converts all
*+ instances of pen 1 to pen 255. String gadget text rendering is currently
*+ hardcoded under intuition to use pen 1.
*+
*+ Addendum 11/5/89:
*+
*+*******

	IFNE	_CCODE
	XDEF	_TrapSetAPenCode
_TrapSetAPenCode:
	ENDC

	XDEF	TrapSetAPenCode
TrapSetAPenCode:
	move.l	OrgSetAPenCode(pc),-(sp)
	cmp.b	#1,d0
	bne.s	10$
	move.b	#255,d0
10$:
	rts

	IFNE	_CCODE
	XDEF	_OrgSetAPenCode
_OrgSetAPenCode:
	ENDC

	XDEF	OrgSetAPenCode
OrgSetAPenCode:
	DS.l	1

*+*******
*+
*+ RefreshFCString
*+
*+ This function re-displays a file comment string which will in reality be
*+ an intuition string gadget.
*+
*+ void RefreshFCString( FCFastGadget );
*+                        A0
*+
*+ APTR FCFastGadget:
*+   Pointer to a File Comment FastGadget whose Gadget structure subset must
*+   represent a valid intuition string gadget.
*+
*+ Notes:
*+   This function was completely hidden within ReDoDisplay(), but is now
*+   publicly available in ToasterBase to make it easy for application
*+   code to make changes to the file comment string. Trashes D0,D1,A0,A1,
*+   and the condition codes. Returns nothing. Requires a pointer to
*+   ToasterBase in A5 and is closely tied to the Switcher interface display.
*+
*+ Addendum 12/12/89:
*+
*+ Additional notes:
*+   Previously this function was only for the NumPad system's file comment
*+   FastGadget and as such required no argument. Now this function is more
*+   generalized in that it will refresh whatever similiar file comment
*+   FastGadget that is supplied as an argument to this function.
*+
*+ Addendum 1/11/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_RefreshFCString
_RefreshFCString:
	move.l	4(sp),a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	RefreshFCString
	REST1	a5
	rts

	ENDC

	XDEF	RefreshFCString
RefreshFCString:
	SAVE	d3/a2/a3/a6

	move.l	a0,a3
	move.l	(a3),d3

	GET.l	TB_SYSBase,a6		; Addendum 11/5/89: trap SetAPen
	GET.l	TB_GFXBase,a1		; of pen 1 to pen 255
	lea	TrapSetAPenCode(pc),a0
	move.l	a0,d0
	lea	_LVOSetAPen,a0
	CALLROM	SetFunction
	lea	OrgSetAPenCode(pc),a0
	move.l	d0,(a0)

	addq.w	#2,gg_TopEdge(a3)	; Addendum 10/27/89: centers text
	addq.w	#2,gg_LeftEdge(a3)
	subq.w	#4,gg_Width(a3)
	subq.w	#4,gg_Height(a3)

	GET.l	TB_Window,a0
	move.l	a3,a1
	moveq	#-1,d0
	GET.l	TB_ITUBase,a6
	CALLROM	AddGadget

	move.l	a3,a0
	GET.l	TB_Window,a1
	CLEARA	a2
	moveq	#1,d0
	CALLROM	RefreshGList

	GET.l	TB_Window,a0
	move.l	a3,a1
	CALLROM	RemoveGadget

	subq.w	#2,gg_TopEdge(a3)
	subq.w	#2,gg_LeftEdge(a3)
	addq.w	#4,gg_Width(a3)
	addq.w	#4,gg_Height(a3)

	GET.l	TB_SYSBase,a6
	GET.l	TB_GFXBase,a1
	move.l	OrgSetAPenCode(pc),d0
	lea	_LVOSetAPen,a0
	CALLROM	SetFunction

	move.l	d3,(a3)

	REST	d3/a2/a3/a6

	rts

*+*******
*+
*+ ActivateFCString
*+
*+ This function activates for updating a file comment FastGadget's string
*+ gadget.
*+
*+ void ActivateFCString( FCFastGadget );
*+                         A0
*+
*+ APTR FCFastGadget:
*+   Pointer to a File Comment FastGadget whose Gadget structure subset must
*+   represent a valid intuition string gadget.
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. Requires
*+   that A5 points to ToasterBase on entry and is closely tied to the
*+   Switcher display.
*+
*+ Addendum 1/11/90:
*+
*+ Addendum 5/8/90:
*+   Added Switcher floppy disk updating system to this routine.
*+
*+*******

	IFNE	_CCODE

	XDEF	_ActivateFCString
_ActivateFCString:
	move.l	4(sp),a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ActivateFCString
	REST1	a5
	rts

	ENDC

	XDEF	ActivateFCString
ActivateFCString:
	SAVE	d0-d5/a0-a2/a4/a6		; save work registers

	bset.b	#MASKDOSSPECIAL_BIT,TB_Flags(a5)
	CALLTL	EnableKeyRepeat

	move.l	6*4(sp),a4		; get FCFastGadget in a safe reg

	CLEAR	d5			; denote no diskchange IDCMP received

	GET.l	TB_SYSBase,a6		; setup the string gadget for input
	CALLROM	Forbid

	XCALL	SoftSpriteOff

	move.l	#GADGETUP+GADGETDOWN+DISKINSERTED+DISKREMOVED!MOUSEBUTTONS,d0
	GET.l	TB_Window,a0
	move.l	wd_IDCMPFlags(a0),d2
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6		; Addendum 11/5/89: trap SetAPen
	GET.l	TB_GFXBase,a1		; of pen 1 to pen 255
	lea	TrapSetAPenCode,a0
	move.l	a0,d0
	lea	_LVOSetAPen,a0
	CALLROM	SetFunction
	lea	OrgSetAPenCode,a0
	move.l	d0,(a0)

	addq.w	#2,gg_TopEdge(a4)	; Addendum 10/26/89: centers text
	addq.w	#2,gg_LeftEdge(a4)
	subq.w	#4,gg_Width(a4)
	subq.w	#4,gg_Height(a4)

	move.l	(a4),d4			; Addendum 10/27/89: save FG link

	GET.l	TB_Window,a0
	move.l	a4,a1
	moveq	#-1,d0
	GET.l	TB_ITUBase,a6
	CALLROM	AddGadget

	GET.l	TB_Window,a1
	move.l	a4,a0
	CLEARA	a2,a2
	CALLROM	ActivateGadget
	move.l	d0,d0
	beq.s	.ExitQ			; exit if the string gadget didn't
*					; activate

	GET.l	TB_SYSBase,a6
	CALLROM	Permit

.WaitForIDCMP:
	GET.l	TB_MsgPort,a0		; wait for USER to terminate
	CALLROM	WaitPort		; string gadget input

.NextIDCMP:
	GET.l	TB_MsgPort,a0
	CALLROM	GetMsg
	move.l	d0,d0
	beq.s	.WaitForIDCMP		; if no ready IDCMP messages - wait
	move.l	d0,a1			; save pointer to IDCMP message
	move.l	im_Class(a1),d3		; get message class

	tst.l	d5			; diskchange IDCMP occur before?
	bne.s	.AllReadySet		; yup - skip on

	cmp.l	#DISKINSERTED,d3	; Addendum 5/8/90: disk update system
	beq.s	.DoDiskChange		; - note that WE WILL be on an active
	cmp.l	#DISKREMOVED,d3		; interface display
	bne.s	.NoDiskChange

.DoDiskChange:
	move.l	a1,d5			; save this message for later usage
	bra.s	.NextIDCMP		; keep going

.NoDiskChange:
.AllReadySet:
	CALLROM	ReplyMsg		; reply to the message

	cmp.l	#GADGETUP,d3		; did USER terminate the string
*					; gadget?
	beq.s	.Exit			; yup - exit IDCMP loop

	GET.l	TB_Window,a1		; else something else going on -
	move.l	a4,a0			; force the string gadget to stay
;;	CLEARA	a2,a2			; selected
	GET.l	TB_ITUBase,a6
	CALLROM	ActivateGadget
	GET.l	TB_SYSBase,a6
	move.l	d0,d0
	bne.s	.NextIDCMP		; if selected - reloop

.Exit:
	CALLROM	Forbid			; de-activate the string FG system
*					; and exit

.ExitQ:
	GET.l	TB_Window,a0
	move.l	a4,a1
	GET.l	TB_ITUBase,a6
	CALLROM	RemoveGadget

	move.l	d4,(a4)			; restore FG link

	subq.w	#2,gg_TopEdge(a4)	; Addendum 10/26/89:
	subq.w	#2,gg_LeftEdge(a4)	; undo text centering
	addq.w	#4,gg_Width(a4)
	addq.w	#4,gg_Height(a4)

	GET.l	TB_SYSBase,a6
	GET.l	TB_GFXBase,a1
	move.l	OrgSetAPenCode,d0
	lea	_LVOSetAPen,a0
	CALLROM	SetFunction

	move.l	d2,d0
	GET.l	TB_Window,a0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	XCALL	SoftSpriteOn

	GET.l	TB_SYSBase,a6
	CALLROM	Permit

	tst.l	d5			; do we have a diskchange IDCMP from
*					; earlier?
	beq.s	.NoChange		; if not - skip on

	GET.l	TB_MsgPort,a0		; else place diskchange IDCMP at the
	lea	MP_MSGLIST(a0),a0	; top of the message list
	move.l	d5,a1
	CALLROM	AddHead

.NoChange:
	CALLTL	DisableKeyRepeat
	bclr.b	#MASKDOSSPECIAL_BIT,TB_Flags(a5)
	REST	d0-d5/a0-a2/a4/a6		; restore work registers
	rts

*+*******
*+
*+ UpdateDisplay
*+
*+ This routine checks the certain FastGadgets for changes made to those
*+ FastGadgets and updates the interface/switcher display only for those
*+ those FastGadgets that have been changed.
*+
*+ void UpdateDisplay();
*+
*+ Notes:
*+   Application code should never really use this function. It is mainly an
*+   internal function for the interface/switcher code and will always be
*+   be called by the interface/switcher code after control has returned
*+   from the any function code routine that has been invoked if the
*+   TB_CleanUp flag in ToasterBase is zero. This function is 100% tied to
*+   the Video Toaster system and requires that A5 point to the ToasterBase
*+   structure on entry. Trashes D0,D1,A0,A1, and the condition codes.
*+   Returns nothing. See also the documentation for the
*+   ReDoDisplay function also.
*+
*+ Addendum 10/11/89:
*+   This routine uses the FGC_UPDATE system to update certain known about
*+   FastGadgets systems. This also includes updating those FastGadget
*+   system's TB_xxxPri fields in ToasterBase.
*+ Addendum 12/6/90:
*+   Added a check of the new TB_Flags field to see if the IMAGERY_ONOFF_BIT
*+   is set. If set, this routine will not render.
*+
*+*******

	IFNE	_CCODE

	XDEF	_UpdateDisplay
_UpdateDisplay:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	UpdateDisplay
	REST1	a5
	rts

	ENDC

	XDEF	UpdateDisplay
UpdateDisplay:
	btst.b	#4,TB_DisplayRenderMode(a5)	;are we in sequence
	beq.s	1$
	rts

1$	SAVE	d0-d7/a0-a6		; save work registers

	CLEAR	d0			; place stack end delimeter
	SAVE1	d0			; for later

	lea	.MainUp(pc),a6		; update Main row
	moveq	#7-1,d1
	GET.w	TB_MainPri,d2
	GET.w	TB_MainSec,d3
	DEA	TB_MainFGL,a1
	bra	DoBitFieldFGs

.MainUp:
	PUT.w	TB_MainSec(a5),TB_MainPri

	lea	.PrvwUp(pc),a6		; update Preview row
	moveq	#7-1,d1
	GET.w	TB_PrvwPri,d2
	GET.w	TB_PrvwSec,d3
	DEA	TB_PrvwFGL,a1
	bra	DoBitFieldFGs

.PrvwUp:
	PUT.w	TB_PrvwSec(a5),TB_PrvwPri

	lea	.LumKeyUp(pc),a6	; update LumKey row
	moveq	#7-1,d1
	GET.w	TB_LumKeyAPri,d2
	GET.w	TB_LumKeyASec,d3
	DEA	TB_LumKeyFGL,a1
	bra	DoBitFieldFGs

.LumKeyUp:
	PUT.w	TB_LumKeyASec(a5),TB_LumKeyAPri

	GET.w	TB_ClipAPri,d0		; update Clip A FG
	cmp.w	TB_ClipASec(a5),d0
	beq.s	.NoClipAUp0
	GET.l	TB_ClipFGL,d0
	beq.s	.NoClipAUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoClipAUp1
	SAVE1	a0
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoClipAUp1:
	PUT.w	TB_ClipASec(a5),TB_ClipAPri

.NoClipAUp0:

;;	GET.w	TB_ClipBPri,d0		; update Clip B FG
;;	cmp.w	TB_ClipBSec(a5),d0	; Addendum 1/5/90: removed
;;	beq.s	.NoClipBUp0
;;	DEA	TB_ClipFGL,a0
;;	moveq	#1,d0
;;	CALL	IndexFastG
;;	beq.s	.NoClipBUp1
;;	move.l	d0,a0
;;	move.l	FG_Function(a0),d0
;;	beq.s	.NoClipBUp1
;;	SAVE1	a0
;;	SAVE1	a5
;;	move.l	a5,-(sp)
;;	move.l	a0,-(sp)
;;	move.l	#FGC_UPDATE,-(sp)
;;	move.l	d0,a0
;;	jsr	(a0)
;;	lea	12(sp),sp
;;	REST1	a5
;;
;;.NoClipBUp1:
;;	PUT.w	TB_ClipBSec(a5),TB_ClipBPri
;;
;;.NoClipBUp0:

	GET.w	TB_KeyModePri,d0	; update Clip Key Mode FG
	cmp.w	TB_KeyModeSec(a5),d0	; Addendum 1/5/90:
	beq.s	.NoKeyModeUp0
	DEA	TB_ClipFGL,a0
	moveq	#CLIPMODEID,d0
	CALL	IndexFastG
	beq.s	.NoKeyModeUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoKeyModeUp1
	SAVE1	a0
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

	xref	ClipOffFastG
	LEA	ClipOffFastG,a0		;put all clip mode Fast gadgets
	move.l	a0,-(sp)		;on stack for redraw.
	move.l	(a0),a0
	move.l	a0,-(sp)
	move.l	(a0),a0
	move.l	a0,-(sp)

.NoKeyModeUp1:
	PUT.w	TB_KeyModeSec(a5),TB_KeyModePri

.NoKeyModeUp0:

	GET.w	TB_TValSec,d0		; Addendum 2/5/90: TBEFX indicator -
	beq.s	10$			; updates on 0 and 511
	eor.w	#511,d0
	sne.b	d0
10$:
	GET.w	TB_TValPri,d1
	beq.s	20$
	eor.w	#511,d1
	sne.b	d1
20$:
	eor.b	d0,d1
	beq.s	.NoTBEFXUp
	DEA	TB_TBarFGL,a0
	moveq	#TBEFXID,d0
	CALL	IndexFastG
	beq.s	.NoTBEFXUp
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoTBEFXUp
	SAVE1	a0
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoTBEFXUp:

	GET.w	TB_TValPri,d0		; update T-Bar
	cmp.w	TB_TValSec(a5),d0
	beq.s	.NoTValUp0
	GET.l	TB_TBarFGL,d0
	beq.s	.NoTValUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoTValUp1
	SAVE1	a0
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoTValUp1:
	PUT.w	TB_TValSec(a5),TB_TValPri

.NoTValUp0:

	GET.w	TB_FCountModePri,d0	; update SMF buttons
	cmp.w	TB_FCountModeSec(a5),d0
	bne.s	.NeedFCountModeUpdate

	GET.w	TB_FCountPri,d0		; update Frame Count
	cmp.w	TB_FCountSec(a5),d0
	beq.s	.NoFCountUp0

.NeedFCountModeUpdate
	GET.l	TB_FMCountFGL,d0
	beq.s	.NoFCountUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoFCountUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)	; updates !2! Frame count FGs now
	move.l	d0,a0			; Addendum 2/2/90:
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

	GET.w	TB_FCountModePri,d0	; get FGs that were updated
	addq.w	#1,d0			; Addendum 2/2/90:
	and.w	#3,d0
	DEA	TB_FMCountFGL,a0
	CALL	IndexFastG
	beq.s	.Over1

	SAVE1	d0

.Over1:
	GET.w	TB_FCountModeSec,d0
	addq.w	#1,d0
	and.w	#3,d0
	DEA	TB_FMCountFGL,a0
	CALL	IndexFastG
	beq.s	.NoFCountUp1

	SAVE1	d0

.NoFCountUp1:
	PUT.w	TB_FCountModeSec(a5),TB_FCountModePri
	PUT.w	TB_FCountSec(a5),TB_FCountPri

.NoFCountUp0:

	GET.w	TB_NumPadPri,d0		; update Numeric Pad FG
	cmp.w	TB_NumPadSec(a5),d0
	beq.s	.NoNumPadUp0
	GET.l	TB_NumPadFGL,d0
	beq.s	.NoNumPadUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoNumPadUp1
	SAVE1	a0
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoNumPadUp1:
	PUT.w	TB_NumPadSec(a5),TB_NumPadPri

.NoNumPadUp0:

	GET.w	TB_VideoFlagPri,d0	; update Freeze/Live video state FG
	cmp.w	TB_VideoFlagSec(a5),d0
	beq.s	.NoVideoUp0
	DEA	TB_TransFGL,a0
	moveq	#FRLVID,d0
	CALL	IndexFastG
	beq.s	.NoVideoUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoVideoUp1
	SAVE1	a0
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoVideoUp1:
	PUT.w	TB_VideoFlagSec(a5),TB_VideoFlagPri

.NoVideoUp0:

	GET.w	TB_KeyGenPri,d0		; computer gened keymask state FG
	cmp.w	TB_KeyGenSec(a5),d0
	beq.s	.NoKeyGenUp0
	DEA	TB_LumKeyFGL,a0
	moveq	#SCOMPKEY,d0
	CALL	IndexFastG
	beq.s	.NoKeyGenUp1
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.NoKeyGenUp1
	SAVE1	a5
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_UPDATE,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST1	a5

.NoKeyGenUp1:
	PUT.w	TB_KeyGenSec(a5),TB_KeyGenPri

.NoKeyGenUp0:

	tst.b	TB_Flags(a5)		; Addendum 12/6/90: If rendering by
	bpl.s	.NoSkip			; this routine has not been
*					; disabled - skip on

.CleanUpLoop:
	tst.l	(sp)+
	bne.s	.CleanUpLoop
	bra.s	.BigSkip1

.NoSkip:
	GET.l	TB_SYSBase,a6
	CALLROM	Forbid

	XCALL	SoftSpriteOff

	CALLTL	UpdateSoundImage
.Loop:
	move.l	(sp)+,d0
	beq.s	.ExitLoop
	move.l	d0,a0
	moveq	#1,d0
	CLEAR	d1
	GET.l	TB_Window,a1
	CALL	DrawFastGList
	bra.s	.Loop

.ExitLoop:

*-- Refresh special string gadget/FG of the Numeric FG system -
*-- Addendum 10/17/89:
*-- Addendum 3/2/90: Now implemented as an update system


.BigSkip1:

 ifeq 1		;this Intuition Gadget is no longer Rendered

	DEA	TB_NumPadFGL,a0
	moveq	#FCMNTID,d0
	CALL	IndexFastG
	beq.s	.NoNumPadFG
	move.l	d0,a2
	GET.l	TB_FCStringSec,a0
	GET.l	TB_FCString,a1
	CALL	STRcmp
	beq.s	.NoNumPadChng
	CALL	STRcopy

.NoNumPadChng:
	tst.b	TB_Flags(a5)		; Addendum 12/6/90:
	bmi.s	.BigSkip2

	move.l	a2,a0
	CALL	RefreshFCString
 endc
.NoNumPadFG:
	tst.b	TB_Flags(a5)		; Addendum 12/6/90:
	bmi.s	.BigSkip2


	XJSR	PrintComment
	XJSR	PrintClip
	XJSR	PrintAutoSpeed
	XJSR	PrintBGColor		; this is being redrawen durring drag effects
	XJSR	PrintFXComment

	tst.b	TB_Flags(a5)		; Addendum 12/6/90:
	bmi.s	.BigSkip2

	XCALL	SoftSpriteOn

	CALLROM	Permit

.BigSkip2:
	REST	d0-d7/a0-a6		; restore work registers
	rts				; return to caller

********************************************************************
	XDEF	UpdateSoundImage
	XDEF	LoadFastG
	XDEF	ReadProjEntry
	XDEF	ToolBoxFill

UpdateSoundImage:
LoadFastG:		;see LoadFastGadget() instead
ReadProjEntry		;see ReadProjectEntry() instead
ToolBoxFill		;only the Project Editor can render the ToolBox!
	rts

	IFD	CRAP3

*+	xref	SoundFG
*+UpdateSoundImage:
*+	movem.l	d0-d1/a0-a2,-(sp)
*+
*+
*+	move.w	TB_HasSoundSec(a5),d0
*+	cmp.w	TB_HasSoundPri(a5),d0
*+	beq.s	.Exit
*+
*+	lea	SoundFG,a0
*+	move.l	FG_PTRTable(a0),a1
*+	move.w	d0,FG_PTRIndex(a0)
*+	add.w	d0,d0
*+	add.w	d0,d0
*+	move.l	0(a1,d0.w),FG_Data(a0)
*+
*+	move.w	TB_HasSoundSec(a5),TB_HasSoundPri(a5)
*+
*+	GET.l	TB_Window,a1
*+	sub.l	a2,a2
*+	moveq.l	#0,d1			;offset
*+	moveq.l	#1,d0
*+	CALLTL	DrawFastGList
*+
*+.Exit
*+	movem.l	(sp)+,d0-d1/a0-a2
*+	rts

	ENDC	;CRAP3

*+************************************************************************
*+
*+ AddFastGList
*+
*+ This function adds a sublist of FastGadgets into the specified FastGadget
*+ list at the specified position and returns the position where they were
*+ inserted.
*+
*+ LONG AddFastGList( Count, Position, FastGadgetSrc, FastGadgetDestBase );
*+  D0                 D0     D1        A0             A1
*+
*+ LONG Count:
*+   The low unsigned 16 bits of this value denotes the number of FastGadgets
*+   from the source list are to be inserted into FastGadgetDest. Zero
*+   denotes a count of 65536.
*+ LONG Position:
*+   The low unsigned 16 bits of this value is to be used as a placement
*+   index where the FastGadgetSrc is to be placed in FastGadgetDest.
*+   Zero denotes the first position in a FastGadget list.
*+   -1 = tack onto the end of the list.
*+ APTR FastGadgetSrc:
*+   The pointer to the FastGadget list to be added.
*+ APTR FastGadgetDestBase:
*+   The pointer to the base pointer that points to the FastGadget list that
*+   is to be inserted into.
*+
*+ Notes:
*+   This function will do all the slicing and dicing of both the source and
*+   destination FastGadget lists to satisfy the specified parameters. A
*+   position specified past the end of the destination FastGadget list will
*+   cause the source FastGadget list to be appended to the destination
*+   FastGadget list. Also since the gg_NextGadget link fields will be
*+   manipulated accordingly to perform the task, watch out for side effects
*+   such as disrupting your source FastGadget list. Toaster Note!! In
*+   some ToasterBase FastGadget lists, the index position is assumed and
*+   important to the interface/switcher code, so beware of adding or
*+   deleting from some of the ToasterBase FastGadget lists. This function
*+   does not need a pointer to ToasterBase in A5 and can be used outside of
*+   the interface/switcher environment. The condition
*+   codes (the condition codes will be set according to result returned in
*+   D0). Note that in the rare case of having more than 65535 FastGadgets
*+   in a list, the position result will roll through zero at the 65536th FG.
*+
*+*******

	IFNE	_CCODE

	XDEF	_AddFastGList
_AddFastGList:
	movem.l	4(sp),d0/d1/a0/a1

	ENDC

	XDEF	AddFastGList
AddFastGList:	; entry: Count, Position, FastGadgetSrc, FastGadgetDestBase
*                         D0     D1        A0             A1
	SAVE	d1-d3/a0-a2		; save work registers

	CLEAR	d3			; init add position result index
	move.l	(a1),d2			; initial dest FastGadget after
*					; our source list of FastGadgets to
*					; add to the dest FastGadget list
	move.l	d2,a2			; setup Z flag going into loop
	bra.s	.SneakIn		; and jump into the loop

.PosnLoop:
	addq.w	#1,d3			; bump up insert position
	move.l	a2,a1			; form new FG ahead of us
	move.l	(a2),d2			; forn new FG after us
	move.l	d2,a2

.SneakIn:
	dbeq	d1,.PosnLoop		; reloop if not at desired position
*					; in the dest FG list or not at end
*					; of dest FG list

	subq.w	#1,d0			; form Count parameter into counter
	move.l	a0,(a1)			; link in start of src FG list

.LinkLoop:
	move.l	(a0),d2			; walk down the src FG list until we
	exg.l	a0,d2			; we count out or hit the end of list
	dbeq	d0,.LinkLoop

	move.l	d2,a0			; take the last FG in the src list
	move.l	a2,(a0)			; and link on leftover dest FG list
	move.l	d3,d0			; move insert position into D0

	REST	d1-d3/a0-a2		; restore work registers
	rts				; and return to caller

*+*******
*+
*+ RemoveFastGList
*+
*+ This function removes a sublist of FastGadgets from the specified
*+ FastGadget list and returns the position where they were removed.
*+
*+ LONG RemoveFastGList( Count, FastGadgetSrc, FastGadgetDestBase );
*+  D0                    D0     A0             A1
*+
*+ LONG Count:
*+   The low unsigned 16 bits of this value denotes the number of FastGadgets
*+   that are to be removed from the FastGadgetDest. Zero denotes a count of
*+   65536.
*+ APTR FastGadgetSrc:
*+   The pointer to the FastGadget list to be removed.
*+ APTR FastGadgetDestBase:
*+   The pointer to the base pointer that points to the FastGadget list that
*+   is to be removed from.
*+
*+ Notes:
*+   This function will do all the slicing and dicing of the destination
*+   FastGadget lists to satisfy the specified parameters. The resulting
*+   FastGadget list will NOT have its last FG link field zeroed out. If the
*+   FastGadget list to be removed could not be found or the FastGadget list
*+   is empty, -1L is returned, otherwise the position where the FastGadget
*+   list was removed is returned. Toaster Note!! In some ToasterBase
*+   FastGadget lists, the index position is assumed and important to the
*+   interface/switcher code, so beware of adding or deleting from some of
*+   the ToasterBase FastGadget lists. Also the interface/switcher code
*+   cannot handle a situation where any of the active ToasterBase FG lists
*+   are empty (the base pointer contains NULL), therefore your application
*+   code must assure that this never occurs before returning control back
*+   to the interface/switcher code. This function does not need a pointer
*+   to ToasterBase in A5 and can be used outside of the interface/switcher
*+   environment. Trashes D1,A0,A1, and the condition codes (the condition
*+   codes will be set according to result returned in D0). Concerning the
*+   result in D0, zero denotes the first position in a FG list. Note also
*+   that in the rare case of having more than 65535 FastGadgets in a list,
*+   the position result rolls through zero at the 65536th FG.
*+
*+ Addendum 8/30/89:
*+   The restriction above about NULL active ToasterBase FastGadget list
*+   no longer is true. It is now possible to have NULL ToasterBase
*+   FastGadget lists and still be displayed and receive input properly by
*+   the interface/switcher code, except for the TB_TBarFG and TB_SpeedoFG
*+   FastGadget lists.
*+
*+*******

	IFNE	_CCODE

	XDEF	_RemoveFastGList
_RemoveFastGList:
	movem.l	4(sp),d0/a0/a1

	ENDC

	XDEF	RemoveFastGList
RemoveFastGList:  ; entry: Count, FastGadgetSrc, FastGadgetDestBase
*                           D0     A0             A1
	SAVE1	d2			; save a work register

	CLEAR	d2
	move.w	#-1,d2			; setup remove position count

.FindLoop:
	addq.w	#1,d2			; bump up remove position
	move.l	(a1),d1			; get next FG in list
	beq.s	.NotFound		; if end of list - we didn't find the
*					; FG sublist we were to remove - jump
	exg.l	d1,a1
	cmp.l	a0,a1			; have we reached to FG sublist yet?
	bne.s	.FindLoop		; if not - reloop

	move.l	d1,a1			; else hold on to the FG just ahead
*					; of us for linkage ajustment later
	subq.w	#1,d0			; form sublist Count into a counter

.LinkLoop:
	move.l	(a0),d1			; walk down the FG sublist till we
	move.l	d1,a0			; either count out or reach the end
	dbeq	d0,.LinkLoop

	move.l	a0,(a1)			; link the FG list after the sublist
*					; into the FG list ahead of where our
*					; FG sublist was removed
	move.l	d2,d0			; position in FG list where the FG
*					; sublist was removed
	REST	d2			; restore work register - no
*					; condition code change!
	rts				; return to caller

.NotFound:
	REST1	d2			; restore the work register
	moveq	#-1,d0			; denote FG sublist was not found in
*					; the main FG list
	rts				; return to caller

*+*******
*+
*+ IndexFastG
*+
*+ This function returns a pointer to the FastGadget at the specified index
*+ into the specified FastGadget list.
*+
*+ LONG IndexFastG( Index, FastGadgetListBase );
*+  D0               D0     A0
*+
*+ LONG Index:
*+   The low unsigned 16-bits is used to represent the position within the
*+   FastGadget list of the FastGadget desired. Zero represents the first
*+   FastGadget in the list.
*+ APTR FastGadgetListBase:
*+   Pointer to a base pointer to the start of the FastGadget list.
*+
*+ Notes:
*+   Returns NULL if a FastGadget could not be found at the specified index,
*+   or if the FastGadget list was empty. This function does not need a
*+   pointer to ToasterBase in A5 and can be used outside of the
*+   interface/switcher environment. Trashes D1,A0,A1, and the condition
*+   codes (the condition codes will be set according to result returned in
*+   D0).
*+
*+*******

	IFNE	_CCODE

	XDEF	_IndexFastG
_IndexFastG:
	movem.l	4(sp),d0/a0

	ENDC

	XDEF	IndexFastG
IndexFastG:	; entry: Index, FastGadgetListBase
*                         D0     A0

	move.l	(a0),d1			; get first FG of the list
	move.l	d1,a0
	beq.s	.Exit			; if empty list - skip on
	bra.s	.SneakIn		; jump into loop

.Loop:
	move.l	(a0),d1			; walk down the FG list until we
	move.l	d1,a0			; either hit the index position or
.SneakIn:
	dbeq	d0,.Loop		; the end of the FG list

.Exit:
	move.l	a0,d0			; return the address of the indexed
*					; FG or NULL if not obtainable
	rts				; return to caller

*+*******
*+
*+ IndexIDFastG
*+
*+ This function returns a pointer to the FastGadget containing the specified
*+ index WORD value in the FG_IndexID field from within the specified
*+ FastGadget list.
*+
*+ LONG IndexIDFastG( IndexID, FastGadgetListBase );
*+  D0                 D0       A0
*+
*+ LONG Index:
*+   The low unsigned 16-bits is used to represent the WORD value to be
*+   searched for in the FG_IndexID field of the FastGadgets in the list.
*+ APTR FastGadgetListBase:
*+   Pointer to a base pointer to the start of the FastGadget list.
*+
*+ Notes:
*+   Returns NULL if a FastGadget could not be found of the specified WORD
*+   index, or if the FastGadget list was empty. This function will only
*+   search and return a FastGadget pointer to the first FastGadget instance
*+   of the WORD index value found in the FG list. This function does not
*+   need a pointer to ToasterBase in A5 and can be used outside of the
*+   interface/switcher environment. Trashes D1,A0,A1, and the condition
*+   codes (the condition codes will be set according to result returned in
*+   D0).
*+
*+*******

	IFNE	_CCODE

	XDEF	_IndexIDFastG
_IndexIDFastG:
	movem.l	4(sp),d0/a0

	ENDC

	XDEF	IndexIDFastG
IndexIDFastG:	; entry: IndexID, FastGadgetListBase
*                         D0       A0

	move.l	(a0),d1			; get first FG of the list
	move.l	d1,a0
	beq.s	.Exit			; if empty list - skip on
	bra.s	.SneakIn		; jump into loop

.Loop:
	move.l	(a0),d1			; walk down the FG list until we
	move.l	d1,a0			; either hit the index position or
	beq.s	.Exit			; the end of the FG list
.SneakIn:
	cmp.w	FG_IndexID(a0),d0	; index WORD values match?
	bne.s	.Loop			; if not - reloop

.Exit:
	move.l	a0,d0			; return the address of the indexed
*					; FG or NULL if not obtainable
	rts				; return to caller

*+*******
*+
*+ AddressFastG
*+
*+ This function returns the index within the specified FastGadget list of
*+ where the specified FastGadget resides.
*+
*+ LONG AddressFastG( FastGadget, FastGadgetListBase );
*+  D0                 A0          A1
*+
*+ APTR FastGadget:
*+   Pointer to the FastGadget that is to be found in the specified FG list.
*+ APTR FastGadgetListBase:
*+   Pointer to a base pointer to the start of the FastGadget list.
*+
*+ Notes:
*+   Returns LONG -1 if the specified FastGadget could not be found in the
*+   specified FastGadget list or the FastGadget list was empty. Otherwise
*+   the index of the first occurence of the the specified FastGadget in the
*+   FastGadget list will be returned. If there is 65536 or more FastGadgets
*+   in the list, there can be roll over through zero of the index returned.
*+   This function does not need a pointer to ToasterBase in A5 and can be
*+   used outside of the interface/switcher environment. Trashes D1,A0,A1,
*+   and the condition codes (the condition codes will be set according to
*+   result returned in D0).
*+
*+*******

	IFNE	_CCODE

	XDEF	_AddressFastG
_AddressFastG:
	movem.l	4(sp),a0/a1

	ENDC

	XDEF	AddressFastG
AddressFastG:	; entry: FastGadget, FastGadgetListBase
*                         A0          A0

	SAVE1	d2

	CLEAR	d2
	move.w	#-1,d2			; pre-set index counter

.Loop:
	addq.w	#1,d2			; bump up index position
	move.l	(a1),d1			; get next FG of the list
	beq.s	.NotFound		; if empty list - skip on
	move.l	d1,a1
	cmp.l	a0,a1			; found the FG?
	bne.s	.Loop			; if not - reloop

	move.l	d2,d0			; return the index position
	REST	d2			; restore WITHOUT touching CCodes
	rts				; return to caller

.NotFound:
	REST1	d2
	moveq	#-1,d0			; denote failure to find FG in list
	rts

*+*******
*+
*+ PutNewLocTB
*+
*+ This function updates the imagery position and selection box of the
*+ specified ToolBox FastGadget according to the value contained in the
*+ FG_IndexID field of the specified ToolBox FastGadget's structure.
*+
*+ void PutNewLocTB( TBFastGadget );
*+                    A0
*+
*+ APTR TBFastGadget:
*+   Pointer to the ToolBox FastGadget structure to be updated.
*+
*+ Notes:
*+   This MUST be updating a ToolBox FastGadget as certain constant values
*+   are assumed in formulating the new imagery and select box positions.
*+   This function has nothing to do with the re-display of the ToolBox
*+   FastGadget to its new position or the moving of the ToolBox FastGadget
*+   to a new list if it is needed due to the new IndexID field index.
*+   This function trashes D0,D1 and the condition codes. Returns nothing.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment (it does not need an ToasterBase
*+   resources). However, it is heavily related to the interface/switcher's
*+   ToolBox grid.
*+
*+*******

	IFNE	_CCODE

	XDEF	_PutNewLocTB
_PutNewLocTB:
	move.l	4(sp),a0

	ENDC

	XDEF	PutNewLocTB
PutNewLocTB:	; TBFastGadget
*		   A0
	CLEAR	d1			; get index into a display grid
	move.w	FG_IndexID(a0),d1	; position
	divu	#TBFG_GRIDSIZE,d1
	swap	d1

	CLEAR	d0			; grid position to LONG
	move.w	d1,d0

	divu	#TBFG_GRIDACROSS,d0
	move.w	d0,d1			; row component in D1
	swap	d0			; column component in D0

	mulu	#TBFG_WIDTH,d0		; get left edge pixel position
	add.w	#TBFG_LEFTEDGE,d0	; (must be a multiple of 16)
	move.w	d0,gg_LeftEdge(a0)	; set left edge of select box

	mulu	#TBFG_HEIGHT,d1		; get top edge pixel position
	add.w	#TBFG_TOPEDGE,d1
;;;??? Addendum 1/24/90:
;;;???	addq.w	#1,d1			; position 1 line lower
;;;???
	move.w	d1,gg_TopEdge(a0)	; set top edge of select box

	mulu	#DISPLAYWIDTH/8,d1	; get byte offset into window that
	lsr.w	#3,d0			; the imagery should be rendered at
	add.l	d1,d0			; (note the WORD operations above -
*					; should work as long as the pixel
*					; width doesn't exceed 65535)
	move.l	d0,FG_Offset(a0)	; place the offset in the FG -
*					; all other pertinent fields relate
*					; to size and should be OK as is
	rts

**************************************************
* a0->FastGadget
* Returns BOOL
* Currently this only opens the Effects.Library!!!!!!! ****!!!!****
* And the Library FGS_EntryRoutine is not supported    ****!!!!****
* All effects currently call _LVOStdCroutonHandler(EF) only ***!!!****

	XDEF	OpenCroutonLibraries
OpenCroutonLibraries
	movem.l	d1/a0-a3,-(sp)
	movea.l	a0,a3

.AuxLibLoop
	lea	.EffectsLibName(pc),a0
	XCALL	OpenAuxLib
	move.l	d0,FGS_EntryLibrary(a3)		; place resulting pointer
	beq.s	666$			;jump if unable to load

	PUT.w	#0,TB_ErrFlag		; assure TB_ErrFlag is clear
	moveq	#1,d0			;success
777$	movem.l	(sp)+,d1/a0-a3
	rts

666$	cmp.l	#-1,TB_LastGlobalError(a5)	; failure due to low memory?
	beq.s	.AuxLibError			; yup - remove TBFG

	lea	.AuxLib(pc),a0		; else an error - put up a requester
	bsr	ReqSystem		; for USER benefit
	bne.s	.AuxLibLoop		; if retry selected - jump to it

.AuxLibError
	moveq	#0,d0			;failure
	bra.s	777$

*--------------------------------
.AuxLib:
	DC.l	.AuxSTR
	DC.l	0
	DC.l	.RetrySTR
	DC.l	.CancelSTR

.AuxSTR:
	DC.b	'Can not load an auxillary library',0
.RetrySTR:
	DC.b	'RETRY',0
.CancelSTR:
	DC.b	'CANCEL',0
.EffectsLibName
	dc.b	'effects.library',0

	CNOP	0,2

**************************************************
DUMPFGCNAME	MACRO	;name

	IFD	DBFGC
	IFD	SERDEBUG
	 DUMPHEXI.l	<\1command: FG=>,a0,< >
	 DUMPTXT	<Name=>
	 movem.l	d0/a0,-(sp)
	 move.l		FGS_FileName(a0),d0
	 beq		.fooo\@
	 movea.l	d0,a0
	 DUMPSTR	0(a0)
.fooo\@	 movem.l	(sp)+,d0/a0
	 DUMPTXT	< >
	ENDC
	ENDC

	move.l	#\1,-(sp)
	bra	sendFGC

	ENDM

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_LoadCommand
FGC_LoadCommand
	DUMPFGCNAME	FGC_LOAD

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_PbuttonCommand
FGC_PbuttonCommand
	DUMPFGCNAME	FGC_PBUTTON

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_MbuttonCommand
FGC_MbuttonCommand
	DUMPFGCNAME	FGC_MBUTTON

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_ObuttonCommand
FGC_ObuttonCommand
	DUMPFGCNAME	FGC_OBUTTON

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_RemoveCommand
FGC_RemoveCommand
	DUMPFGCNAME	FGC_REMOVE

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_RemoveQCommand
FGC_RemoveQCommand
	DUMPFGCNAME	FGC_REMOVEQ

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_AutoCommand
FGC_AutoCommand
	DUMPFGCNAME	FGC_AUTO

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_TakeCommand
FGC_TakeCommand
	DUMPFGCNAME	FGC_TAKE

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_BGCommand
FGC_BGCommand
	DUMPFGCNAME	FGC_BG

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_UnloadCommand
FGC_UnloadCommand
	DUMPFGCNAME	FGC_UNLOAD

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_SelectCommand
FGC_SelectCommand:
	DUMPFGCNAME	FGC_SELECT

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_SelectKCommand
FGC_SelectKCommand:
	DUMPFGCNAME	FGC_SELECTK

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_SelectQCommand
FGC_SelectQCommand:
	DUMPFGCNAME	FGC_SELECTQ

**************************************************
* a0->Internal or External Crouton
* SEE PutValue for usage
	XDEF	FGC_PutValueCommand
FGC_PutValueCommand:
	DUMPFGCNAME	FGC_PUTVALUE

**************************************************
* a0->Internal or External Crouton
* SEE GetValue for useage
	XDEF	FGC_GetValueCommand
FGC_GetValueCommand:
	DUMPFGCNAME	FGC_GETVALUE

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_LoadTagsCommand
FGC_LoadTagsCommand:
	DUMPFGCNAME	FGC_LOADTAGS

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_TagInfoCommand
FGC_TagInfoCommand:
	DUMPFGCNAME	FGC_TAGINFO

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_UpdateTagCommand
FGC_UpdateTagCommand:
	DUMPFGCNAME	FGC_UPDATETAG

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_SaveTagsCommand
FGC_SaveTagsCommand:
	DUMPFGCNAME	FGC_SAVETAGS

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_PanelCommand
FGC_PanelCommand:
	DUMPFGCNAME	FGC_PANEL

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_NextCommand
FGC_NextCommand:
	DUMPFGCNAME	FGC_NEXT

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_ToMainCommand
FGC_ToMainCommand:
	DUMPFGCNAME	FGC_TOMAIN

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_ToPrvwCommand
FGC_ToPrvwCommand:
	DUMPFGCNAME	FGC_TOPRVW

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_UnSavableCommand
FGC_UnSavableCommand:
	DUMPFGCNAME	FGC_UNSAVABLE

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_FCountCommand
FGC_FCountCommand:
	DUMPFGCNAME	FGC_FCOUNT

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_QueueCommand
FGC_QueueCommand:
	DUMPFGCNAME	FGC_QUEUE

**************************************************
* a0->Internal or External Crouton
	XDEF	FGC_InterpTagsCommand
FGC_InterpTagsCommand:
	DUMPFGCNAME	FGC_INTERP



** NEW FGC_commands go HERE!

**************************************************
* a0->Internal or External Crouton, d0 = FGC_ command #
	XDEF	SendFGC2Crouton
SendFGC2Crouton
	move.l	d0,-(sp)

	IFD	DBFGC
	IFD	SERDEBUG
	 DUMPHEXI.l	<SendFGC2Crouton: FG=>,a0,< >
	 DUMPUDEC.w	<FGC=>,d0,< >
	ENDC
	ENDC

* FALL THRU TO sendFGC ROUTINE !!!!!!

**************************************************
* a0->Internal or External Crouton, LONG on stack = FGC_ command
* Stack is cleared on exit, and returns back to initial routine

cmdptr  set	(8*4+7*4)
sendFGC
	movem.l	d0-d7/a0-a6,-(sp)
	clr.l	TB_LastError(a5)	; Forget last error

	PUT.w	#-1,TB_ErrFlag		; Assume error
	move.l	a0,d0
	beq	666$			; Not a valid ->FG

	move.l	FG_Function(a0),d0	; the FG have a function to call?
	beq.s	666$			; if not - skip the FGC_xxxx command

	PUT.w	#0,TB_ErrFlag		; first assure error flag reset

	move.l	FG_Function(a0),-(sp)

	move.l	a5,-(sp)		; ToastBase
	move.l	a0,-(sp)		; FG
	move.l	cmdptr+2*4+4(sp),-(sp)	; FGC_Command
	move.l	d0,a0

	jsr	(a0)			; May set TB_ErrFlag (usually non -1)

	lea	4(sp),sp		; Advance

	lea	12(sp),sp		; And may set TB_LastError
666$	movem.l	(sp)+,d0-d7/a0-a6
	addq.w	#4,sp

	IFD	DBFGC
	IFD	SERDEBUG
	 tst.w	TB_ErrFlag(a5)
	 beq	777$
	 DUMPTXT	< FGCcommandERROR! >
777$	 DUMPMSG	<*>
	ENDC
	ENDC

	rts

******************************************************************
******************************************************************
* LONG PutStructValue(->FG, ->Data, ->TB, TagID, TagSize)
*	                a0    a1     a5     d0     d1
*
* Returns d0 = ERROR Code, = TB_ErrFlag = non zero if can't put
*
* CURRENTLY, THE FOLLOWING COMMENTS ARE WRONG!!!!
* INSTEAD THIS RETURNS AN ERROR IF THE SIZES DON'T MATCH,
* If the destination is smaller than the source, then the destination
* will use the first part of the source.
*
* If the destination is larger than the source, then only the first
* part of the destination will be updated.

* NOT CURRENTLY USED!!!!!! Used  TB AddValue2FGtags() instead!!!


	XDEF	PutStructValue

PutStructValue:
	PUT.l	d0,TB_TagID	;TagCTRL+TagID
	PUT.l	d1,TB_TagSize
	PUT.l	a1,TB_TagData
	bsr	FGC_PutValueCommand
	GET.w	TB_ErrFlag,d0
	ext.l	d0
	rts

***************************************************
* LONG GetStructValue(->FG, ->Data, ->TB, TagID, TagSize)
*	                a0    a1     a5     d0     d1
*
* Returns d0 = ERROR Code, = TB_ErrFlag = non zero if can't get
*
* CURRENTLY, THE FOLLOWING COMMENTS ARE WRONG!!!!
* INSTEAD THIS RETURNS AN ERROR IF THE SIZES DON'T MATCH,
* If the destination is smaller than the source, then the destination
* will use the first part of the source.
*
* If the destination is larger than the source, then only the first
* part of the destination will be updated.

	XDEF	GetStructValue

GetStructValue:
	PUT.l	d0,TB_TagID	;TagCTRL+TagID
	PUT.l	d1,TB_TagSize
	PUT.l	a1,TB_TagData
	bsr	FGC_GetValueCommand
	GET.w	TB_ErrFlag,d0
	ext.l	d0
	rts

***************************************************
* error = PutLongValue(->FG, TagID, Value)
*	              a0    d0    d1
*
* Returns d0 = ERROR Code, = TB_ErrFlag = non zero if can't put
*
* NOTE: You might want to use TB AddValue2FGtags() instead?

	XDEF	PutLongValue

PutLongValue:
	move.l	a1,-(sp)

;;	DUMPHEXI.l	<PUTLongValue: FG=>,a0,< >
;;	DUMPHEXI.l	<ID=>,d0,<\>

	PUT.l	d0,TB_TagID
	PUT.l	#4,TB_TagSize
	DEA.l	TB_TagLongData,a1
	PUT.l	a1,TB_TagData
	PUT.l	d1,TB_TagLongData

	bsr	FGC_PutValueCommand	;will always put if enough memory!

	GET.w	TB_ErrFlag,d0
	ext.l	d0
	movea.l	(sp)+,a1
	rts

***************************************************
* LONG GetLongValue(->FG, TagID)
*	              a0   d0
*
* Returns d0 = value (may be zero).  If value is unknown or Error,
* then returns 0. You may check TB_ErrFlag for possible error.

	XDEF	GetLongValue

GetLongValue:
	move.l	a1,-(sp)

;;	DUMPHEXI.l	< GetLongValue: FG=>,a0,< >
;;	DUMPHEXI.l	<ID=>,d0,<\>

	PUT.l	d0,TB_TagID
	PUT.l	#4,TB_TagSize
	DEA.l	TB_TagLongData,a1
	PUT.l	a1,TB_TagData

	clr.l	TB_TagLongData(a5)	;assume error
	bsr	FGC_GetValueCommand
	GET.l	TB_TagLongData,d0	;errors return 0

666$	movea.l	(sp)+,a1
	rts

******************************************************************
* value = GetTagValue(TAGID,->FG, ->TB)
*  d0                  d0     a3   a5
* This command is used within a FG-handler, so that we can assume
* we understand the tag list structure.  In other words, this one
* does not use FGC_CMDs (which would have caused recursion).
*
* Returns d0 = value (may be zero).  If value is unknown or Error,
* then returns 0. You may check TB_ErrFlag for possible error.
*
	XDEF	GetTagValue
GetTagValue
	movem.l	d1/a0,-(sp)
	PUT.w	#-1,TB_ErrFlag			;assume error

	move.l	FGS_TagLists(a3),d1	;offset
	beq	666$			;no TagLists offset
	lea	0(a3,d1.l),a0		;search link lists

	moveq.l	#4,d1		;destination size
	CALLTL	SearchLists4TagGetID
	tst.l	d0
	beq	666$

	move.l	d0,a0
	move.l	4(a0),d0
	clr.w	TB_ErrFlag(a5)

666$	movem.l (sp)+,d1/a0
	rts

***************************************************
* TotalLength = GetSizeOfListsUnsavedItems(->LinkListOfTagLists)
*   d0                                 a0
* Does not include NULLs at tag list ends
* This is used to with Project Saving to obtain a tag list Length.

	XDEF	GetSizeOfListsUnsavedItems
GetSizeOfListsUnsavedItems:
	movem.l	d1-d2/a0-a1,-(sp)
	moveq	#0,d2	;init accum

	move.l	a0,d1	;->first node
	beq.s	666$	;can't find TagID because no ->LinkLists

10$	movea.l	d1,a1	 		;->node
	lea	TLN_SIZEOF(a1),a0 	;->first item in tag list
	bsr.s	GetSizeOfUnsavedItems
	add.l	d0,d2
	move.l	(a1),d1		;->next node in list
	bne.s	10$		;jump if more lists

666$	move.l	d2,d0
	movem.l	(sp)+,d1-d2/a0-a1
	rts

***************************************************
* TotalLength = GetSizeOfUnsavedItems(->TagList)
*   d0                                 a0
*
* Does not include NULL at end
* This is used to with AllocMem() when allocating Unsaved Tag lists.

	XDEF	GetSizeOfUnsavedItems
GetSizeOfUnsavedItems:
	movem.l	d1-d3/a0,-(sp)
	moveq	#TAGCTRL_UNSAVED+16,d3
	bra.s	getsizeofitems	;NOTE! JUMPS BELOW!!!

***************************************************
* TotalLength = GetSizeOfNewItems(->TagList)
*   d0                                 a0
*
* Does not include NULL at end
* This is used to with AllocMem() when allocating new Tag lists.

	XDEF	GetSizeOfNewItems
GetSizeOfNewItems:
	movem.l	d1-d3/a0,-(sp)
	moveq	#TAGCTRL_NEW+16,d3

* NOTE! THIS IS JUMPED TO FROM ABOVE
getsizeofitems:

	DEBUGHEXI.l	DBGLTS,<GetSizeOfNew/UnsavedItems: taglist=>,a0,<\>

	moveq	#0,d0	;init accum

10$	moveq	#4,d2	;assume LONG

	DEBUGHEXI.l	DBGLTS,<tagptr=>,a0,< >
	DEBUGHEXI.l	DBGLTS,<tagid=>,(a0),<\>

	move.l	(a0)+,d1
	beq	666$	;end of list

	tst.w	d1
	beq	200$	;jump if ignore

	btst	d3,d1
	beq.s	200$	;jump if old

50$	tst.l	d1
	bmi.s	100$	;jump if LONG
	move.l	(a0)+,d2
	addq.l	#4,d0
	DEBUGMSG	DBGLTS,<STRUCT tag>

100$	add.l	d2,d0
	addq.l	#4,d0	;CTRL + ID
	adda.l	d2,a0
	bra	10$

*ignore this item
200$
	DEBUGMSG	DBGLTS,<ignore non-new or zeroed tag>
	tst.l	d1
	bmi.s	210$	;jump if LONG
	move.l	(a0)+,d2
210$	adda.l	d2,a0
	bra	10$

666$	DEBUGUDEC.l	DBGLTS,<final size=>,d0,<\>

	movem.l	(sp)+,d1-d3/a0
	rts

***************************************************
* MakeTagListsSaved(->LinkListOfTagLists)
*                 	a0

	XDEF	MakeTagListsSaved
MakeTagListsSaved:
	movem.l	d0/a0-a1,-(sp)

	move.l	a0,d0	;->first node
	beq.s	666$	;can't find TagID because no ->LinkLists

10$	movea.l	d0,a1	 		;->node
	lea	TLN_SIZEOF(a1),a0 	;->first item in tag list
	bsr.s	MakeTagListSaved
	move.l	(a1),d0		;->next node in list
	bne.s	10$		;jump if more lists

666$	movem.l	(sp)+,d0/a0-a1
	rts

***************************************************
* MakeTagListSaved(->TagList)
*                    a0
*
	XDEF	MakeTagListSaved
MakeTagListSaved:
	movem.l	d0-d1/a0,-(sp)

10$	moveq	#8,d0	;assume LONG

	move.l	(a0),d1
	beq	666$	;end of list

	bclr.b	#TAGCTRL_UNSAVED-8,(a0)

50$	tst.l	d1
	bmi.s	100$	 ;jump if LONG
	add.l	4(a0),d0	;+STRUCT size

100$	adda.l	d0,a0
	bra	10$

666$	movem.l	(sp)+,d0-d1/a0
	rts

***************************************************
* TotalLength = GetSizeOfAllItems(->TagList)
*   d0                                 a0
*
* Does not include NULL at end
* This is used to with FreeMem() when deallocating Tag lists from memory.

	XDEF	GetSizeOfAllItems
GetSizeOfAllItems:
	movem.l	d1-d2/a0,-(sp)

	DEBUGMSG	DBGLTS,<GetSizeOfAllItems>

	moveq	#0,d0	;init accum

10$	moveq	#4,d2	;assume LONG
	move.l	(a0)+,d1
	beq.s	666$	;end of list

50$	tst.l	d1
	bmi.s	100$	;jump if LONG
	move.l	(a0)+,d2
	addq.l	#4,d0

100$	add.l	d2,d0
	addq.l	#4,d0	;CTRL + ID
	adda.l	d2,a0
	bra.s	10$

666$	DEBUGUDEC.l	DBGLTS,<final size=>,d0,<\>

	movem.l	(sp)+,d1-d2/a0
	rts

***************************************************
* ->struct = SearchFG4Struct(->FG, TagID)
*   d0                        a3    d0
*
	XDEF	SearchFG4Struct
SearchFG4Struct:
	movem.l	d1-d2/a0,-(sp)

	DEBUGMSG	DBSEAR,<SearchFG4Struct:>

	move.l	FGS_TagLists(a3),d1	;offset
	beq.s	666$
	lea	0(a3,d1.l),a0		;search link lists

	moveq	#0,d1	;don't care about length
	moveq	#0,d2	;get

	bsr	SearchLists4TagID
	beq.s	777$
	addq.l	#8,d0		;assume standard STRUCT ****!!!!*****

777$	movem.l	(sp)+,d1-d2/a0
	rts

666$	moveq.l	#0,d0
	bra.s	777$


***************************************************
* BOOL = ApplyTags2Lists(a0->Tags, a1->Lists)
* CALLED by FGC_LoadTags

	XDEF	ApplyTags2Lists
ApplyTags2Lists
	movem.l	d1/a0-a3/a6,-(sp)
	movea.l	a0,a3
	movea.l	a1,a2

	movea.l	a3,a1
10$	moveq.l	#4,d1		;assume Tag size of 4
	movea.l	a1,a6
	move.l	(a1)+,d0	;TagCTRL+TagID
	beq	200$		;done with source tags
	bset.b	#TAGCTRL_NEW-8,(a6)	;assume this is a new item
	bmi.s	20$		;jump if standard LONG tag data
	move.l	(a1)+,d1	;size

20$	movea.l	a2,a0		;destination link lists

* If IDs match, but lengths differ, the PUT destination item is NULLed!!
	DEBUGMSG	DBPETAGS,<before SearchLists4TagPutID>
	CALLTL	SearchLists4TagPutID
	beq	100$			;can't find tag item

****!!!!*** If it can't find a Tag value, it should then search for
****!!!!*** NULLed items that have the correct size.  So they can be
****!!!!*** used instead of putting the item into a new node.

	bclr.b	#TAGCTRL_NEW-8,(a6)	;its an old item

	DEBUGMSG DBPETAGS,<Found TagID in crouton>

	movea.l	d0,a0
	move.l	d1,d0		;source size
	CALLTL	MoveValue2Tag

100$	adda.l	d1,a1		;do next tag
	bra	10$

* Finished with 1st pass.  Now check for NEW items.
200$	movea.l	a3,a0		;->source tag list
	bsr	GetSizeOfNewItems

	DEBUGUDEC.l DBPETAGS,<SizeOfNewItems to add=>,d0,<\>

	tst.l	d0
	beq	777$		;d0=size of total items
				;a0->source tag list
	movea.l	a2,a1		;->destination linked lists
	DEBUGMSG	DBPETAGS,<before AddNewItems2Lists>

	bsr	AddNewItems2Lists

	tst.l	d0		;BOOL
666$	movem.l	(sp)+,d1/a0-a3/a6
	rts

777$	moveq	#1,d0		;OK
	bra.s	666$

***************************************************
* ->Tag = SearchLists4TagID(->LinkListOfTagLists,TagID,Length,[mode])
*   d0                              a0             d0	d1	d2
*
* If d1=0, then any length will do (and mode is ignored)
* Mode = 1 for put, 0 for get
* If d1<>0, and if IDs match, but lengths differ, the PUT destination
*   item is NULLed!!


***!!!!!!**** SearchPUT needs to look at IGNORED items to see if they
* are of the correct size.  And use them, if no other match is found!!!!!

	XDEF	SearchLists4TagID,SearchLists4TagPutID,SearchLists4TagGetID
SearchLists4TagPutID:
	movem.l d2-d4/a0-a1,-(sp)
	moveq	#1,d2
	bra.s	searchlists4id

SearchLists4TagGetID:
	movem.l d2-d4/a0-a1,-(sp)
	moveq	#0,d2
	bra.s	searchlists4id

* D2=mode
SearchLists4TagID:
	movem.l d2-d4/a0-a1,-(sp)

searchlists4id
	DEBUGHEXI.l	DBSEAR,<SearchLists4TagID: ID=>,d0,<\>

	move.l	a0,d3	;->first node
	beq	666$	;can't find TagID because no ->LinkLists

	DEBUGMSG	DBSEAR,<have ptr to linklists>

	move.l	d0,d4			;stash ID
10$	move.l	d4,d0
	movea.l	d3,a1	 		;->node
	lea	TLN_SIZEOF(a1),a0 	;->first item in tag list
	bsr	Search4TagID		;kills d0 which = ID
	bne	777$		;jump if found a match

	DEBUGMSG	DBSEAR,<search next linked list>

	move.l	(a1),d3		;->next node in list
	bne	10$		;jump if more lists

666$	moveq	#0,d0	;couldn't find TagID

	DEBUGMSG	DBSEAR,<SearchLists4TagID could not find TagID>

777$	movem.l	(sp)+,d2-d4/a0-a1
	rts

***************************************************
* ->Tag = Search4TagID(->TagList,TagID,Length,[mode])
*   d0                     a0      d0	d1	d2
* = NULL (Z flag set) if can't find item
*
* If d1=0, then any length will do (and mode is ignored)
* Mode = 1 for put, 0 for get
* If d1<>0, and if IDs match, but lengths differ, the PUT destination
*   item is NULLed!!

***!!!!!!**** SearchPUT needs to look at IGNORED items to see if they
* are of the correct size.  And use them, if no other match is found!!!!!

	XDEF	Search4TagID,Search4TagPutID,Search4TagGetID
Search4TagPutID:
	movem.l d2-d3/a0,-(sp)
	moveq	#1,d2		;Put mode
	bra.s	search4id

Search4TagGetID:
	movem.l d2-d3/a0,-(sp)
	moveq	#0,d2		;Get mode
	bra.s	search4id

* d2=mode
Search4TagID:
	movem.l d2-d3/a0,-(sp)

search4id:
	DEBUGHEXI.l	DBSEAR,<Search4TagID sourceID=>,d0,< >
	DEBUGHEXI.l	DBSEAR,<ptr taglist=>,a0,<\>

	move.l	a0,d3
	beq	666$	;can't find TagID because no ->TagList

	DEBUGMSG	DBSEAR,<valid pointer to TagList>

10$	move.l	(a0),d3 ;look at TagID
	beq	666$	 ;jmp if couldn't find TagID = end of TagList

	DEBUGHEXI.l	DBSEAR,<not at TagList End destID=>,d3,< >
	DEBUGHEXI.l	DBSEAR,<at>,a0,<\>

	cmp.w	d3,d0	;Just look at ID
	bne	15$	;jump if no ID match

	DEBUGMSG	DBSEAR,<ID match>

	tst.l	d3
	bpl.s	12$	;jump if STRUCT

	DEBUGMSG	DBSEAR,<long match>

	cmpi.l	#4,d1
	beq	555$	;found a match, LONG
	bra	14$

12$
;;	DUMPUDEC.l <Struct Match!!! Source Size=>,d1,< >
;;	DUMPUDEC.l <Dest Size=>,4(a0),<\>

	tst.l	d1
	beq	555$
	cmp.l	4(a0),d1
	beq	555$	;found a match, STRUCT

14$	tst.w	d2	;Get/Put mode
	beq.s	15$	;jump if Get mode
	move.w	#TAGID_IGNORE,2(a0)	;mark as ignore

15$	DEBUGMSG	DBSEAR,<not a match>

	tst.l	d3
	bmi	20$	 ;jump if LONG Tag (vs STRUCT Tag)

	DEBUGHEXI.l	DBSEAR,<Currenttag=>,a0,< >
	DEBUGHEXI.l	DBSEAR,<Add struct size=>,4(a0),<\>

	adda.l	4(a0),a0 ;add TagSize

20$	addq.w	#8,a0	;skip over (ID & data), or (ID & Size)
	bra	10$

666$	moveq	#0,d0	;couldn't find TagID
	bra	777$

555$	move.l	a0,d0

	DEBUGMSG	DBSEAR,<found a match>
	IFD DBSEAR
	  tst.l d0
	ENDC

777$	movem.l	(sp)+,d2-d3/a0
	rts

***************************************************
* MoveTag2Value(->sourceTagID,->destTagData,destSize)
*                     a0             a1        d0
*
* This routine can only be called if the IDs and Sizes match!!!
* We also assume ->sourceTagID is valid! So, there aren't any errors possible.

	XDEF	MoveTag2Value
MoveTag2Value:
;;	DEBUGMEM	DBTAG,<MoveSource Tag+Data>,0(a0),#16


	tst.l	(a0)
	bpl.s	100$		;jump if STRUCT tag

	DEBUGMSG	DBTAG,<got LONG data>

	move.l	4(a0),(a1)	;standard LONG tag
	rts

* Move STRUCT Tag
100$
	DEBUGMSG	DBTAG,<got STRUCT data>

	movem.l	d0/a0-a1,-(sp)
	addq.w	#8,a0		;->source DATA
	lsr.l	#1,d0		;Assume WORD size!
	bra.s	200$

120$	move.w	(a0)+,(a1)+
	subq.l	#1,d0
200$	bne.s	120$

	movem.l	(sp)+,d0/a0-a1

;;	DEBUGMEM	DBTAG,<DestTable>,0(a1),#16

	rts

***************************************************
* MoveValue2Tag(->destTagID,->sourceTagData,[sourceSize])
*                   a0             a1           d0
*
* This routine can only be called if the IDs and Sizes match!!!
* We also assume ->sourceTagID is valid! So, there aren't any errors possible.
* Only if the destination needs to be updated is it marked as UNSAVED.

	XDEF	MoveValue2Tag
MoveValue2Tag:
;;	DEBUGMEM	DBTAG,<MoveSource Data>,0(a1),#16

	tst.l	(a0)
	bpl	100$		;jump if STRUCT tag

	DEBUGMSG	DBTAG,<got LONG data>

	move.l	d0,-(sp)
	move.l	(a1),d0		;source
	cmp.l	4(a0),d0	;=destination ?
	beq.s	10$

	bset.b	#TAGCTRL_UNSAVED-8,(a0)	;Mark as updated = NEW
	move.l	d0,4(a0)	;standard LONG tag

10$	move.l	(sp)+,d0
	rts

* Move STRUCT Tag
100$
	DEBUGMSG	DBTAG,<got STRUCT data>

	movem.l	d0-d2/a0-a1,-(sp)
	addq.w	#8,a0		;->dest DATA
	moveq	#0,d1		;assume no change
	lsr.l	#1,d0		;Assume WORD size!!!!!
	bra.s	200$

120$	move.w	(a1)+,d2
	cmp.w	(a0),d2
	beq.s	150$
	moveq	#1,d1		;flag change
150$	move.w	d2,(a0)+

	subq.l	#1,d0
200$	bne.s	120$

	tst.w	d1
	movem.l	(sp)+,d0-d2/a0-a1
	beq.s	300$			;jump if no change
	bset.b	#TAGCTRL_UNSAVED-8,(a0)	;Mark as updated = NEW
300$
;;	DEBUGMEM	DBTAG,<Dest Tag+Data>,0(a0),#16
	rts

******************************************************************
* BOOL= AddNewItems2Lists(TotalSize,->SourceTagList,->LinkedLists)
*			     d0		  a0		a1
* Total size does not include NULL at end, or the Node header.

	XDEF	AddNewItems2Lists

a0ptr	set	8
a1ptr	set	12

AddNewItems2Lists:
	movem.l	d1-d2/a0-a1/a6,-(sp)

	DEBUGMSG	ANI2L,<AddNewItems2Lists>

	move.l	(4).w,a6
	addi.l	#TLN_SIZEOF+4,d0	;node + NULL terminater
	move.l	d0,d2			;save size
	move.l	#MEMF_PUBLIC,d1
	CALLROM	AllocMem
	tst.l	d0
	beq	666$	;alloc failed

	DEBUGMSG	ANI2L,<AllocMem OK>

	movea.l	a1ptr(sp),a0
5$	move.l	(a0),d1
	beq.s	20$		;jump if end of list
	movea.l	d1,a0
	bra.s	5$

20$	move.l	d0,(a0)		;put in ->new node
	movea.l	d0,a1
	clr.l	(a1)		;mark end of linked lists
	move.l	d2,TLN_Size(a1)
	lea	TLN_SIZEOF(a1),a1

	move.l	a0ptr(sp),a0	;Source taglist

* a0->source tag list, a1->destination memory
10$	move.l	(a0)+,d0
	beq	555$	;end of list

	DEBUGHEXI.l	ANI2L,<TagID=>,d0,<\>

	tst.w	d0
	beq	200$	;jump if ignore

	btst	#TAGCTRL_NEW+16,d0
	beq	200$	;jump if old

	bset	#TAGCTRL_UNSAVED+16,d0		;Mark as updated
	move.l	d0,(a1)+	;stash new CTRL+ID
	bpl.s	100$		;jump if STRUCT

	DEBUGMSG	ANI2L,<moving in LONG>

	move.l	(a0)+,(a1)+
	bra	10$

* STRUCT
100$	move.l	(a0)+,d0	;length
	move.l	d0,(a1)+

	DEBUGMEM	ANI2L,<moving in STRUCT, source tag=>,-8(a0),d0
	IFD	ANI2L
	move.l	a1,d1
	subq.l	#8,d1
	DEBUGHEXI.l	ANI2L,<Destionation Tag at >,d1
	ENDC

	lsr.l	#1,d0		;Assume WORD size!
	bra.s	130$

120$	move.w	(a0)+,(a1)+
	subq.l	#1,d0
130$	bne.s	120$
	bra	10$

*ignore this item
200$	DEBUGMSG	ANI2L,<ignore item>

	moveq	#4,d1	;assume LONG
	tst.l	d0
	bmi.s	210$	;jump if LONG
	move.l	(a0)+,d1
210$	adda.l	d1,a0
	bra	10$

555$	clr.l	(a1)	;mark end of list

666$	movem.l	(sp)+,d1-d2/a0-a1/a6
	rts

******************************************************************
* error = AddString2FGtags(TagID, ->FG, ->string, ->TB)
*		    d0      a0     a1      a5
* Only works on strings up to 64K in size.

	XDEF	AddString2FGtags
AddString2FGtags:
	move.l	d1,-(sp)

	move.l	d0,d1		;stash TagID
	exg	a0,a1		;a0->string, a1->FG
	CALLTL	STRlen
	exg	a0,a1		;a0->FG, a1->string
	exg	d0,d1		;d0=TagID, d1=size
	addq.l	#1,d1		;add null byte

	bsr	AddValue2FGtags

	move.l	(sp)+,d1
	rts

******************************************************************
* error=AddValue2FGTags(TagID, size, ->FG, ->data, ->TB)
*		          d0    d1     a0     a1    a5
*
* Table Data Sizes will be rounded up to word size (padded with garbage)
* Works on LONGs or Tables
* If LONG tags of sizes of 1,2 will be sign extended to 4 bytes.
* It assumes LONG tags of sizes 2 or 4 are WORD aligned.  (Size of 3 isn't supported)

	XDEF	AddValue2FGtags
AddValue2FGtags:
	movem.l	d1-d3/a1-a2,-(sp)

	DEBUGHEXI.l	DBTAG,<Add Value TagID=>,d0,<\>

	PUT.w	#-1,TB_ErrFlag	;assume error

	tst.l	d1
	beq	666$		;can't add zero size data

	move.l	sp,d2		;original stack position
	lea	-12(sp),sp	;room for tagid and size longs, tag end null
				;or tagid, LONG and tag end
	tst.l	d0
	bpl.s	5$		;jump if Table

*---------------
* Its a LONG value
	cmpi.l	#4,d1
	bhi	555$		;Won't allow sizes > 4 for LONGs
	beq.s	3$

	cmpi.l	#1,d1
	beq.s	2$

* Assume 2 WORD aligned bytes, don't allow 3 bytes
	move.w	(a1),d3
	bra.s	1$

* Assume One byte (don't allow 3 bytes)
2$	move.b	(a1),d3
	ext.w	d3

1$	ext.l	d3
	bra.s	4$

* 4 bytes (assume WORD aligned)
3$	move.l	(a1),d3

4$	move.l	d0,(sp)		;tagID
	move.l	d3,4(sp)	;data LONG
	clr.l	8(sp)		;end of tag list null
	bra	20$

*---------------
* It's a Table value
5$	DEBUGMSG	DBTAG,<its a table value>

	addq.l	#1,d1		;round up to even
	andi.l	#~1,d1		;will be atleast 2 bytes minimum
	suba.l	d1,sp

	movea.l	sp,a2
	move.l	d0,(a2)+	;tagID
	move.l	d1,(a2)+	;size (including null [and even byte])

10$	move.b	(a1)+,(a2)+	;move string pull null [+ even byte]
	subq.l	#1,d1
	bne.s	10$

	clr.l	(a2)		;end of tag list null

20$	PUT.l	sp,TB_Tags		;a0->FG

;;	DEBUGMEM	DBTAG,<Apply Taglist>,0(sp),#32

	CALLTL	FGC_LoadTagsCommand

555$	movea.l	d2,sp		;restore stack ptr

	GET.w	TB_ErrFlag,d0
	ext.l	d0

666$	movem.l	(sp)+,d1-d3/a1-a2
	rts

******************************************************************
*+****************************************************************
*+
*+ WriteProjEntry
*+
*+ This function writes out the next project entry into the specified
*+ project script from the specified ToolBox FastGadget.
*+
*+ LONG WriteProjEntry( FileHandle, TBFastGadget );
*+  D0                   A0          A1
*+
*+ APTR FileHandle:
*+   Pointer to the open DOS file where we will write, starting at the
*+   current file position, the next ToolBox FastGadget project entry.
*+ APTR TBFastGadget:
*+   Pointer to the ToolBox FastGadget whose contained information is to
*+   be written out as an entry to the project script.
*+
*+ Notes:
*+   The FastGadget being processed is ASSUMED to be and MUST be a proper
*+   ToolBox FastGadget. If everthing went OK, this function will return 0.
*+   Otherwise this function will return -1. Trashes D1,A0,A1, and the
*+   condition codes are set according to the result in D0. This function
*+   requires that A5 contain a pointer to ToasterBase. It is not tied
*+   closely with interface/switcher display. The value in the ToolBox
*+   FastGadget's FG_LoadFlag is assumed to be and must be correct.
*+
*+ Addendum 2/23/90: Now handles AddOn data.
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back the DOS secondary
*+   error number obtained from IoErr().
*+ Addendum 4/20/90:
*+   Additional information on handling AddOn data. The standard portions of
*+   the ToolBox FastGadget structure PLUS all of the AddOn data must be able
*+   to fit in the TB_FileBuff buffer, or there will be trouble. Currently
*+   this buffer is about 4K.
*+ Addendum 4/25/90:
*+   Now has no restriction due to buffering data in TB_FileBuff. Also
*+   properly handles AddOn data ONLY on external TBFGs.
*+ Addendum 3/7/91:
*+  Does not try to save the dummy couton when encountering it.
*+
*+*******

	XDEF	WriteProjEntry
WriteProjEntry:	; entry: FileHandle, TBFastGadget
*                         A0          A1

	DEBUGMSG	DBWPE,<WriteProjectEntry>

;;;	cmp.l	#-1,FGS_AddOnSize(a1)
	tst.b	FG_LoadFlag(a1)
	bne.s	.NormalCrouton

	moveq	#0,d0	; a dummy crouton so DO NOT save it!
	rts		; early exit if dummy crouton...

*-----------
.NormalCrouton:
	DEBUGMSG	DBWPE,<Normal Crouton>
	SAVE	d1-d4/a0-a4/a6		; save work registers
	move.l	a0,d4			; keep filehandle pointer safe
	movea.l	a1,a3
	movea.l	a1,a0			;->FG
	bsr	FGC_SaveTagsCommand		;see if FG has any tags & where
					;Fills in ->TB_Tags

	DEBUGMSG	DBWPE,<Return From SaveTagsCommand>

* determine total size of entry write
	GET.l	TB_Tags,a0
	bsr	GetSizeOfListsUnsavedItems	;might be zero

	DEBUGUDEC.l	DBWPE,<GetSizeOfNewItems=>,d0,<\>

	movea.l	FGS_FileName(a3),a4	;->filename BSTR
	subq.w	#2,a4
	move.w	(a4),d1			;file name size
	addi.w	#6+TBPE_FileNameSize-TBPE_EntryData,d1	;plus filesize word & end of taglist marker long
	ext.l	d1
	add.l	d1,d0			;total required write size

	GET.l	TB_DOSBase,a6		; get pointer to DOS lib base

* For future expansion pads
	clr.l	-(sp)		;clear pad3
	clr.l	-(sp)		;clear pad2
	clr.l	-(sp)		;clear pad1
	clr.l	-(sp)		;clear pad0

* write entry size + ObjectType + ObjectVersion
	move.l	FGS_ObjectVersion(a3),-(sp)
	move.l	FGS_ObjectType(a3),-(sp)
	move.l	d0,-(sp)	;stash total length on stack

	move.l	sp,d2
	moveq	#4*(4+3),d3
	move.l	d4,d1
	CALLROM	Write		; now write out tag list block
	lea	4*(4+3)(sp),sp
	cmp.l	d0,d3		; everything written out?
	bne	.DOSErr		; if not - denote the error

	DEBUGMSG	DBWPE,<EntrySize/ObjectType/ObjectVersion + pads Written>

* write out filename size and string
	move.l	a4,d2		;->name size & string
	move.w	(a4),d3
	addq.w	#2,d3		;add on file name size word
	ext.l	d3
	move.l	d4,d1
	CALLROM	Write		; now write out tag list block
	cmp.l	d0,d3		; everything written out?
	bne	.DOSErr		; if not - denote the error

	DEBUGMSG	DBWPE,<Filename Writen>

	GET.l	TB_Tags,d2
	beq	.NormalExit		;jump if no tags to save

*--------------------
	movea.l	d4,a0			;handle
	movea.l	d2,a1			;taglists
	bsr	WriteUnsavedTagLists
	beq	.DOSErr

*--------------------
* end of all tag lists

.NormalExit:
	move.l	#0,-(sp)	;stash taglist end on stack
	move.l	sp,d2
	moveq	#4,d3
	move.l	d4,d1
	CALLROM	Write		; now write out tag list block
	addq.w	#4,sp
	cmp.l	d0,d3		; everything written out?
	bne	.DOSErr		; if not - denote the error

	DEBUGMSG	DBWPE,<End of Tag marker Writen>

	CLEAR	d0			; give a clean bill of health
666$	REST	d1-d4/a0-a4/a6		; restore work registers
	rts

.DOSErr:
	DEBUGMSG	DBWPE,<.DOSErr>

	CALLROM	IoErr			; get secodary error code from DOS
	PUT.l	d0,TB_LastGlobalError
	moveq	#-1,d0			; denote a problem occured
	bra.s	666$

***************************************************
* BOOL = WriteUnsavedTagLists(handle, ->LinkListOfTagLists)
*  d0                       a0            a1

	XDEF	WriteUnsavedTagLists
WriteUnsavedTagLists:
	movem.l	a1-a2,-(sp)
	move.l	a1,d0	;->first node
	beq	666$	;can't find TagID because no ->LinkLists

10$	movea.l	d0,a2	 		;->node
	lea	TLN_SIZEOF(a2),a1 	;->first item in tag list
	bsr	WriteUnsavedTagList
	beq	555$

	DEBUGHEXI.l	DBWPE,<Next taglist=>,(a2),<\>

	move.l	(a2),d0		;->next node in list
	bne	10$		;jump if more lists

666$	moveq	#1,d0		;success
555$	movem.l	(sp)+,a1-a2
	rts

***************************************************
* BOOL  = WriteUnsavedTagList(handle, ->TagList)
*   d0                    a0  	    a1
*
	XDEF	WriteUnsavedTagList
WriteUnsavedTagList:
	movem.l	d1-d4/a0-a2/a6,-(sp)

	DEBUGHEXI.l	DBWPE,<WriteUnsavedTagList: tagptr=>,a1,<\>

	move.l	a0,d4
	movea.l	a1,a2

	GET.l	TB_DOSBase,a6		; get pointer to DOS lib base

10$	moveq	#8,d3	;assume LONG, CTRL+ID+(VALUE/SIZE)

	DEBUGHEXI.l	DBWPE,<tagptr=>,a2,< >
	DEBUGHEXI.l	DBWPE,<tagid=>,(a2),<\>

	move.l	(a2),d1
	beq	666$	;end of list

	tst.w	d1
	beq	200$	;jump if ignore

	btst	#TAGCTRL_UNSAVED+16,d1
	beq	200$	;jump if old

50$	tst.l	d1
	bmi.s	100$	 ;jump if LONG
	add.l	4(a2),d3 ;add STRUCT size

* d3=size to write
100$	move.l	d4,d1		;handle
	move.l	a2,d2		;buff

	DEBUGHEXI.l	DBWPE,<  write buff=>,d2,< >
	DEBUGUDEC.l	DBWPE,<  write size=>,d3,<\>

	CALLROM	Write		;now write out tag list block
	cmp.l	d0,d3
	beq	150$

	DEBUGMSG	DBWPE,<DOSerror>

	moveq	#0,d0
	bra	777$		;write error

150$	adda.l	d3,a2
	bra	10$

*ignore this item
200$	DEBUGMSG	DBWPE,<  IGNORE this item>

	tst.l	d1
	bmi.s	150$	;jump if LONG
	add.l	4(a2),d3 ;add STRUCT size
	bra	150$

666$	moveq	#1,d0		;success
777$	movem.l	(sp)+,d1-d4/a0-a2/a6
	rts

*+*****************************************************************
*+
*+ SaveFastGList
*+
*+ This function uses the 680X0 processor to save the background specified
*+ under the template presented by the list of FastGadgets specified.
*+
*+ void SaveFastGlist( Count, Offset, FastGadget, Window, Requester, Buff );
*+                      D0     D1      A0          A1      A2         A3
*+
*+ LONG Count:
*+   Low unsigned 16 bits are used as a maximum count of FastGadget
*+   structures to process. Zero denotes a count of 65536.
*+ LONG Offset:
*+   Caller specified byte offset to be added to position of FastGadget image
*+   in the BitMap source. This field is not checked for WORD boundry
*+   alignment.
*+ APTR FastGadget:
*+   Pointer to list of FastGadgets to be processed.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget list. It is assumed
*+   that the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget list. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the first
*+   FastGadget in the specified list. It is assumed that the offset formed
*+   from this requester will be WORD boundry aligned. This pointer will be
*+   ignored if the FastGadget list is not tethered to a requester.
*+ APTR Buff:
*+   Pointer to a buffer area that is to hold the contents of the display
*+   under the template areas of the FastGadget list, in the consective order
*+   of the FastGadget list. The storage is always done using DISPLAYMODE0,
*+   which guarantees that the entire background is saved. PLEASE BE SURE
*+   that this buffer is large enough to hold what is to be saved.
*+
*+ Notes:
*+   There is no support for GIMMEZEROZERO FastGadgets or FastGadgets linked
*+   to a screen, they must be tethered to a window directly, or indirectly
*+   via a requester. Trashes D0,D1,A0,A1, and the condition codes. This
*+   function assumes EVERYTHING is in order and ready to go. Bad vibes can
*+   occur in your system if the FastGadget list specified is not a true
*+   FastGadget list, but contains one or more regular Gadgets. FastGadgets
*+   can be processed by Intuition Gadget handling functions since the Gadget
*+   structure subset will have no imagery selected, but the reverse is not
*+   true.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment.
*+
*+*******

	IFNE	_CCODE

	XDEF	_SaveFastGList
_SaveFastGList:
	SAVE	a2/a3
	movem.l	12(sp),d0/d1/a0-a3
	CALL.s	SaveFastGList
	REST	a2/a3
	rts

	ENDC

	XDEF	SaveFastGList
SaveFastGList:	; entry: Count, Offset, FastGadget, Window, Requester, Buff
*                         D0     D1      A0          A1      A2         A3
	SAVE	d2-d6/a2-a6		; save work registers
	CLEAR	d2			; assure longword usable
	move.w	wd_TopEdge(a1),d3	; form offset from window position
	mulu	#DISPLAYWIDTH/8,d3	; and add it to offset parameter
	move.w	wd_LeftEdge(a1),d2
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1
	btst.b	#4,gg_GadgetType(a0)	; are these FastGadgets tethered to a
*					; requester?
	beq.s	10$			; if not - skip on
	move.w	rq_TopEdge(a2),d3	; form additional offset from
	mulu	#DISPLAYWIDTH/8,d3	; requester position
	move.w	rq_LeftEdge(a2),d2	; and add it to offset total
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1

10$:
	move.l	wd_WScreen(a1),a1		; BitMap for this window
	lea	sc_BitMap+bm_Planes(a1),a1	; point at BitMap planes
	subq.w	#1,d0				; form FastGadget count

20$:
	lea	FG_ModeType(a0),a2	; first get placement control:
	movem.w	(a2)+,d2-d5		; type, word width, height, modulus

	move.l	(a2),d2			; offset within container


* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2/a4-a6		; source bitplane pointers
	movem.l	(a1),a2/a4		; source bitplane pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a2			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

30$:
	move.w	d3,d2			; setup line word counter

40$:
	move.w	(a2)+,(a3)+		; save image into buffer
	move.w	(a4)+,(a3)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	(a5)+,(a3)+
;;	move.w	(a6)+,(a3)+
	dbf	d2,40$			; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	dbf	d4,30$			; reloop till all lines are done

	move.l	(a0),d2			; address next FG area to save
	beq.s	50$			; if no more - exit
	move.l	d2,a0
	dbf	d0,20$			; save another FastGadget area till
*					; count out or no more

50$:
	REST	d2-d6/a2-a6		; restore work registers
	rts

*+*******
*+
*+ LoadFastGList
*+
*+ This function uses the 680X0 processor to load the background specified
*+ under the template presented by the list of FastGadgets specified.
*+
*+ void LoadFastGlist( Count, Offset, FastGadget, Window, Requester, Buff );
*+                      D0     D1      A0          A1      A2         A3
*+
*+ LONG Count:
*+   Low unsigned 16 bits are used as a maximum count of FastGadget
*+   structures to process. Zero denotes a count of 65536.
*+ LONG Offset:
*+   Caller specified byte offset to be added to position of FastGadget image
*+   in the BitMap destination. This field is not checked for WORD boundry
*+   alignment.
*+ APTR FastGadget:
*+   Pointer to list of FastGadgets to be processed.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget list. It is assumed
*+   that the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget list. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the first
*+   FastGadget in the specified list. It is assumed that the offset formed
*+   from this requester will be WORD boundry aligned. This pointer will be
*+   ignored if the FastGadget list is not tethered to a requester.
*+ APTR Buff:
*+   Pointer to the buffer holding the data to be placed in the display
*+   under the template areas of the FastGadget list, in the consective order
*+   of the FastGadget list. The storage is always done using DISPLAYMODE0,
*+   which guarantees that the entire background is loaded. PLEASE BE SURE
*+   that this buffer holds what is to be loaded.
*+
*+ Notes:
*+   There is no support for GIMMEZEROZERO FastGadgets or FastGadgets linked
*+   to a screen, they must be tethered to a window directly, or indirectly
*+   via a requester. Trashes D0,D1,A0,A1, and the condition codes. This
*+   function assumes EVERYTHING is in order and ready to go. Bad vibes can
*+   occur in your system if the FastGadget list specified is not a true
*+   FastGadget list, but contains one or more regular Gadgets. FastGadgets
*+   can be processed by Intuition Gadget handling functions since the Gadget
*+   structure subset will have no imagery selected, but the reverse is not
*+   true.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment.
*+
*+*******

	IFNE	_CCODE

	XDEF	_LoadFastGList
_LoadFastGList:
	SAVE	a2/a3
	movem.l	12(sp),d0/d1/a0-a3
	CALL.s	LoadFastGList
	REST	a2/a3
	rts

	ENDC

	XDEF	LoadFastGList
LoadFastGList:	; entry: Count, Offset, FastGadget, Window, Requester, Buff
*                         D0     D1      A0          A1      A2         A3
	SAVE	d2-d6/a2-a6		; save work registers
	CLEAR	d2			; assure longword usable
	move.w	wd_TopEdge(a1),d3	; form offset from window position
	mulu	#DISPLAYWIDTH/8,d3	; and add it to offset parameter
	move.w	wd_LeftEdge(a1),d2
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1
	btst.b	#4,gg_GadgetType(a0)	; are these FastGadgets tethered to a
*					; requester?
	beq.s	10$			; if not - skip on
	move.w	rq_TopEdge(a2),d3	; form additional offset from
	mulu	#DISPLAYWIDTH/8,d3	; requester position
	move.w	rq_LeftEdge(a2),d2	; and add it to offset total
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1

10$:
	move.l	wd_WScreen(a1),a1		; BitMap for this window
	lea	sc_BitMap+bm_Planes(a1),a1	; point at BitMap planes
	subq.w	#1,d0				; form FastGadget count

20$:
	lea	FG_ModeType(a0),a2	; first get placement control:
	movem.w	(a2)+,d2-d5		; type, word width, height, modulus

	move.l	(a2),d2			; offset within container

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a2/a4-a6		; destination bitplane pointers
	movem.l	(a1),a2/a4		; destination bitplane pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a2			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

30$:
	move.w	d3,d2			; setup line word counter

40$:
	move.w	(a3)+,(a2)+		; load image from buffer
	move.w	(a3)+,(a4)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	(a3)+,(a5)+
;;	move.w	(a3)+,(a6)+

	dbf	d2,40$			; reloop till a line has been done

	add.w	d5,a2			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6

	dbf	d4,30$			; reloop till all lines are done

	move.l	(a0),d2			; address next FG area to load
	beq.s	50$			; if no more - exit
	move.l	d2,a0
	dbf	d0,20$			; load another FastGadget area till
*					; count out or no more

50$:
	REST	d2-d6/a2-a6		; restore work registers
	rts

*+*******
*+
*+ DigitFastG
*+
*+ This function renders a digit into the specified imagery data of the
*+ specified FastGadget.
*+
*+ void DigitFastG( X, Y, DigitIndex, ImageTableIndex, FastGadget );
*+                  D0 D1  D2          D3               A0
*+
*+ LONG X:
*+   The low unsigned 16 bits represents the X pixel offset into the
*+   FastGadget image data where the digit is to be rendered. It is assumed
*+   and MUST be a multiple of 16.
*+ LONG Y:
*+   The low unsigned 16 bits represents the Y pixel offset into the
*+   FastGadget image data where the digit is to be rendered.
*+ LONG DigitIndex:
*+   The low unsigned 16 bits represents the binary value (0-9) of the digit
*+   that is to be rendered into the FastGadget imagery.
*+ LONG ImageTableIndex:
*+   The low unsigned 16 bits represents the binary index into the
*+   FG_PTRTable of the specified FastGadget in order to obtain the pointer
*+   to the imagery data that the digit will be rendered into.
*+ APTR FastGadget:
*+   Pointer to the FastGadget that the digit rendering will be pertinent to.
*+
*+ Notes:
*+   The digits rendered are a fixed size of 16x14. This routine DOES NOT
*+   perform validity checking or clipping via information in the specified
*+   FastGadget in any way. BE SURE that what you are doing is kosher or
*+   things may fly south in a big way. Presently the digit image data base
*+   only allows the rendering of DISPLAYMODE2 type/4 grey scale images
*+   regardless of whether you use DISPLAYMODEs 0 or 2. Unfortunately in
*+   the case of DISPLAYMODE1, the digit data will displayed as colors of a
*+   sort due to the encoding of the image data. In the case of the target
*+   FastGadget being DISPLAYMODE3, only the significant data image plane is
*+   rendered into the FastGadget imagery. Also the rendering is done in
*+   AMIGA style JAM2, no cookie cutting into the FastGadget imagery
*+   background. This function does not require a pointer to ToasterBase in
*+   A5, and therefore is not tied to interface/switcher in any way.
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing.
*+   Addendum 10/13/89:
*+
*+*******

	IFNE	_CCODE

	XDEF	_DigitFastG
_DigitFastG:
	SAVE	d2/d3
	movem.l	12(sp),d0-d3/a0
	CALL.s	DigitFastG
	REST	d2/d3
	rts

	ENDC

	XDEF	DigitFastG
DigitFastG:	; Entry X, Y, DigitIndex, ImageTableIndex, FastGadget
*                       D0 D1  D2          D3               A0

	SAVE	d2-d4			; save work registers

	add.w	d3,d3			; first get destination imagery
	add.w	d3,d3			; dataplane from FastGadget
	move.l	FG_PTRTable(a0),a1
	move.l	0(a1,d3.w),a1

	move.w	FG_WWidth(a0),d3	; get word width of FastGadget
	addq.w	#1,d3			; dataplane on the display

	add.w	d2,d2			; get pointer to source digit
	add.w	d2,d2			; dataplane
	move.l	.DigitTable(pc,d2.w),d2

	move.w	FG_ModeType(a0),d4	; get DISPLAYMODE type
	move.l	.ModeCode(pc,d4.w),a0	; get address of handler
	jmp	(a0)			; to use and jump to it

.ModeCode:
	DC.l	.Mode0			; DISPLAYMODE0 handler
	DC.l	.Mode1			; DISPLAYMODE1 handler
	DC.l	.Mode2			; DISPLAYMODE2 handler
	DC.l	.Mode3			; DISPLAYMODE3 handler

	DC.l	.Mode4			; DISPLAYMODE4 handler
	DC.l	.Mode5			; DISPLAYMODE5 handler

	DC.l	.Mode5	; DISPLAYMODE6 handler ****!!!!****

.DigitTable:
	DC.l	.Zero
	DC.l	.One
	DC.l	.Two
	DC.l	.Three
	DC.l	.Four
	DC.l	.Five
	DC.l	.Six
	DC.l	.Seven
	DC.l	.Eight
	DC.l	.Nine

.Mode5:
.Mode4:

	move.l	d2,a0	;pointer to source data
	lsl.w	#3,d3	;word width *8 =bytes per row
	mulu	d3,d1
	add.l	d1,a1	;start of first row

	lsr.w	#1,d0
	add.w	d0,a1

	moveq	#12-1,d0		; setup loop counter
	add.l	d3,a1

.Mode4Loop:
	move.w	(a0)+,(a1)
	move.w	(a0)+,2(a1)
	move.w	(a0)+,4(a1)
	move.w	(a0)+,6(a1)
	add.w	d3,a1			; modulus dest pointer to next line

	dbf	d0,.Mode4Loop		; reloop till done

	REST	d2-d4			; restore work registers
	rts




.Mode0:
	move.l	d2,a0			; get source digit dataplane pointer

*					; number actual data bytes per
*					; display bytes is 4
*					; (interleaved word data)

	lsl.w	#3,d3			; get number of data bytes per row
*					; of display words

	mulu	d3,d1			; then multiply it by the Y offset
*					; to get the byte display offset
*					; into destination FastGadget
*					; dataplane
	add.l	d1,a1			; accumulate it into dest pointer

	lsr.w	#1,d0			; form byte data X offset
	add.w	d0,a1			; form final byte data offset into
*					; destination FastGadget dataplane
*					; pointer

	moveq	#14-1,d0		; setup loop counter

	add.l	#.size-.Zero,a0

.Mode0Loop:

	move.w	(a0)+,d1		; get LSW of source digit data
	move.w	(a0)+,d2		; get MSW of source digit data

	move.w	d1,(a1)			; place source in dest
	move.w	d2,2(a1)
	move.w	d1,4(a1)
	move.w	d2,6(a1)

	add.w	d3,a1			; modulus dest pointer to next line
	dbf	d0,.Mode0Loop		; reloop till done

	REST	d2-d4			; restore work registers
	rts				; return to caller

.Mode1:		; shares with .Mode2 handler for now....
.Mode2:
	move.l	d2,a0			; get source digit dataplane pointer

*					; number actual data bytes per
*					; display bytes is 2
*					; (interleaved word data)

	lsl.w	#2,d3			; get number of data bytes per row
*					; of display words

	mulu	d3,d1			; then multiply it by the Y offset
*					; to get the byte display offset
*					; into destination FastGadget
*					; dataplane
	add.l	d1,a1			; accumulate it into dest pointer

	lsr.w	#2,d0			; form byte data X offset
	add.w	d0,a1			; form final byte data offset into
*					; destination FastGadget dataplane
*					; pointer

	moveq	#14-1,d0		; setup loop counter
	add.l	#.size-.Zero,a0

.Mode2Loop:
	move.w	(a0)+,(a1)		; LSW of source digit data into dest
	move.w	(a0)+,2(a1)		; MSW of source digit data into dest

	add.w	d3,a1			; modulus dest pointer to next line
	dbf	d0,.Mode2Loop		; reloop till done

	REST	d2-d4			; restore work registers
	rts				; return to caller

.Mode3:
	move.l	d2,a0			; get source digit dataplane pointer

*					; number actual data bytes per
*					; display bytes is

	add.w	d3,d3			; get number of data bytes per row
*					; of display words

	mulu	d3,d1			; then multiply it by the Y offset
*					; to get the byte display offset
*					; into destination FastGadget
*					; dataplane
	add.l	d1,a1			; accumulate it into dest pointer

	lsr.w	#3,d0			; form byte data X offset
	add.w	d0,a1			; form final byte data offset into
*					; destination FastGadget dataplane
*					; pointer

	moveq	#14-1,d0		; setup loop counter
	lea	2(a0),a0		; offset source digit pointer to MSW
	add.l	#.size-.Zero,a0

.Mode3Loop:
	move.w	(a0),(a1)		; MSW of source digit data into dest

	lea	4(a0),a0		; address next MSW of source digit
	add.w	d3,a1			; modulus dest pointer to next line
	dbf	d0,.Mode3Loop		; reloop till done

	REST	d2-d4			; restore work registers
	rts				; return to caller

.Zero
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,1056,63519,576
 DC.W 65535,0,61455,2064,65535,4680,57735,0,65535,1056,58311,0
 DC.W 65535,0,59367,0,65535,0,59367,0,65535,1056,58311,0
 DC.W 65535,4680,57735,0,65535,0,61455,2064,65535,1056,63519,576
 DC.W 65535,0,65535,0,65535,0,65535,0
.size
 DC.W 0,0,2032,992,3544,3640,6156,3096,4100,6156,4100,6156
 DC.W 4100,6156,4100,6156,4100,6156,4100,6156,6156,3096,3544,3640
 DC.W 2032,992,0,0

.One
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,65151,0
 DC.W 65535,1024,63615,0,65535,0,63615,1024,65535,0,65151,0
 DC.W 65535,0,65151,0,65535,0,65151,0,65535,0,65151,0
 DC.W 65535,0,65151,0,65535,0,63519,1632,65535,0,63519,0
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,384,128,896,384,1920,896,1920,1920,384,384
 DC.W 384,384,384,384,384,384,384,384,384,384,2448,2016
 DC.W 2016,4080,0,0

.Two
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,1552,63503,560
 DC.W 65535,8,61447,2504,65535,512,57831,5120,65535,5152,58311,2080
 DC.W 65535,136,65287,216,65535,528,64527,816,65535,2240,61503,2432
 DC.W 65535,4608,57855,5120,65535,0,57351,0,65535,0,57351,0
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,1512,1008,2036,3608,2584,7180,5132,6156,44,24
 DC.W 184,112,720,480,832,1920,1792,3584,7680,3072,3072,8188
 DC.W 4092,8188,0,0

.Three
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,3088,61455,1584
 DC.W 65535,4104,57351,4104,65535,0,59367,2048,65535,0,65511,0
 DC.W 65535,8,64519,0,65535,8,64519,0,65535,0,65511,0
 DC.W 65535,0,59367,2048,65535,4104,57351,4104,65535,3088,61455,1584
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,3048,2032,4092,7192,5144,6156,2056,4108,28,8
 DC.W 504,496,28,504,24,12,2060,4108,5144,6156,8188,3096
 DC.W 3048,2032,0,0

.Four
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,65439,0
 DC.W 65535,0,63903,0,65535,2048,61855,2048,65535,512,61855,512
 DC.W 65535,4096,58271,4096,65535,0,57351,0,65535,0,57351,0
 DC.W 65535,0,65439,0,65535,0,65439,0,65535,0,65439,0
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,16,48,1808,816,784,1584,3088,1584,1552,3120
 DC.W 6160,3120,4092,8188,8188,8188,16,48,16,48,16,48
 DC.W 16,48,0,0

.Five
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,57351,0
 DC.W 65535,0,57351,0,65535,0,59391,0,65535,0,59391,0
 DC.W 65535,0,57359,4112,65535,4096,57351,2056,65535,0,65511,0
 DC.W 65535,0,59367,0,65535,0,57351,4104,65535,0,61455,2064
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,8188,8188,6144,8188,4096,6144,4096,6144,6160,8160
 DC.W 8176,8184,8,28,4,12,2052,4108,5128,6172,7192,4088
 DC.W 992,2032,0,0
.Six
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,2096,61455,3168
 DC.W 65535,4104,57351,4104,65535,0,59367,16,65535,0,59391,0
 DC.W 65535,0,57359,16,65535,0,57351,8,65535,0,59367,0
 DC.W 65535,0,59367,0,65535,0,57351,4104,65535,0,61455,2064
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,752,496,832,1920,1024,3584,6144,3072,3528,7152
 DC.W 7740,8184,7176,6172,4100,6156,4100,6156,2056,7196,7740,4088
 DC.W 2504,2032,0,0
.Seven
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,57351,0
 DC.W 65535,0,57351,0,65535,32,59335,0,65535,64,65415,40
 DC.W 65535,128,65295,80,65535,256,65055,160,65535,512,64575,320
 DC.W 65535,0,64639,128,65535,0,64767,0,65535,0,64767,0
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,8188,8188,8184,8188,48,24,32,112,64,224
 DC.W 384,192,192,384,768,384,384,768,768,768,768,768
 DC.W 768,768,0,0

.Eight
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,61455,2064
 DC.W 65535,0,57351,4104,65535,0,59367,0,65535,0,59367,4104
 DC.W 65535,4104,57351,0,65535,4104,57351,0,65535,0,59367,4104
 DC.W 65535,0,59367,0,65535,0,57351,4104,65535,0,61455,2064
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,3048,2032,8188,3096,3096,6156,2056,6156,6156,3096
 DC.W 4088,2032,6156,3096,2056,6156,2056,6156,3096,6156,8188,3096
 DC.W 3048,2032,0,0

.Nine
 DC.W 65535,0,65535,0,65535,0,65535,0,65535,0,61455,2064
 DC.W 65535,0,57351,4104,65535,0,59367,0,65535,0,59367,0
 DC.W 65535,0,57351,4096,65535,0,61447,2048,65535,0,65511,0
 DC.W 65535,0,59367,2048,65535,4104,57351,4104,65535,3088,61455,1584
 DC.W 65535,0,65535,0,65535,0,65535,0

 DC.W 0,0,2504,2032,7740,4088,2056,7196,4100,6156,2076,7180
 DC.W 7740,4092,2524,2028,8,12,12,24,16,56,352,240
 DC.W 928,960,0,0


*+*******
*+
*+ DoHiLiteSelect/Q/K
*+
*+ This function encapsulates the standard normal sequence of events needed
*+ when a Toolbox FG is FGC_SELECTed.
*+
*+ LONG DoHiLiteSelect( FastGadGadget );
*+  D0                    A0
*+
*+ APTR FastGadget:
*+   Pointer to FastGadget to processed.
*+
*+ Notes:
*+   -1 is returned in D0 if your TB FG was truly selected by the user, 0 if
*+   not (because already selected).
*+   This function trashes D1,A0,A1. The condition codes are set
*+   according to the result in D0. This function requires that A5 points to
*+   ToasterBase.
*+
*+ For 4.0,
*+ I removed the relvarify version DoHiLiteSelect(),
*+ and the rendering versions DoHiLiteSelect() & DoHiLiteSelectK
*+ Because relvarify is handled by the Editor, and the switcher is
*+ unable to do any toolbox rendering.
*+
*+*******


	XDEF	DoHiLiteSelectQ,DoHiLiteSelect,DoHiLiteSelectK

DoHiLiteSelect
DoHiLiteSelectK
DoHiLiteSelectQ:	; entry: FastGadget
*				  A0
	SAVE1	a3
	move.l	a0,a3

	cmp.l	TB_EfxFG(a5),a3		; ignore if user selecting already
	bne.s	.Selected		; selected FastGadget - no select

	REST1	a3			; no select -
	CLEAR	d0			; D0=0 - Z flag set
	rts

.Selected:
	GET.l	TB_EfxFG,d0		; is there another FastGadget
*					; currently selected and active?
	beq.s	.NoDeSelect		; if not - skip the following

	move.l	d0,a0			; code routine to call?
	bsr	FGC_RemoveCommand

.NoDeSelect:
	DEBUGHEXI.l DBDHLS,<DoHiLiteSelect/Q/K FG=>,a3,<\>

	PUT.l	a3,TB_EfxFG		; install ourselves

	REST1	a3			; selected -
	moveq	#-1,d0			; D0=-1 - Z flag reset
	rts

*+*******
*+
*+ DoHiLiteRemove/Q
*+
*+ This functions encapsulates the standard normal sequence of events needed
*+ when a ToolBox FG is FGC_REMOVEed.
*+
*+ void DoHiLiteRemove( FastGadget );
*+                        A0
*+
*+ APTR FastGadget:
*+   Pointer to FastGadget to processed.
*+
*+ Notes:
*+   Trashes only the condition codes. Nothing is returned. A
*+   pointer to ToasterBase is not required in A5.
*+
*+ For 4.0, I removed the DoHiLiteRemove() version which did
*+ rendering.  This is now handled by the Editor.
*+
*+*******

	XDEF	DoHiLiteRemoveQ,DoHiLiteRemove

DoHiLiteRemove:
DoHiLiteRemoveQ:	; entry: FastGadget
*				  A0
	clr.w	FG_HiLiteMask(a0)	; denote normal imagery to be used
	rts

*----------------------------------------
* Stuff TB_FCountSec, TB_FCountModeSec, FGS_NumFields based on FGS values.
* a3->FG, a5->TB
* Assumes current FGS speeds/modes are legal (not Locked out)!!!
* ANIM FXs call another routine after this one, to fix FSG_NumFields

	XDEF	StuffFCount

StuffFCount
	movem.l	d0-d5/a0,-(sp)

	clr.w	TB_HasSoundSec(a5)	;After Select or FCount has been
					;processed, a crouton may then
					;indicate a sound as being present.
	movea.l	a3,a0	;->FG
	move.l	#TAGID_FCountMode,d0

	DEBUGMSG DBSFC,<Before GetLongValue1>

	bsr	GetLongValue
	move.w	d0,d1
	andi.w	#3,d1
	PUT.w	d1,TB_FCountModeSec	;defaults to medium if not found

	move.l	#TAGID_SlowFCount,d2
	move.l	#TAGID_MedFCount,d3
	move.l	#TAGID_FastFCount,d4
	move.l	#TAGID_VariableFCount,d5

	bsr	AreWeFast
	bne.s	5$			; If 68020/68030/68040, Default Speed.

* running on 68000
	move.l	#TAGID_SlowFCount68000,d2
	move.l	#TAGID_MedFCount68000,d3
	move.l	#TAGID_FastFCount68000,d4
	move.l	#TAGID_VariableFCount68000,d5

5$	move.l	d2,d0		;assume Slow
	cmpi.w	#FCountMode_Slow,d1
	beq.s	10$

	move.l	d3,d0		;assume Medium
	cmpi.w	#FCountMode_Medium,d1
	beq.s	10$

	move.l	d4,d0		;assume Fast
	cmpi.w	#FCountMode_Fast,d1
	beq.s	10$

* default to variable
	move.l	d5,d0		;assume Variable

10$	movea.l	a3,a0	;->FG

	DEBUGMSG DBSFC,<Before GetLongValue2>

	bsr	GetLongValue	;assumes speed is not "Locked" out!!!

 ;;	PUT.w	d0,TB_FCountPri
	PUT.w	d0,TB_FCountSec

	move.l	d0,d1
	move.l	#TAGID_NumFields,d0
	bsr	PutLongValue

*------
	move.l	d5,d0

	DEBUGMSG DBSFC,<Before GetLongValue3>

	bsr	GetLongValue
	lsl.w	#2,d0
	or.w	d0,TB_FCountModeSec(a5)

666$	movem.l	(sp)+,d0-d5/a0
	rts

*----------------------------------------
* a3->FG, a5->TB
* ANIM FXs call another routine after this one, to fix TB_NumFrames...
	XDEF	StuffNumFrames

StuffNumFrames
	movem.l	d0/d2-d5/a0,-(sp)

	move.l	#TAGID_FastFCount,d2
	move.l	#TAGID_MedFCount,d3
	move.l	#TAGID_SlowFCount,d4
	move.l	#TAGID_VariableFCount,d5

	bsr	AreWeFast
	bne.s	5$			; If 68020/68030/68040, Default Speed.

* running on 68000
	move.l	#TAGID_FastFCount68000,d2
	move.l	#TAGID_MedFCount68000,d3
	move.l	#TAGID_SlowFCount68000,d4
	move.l	#TAGID_VariableFCount68000,d5

5$	movea.l	a3,a0	;->FG

*** Count of 0 = Lock this speed out
*** If bit 15 is set of TB_NumFrames...., then this setting LOOPs
*** Currently, only ANIM code will ever set bit 15.

*------
;;;	move.w	FGS_SlowFCount(a3),d0
	move.l	d4,d0

	DEBUGMSG DBSNF,<Before GetLongValue1>

	bsr	GetLongValue

	addq.w	#1,d0			;round up to nearest frame
	lsr.w	#1,d0
	PUT.w	d0,TB_NumFramesSlow

	move.l	d0,d1
	move.l	#TAGID_NumFramesSlow,d0
	CALLTL	PutLongValue

*------
;;;	move.w	FGS_MedFCount(a3),d0
	move.l	d3,d0

	DEBUGMSG DBSNF,<Before GetLongValue2>

	bsr	GetLongValue

	addq.w	#1,d0
	lsr.w	#1,d0
	PUT.w	d0,TB_NumFramesMedium

	move.l	d0,d1
	move.l	#TAGID_NumFramesMedium,d0
	CALLTL	PutLongValue

*------
;;;	move.w	FGS_FastFCount(a3),d0
	move.l	d2,d0

	DEBUGMSG DBSNF,<Before GetLongValue3>

	bsr	GetLongValue

	addq.w	#1,d0			;round up to nearest frame
	lsr.w	#1,d0
	PUT.w	d0,TB_NumFramesFast

	move.l	d0,d1
	move.l	#TAGID_NumFramesFast,d0
	CALLTL	PutLongValue

*------
;;;	move.w	FGS_VariableFCount(a3),d0
	move.l	d5,d0

	DEBUGMSG DBSNF,<Before GetLongValue4>

	bsr	GetLongValue

	addq.w	#1,d0			;round up to nearest frame
	lsr.w	#1,d0
	PUT.w	d0,TB_NumFramesVariable

	move.l	d0,d1
	move.l	#TAGID_NumFramesVariable,d0
	CALLTL	PutLongValue

	movem.l	(sp)+,d0/d2-d5/a0
	rts

*--------------------------
	XDEF	AreWeFast
* Returns NE=68020/68030/68040, EQ=68000
AreWeFast
	movem.l	d0/a0,-(sp)
	GET.l	TB_SYSBase,a0
	move.w	AttnFlags(a0),D0	; Check For Processor Speed.
	btst.l	#AFB_68020,D0		; Do They Have an 68020 or Better?
	movem.l	(sp)+,d0/a0
	rts

*+*******
*+
*+ DiskDeviceList
*+
*+ This function obtains for the caller the resident disk type devices found
*+ in the system.
*+
*+ void DiskDeviceList( Container );
*+                       A0
*+
*+ APTR Container:
*+   Pointer to the buffer to contain the disk device name list.
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. Requires
*+   a pointer to ToasterBase in A5, but otherwise is not tied closely with
*+   the Switcher display. The storage of the disk type device names in the
*+   Container buffer is a hybrid of BSTRs and C strings. Starting at the
*+   beginning of the buffer each entry device name is its BSTR name followed
*+   by a NULL byte. The end of the list is denoted when the expected leading
*+   BSTR count byte is instead NULL. NOTE: NO CHECKING is performed as to
*+   exceeding the container buffer with device names, so make sure you have
*+   plenty.
*+
*+ Addendum 1/12/90:
*+
*+ Addition notes:
*+   This routine now filters out floppy drives that appear in the device
*+   list, but in fact do not really exist.
*+
*+ Addendum 2/14/90:
*+ Addendum 4/25/91:
*+   Complete overhaul so that access to sensitive DOS lists are done under
*+   proper exclusion. Uses the ToasterBase file buffer area as an
*+   intermediate storage area of DOS nodes. At last recollection, this
*+   buffer was 4K in size and therefore will be able to store 4K/4-1 DOS
*+   node addresses. There is NO CHECKING for file buffer overflow.
*+
*+*******

	IFNE	_CCODE

	XDEF	_DiskDeviceList
_DiskDeviceList:
	move.l	4(sp),a0
	SAVE1	a5
	lea	_ToasterBase
	CALL.s	DiskDeviceList
	REST1	a5
	rts

	ENDC

	XDEF	DiskDeviceList
DiskDeviceList:	; entry: Container
*			  A0
	SAVE	d2/a2-a4/a6

	move.l	a0,a4			; get container pointer in safe reg

	GET.l	TB_SYSBase,a6		; keep to ourselves
	CALLROM	Forbid

	GET.l	TB_FileBuff,a1		; address recipient buffer area

	GET.l	TB_DOSBase,a6		; get DevInfo list
	move.l	dl_Root(a6),a0
	move.l	rn_Info(a0),a0
	add.l	a0,a0
	add.l	a0,a0
	move.l	di_DevInfo(a0),d0
	bne.s	.Loop			; jump if we have a DevInfo list

	GET.l	TB_SYSBase,a6		; else no DevInfo - restore tasking
	CALLROM	Permit

	bra	.Exit			; exodus...

.Loop:
	lsl.l	#2,d0			; get BCPL pointer to DevInfo
	move.l	d0,a0			; into a normal pointer
	cmp.l	#DLT_DEVICE,dol_Type(a0)	; struct for a device?
	bne.s	.SkipIt				; if not - skip this one

	tst.l	dol_Task(a0)		; a resident Task? - disk devices are
*					; assumed to always have this
	beq.s	.SkipIt			; if not - skip this one

	move.l	a0,(a1)+		; a valid candidate DevInfo -
*					; save for later interagation

.SkipIt:
	move.l	(a0),d0			; get next DevInfo - if any
	bne.s	.Loop

	move.l	d0,(a1)			; mark end of the itermediate list

	GET.l	TB_SYSBase,a6		; restore tasking
	CALLROM	Permit

	GET.l	TB_DOSBase,a6		; get DOSBase again
	GET.l	TB_FileBuff,a2		; address DevInfo list
	bra.s	.Continue		; jump into loop

.BuffLoop:
	move.l	d0,a0			; address DevInfo node
	move.l	dol_Name(a0),a0		; get device name
	add.l	a0,a0
	add.l	a0,a0
	move.l	a4,a3			; now place device name in list -
*					; but remember the start so we can
*					; clean it off if we have to
	CLEAR	d0
	move.b	(a0)+,d0
	move.b	d0,d2			; save a copy of the count
	addq.b	#1,d0
	move.b	d0,(a4)+		; place the name char count which
*					; also includes a ":"
	subq.w	#2,d0

.CopyLoop:
	move.b	(a0)+,d1		; copy the device name - assure
	cmp.b	#'a',d1			; upper case
	bcs.s	10$
	cmp.b	#'z'+1,d1
	bcc.s	10$
	and.b	#$DF,d1
10$:
	move.b	d1,(a4)+
	dbf	d0,.CopyLoop

	move.b	#':',(a4)+		; place colon
	clr.b	(a4)+			; and NULL terminator

	cmp.b	#3,d2			; test for devices DF0-DF3 - always
*					; placed in list if they really exist
	bne.s	.DoNextTest
	cmp.b	#'D',1(a3)
	bne.s	.DoNextTest
	cmp.b	#'F',2(a3)
	bne.s	.DoNextTest
	move.b	3(a3),d0
	sub.b	#'0',d0
	cmp.b	#4,d0
	bcc.s	.DoNextTest

	btst.b	d0,TB_FloppyAlloc+1(a5)	; test if floppy drive really exists
	bne.s	.ValidDevice		; if so - jump to it
	bra.s	.InvalidDevice		; else floppy device doesn't exist

.DoNextTest:
	move.l	a3,d1
	addq.l	#1,d1
	move.l	#ACCESS_READ,d2
	CALLROM	Lock			; attempt to lock the device - only
*					; devices that have a filing system
*					; will allow this
	move.l	d0,d1
	bne.s	.OK

.InvalidDevice:
	move.l	a3,a4			; if not a disk type device - remove
*					; the device name from the list
	bra.s	.Continue

.OK:
	CALLROM	UnLock

.ValidDevice:
.Continue:
	move.l	(a2)+,d0		; get next DevInfo node - if any
	bne	.BuffLoop

.Exit:
	clr.b	(a4)			; denote list end
	REST	d2/a2-a4/a6
	rts

*+*******
*+
*+ BSTRcmp
*+
*+ This function compares two BCPL strings.
*+
*+ LONG BSTRcmp( BSTR1, BSTR2 );
*+                A0     A1
*+
*+ APTR BSTR1:
*+   Pointer to a BCPL string.
*+ APTR BSTR2:
*+   Pointer to a BCPL string.
*+
*+ Notes:
*+   This function alters only D0. Returns 1,0,-1 in D0 for
*+   BSTR1 > BSTR2, BSTR1 = BSTR2, and BSTR1 < BSTR2 respectively. The
*+   condition codes are set according to the results in D0. Does not require
*+   a pointer to ToasterBase and is not tied closely to the Switcher
*+   display.
*+
*+ Addendum 1/14/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BSTRcmp
_BSTRcmp:
	movem.l	4(sp),a0/a1

	ENDC

	XDEF	BSTRcmp
BSTRcmp:	; entry: BSTR1, BSTR2
*			  A0     A1
	SAVE	d1-d3/a0/a1
	CLEAR	d3
	move.b	(a0)+,d0
	move.b	(a1)+,d1
	move.b	d0,d3
	cmp.b	d1,d0
	bls.s	.OK
	move.b	d1,d3

.OK:
	subq.w	#1,d3

.Loop:
	move.b	(a0)+,d2
	cmp.b	(a1)+,d2
	dbne	d3,.Loop
	bmi.s	.1.LT.2
	bne.s	.1.GT.2
	cmp.b	d1,d0
	bmi.s	.1.LT.2
	bne.s	.1.GT.2

	CLEAR	d0
	REST	d1-d3/a0/a1
	rts

.1.LT.2:
	moveq	#-1,d0
	REST	d1-d3/a0/a1
	rts

.1.GT.2:
	moveq	#1,d0
	REST	d1-d3/a0/a1
	rts

*+*******
*+
*+ STRcmp
*+
*+ This function compares two C type strings.
*+
*+ LONG STRcmp( STR1, STR2 );
*+               A0    A1
*+
*+ APTR STR1:
*+   Pointer to a C type string.
*+ APTR STR2:
*+   Pointer to a C type string.
*+
*+ Notes:
*+   This function alters only D0. Returns 1,0,-1 in D0 for STR1 > STR2,
*+   STR1 = STR2, and STR1 < STR2 respectively. The condition codes are
*+   set according to the results in D0. Does not require a pointer to
*+   ToasterBase and is not tied closely to the Switcher display.
*+
*+ Addendum 1/14/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_STRcmp
_STRcmp:
	movem.l	4(sp),a0/a1

	ENDC

	XDEF	STRcmp
STRcmp:	; entry: STR1, STR2
*		  A0    A1
	SAVE	d1/a0/a1

.Loop:
	move.b	(a0)+,d0
	move.b	(a1)+,d1
	cmp.b	d1,d0
	bmi.s	.1.LT.2
	bne.s	.1.GT.2
	or.b	d0,d1
	bne.s	.Loop

	CLEAR	d0
	REST	d1/a0/a1
	rts

.1.LT.2:
	moveq	#-1,d0
	REST	d1/a0/a1
	rts

.1.GT.2:
	moveq	#1,d0
	REST	d1/a0/a1
	rts

*+*******
*+
*+ STRlen
*+
*+ This function returns the length of a C type string not including the
*+ NULL terminator.
*+
*+ LONG STRlen( STR );
*+               A0
*+
*+ APTR STR:
*+   Pointer to a C type string.
*+
*+ Notes:
*+   This function alters only D0 and the condition codes. D0 is returned
*+   with length of the STR. Does not require a pointer to ToasterBase and is
*+   not tied closely to the Switcher display.
*+
*+ Addendum 1/14/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_STRlen
_STRlen:
	move.l	4(sp),a0

	ENDC

	XDEF	STRlen
STRlen:	; entry: STR
*		  A0
	SAVE1	a0
	CLEAR	d0

.Loop:
	addq.w	#1,d0
	tst.b	(a0)+
	bne.s	.Loop

	subq.w	#1,d0
	REST1	a0
	rts

*+*******
*+
*+ ByteSubSet
*+
*+ This function merely compares two sequential byte streams for the count
*+ indicated.
*+
*+ LONG ByteSubSet( Count, ByteSeq1, ByteSeq2 );
*+                   D0     A0        A1
*+
*+ APTR ByteSeq1:
*+   Pointer to a sequence of bytes to be tested.
*+ APTR ByteSeq2:
*+   Pointer to a sequence of bytes to be tested.
*+
*+ Notes:
*+   This function alters only D0. Returns 0,-1 in D0 for ByteSeq1 = ByteSeq2
*+   and ByteSeq1 <> ByteSeq2 respectively. The condition codes are
*+   set according to the results in D0. Does not require a pointer to
*+   ToasterBase and is not tied closely to the Switcher display.
*+
*+ Addendum 1/15/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_ByteSubSet
_ByteSubSet:
	movem.l	4(sp),d0/a0/a1

	ENDC

	XDEF	ByteSubSet
ByteSubSet:	; entry: Count, ByteSeq1, ByteSeq2
*			  D0     A0        A1
	SAVE	d1/a0/a1
	subq.w	#1,d0

.Loop:
	move.b	(a0)+,d1
	cmp.b	(a1)+,d1
	dbne	d0,.Loop
	bne.s	.NotEqual

	CLEAR	d0
	REST	d1/a0/a1
	rts

.NotEqual:
	moveq	#-1,d0
	REST	d1/a0/a1
	rts
*********************************************
	XDEF	UpDateFC
UpDateFC
	rts
*********************************************
*+*******
*+
*+ DrawFastGList
*+
*+ This function uses the 680X0 processor to render the images of a list of
*+ FastGadget structures, which are a superset mutation of a Gadget
*+ structure.
*+
*+ void DrawFastGList( Count, Offset, FastGadget, Window, Requester );
*+                      D0     D1      A0          A1      A2
*+
*+ LONG Count:
*+   Low unsigned 16 bits are used as a maximum count of FastGadget
*+   structures to render. Zero denotes a count of 65536.
*+ LONG Offset:
*+   Caller specified byte offset to be added to position of FastGadget image
*+   in the BitMap destination. This field is not checked for WORD boundry
*+   alignment.
*+ APTR FastGadget:
*+   Pointer to list of FastGadgets to be rendered.
*+ APTR Window:
*+   Pointer to the window that contains the FastGadget list. It is assumed
*+   that the offset formed from this window will be WORD boundry aligned.
*+ APTR Requester:
*+   Pointer to the requester that contains the FastGadget list. Valid only
*+   if the REQGADGET bit is set in gg_GadgetType field of the first
*+   FastGadget in the specified list. It is assumed that the offset formed
*+   from this requester will be WORD boundry aligned. This pointer will be
*+   ignored if the FastGadget list is not tethered to a requester.
*+
*+ Notes:
*+   There is no support for GIMMEZEROZERO FastGadgets or FastGadgets linked
*+   to a screen, they must be tethered to a window directly, or indirectly
*+   via a requester. Trashes D0,D1,A0,A1, and the condition codes. This
*+   function assumes EVERYTHING is in order and ready to go. Bad vibes can
*+   occur in your system if the FastGadget list specified is not a true
*+   FastGadget list, but contains one or more regular Gadgets. FastGadgets
*+   can be processed by Intuition Gadget handling functions since the Gadget
*+   structure subset will have no imagery selected, but the reverse is not
*+   true.
*+
*+   For this function, it is not a neccessity to have A5 pointing to the
*+   ToasterBase structure. This function can be used outside of the
*+   interface/switcher setup environment.
*+
*+ Addendum:
*+ (8/9/89)
*+   This function will now render a FastGadget only if its FG_DispFlag
*+   flag is NULL. If a FastGadget is not rendered due to the FG_DispFlag
*+   being non-NULL, it still is counted and pertinent to the Count
*+   parameter specified.
*+
*+ Addendum 11/6/89:
*+   This function now has the capacity to render special hi-lighting info
*+   along with the actual FastGadget imagery using the mask value of the
*+   FastGadget flag FG_HiLiteMask, if it is not 0. The word mask value is
*+   processed into the display along with the FastGadget imagery.
*+   (ONLY if not 0)
*+
*+ Addendum 1/24/90:
*+   This function now has the capability to perform border masking on all
*+   4 sides of the imagery to be rendered. This mode is invoked only when
*+   FG_HiLiteMask is non-0 AND FG_BorderCon is non-0. Therefore the only
*+   time border masking can be in effect is when the imagery is to be
*+   HiLited.
*+
*+ Addendum 12/6/90:
*+   Added a check of the new TB_Flags field to see if the IMAGERY_ONOFF_BIT
*+   is set. If set, this routine will not render.
*+
*+*******

	IFNE	_CCODE

	XDEF	_DrawFastGList
_DrawFastGList:
	SAVE1	a2
	movem.l	8(sp),d0/d1/a0-a2
	CALL.s	DrawFastGList
	REST1	a2
	rts

	ENDC

	XDEF	DrawFastGList
DrawFastGList:	; Count, Offset, FastGadget, Window, Requester
*                  D0     D1      A0          A1      A2
	SAVE1	a6
	lea	_ToasterBase,a6


	btst.b	#4,TB_DisplayRenderMode(a5)	;are we in sequence
	bne.s	.norender
	btst.b	#6,TB_DisplayRenderMode(a5)	;jump if editor controls bottom half
	bne.s	.norender

	tst.b	TB_Flags(a6)		; Addendum 12/7/90: check master
*					; render flag
	bpl.s	.OK_GO			; if rendering enabled....
.norender
	REST1	a6
	rts				; quick return if disabled

a1ptr	set	(6*4)+4
.OK_GO:
	SAVE	d2-d7/a1-a5		; save work registers
	CLEAR	d2			; assure longword usable
	move.w	wd_TopEdge(a1),d3	; form offset from window position
	mulu	#DISPLAYWIDTH/8,d3	; and add it to offset parameter
	move.w	wd_LeftEdge(a1),d2
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1
	btst.b	#4,gg_GadgetType(a0)	; are these FastGadgets tethered to a
*					; requester?
	beq.s	10$			; if not - skip on
	move.w	rq_TopEdge(a2),d3	; form additional offset from
	mulu	#DISPLAYWIDTH/8,d3	; requester position
	move.w	rq_LeftEdge(a2),d2	; and add it to offset total
	lsr.w	#3,d2
	add.l	d2,d1
	add.l	d3,d1

10$:
	move.l	wd_WScreen(a1),a1		; BitMap for this window
	lea	sc_BitMap+bm_Planes(a1),a1	; point at BitMap planes
	subq.w	#1,d0				; form FastGadget count

GadgetRenderLoop:

	lea	NormTab,a3

	tst.b	FG_DispFlag(a0)		; FastGadget enabled for display?
	bne.s	.NextGadget		; if not - skip on
	lea	FG_ModeType(a0),a2	; first get placement control:
	movem.w	(a2)+,d2-d5		; type, word width, height, modulus
	tst.w	ABS_TB_Hilightoff
	bne.s	.normalrender		;global hilight off

	move.w	FG_HiLiteMask(a0),d7	; (Addendum 11/6/89:) get HiLite mask
	beq.s	.normalrender
	lea	HiLiteTab,a3		;select hilite functions

	tst.w	FG_BorderCon(a0)
	beq.s	.normalrender
	lea	HiLiteMaskTab,a3

.normalrender

;;	btst.b	#7,TB_DisplayRenderMode(a5)	;if project edit running do
;;	beq.s	1$				;not render display mode 5
	cmp.w	#DISPLAYMODE6,d2	;*****!!!!*****
	bge.s	.NextGadget
1$
	move.l	0(a3,d2.w),a3		; based on Mode display type -
	jsr	(a3)			; jump to appropriate render routine

.NextGadget
	move.l	(a0),d2			; address next FastGadget to render
	move.l	d2,a0
	dbeq	d0,GadgetRenderLoop	; render another FastGadget till
					; count out or no more

	REST	d2-d7/a1-a6		; restore work registers
	rts

	CNOP	0,4			; assure longword alignment

NormTab:
	DC.l	100$			; mode 0
	DC.l	200$			; mode 1
	DC.l	300$			; mode 2
	DC.l	400$			; mode 3
	DC.l	500$			; mode 4
	DC.l	600$			; mode 5

	DC.l	600$			; mode 6  DISPLAYMODE6 ***!!!***


*****************************************************************************
*----	mode 0
100$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

110$:
	move.w	d3,d2			; setup line word counter

120$:
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
	addq.w	#4,a2	;HACK SKELL 9/18/92
;;	move.w	(a2)+,(a5)+
;;	move.w	(a2)+,(a6)+

	dbf	d2,120$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	dbf	d4,110$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	125$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

125$	rts

*****************************************************************************
*----	mode 1
200$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

210$:
	move.w	d3,d2			; setup line word counter

220$:
	move.w	(a2),(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
	addq.w	#2,a2	;HACK SKELL 9/18/92
;;	move.w	(a2),(a5)+
;;	move.w	(a2)+,(a6)+
	dbf	d2,220$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	dbf	d4,210$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	225$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

225$	rts

*****************************************************************************
*----	mode 2
300$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

310$:
	move.w	d3,d2			; setup line word counter

320$:

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
	move.w	(a2)+,(a3)+		; place image into bitplanes
;;	move.w	(a2),(a3)+		; place image into bitplanes

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
	move.w	(a2)+,(a4)+
;;	move.w	(a2)+,(a5)+
;;	move.w	(a2),(a4)+
;;	move.w	(a2)+,(a6)+

	dbf	d2,320$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	dbf	d4,310$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	325$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

325$	rts

*****************************************************************************
*----	mode 3
400$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

410$:
	move.w	d3,d2			; setup line word counter

420$:
	move.w	(a2)+,d6		; place image into bitplanes
	move.w	d6,(a3)+
	move.w	d6,(a4)+

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+

	dbf	d2,420$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	dbf	d4,410$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	425$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

425$	rts


	IFD	AACHIPS
*****************************************************************************
*	Mode 4

500$	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers
	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

510$:	move.w	d3,d2			; setup line word counter
520$:
	move.w	(a2)+,d7			;mask
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+		; place image into bitplanes
	move.w	(a2)+,(a5)+		; place image into bitplanes

	dbf	d2,520$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,510$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	525$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

525$	rts


*****************************************************************************
*	Mode 5

600$	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers
	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

610$:	move.w	d3,d2			; setup line word counter
620$:
	move.w	(a2)+,d7			;mask
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+		; place image into bitplanes
	clr.w	(a5)+

	dbf	d2,620$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,610$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	625$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

625$	rts
	endc

	IFND	AACHIPS
*****************************************************************************
*	Mode 4

500$	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers
	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

510$:	move.w	d3,d2			; setup line word counter
520$:
	move.w	(a2)+,d7			;mask
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+		; place image into bitplanes
;	move.w	(a2)+,(a5)+		; place image into bitplanes
	addq.l	#2,a2
	dbf	d2,520$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,510$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	525$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

525$	rts


*****************************************************************************
*	Mode 5

600$	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers
	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

610$:	move.w	d3,d2			; setup line word counter
620$:
	move.w	(a2)+,d7			;mask
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+		; place image into bitplanes
;	clr.w	(a5)+

	dbf	d2,620$			; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5
	dbf	d4,610$			; reloop till all lines are done

	btst.b	#TRIMARK_BIT,FG_Flags1(a0)
	beq.s	625$
	move.l	a1,-(sp)
	movea.l	a1ptr+4(sp),a1		;window
	movea.l	a1ptr+8(sp),a2		;requester
	bsr	DrawTriMark
	movea.l	(sp)+,a1

625$	rts
	endc







	CNOP	0,4			; assure longword alignment
HiLiteTab:
	DC.l	1000$			; mode 0
	DC.l	2000$			; mode 1
	DC.l	3000$			; mode 2
	DC.l	4000$			; mode 3
	DC.l	5000$			; mode 4
	DC.l	6000$			; mode 5

	DC.l	6000$			; mode 6 DISPLAYMODE6

*****************************************************************************
*----	mode 0
1000$:
	move.l	d0,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	1005$
	exg.l	d1,d7

1005$:
	moveq	#1,d0
	and.w	d2,d0

1100$:
	move.w	d3,d2			; setup line word counter

1200$:
	move.w	(a2)+,d6
	eor.w	d7,d6
	move.w	d6,(a3)+
	move.w	(a2)+,d6
	eor.w	d7,d6
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a6)+
	dbf	d2,1200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	eor.w	#1,d0
	bne.s	1250$
	exg.l	d1,d7
1250$:
	dbf	d4,1100$		; reloop till all lines are done

	move.l	(sp)+,d0
	rts

*****************************************************************************
*----	mode 1
2000$:
	move.l	d0,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	2005$
	exg.l	d1,d7

2005$:
	moveq	#1,d0
	and.w	d2,d0

2100$:
	move.w	d3,d2			; setup line word counter

2200$:
	move.w	(a2)+,d6
	eor.w	d7,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+
	dbf	d2,2200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	eor.w	#1,d0
	bne.s	2250$
	exg.l	d1,d7
2250$:
	dbf	d4,2100$		; reloop till all lines are done

	move.l	(sp)+,d0
	rts

*****************************************************************************
*----	mode 2

3000$:
	move.l	d0,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	3005$
	exg.l	d1,d7

3005$:
	moveq	#1,d0
	and.w	d2,d0

3100$:
	move.w	d3,d2			; setup line word counter

	SAVE1	d0

3200$:
	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d7,d6
	move.w	d6,(a3)+
	eor.w	d1,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a5)+

	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d7,d6
	move.w	d6,(a4)+
	eor.w	d1,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a6)+
	dbf	d2,3200$		; reloop till a line has been done

	REST1	d0

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	eor.w	#1,d0
	bne.s	3250$
	exg.l	d1,d7
3250$:
	dbf	d4,3100$		; reloop till all lines are done

	move.l	(sp)+,d0
	rts

*****************************************************************************
*----	mode 3

4000$:
	move.l	d0,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	4005$
	exg.l	d1,d7

4005$:
	moveq	#1,d0
	and.w	d2,d0

4100$:
	move.w	d3,d2			; setup line word counter

4200$:
	move.w	(a2),d6
	eor.w	d7,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+
	dbf	d2,4200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	eor.w	#1,d0
	bne.s	4250$
	exg.l	d1,d7
4250$:
	dbf	d4,4100$		; reloop till all lines are done

	move.l	(sp)+,d0
	rts

	IFD	AACHIPS
*****************************************************************************
*----	mode 4

5000$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

5100$:
	move.w	d3,d2			; setup line word counter
5200$:
	move.w	(a2)+,d7		;mask

	move.w	(a2)+,d6
	move.w	d6,(a3)+		;lsb
	move.w	(a2)+,d6
	move.w	d6,(a4)+		;msb
	move.w	(a2)+,d6
	move.w	d7,(a5)+		;mask is msb

	dbf	d2,5200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,5100$		; reloop till all lines are done
	rts

*****************************************************************************
*----	mode 5

6000$:
	move.l	d0,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

6100$:
	move.w	d3,d2			; setup line word counter

	SAVE1	d0

6200$:
	move.w	(a2)+,d7			;mask
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+		; place image into bitplanes
	move.w	d7,(a5)+

	dbf	d2,6200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,6100$		; reloop till all lines are done

	move.l	(sp)+,d0
	rts

	endc

	IFND	AACHIPS
*****************************************************************************
*----	mode 4

5000$:
	movem.l	d0-d1,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

5100$:

	move.w	d3,d2			; setup line word counter
5200$:
;	move.w	(a2)+,d7		;mask
;	move.w	(a2)+,d6
;	move.w	d6,(a3)+		;lsb
;	move.w	(a2)+,d6
;	move.w	d6,(a4)+		;msb
;	move.w	(a2)+,d6
;	move.w	d7,(a5)+		;mask is msb

;	move.l	(a2)+,d7		;mask and low
;	swap.w	d7
;	not.w	d7
;	move.w	(a2)+,d6		;Hi
;	or.w	d7,d6
;	move.w	d6,(a3)+		;lsb
;	not.w	d7
;	swap.w	d7
;	eor.w	d7,d6
;	swap.w	d7
;	and.w	d7,d6
;	move.w	d6,(a4)+		;msb


	move.w	(a2)+,d7		;Mask
	move.w	d7,d6
	not.w	d6			;Not Mask
	move.l	(a2)+,d0
	move.l	d0,d1
	and.w	d6,d1
	swap.w	d1
	and.w	d6,d1			;plane1 and not mask
	and.w	d7,d0
	or.w	d0,d1
	move.w	d1,(a3)+		;write Plane 1
	swap.w	d1			;plane2 and not mask
	move.w	d0,d6
	swap.w	d0
	eor.w	d6,d0
	and.w	d7,d0
	or.w	d1,d0
	move.w	d0,(a4)+

	addq.w	#2,a2

	dbf	d2,5200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,5100$		; reloop till all lines are done
	movem.l	(sp)+,d0-d1
	rts

*****************************************************************************
*----	mode 5

6000$:
	movem.l	d0-d1,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

6100$:
	move.w	d3,d2			; setup line word counter

6200$:
;	move.w	(a2)+,d7			;mask
;	move.w	(a2)+,(a3)+		; place image into bitplanes
;	move.w	(a2)+,(a4)+		; place image into bitplanes
;	move.w	d7,(a5)+

;	move.l	(a2)+,d7		;mask and low
;	swap.w	d7
;	not.w	d7
;	move.w	(a2)+,d6		;Hi
;	or.w	d7,d6
;	move.w	d6,(a3)+		;lsb
;	not.w	d7
;	swap.w	d7
;	eor.w	d7,d6
;	swap.w	d7
;	and.w	d7,d6
;	move.w	d6,(a4)+		;msb


	move.w	(a2)+,d7			;Mask
	move.w	d7,d6
	not.w	d6			;Not Mask
	move.l	(a2)+,d0
	move.l	d0,d1
	and.w	d6,d1
	swap.w	d1
	and.w	d6,d1			;plane1 and not mask
	and.w	d7,d0
	or.w	d0,d1
	move.w	d1,(a3)+		;write Plane 1
	swap.w	d1			;plane2 and not mask
	move.w	d0,d6
	swap.w	d0
	eor.w	d6,d0
	and.w	d7,d0
	or.w	d1,d0
	move.w	d0,(a4)+

	dbf	d2,6200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,6100$		; reloop till all lines are done

	movem.l	(sp)+,d0-d1
	rts

	endc




	CNOP	0,4			; assure longword alignment
HiLiteMaskTab:
	DC.l	10000$			; mode 0
	DC.l	20000$			; mode 1
	DC.l	30000$			; mode 2
	DC.l	40000$			; mode 3
	DC.l	5000$			; mode 4
	DC.l	6000$			; mode 5

	DC.l	6000$			; mode 6 DISPLAYMODE6

*----	mode 0
10000$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets so far

	SAVE	d0/d1/a1		; save some extras for use

	move.w	FG_TopSize(a0),d0	; get new line count in d4
	sub.w	d0,d4
	sub.w	FG_BotSize(a0),d4

	mulu	#DISPLAYWIDTH/8,d0	; start fixing width count in d3
	CLEAR	d1			; and get total offset in d2
	move.w	FG_LeftWSize(a0),d1
	sub.w	d1,d3
	add.w	d1,d1
	add.l	d1,d0
	add.l	d0,d2

	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	FG_RightWSize(a0),d0	; finish up width count in d3
	sub.w	d0,d3			; and get bitplane modulus in d5
	add.w	d0,d0
	add.w	d1,d0
	add.w	d0,d5

	add.w	d0,d0	; mode dependent
	add.w	d0,d0	; mode dependent
	move.w	d0,a1			; get data modulus in a1

	move.w	FG_WWidth(a0),d0	; get data offset in a2
	addq.w	#1,d0
	add.w	d0,d0
	move.w	d0,-(sp)
	move.w	FG_TopSize(a0),d0
	mulu	(sp),d0
	add.l	d1,d0
	add.l	d0,d0	; mode dependent
	add.l	d0,d0	; mode dependent
	add.l	d0,a2

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	10050$
	exg.l	d1,d7
10050$:
	moveq	#1,d0
	and.w	d2,d0
	move.w	d4,(sp)
11000$:
	move.w	FG_LeftMask(a0),d2	; get first word mask
	move.w	d3,d3			; first AND last word?
	bne.s	11055$			; nope - skip on
	and.w	FG_RightMask(a0),d2	; else finish up the mask
11055$:
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2)+,d6
	eor.w	d4,d6
	move.w	d6,(a3)+
	move.w	(a2)+,d6
	eor.w	d4,d6
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a6)+

	move.w	d3,d2			; setup line word counter
	beq.s	12003$			; if finished with the line - jump on
	subq.w	#2,d2			; else decrement the count
	bmi.s	12005$			; if last word - jump on
12000$:
	move.w	(a2)+,d6
	eor.w	d7,d6
	move.w	d6,(a3)+
	move.w	(a2)+,d6
	eor.w	d7,d6
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a6)+
	dbf	d2,12000$		; reloop till a line-1 has been done
12005$:
	move.w	FG_RightMask(a0),d2	; get last word mask
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2)+,d6
	eor.w	d4,d6
	move.w	d6,(a3)+
	move.w	(a2)+,d6
	eor.w	d4,d6
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a6)+
12003$:
	add.w	a1,a2			; address next data
	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6

	eor.w	#1,d0
	bne.s	12500$
	exg.l	d1,d7
12500$:
	subq.w	#1,(sp)
	bpl	11000$			; reloop till all lines are done

	lea	2(sp),sp		; restore the stack
	REST	d0/d1/a1		; restore extra registers

	rts


*****************************************************************************
*----	mode 1
20000$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets so far

	SAVE	d0/d1/a1		; save some extras for use

	move.w	FG_TopSize(a0),d0	; get new line count in d4
	sub.w	d0,d4
	sub.w	FG_BotSize(a0),d4

	mulu	#DISPLAYWIDTH/8,d0	; start fixing width count in d3
	CLEAR	d1			; and get total offset in d2
	move.w	FG_LeftWSize(a0),d1
	sub.w	d1,d3
	add.w	d1,d1
	add.l	d1,d0
	add.l	d0,d2

	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	FG_RightWSize(a0),d0	; finish up width count in d3
	sub.w	d0,d3			; and get bitplane modulus in d5
	add.w	d0,d0
	add.w	d1,d0
	add.w	d0,d5

	add.w	d0,d0	; mode dependent
	move.w	d0,a1			; get data modulus in a1

	move.w	FG_WWidth(a0),d0	; get data offset in a2
	addq.w	#1,d0
	add.w	d0,d0
	move.w	d0,-(sp)
	move.w	FG_TopSize(a0),d0
	mulu	(sp),d0
	add.l	d1,d0
	add.l	d0,d0	; mode dependent
	add.l	d0,a2

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	20050$
	exg.l	d1,d7
20050$:
	moveq	#1,d0
	and.w	d2,d0
	move.w	d4,(sp)
21000$:
	move.w	FG_LeftMask(a0),d2	; get first word mask
	move.w	d3,d3			; first AND last word?
	bne.s	21055$			; nope - skip on
	and.w	FG_RightMask(a0),d2	; else finish up the mask
21055$:
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2)+,d6
	eor.w	d4,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+

	move.w	d3,d2			; setup line word counter
	beq.s	22003$			; if finished with the line - jump on
	subq.w	#2,d2			; else decrement the count
	bmi.s	22005$			; if last word - jump on
22000$:
	move.w	(a2)+,d6
	eor.w	d7,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+
	dbf	d2,22000$		; reloop till a line-1 has been done
22005$:
	move.w	FG_RightMask(a0),d2	; get last word mask
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2)+,d6
	eor.w	d4,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+

22003$:
	add.w	a1,a2			; address next data
	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6

	eor.w	#1,d0
	bne.s	22500$
	exg.l	d1,d7
22500$:
	subq.w	#1,(sp)
	bpl.s	21000$			; reloop till all lines are done

	lea	2(sp),sp		; restore the stack
	REST	d0/d1/a1		; restore extra registers
	rts

*****************************************************************************
*----	mode 2
30000$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets so far

	SAVE	d0/d1/a1		; save some extras for use

	move.w	FG_TopSize(a0),d0	; get new line count in d4
	sub.w	d0,d4
	sub.w	FG_BotSize(a0),d4

	mulu	#DISPLAYWIDTH/8,d0	; start fixing width count in d3
	CLEAR	d1			; and get total offset in d2
	move.w	FG_LeftWSize(a0),d1
	sub.w	d1,d3
	add.w	d1,d1
	add.l	d1,d0
	add.l	d0,d2

	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	FG_RightWSize(a0),d0	; finish up width count in d3
	sub.w	d0,d3			; and get bitplane modulus in d5
	add.w	d0,d0
	add.w	d1,d0
	add.w	d0,d5

	add.w	d0,d0	; mode dependent
	move.w	d0,a1			; get data modulus in a1

	move.w	FG_WWidth(a0),d0	; get data offset in a2
	addq.w	#1,d0
	add.w	d0,d0
	move.w	d0,-(sp)
	move.w	FG_TopSize(a0),d0
	mulu	(sp),d0
	add.l	d1,d0
	add.l	d0,d0	; mode dependent
	add.l	d0,a2

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	30050$
	exg.l	d1,d7
30050$:
	moveq	#1,d0
	and.w	d2,d0
	move.w	d4,(sp)
31000$:
	move.w	FG_LeftMask(a0),d2	; get first word mask
	move.w	d3,d3			; first AND last word?
	bne.s	31055$			; nope - skip on
	and.w	FG_RightMask(a0),d2	; else finish up the mask
31055$:
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	SAVE1	d0

	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d4,d6
	move.w	d6,(a3)+
	eor.w	d2,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a5)+

	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d4,d6
	move.w	d6,(a4)+
	eor.w	d2,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a6)+

	move.w	d3,d2			; setup line word counter
	beq.s	32003$			; if finished with the line - jump on
	subq.w	#2,d2			; else decrement the count
	bmi.s	32005$			; if last word - jump on
32000$:
	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d7,d6
	move.w	d6,(a3)+
	eor.w	d1,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a5)+

	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d7,d6
	move.w	d6,(a4)+
	eor.w	d1,d0
* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a6)+

	dbf	d2,32000$		; reloop till a line-1 has been done
32005$:
	move.w	FG_RightMask(a0),d2	; get last word mask
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d4,d6
	move.w	d6,(a3)+
	eor.w	d2,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a5)+
	move.w	(a2)+,d6
	move.w	d6,d0
	eor.w	d4,d6
	move.w	d6,(a4)+
	eor.w	d2,d0

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d0,(a6)+
32003$:
	REST1	d0

	add.w	a1,a2			; address next data
	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6

	eor.w	#1,d0
	bne.s	32500$
	exg.l	d1,d7
32500$:
	subq.w	#1,(sp)
	bpl	31000$			; reloop till all lines are done

	lea	2(sp),sp		; restore the stack
	REST	d0/d1/a1		; restore extra registers

	rts

*----	mode 3
*****************************************************************************
40000$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	movem.l	(a1),a3-a6		; bitplane destination pointers
	movem.l	(a1),a3-a4		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets so far

	SAVE	d0/d1/a1		; save some extras for use

	move.w	FG_TopSize(a0),d0	; get new line count in d4
	sub.w	d0,d4
	sub.w	FG_BotSize(a0),d4

	mulu	#DISPLAYWIDTH/8,d0	; start fixing width count in d3
	CLEAR	d1			; and get total offset in d2
	move.w	FG_LeftWSize(a0),d1
	sub.w	d1,d3
	add.w	d1,d1
	add.l	d1,d0
	add.l	d0,d2

	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.l	d2,a5
;;	add.l	d2,a6

	move.w	FG_RightWSize(a0),d0	; finish up width count in d3
	sub.w	d0,d3			; and get bitplane modulus in d5
	add.w	d0,d0
	add.w	d1,d0
	add.w	d0,d5

	move.w	d0,a1			; get data modulus in a1

	move.w	FG_WWidth(a0),d0	; get data offset in a2
	addq.w	#1,d0
	add.w	d0,d0
	move.w	d0,-(sp)
	move.w	FG_TopSize(a0),d0
	mulu	(sp),d0
	add.l	d1,d0
	add.l	d0,a2

	move.w	d7,d1			; form alternate mask
	ror.w	#2,d1

	divu	#DISPLAYWIDTH/8,d2	; according to starting line -
	moveq	#2,d0			; setup line toggle for even/odd
	and.w	d2,d0
	beq.s	40050$
	exg.l	d1,d7

40050$:
	moveq	#1,d0
	and.w	d2,d0
	move.w	d4,(sp)
41000$:
	move.w	FG_LeftMask(a0),d2	; get first word mask
	move.w	d3,d3			; first AND last word?
	bne.s	41055$			; nope - skip on
	and.w	FG_RightMask(a0),d2	; else finish up the mask
41055$:
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2),d6
	eor.w	d4,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+

	move.w	d3,d2			; setup line word counter
	beq.s	42003$			; if finished with the line - jump on
	subq.w	#2,d2			; else decrement the count
	bmi.s	42005$			; if last word - jump on
42000$:
	move.w	(a2),d6
	eor.w	d7,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d1,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+

	dbf	d2,42000$		; reloop till a line-1 has been done
42005$:
	move.w	FG_RightMask(a0),d2	; get last word mask
	move.w	d2,d4			; form the masks to apply to the data
	and.w	d7,d4
	and.w	d1,d2

	move.w	(a2),d6
	eor.w	d4,d6
	move.w	d6,(a3)+
	move.w	d6,(a4)+
	move.w	(a2)+,d6
	eor.w	d2,d6

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	move.w	d6,(a5)+
;;	move.w	d6,(a6)+

42003$:
	add.w	a1,a2			; address next data
	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4

* HACK OUT RENDERING TO UPPER OF 4 PLANES.  SKELL 9/18/92
;;	add.w	d5,a5
;;	add.w	d5,a6
	eor.w	#1,d0
	bne.s	42500$
	exg.l	d1,d7
42500$:
	subq.w	#1,(sp)
	bpl.s	41000$			; reloop till all lines are done

	lea	2(sp),sp		; restore the stack
	REST	d0/d1/a1		; restore extra registers

	rts

50000$					;modes not supported or needed
60000$					;when using mask
	rts

	IFD	AACHIPS
*****************************************************************************
*----	mode 4

5000$:

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

5100$:
	move.w	d3,d2			; setup line word counter

5200$:
	move.w	(a2)+,d7		;mask

	move.w	(a2)+,d6
	move.w	d6,(a3)+		;lsb
	move.w	(a2)+,d6
	move.w	d6,(a4)+		;msb
	move.w	(a2)+,d6
	move.w	d7,(a5)+		;mask is msb

	dbf	d2,5200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,5100$		; reloop till all lines are done

	rts

*****************************************************************************
*----	mode 5

6000$:
	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

6100$:
	move.w	d3,d2			; setup line word counter

6200$:
	move.w	(a2)+,d7		;mask
	move.w	(a2)+,(a3)+		; place image into bitplanes
	move.w	(a2)+,(a4)+		; place image into bitplanes
	move.w	d7,(a5)+

	dbf	d2,6200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,6100$		; reloop till all lines are done

	rts
	ENDC

	IFND	AACHIPS
*****************************************************************************
*----	mode 4

5000$:
	movem.l	d0-d1,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

5100$:
	move.w	d3,d2			; setup line word counter

5200$:
;	move.w	(a2)+,d7		;mask
;	move.w	(a2)+,d6
;	move.w	d6,(a3)+		;lsb
;	move.w	(a2)+,d6
;	move.w	d6,(a4)+		;msb
;	move.w	(a2)+,d6
;	move.w	d7,(a5)+		;mask is msb


;	move.l	(a2)+,d7		;mask and low
;	swap.w	d7
;	not.w	d7
;	move.w	(a2)+,d6		;Hi
;	or.w	d7,d6
;	move.w	d6,(a3)+		;lsb
;	not.w	d7
;	swap.w	d7
;	eor.w	d7,d6
;	swap.w	d7
;	and.w	d7,d6
;	move.w	d6,(a4)+		;msb


	move.w	(a2)+,d7			;Mask
	move.w	d7,d6
	not.w	d6			;Not Mask
	move.l	(a2)+,d0
	move.l	d0,d1
	and.w	d6,d1
	swap.w	d1
	and.w	d6,d1			;plane1 and not mask
	and.w	d7,d0
	or.w	d0,d1
	move.w	d1,(a3)+		;write Plane 1
	swap.w	d1			;plane2 and not mask
	move.w	d0,d6
	swap.w	d0
	eor.w	d6,d0
	and.w	d7,d0
	or.w	d1,d0
	move.w	d0,(a4)+

	addq.w	#2,a2

	dbf	d2,5200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,5100$		; reloop till all lines are done

	movem.l	(sp)+,d0-d1
	rts

*****************************************************************************
*----	mode 5

6000$:
	movem.l	d0-d1,-(sp)

	move.l	(a2)+,d2		; offset within container
	move.l	(a2),a2			; pointer to source image data

	movem.l	(a1),a3-a5		; bitplane destination pointers

	add.l	d1,d2			; accumulate all offsets
	add.l	d2,a3			; offset bitplane pointers
	add.l	d2,a4
	add.l	d2,a5

6100$:
	move.w	d3,d2			; setup line word counter

6200$:
;	move.w	(a2)+,d7		;mask
;	move.w	(a2)+,(a3)+		; place image into bitplanes
;	move.w	(a2)+,(a4)+		; place image into bitplanes
;	move.w	d7,(a5)+

;	move.l	(a2)+,d7		;mask and low
;	swap.w	d7
;	not.w	d7
;	move.w	(a2)+,d6		;Hi
;	or.w	d7,d6
;	move.w	d6,(a3)+		;lsb
;	not.w	d7
;	swap.w	d7
;	eor.w	d7,d6
;	swap.w	d7
;	and.w	d7,d6
;	move.w	d6,(a4)+		;msb


	move.w	(a2)+,d7			;Mask
	move.w	d7,d6
	not.w	d6			;Not Mask
	move.l	(a2)+,d0
	move.l	d0,d1
	and.w	d6,d1
	swap.w	d1
	and.w	d6,d1			;plane1 and not mask
	and.w	d7,d0
	or.w	d0,d1
	move.w	d1,(a3)+		;write Plane 1
	swap.w	d1			;plane2 and not mask
	move.w	d0,d6
	swap.w	d0
	eor.w	d6,d0
	and.w	d7,d0
	or.w	d1,d0
	move.w	d0,(a4)+



	dbf	d2,6200$		; reloop till a line has been done

	add.w	d5,a3			; address next line in bitplanes
	add.w	d5,a4
	add.w	d5,a5

	dbf	d4,6100$		; reloop till all lines are done

	movem.l	(sp)+,d0-d1
	rts
	ENDC

*+*******
*+
*+ FloppyInOut
*+
*+ This function checks to see if any of the floppy devices known to the
*+ Switcher system has had a disk change and to update the Project/FrameStore
*+ string tables if required.
*+
*+ void FloppyInOut();
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Nothing is returned.
*+   Requires that a pointer to ToasterBase be in A5 and is closely tied to
*+   the inner working of the Switcher system. This routine is mostly for
*+   internal use by the Switcher system and those Slice entities hosted by
*+   the Switcher system when responding to DISKINSERTED/DISKREMOVED IDCMP
*+   messages. It requires that the FloppyDiskTest() function been run to
*+   install the floppy device allocation system.
*+
*+ Addendum 3/5/90:
*+ Addendum 3/21/90:
*+   This routine now investigates a certain private DiskManagerData field
*+   DMD_DiskIn for the last know state of all known units to the Switcher.
*+   If this routine discovers a unit that has had a floppy change, now has a
*+   disk inserted, AND that drive was previously known to have had a disk
*+   inserted, then this routine will ReValidate() that particular unit. This
*+   will cause a DISKINSERTED message to be broadcast from the input.device,
*+   but because there will have been no disk change from the ReValidate()d
*+   unit a case of no change should show up. This case is now treated
*+   special as it will force a rebuild of the Project/FrameStore tables if
*+   they are assigned to floppy units. This is neccessary because we cannot
*+   tell which unit the special case request pertains to. IMPORTANT: This
*+   routine must be called every time a diskchange occurs. Failure to do so
*+   can cause an invalid state to be presented to this function in
*+   DMD_DiskIn.
*+
*+*******

	IFNE	_CCODE

	XDEF	_FloppyInOut
_FloppyInOut:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FloppyInOut
	REST1	a5
	rts

	ENDC

	XDEF	FloppyInOut
FloppyInOut:
	CALL	FloppyDiskChange	; get floppy changes - if any
	beq	.Special		; if no changes - skip to special

	SAVE	d2-d5/a4		; save work registers
	lea	DiskManagerData(pc),a4	; address private disk data

	move.w	d0,d1			; get current unit status in D1
	lsr.w	#8,d1			; (units effected in D0)

	move.b	DMD_DiskIn(a4),d2	; get previous unit status in D2

	move.b	d0,d3			; update previous unit status
	not.b	d3
	and.b	d2,d3
	move.b	d0,d4
	and.b	d1,d4
	or.b	d4,d3
	move.b	d3,DMD_DiskIn(a4)

	move.b	d1,d3			; get units that are trouble
	and.b	d2,d3

	move.b	d0,d4			; get units that are not trouble
	eor.b	d3,d4

	moveq	#1,d5			; ReValidate troublesome units
	moveq	#4-1,d2

.RLoop:
	move.b	d3,d0
	and.b	d5,d0
	beq.s	.NoReValidate

	CALL	ReValidate

.NoReValidate:
	add.b	d5,d5
	dbf	d2,.RLoop

	GET.l	TB_ProjDev,a0		; get project device name
	cmp.b	#4,(a0)+		; and see if it is a floppy device
	bne.s	.NotPJDev
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'D',d0
	bne.s	.NotPJDev
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'F',d0
	bne.s	.NotPJDev
	move.b	(a0)+,d0
	sub.b	#'0',d0
	cmp.b	#3,d0
	bhi.s	.NotPJDev

	CLEAR	d1			; using a floppy device name
	bset.l	d0,d1			; form the bit mask

	and.b	d4,d1			; did floppy get changed?
	beq.s	.NotPJDev		; nope - skip out

	CALL	BuildProjectTable	; else rebuild framestore table

.NotPJDev:
	GET.l	TB_FSDev,a0		; get framestore device name
	cmp.b	#4,(a0)+		; and see if it is a floppy device
	bne.s	.NotFSDev
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'D',d0
	bne.s	.NotFSDev
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'F',d0
	bne.s	.NotFSDev
	move.b	(a0)+,d0
	sub.b	#'0',d0
	cmp.b	#3,d0
	bhi.s	.NotFSDev

	CLEAR	d1			; using a floppy device name
	bset.l	d0,d1			; form the bit mask

	and.b	d4,d1			; did floppy get changed?
	beq.s	.NotFSDev		; nope - skip out

	CALL	BuildFSTable		; else rebuild project table

.NotFSDev:
	REST	d2-d5/a4		; restore work registers
	rts

.Special:
	GET.l	TB_ProjDev,a0		; get project device name
	cmp.b	#4,(a0)+		; and see if it is a floppy device
	bne.s	.NotPJDev1
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'D',d0
	bne.s	.NotPJDev1
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'F',d0
	bne.s	.NotPJDev1
	move.b	(a0)+,d0
	sub.b	#'0',d0
	cmp.b	#3,d0
	bhi.s	.NotPJDev1

	CALL	BuildProjectTable	; rebuild project table

.NotPJDev1:
	GET.l	TB_FSDev,a0		; get framestore device name
	cmp.b	#4,(a0)+		; and see if it is a floppy device
	bne.s	.NotFSDev1
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'D',d0
	bne.s	.NotFSDev1
	move.b	(a0)+,d0
	CALL	ToUpperCase
	cmp.b	#'F',d0
	bne.s	.NotFSDev1
	move.b	(a0)+,d0
	sub.b	#'0',d0
	cmp.b	#3,d0
	bhi.s	.NotFSDev1

	CALL	BuildFSTable		; rebuild framestore table

.NotFSDev1:
	rts

*************************************************************************
	IFD	NEEDED

*+*******
*+
*+ FindFileEntity
*+
*+ This function attempts to finds the associated project or frame store file
*+ specified and if found, returns the comment string associated with
*+ the file.
*+
*+ LONG FindFileEntity( Value, Type, Count, DevPath, Container );
*+                       D0     D1    D2     A0       A1
*+
*+ LONG Value:
*+   The low unsigned 16 bits represents the file name prefix which should
*+   be 000 to 999. Upper 16 bits MUST be clear.
*+ LONG Type:
*+   The low unsigned 16 bits represents the type of file to be found:
*+   project or frame store. This forms the next portion of the filename:
*+   .PJ. or .FS. for project and frame store files respectively.
*+   For project files, this value will be 0. For frame store files it will
*+   be 1.
*+ LONG Count:
*+   The low unsigned 16 bit represents the number of file comment characters
*+   the are to be copied from the filename (if found) into the container
*+   buffer (described below).
*+ APTR DevPath:
*+   Pointer to the device pathname that is to be used to access the
*+   specified file.
*+ APTR Container:
*+   Pointer to the container to hold the comment portion of the specified
*+   filename (if found) for the number of characters specified in Count
*+   (see above). Must be have room for 1 byte more than the specified
*    count for a NULL terminator.
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns D0 with -1 if the specified filename was
*+   found, 0 if not. The condition codes will be setup according to the
*+   results in D0. Requires a pointer to ToasterBase in A5, but is not
*+   closely tied to the Switcher display. NO CHECKING is performed on the
*+   input parameters!
*+
*+ Addendum 1/15/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_FindFileEntity
_FindFileEntity:
	SAVE	d2/a5
	lea	_ToasterBase,a5
	movem.l	12(sp),d0-d2/a0/a1
	CALL.s	FindFileEntity
	REST	d2/a5
	rts

	ENDC

	XDEF	FindFileEntity
FindFileEntity:	; entry Value, Type, Count, DevPath, Container
*			 D0     D1    D2     A0       A1
	SAVE	d2-d5/a2-a4/a6		; save some work registers

	move.l	sp,a2			; save stack pointer for later

	lea	-fib_SIZEOF(sp),sp	; allocate a File Info Block
	move.l	sp,d3
	and.b	#2,d3
	beq.s	.LAlign
	lea	-2(sp),sp

.LAlign:
	move.l	sp,a3			; pointer to FIB - longword aligned

	move.l	d2,d3			; save Count in safe register

	divu	#100,d0			; get Value into ASCII XXX.
	move.b	d0,d4
	or.b	#'0',d4
	lsl.w	#8,d4

	clr.w	d0
	swap	d0
	divu	#10,d0
	move.b	d0,d4
	or.b	#'0',d4
	lsl.l	#8,d4

	swap	d0
	move.b	d0,d4
	or.b	#'0',d4
	lsl.l	#8,d4

	move.b	#'.',d4

	move.l	#'PJ.'<<8,d5		; form PJ.<NULL> or FS.<NULL>
	tst.w	d1			; depending on Type
	beq.s	.Suffix
	move.l	#'FS.'<<8,d5

.Suffix:
	SAVE	d4/d5			; place complete filename prefix

	move.l	a1,a4			; keep Container in a safe place

	move.l	a0,d1			; attempt to get a lock on the
	addq.l	#1,d1			; specified DevPath
	move.l	#ACCESS_READ,d2
	GET.l	TB_DOSBase,a6
	CALLROM	Lock
	move.l	d0,d4
	beq.s	.BadExitQ

	move.l	d4,d1			; fill out FIB
	move.l	a3,d2
	lea	fib_FileName(a3),a3
	CALLROM	Examine
	move.l	d0,d0
	beq.s	.BadExit
	bra.s	.IntoELoop

.ELoop:
	move.l	d4,d1			; attempt to find a file with the
	CALLROM	ExNext			; specified prefix
	move.l	d0,d0
	beq.s	.BadExit

.IntoELoop:
	move.l	a3,a0			; check for file prefix
	move.l	sp,a1
	moveq	#7,d0
	CALL	ByteSubSet
	bne.s	.ELoop

	lea	7(a3),a3		; we found a file - copy the
	subq.w	#1,d3			; specified file comment into the
	bmi.s	.SkipIt			; Container

.CLoop
	move.b	(a3)+,(a4)+
	dbf	d3,.CLoop

.SkipIt:
	clr.b	(a4)			; place NULL terminator

	move.l	d4,d1			; release the Lock on the DevPath
	CALLROM	UnLock

	move.l	a2,sp			; restore stack
	REST	d2-d5/a2-a4/a6		; restore registers
	moveq	#-1,d0			; denote all went well
	rts

.BadExit:
	move.l	d4,d1			; release the Lock on the DevPath
	CALLROM	UnLock

.BadExitQ:
	move.l	a2,sp			; restore stack
	REST	d2-d5/a2-a4/a6		; restore registers
	CLEAR	d0			; denote a problem occured
	rts

	ENDC

*+*******
*+
*+ BuildFileName
*+
*+ This function builds a FileName string from the parameters introduced
*+ to this function for Projects, Frame Stores, or Books.
*+
*+ LONG BuildFileName( Value, Type, Comment, Container );
*+  D0                  D0     D1    A0       A1
*+
*+ LONG Value:
*+   Long value should represent a value from 0-999.
*+ LONG Type:
*+   The long value should be 0 for Projects - a positive value for
*+   Frame Stores - a negative value for Books.
*+ APTR Comment:
*+   Pointer to a normal C string.
*+ APTR Container:
*+   Pointer to FileName string result buffer.
*+
*+ Notes:
*+   Trashes D1,A0,A1. -1 is returned in D0 if all went well, 0 is returned
*+   in D0 if the Value is invalid. If Toaster conventions are followed for
*+   the comment portion of the Project or Frame Store file comment being
*+   only 12 characters or less, then the entire resultant string cannot be
*+   more than 20 characters, including the NULL. The standard FileName
*+   formats is:
*+
*+   XXX.CC.<comment>NULL
*+
*+   XXX       = 000 to 999
*+   CC        = FS for Frame Store, PJ for Project, or BK for Book
*+   (comment> = up to 12 characters
*+
*+   Does not require a pointer to ToasterBase in A5 and is not tied to the
*+   Switcher system in any way.
*+
*+ Addendum 1/31/90:
*+ Addendum 2/23/90: Added type Book.
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuildFileName
_BuildFileName:
	movem.l	4(sp),d0/d1/a0/a1

	ENDC

	XDEF	BuildFileName
BuildFileName:	; entry: Value, Type, Comment, Container
*+			  D0     D1    A0       A1
	cmp.l	#1000,d0	; valid Value?
	bcs.s	.OK		; yup - keep going

	CLEAR	d0		; else return denoting failure
	rts

.OK:
	SAVE1	a0		; save Comment in a safe place

	divu	#100,d0		; get digit prefix field
	add.w	#'0',d0
	move.b	d0,(a1)+
	clr.w	d0
	swap	d0
	divu	#10,d0
	add.w	#'0',d0
	move.b	d0,(a1)+
	swap	d0
	add.w	#'0',d0
	move.b	d0,(a1)+

	lea	.ProjString(pc),a0	; place appropriate ID substring
	move.w	d1,d1
	beq.s	.AllRight
	lea	.FSString(pc),a0
	bpl.s	.AllRight
	lea	.BookString(pc),a0

.AllRight:
	CALL	STRcopy

	REST1	a0		; now append comment
	CALL	STRcopy

	moveq	#-1,d0		; give clean bill of health
	rts

.ProjString:
	DC.b	'.PJ.',0

.FSString:
	DC.b	'.FS.',0

.BookString:
	DC.b	'.BK.',0

	CNOP	0,2

*+*******
*+
*+ BuildFSTable
*+
*+ This function completely rebuilds the Frame Store file comment string
*+ table from the specified Frame Store directory.
*+
*+ LONG BuildFSTable();
*+  D0
*+
*+ Notes:
*+   This function trashes D1,A0,A1. -1 is returned in D0 if all went OK, 0
*+   otherwise. The condition codes are set according to the result in D0.
*+   If the function fails, all string table entries will be invalidated,
*+   Otherwise the string table will be setup according to the contents of
*+   the specified directory. In addition, the current directory will be the
*+   specified directory. Note that even if the function fails, the current
*+   directory may have been changed. Also some entrys may have been
*+   validated in the string table before the function failed. Requires a
*+   pointer to ToasterBase in A5. It is not closely tied to the Switcher
*+   display system.
*+
*+ Addendum 1/30/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuildFSTable
_BuildFSTable:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuildFSTable
	REST1	a5
	rts

	ENDC

	XDEF	BuildFSTable
BuildFSTable:
	SAVE	d2-d5/a2/a3/a6

	GET.l	TB_FSStrings,a0		; invalidate all string table entries
	move.l	a0,a3
	move.w	#$FF00,d0
	move.w	#1000-1,d1

.ClearLoop:
	move.w	d0,(a0)
	lea	14(a0),a0
	dbf	d1,.ClearLoop

	CALL	LockFS			; get lock on Frame Store directory
	beq	.Exit			; if we failed - exit

	move.l	d0,d3			; hold on to the lock

	move.l	sp,a2			; allocate a FileInfoBlock
	lea	-fib_SIZEOF(sp),sp
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp

	GET.l	TB_DOSBase,a6		; now attempt to fill out FIB
	move.l	d3,d1
	CALLROM	Examine
	bra.s	.SneakIn		; jump into primary loop

.PrimaryLoop:
	move.l	d3,d1			; get lock
*					; FIB already in D2
	CALLROM	ExNext			; fill out the FIB

.SneakIn:
	move.l	d0,d0			; rom call fail?
	beq.s	.ExitLoop		; if so - exit this primary loop

	tst.l	fib_DirEntryType(sp)	; what are we looking at?
	bpl.s	.PrimaryLoop		; if not a file - skip this one

	lea	fib_FileName+3(sp),a0	; else check out the filename
	lea	.TheirString(pc),a1	; first do check 1
	move.b	(a0)+,(a1)+
	move.b	(a0)+,d0
	CALL	ToUpperCase
	move.b	d0,(a1)+
	move.b	(a0)+,d0
	CALL	ToUpperCase
	move.b	d0,(a1)+
	move.b	(a0),(a1)
	lea	.OurString(pc),a0
	lea	.TheirString(pc),a1
	moveq	#4,d0
	CALL	ByteSubSet
	bne.s	.PrimaryLoop		; if it flunks out - reloop

	CLEAR	d4			; do check 2 - for valid digit field
	CLEAR	d1
	lea	fib_FileName(sp),a0
	moveq	#2,d5

.DigitLoop:
	move.b	(a0)+,d0
	move.b	d0,d1
	CALL	IsaDigit
	beq.s	.PrimaryLoop		; if it flunk out - reloop
	sub.w	#'0',d1
	CALL	.MultD4by10
	add.w	d1,d4
	dbf	d5,.DigitLoop

*					; at this point a valid prefix

	lea	fib_FileName+7(sp),a0	; index beginning of file comment

	CALL	STRlen			; get comment length
	cmp.w	#12,d0			; maximum of 12
	bhi.s	.PrimaryLoop		; if it flunks out - reloop

	mulu	#14,d4			; index string table element
	lea	0(a3,d4.l),a1

	move.b	d0,(a1)+		; write the new string table entry
	subq.w	#1,d0
	bmi.s	.PutNULL

.CommLoop:
	move.b	(a0)+,(a1)+
	dbf	d0,.CommLoop

.PutNULL:
	clr.b	(a1)
	bra	.PrimaryLoop		; reloop till done

.ExitLoop:
	move.l	a2,sp				; de-allocate FIB
	CALLROM	IoErr				; determine sucess or failure
	moveq	#-1,d2				; assume success
	cmp.l	#ERROR_NO_MORE_ENTRIES,d0
	beq.s	.Success

	PUT.l	d0,TB_LastGlobalError	; save secondary error code from DOS
	CLEAR	d2			; denote function failure

.Success:
	move.l	d3,d1			; release directory lock
	CALLROM	UnLock

	GET.w	TB_NumPadPri,d0
	moveq	#-1,d1
	move.w	d0,d3
	mulu	#14,d3
	cmp.b	0(a3,d3.w),d1
	beq.s	.DoUpdate		; ...if not already at a valid entry

	PUT.w	d0,TB_FLSelVal		; assure both frame numpad entities
	PUT.w	d0,TB_FSSelVal		; are reset

	GET.l	TB_CurrSelFG,a0		; see if FS numpad system of Switcher
	cmp.w	#FLSELID,FG_IndexID(a0)	; needs updating
	bcs.s	.NoUpdate		; ...if FS numpad system not active

	CALL	UpDateFC		; else form new correct FC
	bra.s	.NoUpdate
*					; will update imagery upon return
*					; into Switcher

.DoUpdate:
	move.w	#1000-1,d0		; else form a new FS number to
*					; the first FS we find in table

.SearchLoop:
	cmp.b	(a3),d1
	lea	14(a3),a3
	dbne	d0,.SearchLoop
	beq.s	.NoUpdate		; ...if no valid FSs found

	move.w	#999,d1			; else form and save the new
	sub.w	d0,d1			; FS number
	PUT.w	d1,TB_FLSelVal		; assure both frame numpad entities
	PUT.w	d1,TB_FSSelVal		; are reset

	GET.l	TB_CurrSelFG,a0		; see if FS numpad system of Switcher
	cmp.w	#FLSELID,FG_IndexID(a0)	; needs updating
	bcs.s	.NoUpdate		; ...if FS numpad system not active

	PUT.w	d1,TB_NumPadSec		; make the change active
*					; will update imagery upon return
*					; into Switcher

.NoUpdate:
	move.l	d2,d0			; place return code

.Exit:

	XJSR	ResetCGPopupList

	REST	d2-d5/a2/a3/a6
	rts

.MultD4by10:
	add.w	d4,d4
	move.w	d4,d0
	add.w	d4,d4
	add.w	d4,d4
	add.w	d0,d4
	rts

.OurString:
	DC.b	'.FS.'

.TheirString:
	DS.b	4

	CNOP	0,2

*+*******
*+
*+ BuildProjectTable
*+
*+ This function completely rebuilds the Project file comment string
*+ table from the specified Project directory.
*+
*+ LONG BuildProjectTable();
*+  D0
*+
*+ Notes:
*+   This function trashes D1,A0,A1. -1 is returned in D0 if all went OK, 0
*+   otherwise. The condition codes are set according to the result in D0.
*+   If the function fails, all string table entries will be invalidated,
*+   Otherwise the string table will be setup according to the contents of
*+   the specified directory. In addition, the current directory will be the
*+   specified directory. Note that even if the function fails, the current
*+   directory may have been changed. Also some entrys may have been
*+   validated in the string table before the function failed. Requires a
*+   pointer to ToasterBase in A5. It is not closely tied to the Switcher
*+   display system.
*+
*+ Addendum 1/31/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuildProjectTable
_BuildProjectTable:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuildProjectTable
	REST1	a5
	rts

	ENDC

	XDEF	BuildProjectTable
BuildProjectTable:
	SAVE	d2-d5/a2/a3/a6

	GET.l	TB_ProjStrings,a0	; invalidate all string table entries
	move.l	a0,a3
	move.w	#$FF00,d0
	move.w	#1000-1,d1

.ClearLoop:
	move.w	d0,(a0)
	lea	14(a0),a0
	dbf	d1,.ClearLoop

	CALL	LockProject		; get lock on Frame Store directory
	beq	.Exit			; if we failed - exit

	move.l	d0,d3			; hold on to the lock

	move.l	sp,a2			; allocate a FileInfoBlock
	lea	-fib_SIZEOF(sp),sp
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp

	GET.l	TB_DOSBase,a6		; now attempt to fill out FIB
	move.l	d3,d1
	CALLROM	Examine
	bra.s	.SneakIn		; jump into primary loop

.PrimaryLoop:
	move.l	d3,d1			; get lock
*					; FIB already in D2
	CALLROM	ExNext			; fill out the FIB

.SneakIn:
	move.l	d0,d0			; rom call fail?
	beq.s	.ExitLoop		; if so - exit this primary loop

	tst.l	fib_DirEntryType(sp)	; what are we looking at?
	bpl.s	.PrimaryLoop		; if not a file - skip this one

	lea	fib_FileName+3(sp),a0	; else check out the filename
	lea	.TheirString(pc),a1	; first do check 1
	move.b	(a0)+,(a1)+
	move.b	(a0)+,d0
	CALL	ToUpperCase
	move.b	d0,(a1)+
	move.b	(a0)+,d0
	CALL	ToUpperCase
	move.b	d0,(a1)+
	move.b	(a0),(a1)
	lea	.OurString(pc),a0
	lea	.TheirString(pc),a1
	moveq	#4,d0
	CALL	ByteSubSet
	bne.s	.PrimaryLoop		; if it flunks out - reloop

	CLEAR	d4			; do check 2 - for valid digit field
	CLEAR	d1
	lea	fib_FileName(sp),a0
	moveq	#2,d5

.DigitLoop:
	move.b	(a0)+,d0
	move.b	d0,d1
	CALL	IsaDigit
	beq.s	.PrimaryLoop		; if it flunk out - reloop
	sub.w	#'0',d1
	CALL	.MultD4by10
	add.w	d1,d4
	dbf	d5,.DigitLoop

*					; at this point a valid prefix

	lea	fib_FileName+7(sp),a0	; index beginning of file comment

	CALL	STRlen			; get comment length
	cmp.w	#12,d0			; maximum of 12
	bhi.s	.PrimaryLoop		; if it flunks out - reloop

	mulu	#14,d4			; index string table element
	lea	0(a3,d4.l),a1

	move.b	d0,(a1)+		; write the new string table entry
	subq.w	#1,d0
	bmi.s	.PutNULL

.CommLoop:
	move.b	(a0)+,(a1)+
	dbf	d0,.CommLoop

.PutNULL:
	clr.b	(a1)
	bra	.PrimaryLoop		; reloop till done

.ExitLoop:
	move.l	a2,sp				; de-allocate FIB
	CALLROM	IoErr				; determine sucess or failure
	moveq	#-1,d2				; assume success
	cmp.l	#ERROR_NO_MORE_ENTRIES,d0
	beq.s	.Success

	PUT.l	d0,TB_LastGlobalError	; save secondary error code from DOS
	CLEAR	d2			; denote function failure

.Success:
	move.l	d3,d1			; release directory lock
	CALLROM	UnLock

	GET.w	TB_ProjectNumber,d0	; determine if Projects system in the
	mulu	#14,d0			; Config slice needs updating
	moveq	#-1,d1
	cmp.b	0(a3,d0.w),d1
	bne.s	.NoUpdate		; ...if current Project number valid

	move.w	#1000-1,d0		; else form a new Project number to
*					; the first Project we find in table

.SearchLoop:
	cmp.b	(a3),d1
	lea	14(a3),a3
	dbne	d0,.SearchLoop
	beq.s	.NoUpdate		; ...if no valid Projects found

	move.w	#999,d1			; else form and save the new
	sub.w	d0,d1			; Project number
	PUT.w	d1,TB_ProjectNumber
 ifeq 1
	GET.l	TB_Window,a0		; is the Config slice screen up so
	move.l	wd_FirstGadget(a0),a0	; that we can render the changes?
	cmp.w	#'CF',gg_GadgetID(a0)
	bne.s	.NoUpdate		; ...if not

	SAVE1	a4			; else render the changes
	XREF	MTSliceDataPool
	lea	MTSliceDataPool,a4
	XCALL	UpDateProjectDigits
	GET.l	TB_SYSBase,a6
	CALLROM	Forbid
	XCALL	SoftSpriteOff
	XREF	MT_PJFGs
	lea	MT_PJFGs,a0
	GET.l	TB_Window,a1
	moveq	#1,d0
	CLEAR	d1
;;	move.l	d1,a2
	CALL	DrawFastGList
	moveq	#-1,d0
	XCALL	UpDatePJFC
	XCALL	SoftSpriteOn
	CALLROM	Permit
	REST1	a4
 endc
.NoUpdate:
	move.l	d2,d0			; place return code

.Exit:
	REST	d2-d5/a2/a3/a6
	rts

.MultD4by10:
	add.w	d4,d4
	move.w	d4,d0
	add.w	d4,d4
	add.w	d4,d4
	add.w	d0,d4
	rts

.OurString:
	DC.b	'.PJ.'

.TheirString:
	DS.b	4

	CNOP	0,2

*+*******
*+
*+ IsaDigit
*+
*+ This function determines if the specified argument is a ASCII digit.
*+
*+ LONG IsaDigit( Char );
*+  D0             D0
*+
*+ LONG Char:
*+   The low 8 bits are examined.
*+
*+ Notes:
*+   Returns -1 in D0 if the byte represents an ASCII digit, 0 otherwise.
*+   The condition codes are set according to the result in D0. No other
*+   registers are altered. No pointer to ToasterBase is required in A5. It
*+   is not tied to the Switcher in any way.
*+
*+ Addendum 1/30/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_IsaDigit
_IsaDigit:

	ENDC

	XDEF	IsaDigit
IsaDigit:	; entry: Char
*			  D0

	cmp.b	#'0',d0
	bcs.s	.False
	cmp.b	#'9',d0
	bhi.s	.False

	moveq	#-1,d0
	rts

.False:
	CLEAR	d0
	rts

*+*******
*+
*+ LockEffects
*+
*+ This function makes the Effects directory or volume the current directory
*+ and returns a shared lock to it.
*+
*+ LONG LockEffects( Mode );
*+  D0                D0
*+
*+ LONG Mode:
*+   Determines if the lock and directory should be associated with the
*+   Effects directory in the Toaster ROOT directory or a volume Effects:
*+   (for perhaps additional effects on  floppy). If Mode = 0, then an
*+   attempt will be made first for the Effects directory, if it is not
*+   found, then an attempt will be made for the Effects volume. If Mode < 0,
*+   then an attempt will be made for the Effects directory only.
*+   If Mode > 0, then an attempt will be made for the Effects volume only.
*+
*+ Notes:
*+   Returns a BPTR to a shared lock in D0 if all went well, NULL
*+   otherwise. The condition codes are set according to
*+   the result in D0. Requires a pointer to ToasterBase in A5. It is not
*+   tied closely to the Switcher display system. When you are finished
*+   with the returned lock, you must UnLock() it. Even if this function is
*+   unsuccessful, it may change the current directory.
*+
*+ Addendum 1/30/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_LockEffects
_LockEffects:
	move.l	4(sp),d0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	LockEffects
	REST1	a5
	rts

	ENDC

	XDEF	LockEffects
LockEffects:	; entry: Mode
*			  D0
	SAVE	d1-d4/a0-a2/a6		; save work registers

	GET.l	TB_DOSBase,a6		; get DOS base

	move.l	d0,d4			; which mode does the caller want?
	ble.s	.GetDir			; if search or directory mode - jump

.GetVol:
	lea	.VolName(pc),a0		; else get the volume
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.OK			; continue if we got the lock

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	CLEAR	d0			; denote funtion failed
	bra.s	.Exit

.GetDir:
	GET.l	TB_BootLock,d1		; make TB root the current dir
	CALLROM	CurrentDir

	lea	.DirName(pc),a0		; get directory name under device
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.Skip1			; if OK - skip on

	move.l	d4,d4			; if in search mode - try volume
	beq.s	.GetVol

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	CLEAR	d0			; denote funtion failed
	bra.s	.Exit

.Skip1:
	move.l	sp,a2			; save current stack pointer
	lea	-fib_SIZEOF(sp),sp	; and allocate a FileInfoBlock
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp
	move.l	d3,d1
	CALLROM	Examine			; fill out the FIB
	move.l	fib_DirEntryType(sp),d1	; get type
	move.l	a2,sp			; de-allocate the FIB
	move.l	d0,d0
	beq.s	.Failed			; if rom call failed - skip on
	move.l	d1,d1
	bgt.s	.OK			; if lock on a directory - continue

.Failed:
	CALLROM	IoErr			; get secondary error code
	move.l	d0,d2			; and hang on to it

	move.l	d3,d1			; jettison the lock
	CALLROM	UnLock

	move.l	d4,d4			; if in search mode - try volume
	beq.s	.GetVol

	PUT.l	d2,TB_LastGlobalError

	CLEAR	d0			; denote unsuccessful
	bra.s	.Exit

.OK:
	move.l	d3,d1			; now make it the current dir
	CALLROM	CurrentDir

	move.l	d3,d0			; return the lock to caller

.Exit:
	REST	d1-d4/a0-a2/a6		; restore work registers
	rts

.DirName:
	DC.b	'Effects',0

.VolName:
	DC.b	'Effects:',0

	CNOP	0,2

*+*******
*+
*+ LockFS
*+
*+ This function makes the currently indicated Frame Store directory the
*+ current directory and returns a shared lock to it.
*+
*+ LONG LockFS();
*+  D0
*+
*+ Notes:
*+   Returns a BPTR to a shared lock in D0 if all went well, NULL
*+   otherwise. Trashes D1,A0,A1. The condition codes are set according to
*+   the result in D0. Requires a pointer to ToasterBase in A5. It is not
*+   tied closely to the Switcher display system. When you are finished
*+   with the returned lock, you must UnLock() it. Even if this function is
*+   unsuccessful, it may change the current directory.
*+
*+ Addendum 1/30/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_LockFS
_LockFS:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	LockFS
	REST1	a5
	rts

	ENDC

	XDEF	LockFS
LockFS:
	SAVE	d2-d4/a2/a6		; save work registers

	CLEAR	d4			; assume no lock returned for now
	GET.l	TB_DOSBase,a6		; get DOS base

	GET.l	TB_FSDev,d1		; get ToasterString for FS dev
	addq.l	#1,d1			; past BCPL header to C string
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.Skip1			; if OK - skip on

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	bra.s	.Exit

.Skip1:
	move.l	d3,d1			; make it the current dir for now
	CALLROM	CurrentDir

	lea	.Name(pc),a0		; get directory name under device
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d4
	bne.s	.Skip2			; if OK - skip on

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	bra.s	.Failed2

.Skip2:
	move.l	sp,a2			; save current stack pointer
	lea	-fib_SIZEOF(sp),sp	; and allocate a FileInfoBlock
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp
	move.l	d4,d1
	CALLROM	Examine			; fill out the FIB
	move.l	fib_DirEntryType(sp),d1	; get type
	move.l	a2,sp			; de-allocate the FIB
	move.l	d0,d0
	beq.s	.Failed			; if rom call failed - skip on
	move.l	d1,d1
	bgt.s	.OK			; if lock on a directory - continue

.Failed:
	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError

	move.l	d4,d1			; jettison the lock
	CALLROM	UnLock

	CLEAR	d4			; denote unsuccessful
	bra.s	.Failed2

.OK:
	move.l	d4,d1			; now form new current dir
	CALLROM	CurrentDir

.Failed2:
	move.l	d3,d1			; done with device lock - release it
	CALLROM	UnLock

.Exit:
	move.l	d4,d0			; return the lock to caller
	REST	d2-d4/a2/a6		; restore work registers
	rts

.Name:
	DC.b	'FrameStore',0

	CNOP	0,2

*+*******
*+
*+ LockProject
*+
*+ This function makes the currently indicated Project directory the
*+ current directory and returns a shared lock to it.
*+
*+ LONG LockProject();
*+  D0
*+
*+ Notes:
*+   Returns a BPTR to a shared lock in D0 if all went well, NULL
*+   otherwise. Trashes D1,A0,A1. The condition codes are set according to
*+   the result in D0. Requires a pointer to ToasterBase in A5. It is not
*+   tied closely to the Switcher display system. When you are finished
*+   with the returned lock, you must UnLock() it. Even if this function is
*+   unsuccessful, it may change the current directory.
*+
*+ Addendum 1/30/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_LockProject
_LockProject:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	LockProject
	REST1	a5
	rts

	ENDC

	XDEF	LockProject
LockProject:
	SAVE	d2-d4/a2/a6		; save work registers

	CLEAR	d4			; assume no lock returned for now
	GET.l	TB_DOSBase,a6		; get DOS base

	GET.l	TB_ProjDev,d1		; get ToasterString for project dev
	addq.l	#1,d1			; past BCPL header to C string
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.Skip1			; if OK - skip on

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	bra.s	.Exit

.Skip1:
	move.l	d3,d1			; make it the current dir for now
	CALLROM	CurrentDir

	lea	.Name(pc),a0		; get directory name under device
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d4
	bne.s	.Skip2			; if OK - skip on

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	bra.s	.Failed2

.Skip2:
	move.l	sp,a2			; save current stack pointer
	lea	-fib_SIZEOF(sp),sp	; and allocate a FileInfoBlock
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp
	move.l	d4,d1
	CALLROM	Examine			; fill out the FIB
	move.l	fib_DirEntryType(sp),d1	; get type
	move.l	a2,sp			; de-allocate the FIB
	move.l	d0,d0
	beq.s	.Failed			; if rom call failed - skip on
	move.l	d1,d1
	bgt.s	.OK			; if lock on a directory - continue

.Failed:
	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError

	move.l	d4,d1			; jettison the lock
	CALLROM	UnLock

	CLEAR	d4			; denote unsuccessful
	bra.s	.Failed2

.OK:
	move.l	d4,d1			; now form new current dir
	CALLROM	CurrentDir

.Failed2:
	move.l	d3,d1			; done with device lock - release it
	CALLROM	UnLock

.Exit:
	move.l	d4,d0			; return the lock to caller
	REST	d2-d4/a2/a6		; restore work registers
	rts

.Name:
	DC.b	'Project',0

	CNOP	0,2

*+*******
*+
*+ LockAuxLibs
*+
*+ This function makes the AuxLibs directory the current directory and
*+ returns a shared lock to it.
*+
*+ LONG LockAuxLibs();
*+  D0
*+
*+ Notes:
*+   Returns a BPTR to a shared lock in D0 if all went well, NULL
*+   otherwise. Trashes D1,A0,A1. The condition codes are set according to
*+   the result in D0. Requires a pointer to ToasterBase in A5. It is not
*+   tied closely to the Switcher display system. When you are finished
*+   with the returned lock, you must UnLock() it. Even if this function is
*+   unsuccessful, it may change the current directory.
*+
*+ Addendum 2/16/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_LockAuxLibs
_LockAuxLibs:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	LockAuxLibs
	REST1	a5
	rts

	ENDC

	XDEF	LockAuxLibs
LockAuxLibs:
	SAVE	d2/d3/a2/a6		; save work registers

	GET.l	TB_DOSBase,a6		; get DOS base

	GET.l	TB_BootLock,d1		; make TB root the current dir
	CALLROM	CurrentDir

	lea	.Name(pc),a0		; get directory name under device
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.Skip1			; if OK - skip on

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	CLEAR	d0			; denote funtion failed
	bra.s	.Exit

.Skip1:
	move.l	sp,a2			; save current stack pointer
	lea	-fib_SIZEOF(sp),sp	; and allocate a FileInfoBlock
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp
	move.l	d3,d1
	CALLROM	Examine			; fill out the FIB
	move.l	fib_DirEntryType(sp),d1	; get type
	move.l	a2,sp			; de-allocate the FIB
	move.l	d0,d0
	beq.s	.Failed			; if rom call failed - skip on
	move.l	d1,d1
	bgt.s	.OK			; if lock on a directory - continue

.Failed:
	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError

	move.l	d3,d1			; jettison the lock
	CALLROM	UnLock

	CLEAR	d0			; denote unsuccessful
	bra.s	.Exit

.OK:
	move.l	d3,d1			; now make it the current dir
	CALLROM	CurrentDir

	move.l	d3,d0			; return the lock to caller

.Exit:
	REST	d2/d3/a2/a6		; restore work registers
	rts

.Name:
	DC.b	'AuxLibs',0

	CNOP	0,2

*+*******
*+
*+ LockToasterFonts
*+
*+ This function makes the ToasterFonts directory or volume the current
*+ directory and returns a shared lock to it.
*+
*+ LONG LockToasterFonts( Mode );
*+  D0                     D0
*+
*+ LONG Mode:
*+   Determines if the lock and directory should be associated with the
*+   ToasterFonts directory in the Toaster ROOT directory or a volume
*+   ToasterFonts: (for perhaps additional fonts on  floppy). If Mode = 0,
*+   then an attempt will be made first for the ToasterFonts directory, if it
*+   is not found, then an attempt will be made for the ToasterFonts volume.
*+   If Mode < 0, then an attempt will be made for the ToasterFonts directory
*+   only. If Mode > 0, then an attempt will be made for the ToasterFonts
*+   volume only.
*+
*+ Notes:
*+   Returns a BPTR to a shared lock in D0 if all went well, NULL
*+   otherwise. Trashes D1,A0,A1. The condition codes are set according to
*+   the result in D0. Requires a pointer to ToasterBase in A5. It is not
*+   tied closely to the Switcher display system. When you are finished
*+   with the returned lock, you must UnLock() it. Even if this function is
*+   unsuccessful, it may change the current directory.
*+
*+ Addendum 2/16/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr().
*+
*+*******

	IFNE	_CCODE

	XDEF	_LockToasterFonts
_LockToasterFonts:
	move.l	4(sp),d0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	LockToasterFonts
	REST1	a5
	rts

	ENDC

	XDEF	LockToasterFonts
LockToasterFonts:
	SAVE	d2/d3/d4/a2/a6		; save work registers

	GET.l	TB_DOSBase,a6		; get DOS base

	move.l	d0,d4			; which mode does the caller want?
	ble.s	.GetDir			; if search or directory mode - jump

.GetVol:
	lea	.VolName(pc),a0		; else get the volume
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.OK			; continue if we got the lock

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	CLEAR	d0			; denote funtion failed
	bra.s	.Exit

.GetDir:
	GET.l	TB_BootLock,d1		; make TB root the current dir
	CALLROM	CurrentDir

	lea	.DirName(pc),a0		; get directory name under device
	move.l	a0,d1
	move.l	#SHARED_LOCK,d2
	CALLROM	Lock			; get shared lock
	move.l	d0,d3
	bne.s	.Skip1			; if OK - skip on

	move.l	d4,d4			; if in search mode - try volume
	beq.s	.GetVol

	CALLROM	IoErr			; get secondary error code
	PUT.l	d0,TB_LastGlobalError
	CLEAR	d0			; denote funtion failed
	bra.s	.Exit

.Skip1:
	move.l	sp,a2			; save current stack pointer
	lea	-fib_SIZEOF(sp),sp	; and allocate a FileInfoBlock
	move.l	sp,d2
	and.b	#$FC,d2
	move.l	d2,sp
	move.l	d3,d1
	CALLROM	Examine			; fill out the FIB
	move.l	fib_DirEntryType(sp),d1	; get type
	move.l	a2,sp			; de-allocate the FIB
	move.l	d0,d0
	beq.s	.Failed			; if rom call failed - skip on
	move.l	d1,d1
	bgt.s	.OK			; if lock on a directory - continue

.Failed:
	CALLROM	IoErr			; get secondary error code
	move.l	d0,d2			; and hang on to it

	move.l	d3,d1			; jettison the lock
	CALLROM	UnLock

	move.l	d4,d4			; if in search mode - try volume
	beq.s	.GetVol

	PUT.l	d2,TB_LastGlobalError

	CLEAR	d0			; denote unsuccessful
	bra.s	.Exit

.OK:
	move.l	d3,d1			; now make it the current dir
	CALLROM	CurrentDir

	move.l	d3,d0			; return the lock to caller

.Exit:
	REST	d2/d3/d4/a2/a6		; restore work registers
	rts

.DirName:
	DC.b	'ToasterFonts',0
.VolName:
	DC.b	'ToasterFonts:',0

	CNOP	0,2

*+*******
*+
*+ STRcopy
*+
*+ This function copies the specified source string into the specified
*+ destination buffer.
*+
*+ void STRcopy( STR1, STR2 );
*+                A0    A1
*+
*+ APTR STR1:
*+   Pointer to a C type string.
*+ APTR STR2:
*+   Pointer to a buffer to receive a C type string.
*+
*+ Notes:
*+   Alters only A0,A1, and the condition codes. Returns nothing directly.
*+   However for assembler programmers, both A0 and A1 will be left pointing
*+   at the NULL terminators of their respective strings. This function can
*+   be used to copy Toaster strings (BCPL string + NULL) as long as the
*+   length header is not 0. No pointer to ToasterBase is required in A5.
*+   This function is not tied to the Switcher system in any way.
*+
*+ Addendum 1/31/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_STRcopy
_STRcopy:
	movem.l	4(sp),a0/a1

	ENDC

	XDEF	STRcopy
STRcopy:	; entry: STR1, STR2
*			  A0    A1
	move.b	(a0)+,(a1)+
	bne.s	STRcopy

	lea	-1(a0),a0
	lea	-1(a1),a1

	rts

*+*******
*+
*+ STRNcopy
*+
*+ This function copies the specified source string into the specified
*+ destination buffer until the source string is copied or the count is
*+ exhuasted, whichever comes first.
*+
*+ void STRNcopy( Count, STR1, STR2 );
*+                 D0     A0    A1
*+
*+ LONG Count:
*+   Low 16 bits used as a character count.
*+ APTR STR1:
*+   Pointer to a C type string.
*+ APTR STR2:
*+   Pointer to a buffer to receive a C type string.
*+
*+ Notes:
*+   Alters only D0,A0,A1, and the condition codes. Returns nothing directly.
*+   However for assembler programmers, A1 will be always be left pointing
*+   at the NULL terminator of its respective string. A0 will be left
*+   pointing at either the next character or NULL to copy (if countout
*+   occured) or just past the NULL terminator (if string exhuasted). D0.w
*+   will be in its state of count out (Count-1 to -1). No pointer to
*+   ToasterBase is required in A5. This function is not tied to the
*+   Switcher system in any way.
*+
*+ Addendum 1/31/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_STRNcopy
_STRNcopy:
	movem.l	4(sp),d0/a0/a1

	ENDC

	XDEF	STRNcopy
STRNcopy:	; entry: Count, STR1, STR2
*			  D0     A0    A1
	subq.w	#1,d0
	bmi.s	.CountOut

.Loop:
	move.b	(a0)+,(a1)+
	dbeq	d0,.Loop
	bne.s	.CountOut

	lea	-1(a1),a1
	rts

.CountOut:
	clr.b	(a1)
	rts

*+*******
*+
*+ ToUpperCase
*+
*+ This function assures that the character argument is returned in upper
*+ case, if applicable to the data. Otherwise the argument is returned as is.
*+
*+ LONG ToUpperCase( Char );
*+  D0                D0
*+
*+ LONG Char:
*+   The low 8 bits are examined.
*+
*+ Notes:
*+   Trashes only the condition codes. The byte value in D0 is only altered
*+   if it was converted to upper case. No other registers are altered.
*+   No pointer to ToasterBase is required in A5. It is not tied to the
*+   Switcher in any way.
*+
*+ Addendum 1/30/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_ToUpperCase
_ToUpperCase:

	ENDC

	XDEF	ToUpperCase
ToUpperCase:	; entry Char
*			 D0
	cmp.b	#'a',d0
	bcs.s	10$
	cmp.b	#'z',d0
	bhi.s	10$

	and.b	#$DF,d0

10$:
	rts

*+*******
*+
*+ FloppyDiskTest
*+
*+ This function tests what floppy drives are present in the system.
*+
*+ LONG FloppyDiskTest();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns the existing units bit mask in D0 where bits
*+   0-3 correspond to units 0-3, other bit positions in D0 will be clear. -1
*+   is returned only if the IO port for comm with the trackdisk.device
*+   could not be obtained. The condition codes will be set according to the
*+   result in D0. Requires a pointer to ToasterBase in A5, but is not tied
*+   to the Switcher display system. It is best to leave this function
*+   completely to the Switcher system where it is used at bootup to
*+   determine what is REALLY available.
*+
*+ Addendum 2/1/90:
*+
*+ Additional notes:
*+   Support has been added to filter out floppy devices that have valid
*+   software nodes, but nevertheless do not really exist. The mask returned
*+   from this function represents only those floppy devices that were
*+   opened via the trackdisk.device AND are not filtered out by the new
*+   hardware tests. Also at this time no floppy devices other than standard
*+   AMIGA 3.5 drives are obtained. This routine allocates a message port
*+   if needed for doing device IO which is left in place and must be
*+   manually de-allocated.
*+
*+ Addendum 2/14/90:
*+ Addendum 3/21/90:
*+   There is a new field DMD_DiskIn which is setup by this routine and
*+   used/manipulated by FloppyInOut() only. This field has bit assignments
*+   0-3 for unit 0-3 respectively. A bit position set indicates that the
*+   unit has a disk inserted. A bit position reset indicates that the unit
*+   is empty. Note also that bit positions in this field are only valid if
*+   the corresponding bits are also set in DMD_ExistFlag field. This routine
*+   relies on its internal fields being initially valid (before first call).
*+   It is therefore not re-entrant or re-usabe.
*+
*+*******

	IFNE	_CCODE

	XDEF	_FloppyDiskTest
_FloppyDiskTest:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FloppyDiskTest
	REST1	a5
	rts

	ENDC

	XDEF	FloppyDiskTest
FloppyDiskTest:
	SAVE	a2-a4/a6		; save work registers

	lea	DiskManagerData(pc),a4	; address private data
	GET.l	TB_SYSBase,a6		; and get exec base

	move.l	DMD_Port(a4),d0		; does our port already exist?
	move.l	d0,a2
	bne.s	.SkipToIt		; if it does - skip on

	lea	DMD_PortName(a4),a0	; attempt to get port - priority 0
	CLEAR	d0
	XCALL	CreatePort
	bne.s	.OK			; if we got the port - skip on

	moveq	#-1,d0			; else send back -1 to denote an err
	bra	.ExitQ

.OK:
	move.l	d0,a2			; hold on to port pointer
	move.l	a2,DMD_Port(a4)

.SkipToIt:
	lea	DMD_TDName(a4),a0	; attempt to open unit 0
	lea	DMD_IOReq0(a4),a3
	move.l	a3,a1
	move.l	a2,MN_REPLYPORT(a1)
	CLEAR	d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit0		; if unit not opened - skip on

	CLEAR	d0			; now see if the unit really exists
	move.l	a3,a0
	CALL	TestForFloppyDisk
	bpl.s	.NoRealUnit0

	bset.b	#0,DMD_ExistFlag(a4)		; denote unit exists

	move.l	a3,a1				; get disk change count
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),DMD_ChgCount0(a4)		; fill in
*							; change count

	move.l	a3,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),d0		; disk in drive?
	bne.s	.NoDisk0			; if not - skip on

	bset.b	#0,DMD_DiskIn(a4)		; denote disk in unit

.NoDisk0:
.NoRealUnit0:
	move.l	a3,a1			; now close the unit
	CALLROM	CloseDevice

.NoUnit0:
	lea	DMD_TDName(a4),a0	; attempt to open unit 1
	lea	DMD_IOReq1(a4),a3
	move.l	a3,a1
	move.l	a2,MN_REPLYPORT(a1)
	moveq	#1,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit1		; if unit not opened - skip on

	moveq	#1,d0			; now see if the unit really exists
	move.l	a3,a0
	CALL	TestForFloppyDisk
	bpl.s	.NoRealUnit1

	bset.b	#1,DMD_ExistFlag(a4)		; denote unit exists

	move.l	a3,a1				; get disk change count
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),DMD_ChgCount1(a4)		; fill in
*							; change count

	move.l	a3,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),d0		; disk in drive?
	bne.s	.NoDisk1			; if not - skip on

	bset.b	#1,DMD_DiskIn(a4)		; denote disk in unit

.NoDisk1:
.NoRealUnit1:
	move.l	a3,a1			; now close the unit
	CALLROM	CloseDevice

.NoUnit1:
	lea	DMD_TDName(a4),a0	; attempt to open unit 2
	lea	DMD_IOReq2(a4),a3
	move.l	a3,a1
	move.l	a2,MN_REPLYPORT(a1)
	moveq	#2,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit2		; if unit not opened - skip on

	moveq	#2,d0			; now see if the unit really exists
	move.l	a3,a0
	CALL	TestForFloppyDisk
	bpl.s	.NoRealUnit2

	bset.b	#2,DMD_ExistFlag(a4)		; denote unit exists

	move.l	a3,a1				; get disk change count
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),DMD_ChgCount2(a4)		; fill in
*							; change count

	move.l	a3,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),d0		; disk in drive?
	bne.s	.NoDisk2			; if not - skip on

	bset.b	#2,DMD_DiskIn(a4)		; denote disk in unit

.NoDisk2:
.NoRealUnit2:
	move.l	a3,a1			; now close the unit
	CALLROM	CloseDevice

.NoUnit2:
	lea	DMD_TDName(a4),a0	; attempt to open unit 3
	lea	DMD_IOReq3(a4),a3
	move.l	a3,a1
	move.l	a2,MN_REPLYPORT(a1)
	moveq	#3,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit3		; if unit not opened - skip on

	moveq	#3,d0			; now see if the unit really exists
	move.l	a3,a0
	CALL.s	TestForFloppyDisk
	bpl.s	.NoRealUnit3

	bset.b	#3,DMD_ExistFlag(a4)		; denote unit exists

	move.l	a3,a1				; get disk change count
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),DMD_ChgCount3(a4)		; fill in
*							; change count

	move.l	a3,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a3),d0		; disk in drive?
	bne.s	.NoDisk3			; if not - skip on

	bset.b	#3,DMD_DiskIn(a4)		; denote disk in unit

.NoDisk3:
.NoRealUnit3:
	move.l	a3,a1			; now close the unit
	CALLROM	CloseDevice

.NoUnit3:
	CLEAR	d0
	move.b	DMD_ExistFlag(a4),d0		; return what was found

.ExitQ:
	REST	a2-a4/a6
	rts

****
*
* Private functions to FloppyDisk routines.
*
****

****
*
* TestForFloppyDisk
*
* This function determines if the specified floppy disk drive unit really
* does exist.
*
* BOOL TestForFloppyDisk( Device, DeviceReq, ToastBase, ExecLib );
*  N flag                  D0      A0         a5          A6
*
* BYTE Device:
*   Represents the floppy drive unit number 0-3.
*
* APTR DeviceReq:
*   Pointer to a valid trackdisk.device IO request for the floppy drive unit
*   0-3.
*
* APTR ExecLib:
*   Pointer to ExecBase. The trackdisk.device is assumed open.
*
* Notes:
*   Trashes no registers. Returns the N flag set if the floppy drive unit
*   specified exists. Returns the N flag reset otherwise. Works by first
*   moving the head to track 0 of the specified floppy disk drive unit will
*   in a Forbidden state. A Disabled state is then entered and the specified
*   floppy disk drive unit selected, the head stepped, and the track 0 flag
*   checked to see if the head is over track 0. The track 0 flag is the
*   validation key of this routine. The routine could be broken if someone
*   is messing with the specified floppy disk drive unit hardware using
*   interrupt code.
*   WARNING: This code plays directly with the hardware of the CIAs.
*
* Addendum 2/14/90:
*
****

TestForFloppyDisk:
	SAVE	d0-d3/a0-a2

	move.b	d0,d2
	move.l	a0,a2

	CALLROM	Forbid

	move.l	a2,a1
	move.w	#TD_SEEK,IO_COMMAND(a1)		; get us over track 2
	CLEAR	d0
	clr.b	IO_FLAGS(a1)
	move.l	#2*TD_SECTOR*NUMSECS,IO_OFFSET(a1)
	CALLROM	DoIO

;;	CALLROM	Disable
	CALLTL	AllInterruptsOff	;SKELL 9/11/92

	moveq	#8,d3
	lsl.b	d2,d3
	move.b	d3,d2
	not.b	d3

	and.b	d3,$BFD100	; select drive
	moveq	#1*16,d0
	CALL	ScanLineWait

	or.b	#$03,$BFD100	; set step dir out - assure no step pulse
	move.w	#18*16,d0
	CALL	ScanLineWait

	moveq	#9,d1		; loop counter

.StepLoop:
	and.b	#$FE,$BFD100	; pulse step out toward track 0
	moveq	#1,d0
	CALL.s	ScanLineWait
	or.b	#$01,$BFD100

	move.w	#18*16,d0
	CALL.s	ScanLineWait	; wait for head to move and disk to settle

	move.b	$BFE001,d0	; over track 0? - set accordingly
	and.b	#$10,d0

	dbeq	d1,.StepLoop	; reloop if track 0 not found

	seq	d3		; setup flag according to the result

	bne.s	.NoDrive	; if no drive found - skip the following

	or.b	#$02,$BFD100	; set step dir in
	move.w	#18*16,d0
	CALL.s	ScanLineWait

	and.b	#$FE,$BFD100	; pulse step in back to track 2 (hopefully)
	moveq	#1,d0
	CALL.s	ScanLineWait
	or.b	#$01,$BFD100

	moveq	#4*16,d0
	CALL.s	ScanLineWait	; wait for head to move

	and.b	#$FE,$BFD100	; pulse step in again
	moveq	#1,d0
	CALL.s	ScanLineWait
	or.b	#$01,$BFD100

	moveq	#4*16,d0
	CALL.s	ScanLineWait	; wait for head to move

.NoDrive:
	or.b	d2,$BFD100	; de-select drive

;;	CALLROM	Enable
	CALLTL	AllInterruptsOn	;SKELL 9/11/92

	CALLROM	Permit

	move.b	d3,d0
	REST	d0-d3/a0-a2
	rts

****
*
* ScanLineWait
*
* This function waits for specified number of horizontal scan lines.
* Guaranteed accuracy of N to N+1 scan lines.
*
* void ScanLineWait(#scanlines);
*
* Notes:
*   Trashes only the condition codes, no registers.
*   Use to use $BFD800=lsb of Horiz. Sync TOD Clock.  This clock can break
*   if the Toaster is locking up the HSYNC line, so instead we now (10-9-91)
*   are using the VHPOSR register.
*   This should only be called while in a Disabled state. On an NTSC
*   timed AMIGA, a horizontal scan takes 63.7 us, and 1 ms = 15.69858713
*   scan lines.
*
* Addendum 2/14/90:
*
*
****

ScanLineWait:
	SAVE	d0-d3/a0

	lea	_custom+vhposr,a0
	moveq	#1,d3
	move.b	(a0),d1
	and.b	d3,d1

.Loop1:
	move.b	(a0),d2
	and.b	d3,d2
	eor.b	d1,d2
	beq.s	.Loop1
	dbf	d0,.Loop2

10$	REST	d0-d3/a0
	rts

.Loop2:
	move.b	(a0),d2
	and.b	d3,d2
	eor.b	d1,d2
	bne.s	.Loop2
	dbf	d0,.Loop1
	bra.s	10$

	CNOP	0,4

DiskManagerData:	; Data area for DiskManager system
.DMD:

*---
	DATASYM	DMD_Port,.DMD		; message port for IO requests
	DC.l	0

*---
	DATASYM	DMD_ChgCount0,.DMD	; disk change counts for units 0-3
	DC.l	0

	DATASYM	DMD_ChgCount1,.DMD
	DC.l	0

	DATASYM	DMD_ChgCount2,.DMD
	DC.l	0

	DATASYM	DMD_ChgCount3,.DMD
	DC.l	0

*---
	DATASYM	DMD_IOReq0,.DMD		; IOExtTDs for units 0-3 -
*					; ready to go except for port field
	DCB.b	LN_NAME,0
	DC.l	.U0Name
	DCB.b	IOTD_SIZE-LN_SIZE,0

	DATASYM	DMD_IOReq1,.DMD
	DCB.b	LN_NAME,0
	DC.l	.U1Name
	DCB.b	IOTD_SIZE-LN_SIZE,0

	DATASYM	DMD_IOReq2,.DMD
	DCB.b	LN_NAME,0
	DC.l	.U2Name
	DCB.b	IOTD_SIZE-LN_SIZE,0

	DATASYM	DMD_IOReq3,.DMD
	DCB.b	LN_NAME,0
	DC.l	.U3Name
	DCB.b	IOTD_SIZE-LN_SIZE,0

*---
	DATASYM	DMD_ExistFlag,.DMD	; uses bits 0-3 for mask - bit
*					; set only occurs if unit is shown
*					; to exist after hardware tests
	DC.b	0

	DATASYM	DMD_DiskIn,.DMD		; uses bits 0-3 for mask - bit
*					; set only if unit has disk inserted
	DC.b	0

*---
	DATASYM	DMD_TDName,.DMD
	TD_NAME

	DATASYM	DMD_PortName,.DMD
	DC.b	'Switcher TrackDisk Port',0

.U0Name:
	DC.b	'Disk Unit 0 Message',0

.U1Name:
	DC.b	'Disk Unit 1 Message',0

.U2Name:
	DC.b	'Disk Unit 2 Message',0

.U3Name:
	DC.b	'Disk Unit 3 Message',0

	CNOP	0,2

EndDMData:

*+*******
*+
*+ FloppyDiskChange
*+
*+ This function returns a bit mask representing floppy drives that are both
*+ allocated, exist, have had a disk change occur, and if a disk is
*+ presently in that unit or not.
*+
*+ LONG FloppyDiskChange();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns a bit mask in D0 where bit sets 0-3 and 8-11
*+   correspond to units 0-3. All other bits will be cleared. A mask bit
*+   position in the set of 0-3 will only be set if the unit is allocated and
*+   exists and a disk change has occured in that unit. A mask bit position
*+   in the set of 8-11 is only valid if its corresponding bit in the set of
*+   of 0-3 is set. A bit set in the set 8-11 means that a disk is currently
*+   inserted in that unit. The inverse is true if the bit is reset.
*+   The condition codes will be set according to the result in D0. Requires
*+   that a pointer to ToasterBase be present in A5, but is not closely tied
*+   to the Switcher display. This routine ABSOLUTELY DEPENDS on the
*+   FloppyDiskTest() function having been run before it to setup the floppy
*+   disk exists flags AND to setup a valid replyport in the IO request
*+   messages for the the trackdisk.device.
*+
*+ Addendum 2/1/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_FloppyDiskChange
_FloppyDiskChange:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FloppyDiskChange
	REST1	a5
	rts

	ENDC

	XDEF	FloppyDiskChange
FloppyDiskChange:
	SAVE	d2/a2/a4/a6

	lea	DiskManagerData(pc),a4	; address private data
	GET.l	TB_SYSBase,a6		; and get exec base
	CLEAR	d2			; clear result accumulator

	move.l	DMD_Port(a4),d0		; has the FloppyDiskTest() been run
*					; before and the results still valid?
	beq	.ExitQ			; if not - don't run this routine

	btst.b	#0,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit0		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 0
	lea	DMD_IOReq0(a4),a2
	move.l	a2,a1
	CLEAR	d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit0		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount0(a4),d0		; any change?
	beq.s	.NoChange0			; if not - skip on

	bset.l	#0,d2			; else denote a change occured
	move.l	d0,DMD_ChgCount0(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange0			; if not - skip on

	bset.l	#0+8,d2				; else denote disk in drive

.NoChange0:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit0:
	btst.b	#1,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit1		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 1
	lea	DMD_IOReq1(a4),a2
	move.l	a2,a1
	moveq	#1,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit1		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount1(a4),d0		; any change?
	beq.s	.NoChange1			; if not - skip on

	bset.l	#1,d2			; else denote a change occured
	move.l	d0,DMD_ChgCount1(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange1			; if not - skip on

	bset.l	#1+8,d2				; else denote disk in drive

.NoChange1:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit1:
	btst.b	#2,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit2		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 2
	lea	DMD_IOReq2(a4),a2
	move.l	a2,a1
	moveq	#2,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit2		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount2(a4),d0		; any change?
	beq.s	.NoChange2			; if not - skip on

	bset.l	#2,d2			; else denote a change occured
	move.l	d0,DMD_ChgCount2(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange2			; if not - skip on

	bset.l	#2+8,d2				; else denote disk in drive

.NoChange2:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit2:
	btst.b	#3,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit3		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 3
	lea	DMD_IOReq3(a4),a2
	move.l	a2,a1
	moveq	#3,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit3		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount3(a4),d0		; any change?
	beq.s	.NoChange3			; if not - skip on

	bset.l	#3,d2			; else denote a change occured
	move.l	d0,DMD_ChgCount3(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange3			; if not - skip on

	bset.l	#3+8,d2				; else denote disk in drive

.NoChange3:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit3:

.ExitQ:
	move.l	d2,d0			; place return codes in D0
	REST	d2/a2/a4/a6
	rts

*+*******
*+
*+ FloppyDiskQuery
*+
*+ This function returns a bit mask representing floppy drives that are both
*+ allocated, exist, have had a disk change occur, and if a disk is
*+ presently in that unit or not. This function is identical to
*+ FloppyDiskChange() except that the internal disk change counters ARE NOT
*+ updated as in FloppyDiskChange(). This allows the disk change information
*+ to remain valid after a call to FloppyDiskQuery().
*+
*+ LONG FloppyDiskQuery();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns a bit mask in D0 where bit sets 0-3 and 8-11
*+   correspond to units 0-3. All other bits will be cleared. A mask bit
*+   position in the set of 0-3 will only be set if the unit is allocated and
*+   exists and a disk change has occured in that unit. A mask bit position
*+   in the set of 8-11 is only valid if its corresponding bit in the set of
*+   of 0-3 is set. A bit set in the set 8-11 means that a disk is currently
*+   inserted in that unit. The inverse is true if the bit is reset.
*+   The condition codes will be set according to the result in D0. Requires
*+   that a pointer to ToasterBase be present in A5, but is not closely tied
*+   to the Switcher display. This routine ABSOLUTELY DEPENDS on the
*+   FloppyDiskTest() function having been run before it to setup the floppy
*+   disk exists flags AND to setup a valid replyport in the IO request
*+   messages for the the trackdisk.device.
*+
*+ Addendum 3/27/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_FloppyDiskQuery
_FloppyDiskQuery:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FloppyDiskQuery
	REST1	a5
	rts

	ENDC

	XDEF	FloppyDiskQuery
FloppyDiskQuery:
	SAVE	d2/a2/a4/a6

	lea	DiskManagerData(pc),a4	; address private data
	GET.l	TB_SYSBase,a6		; and get exec base
	CLEAR	d2			; clear result accumulator

	move.l	DMD_Port(a4),d0		; has the FloppyDiskTest() been run
*					; before and the results still valid?
	beq	.ExitQ			; if not - don't run this routine

	btst.b	#0,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit0		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 0
	lea	DMD_IOReq0(a4),a2
	move.l	a2,a1
	CLEAR	d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit0		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount0(a4),d0		; any change?
	beq.s	.NoChange0			; if not - skip on

	bset.l	#0,d2			; else denote a change occured
;;;;	move.l	d0,DMD_ChgCount0(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange0			; if not - skip on

	bset.l	#0+8,d2				; else denote disk in drive

.NoChange0:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit0:
	btst.b	#1,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit1		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 1
	lea	DMD_IOReq1(a4),a2
	move.l	a2,a1
	moveq	#1,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit1		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount1(a4),d0		; any change?
	beq.s	.NoChange1			; if not - skip on

	bset.l	#1,d2			; else denote a change occured
;;;;	move.l	d0,DMD_ChgCount1(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange1			; if not - skip on

	bset.l	#1+8,d2				; else denote disk in drive

.NoChange1:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit1:
	btst.b	#2,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit2		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 2
	lea	DMD_IOReq2(a4),a2
	move.l	a2,a1
	moveq	#2,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit2		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount2(a4),d0		; any change?
	beq.s	.NoChange2			; if not - skip on

	bset.l	#2,d2			; else denote a change occured
;;;;	move.l	d0,DMD_ChgCount2(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange2			; if not - skip on

	bset.l	#2+8,d2				; else denote disk in drive

.NoChange2:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit2:
	btst.b	#3,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit3		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 3
	lea	DMD_IOReq3(a4),a2
	move.l	a2,a1
	moveq	#3,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit3		; if unit not opened - skip on

	move.l	a2,a1				; check change number
	move.w	#TD_CHANGENUM,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; get change number
	cmp.l	DMD_ChgCount3(a4),d0		; any change?
	beq.s	.NoChange3			; if not - skip on

	bset.l	#3,d2			; else denote a change occured
;;;;	move.l	d0,DMD_ChgCount3(a4)	; and save the new count

	move.l	a2,a1				; now check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoChange3			; if not - skip on

	bset.l	#3+8,d2				; else denote disk in drive

.NoChange3:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit3:

.ExitQ:
	move.l	d2,d0			; place return codes in D0
	REST	d2/a2/a4/a6
	rts

*+*******
*+
*+ FloppyDiskInfo
*+
*+ This function returns information on what floppy units exists and are
*+ allocated, if they currently have a disk inserted, and if they have a disk
*+ inserted, whether or not the disk is write protected.
*+
*+ void FloppyDiskInfo();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns a bit mask in D0 where bit sets 0-3, 8-11, and
*+   16-19 correspond to units 0-3. All other bits will be cleared. A mask
*+   bit position in the set of 0-3 will only be set if the unit is allocated
*+   and exists. A mask bit position in the set of 8-11 is only valid if its
*+   corresponding bit in the set of of 0-3 is set. A bit set in the set 8-11
*+   means that a disk is currently inserted in that unit. The inverse is
*+   true if the bit is reset. A mask bit in the set of 16-19 is only valid
*+   if its corresponding bit is set in both sets 0-3 and 8-11. A bit set in
*+   the set 16-19 indicates that the disk inserted is write protected. The
*+   inverse is true if the bit is reset.
*+   The condition codes will be set according to the result in D0. Requires
*+   that a pointer to ToasterBase be present in A5, but is not closely tied
*+   to the Switcher display. This routine ABSOLUTELY DEPENDS on the
*+   FloppyDiskTest() function having been run before it to setup the floppy
*+   disk exists flags AND to setup a valid replyport in the IO request
*+   messages for the the trackdisk.device.
*+
*+ Addendum 3/30/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_FloppyDiskInfo
_FloppyDiskInfo:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FloppyDiskInfo
	REST1	a5
	rts

	ENDC

	XDEF	FloppyDiskInfo
FloppyDiskInfo:
	SAVE	d2/a2/a4/a6

	lea	DiskManagerData(pc),a4	; address private data
	GET.l	TB_SYSBase,a6		; and get exec base
	CLEAR	d2			; clear result accumulator

	move.l	DMD_Port(a4),d0		; has the FloppyDiskTest() been run
*					; before and the results still valid?
	beq	.ExitQ			; if not - don't run this routine

	btst.b	#0,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit0		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 0
	lea	DMD_IOReq0(a4),a2
	move.l	a2,a1
	CLEAR	d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit0		; if unit not opened - skip on

	bset.l	#0,d2			; drive exists and was obtained

	move.l	a2,a1				; check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoDisk0			; if not - skip on

	bset.l	#0+8,d2				; else denote disk in drive

	move.l	a2,a1				; check on protect status
	move.w	#TD_PROTSTATUS,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; write protected?
	beq.s	.NoProt0			; if not - skip on

	bset.l	#0+16,d2			; else denote write protect

.NoProt0:
.NoDisk0:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit0:
	btst.b	#1,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit1		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 1
	lea	DMD_IOReq1(a4),a2
	move.l	a2,a1
	moveq	#1,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit1		; if unit not opened - skip on

	bset.l	#1,d2			; drive exists and was obtained

	move.l	a2,a1				; check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoDisk1			; if not - skip on

	bset.l	#1+8,d2				; else denote disk in drive

	move.l	a2,a1				; check on protect status
	move.w	#TD_PROTSTATUS,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; write protected?
	beq.s	.NoProt1			; if not - skip on

	bset.l	#1+16,d2			; else denote write protect

.NoProt1:
.NoDisk1:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit1:
	btst.b	#2,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit2		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 2
	lea	DMD_IOReq2(a4),a2
	move.l	a2,a1
	moveq	#2,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit2		; if unit not opened - skip on

	bset.l	#2,d2			; drive exists and was obtained

	move.l	a2,a1				; check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoDisk2			; if not - skip on

	bset.l	#2+8,d2				; else denote disk in drive

	move.l	a2,a1				; check on protect status
	move.w	#TD_PROTSTATUS,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; write protected?
	beq.s	.NoProt2			; if not - skip on

	bset.l	#2+16,d2			; else denote write protect

.NoProt2:
.NoDisk2:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit2:
	btst.b	#3,DMD_ExistFlag(a4)	; unit exist?
	beq.s	.NoUnit3		; if not - skip

	lea	DMD_TDName(a4),a0	; attempt to open unit 3
	lea	DMD_IOReq3(a4),a2
	move.l	a2,a1
	moveq	#3,d0
	CLEAR	d1
	CALLROM	OpenDevice
	move.l	d0,d0
	bne.s	.NoUnit3		; if unit not opened - skip on

	bset.l	#3,d2			; drive exists and was obtained

	move.l	a2,a1				; check on disk status
	move.w	#TD_CHANGESTATE,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; disk in drive?
	bne.s	.NoDisk3			; if not - skip on

	bset.l	#3+8,d2				; else denote disk in drive

	move.l	a2,a1				; check on protect status
	move.w	#TD_PROTSTATUS,IO_COMMAND(a1)
	clr.b	IO_FLAGS(a1)
	CALLROM	DoIO
	move.l	IO_ACTUAL(a2),d0		; write protected?
	beq.s	.NoProt3			; if not - skip on

	bset.l	#3+16,d2			; else denote write protect

.NoProt3:
.NoDisk3:
	move.l	a2,a1
	CALLROM	CloseDevice		; close the unit

.NoUnit3:

.ExitQ:
	move.l	d2,d0			; place return codes in D0
	REST	d2/a2/a4/a6
	rts

*+*******
*+
*+ RemFloppyDiskPort
*+
*+ This function frees up the FloppyDiskTest() function's allocated message
*+ port - if any.
*+
*+ void RemFloppyDiskPort()
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. Requires
*+   a pointer to ToasterBase in A5. It is not closely tied to the Switcher
*+   display system. This functions also NULLs the port field after
*+   de-allocation.
*+
*+ Addendum 2/27/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_RemFloppyDiskPort
_RemFloppyDiskPort:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	RemFloppyDiskPort
	REST1	a5
	rts

	ENDC

	XDEF	RemFloppyDiskPort
RemFloppyDiskPort:
	lea	DiskManagerData(pc),a1	; address private data

	move.l	DMD_Port(a1),d0		; does port exist?
	beq.s	.Exit

	move.l	d0,a0			; prepare function argument

	CLEAR	d0			; now denote that port is gone
	move.l	d0,DMD_Port(a1)

	XCALL	DeletePort		; now remove the port

.Exit:
	rts

*+*******
*+
*+ FloppyDiskFormat
*+
*+ This function formats the floppy disk on the specified unit giving it the
*+ specified name. This function will also put up a formatting notice on the
*+ display if requested.
*+
*+ LONG FloppyDiskFormat( Unit, ShowFlag, Name );
*+  D0                     D0    D1        A0
*+
*+ LONG Unit:
*+   Longword value must be a floppy unit 0-3.
*+
*+ LONG ShowFlag:
*+   Longword flag - 0 denotes no formatting notice is to be presented on
*+   the display - non-0 denotes that a formatting notice be presented.
*+
*+ APTR Name:
*+   Pointer to a C type string that is to be used as the name for the disk
*+   that will be formatted.
*+
*+ Notes:
*+   Trashes D1,A0,A1. The condition codes will be set to the result returned
*+   in D0. 0 will be returned in D0 if everything went OK and the disk will
*+   have been formatted. A negative error code will be returned if something
*+   went wrong. If this function was requested to put up a formatting notice
*+   on the Switcher interface, then when the format is complete, the
*+   interace will be re-displayed via ReDoDisplay(). This function also uses
*+   the TB_FileBuff area to form the format string to pass to the DOS
*+   execute function. This function needs a pointer to ToasterBase in A5 and
*+   is tied closely with the Switcher system.
*+
*+ Addendum 4/27/90:
*+ Addendum 2/11/91:
*+  Now uses the wait SoftSprite imagery system rather than turning off the
*+  SoftSprite for the duration of the call. This is done ONLY if the caller
*+  has specified that he wants the formatting notice. This routine remembers
*+  the previous SoftSprite imagery state and will restore to that state.
*+
*+*******

	IFNE	_CCODE

	XDEF	_FloppyDiskFormat
_FloppyDiskFormat:
	movem.l	4(sp),d0/d1/a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FloppyDiskFormat
	REST1	a5
	rts

	ENDC

	XDEF	FloppyDiskFormat
FloppyDiskFormat:	; entry: Unit, ShowFlag, Name
*				  D0    D1        A0

	SAVE	d2-d7/a2/a6		; save work registers

	cmp.l	#4,d0			; is the requested unit valid?
	bcs.s	.OKUnit

	moveq	#-1,d0			; else denote the error
	bra	.Exit

.OKUnit:
	move.l	d0,d4			; keep binary unit number safe
	move.l	d1,d5			; hold onto requester flag
	move.l	a0,a2			; hold onto format name string

	CALL	FloppyDiskInfo		; get floppy disk system info
	move.l	d4,d1
	btst.l	d1,d0			; does the disk unit exist?
	bne.s	.DoesExist

	moveq	#-2,d0			; else denote the error
	bra	.Exit

.DoesExist:
	addq.w	#8,d1			; is there a disk inserted?
	btst.l	d1,d0
	bne.s	.HasDisk

	moveq	#-3,d0			; else denote the error
	bra	.Exit

.HasDisk:
	addq.w	#8,d1			; is the disk write protected?
	btst.l	d1,d0
	beq.s	.NoWriteProtect

	moveq	#-4,d0			; else denote the error
	bra	.Exit

.NoWriteProtect:
	move.l	d4,d0
	add.b	#'0',d0			; make ascii digit from unit number
	lea	.UnitNum(pc),a0		; and setup unit string
	move.b	d0,(a0)

	GET.l	TB_FileBuff,a1		; address buffer where resulting
*					; format string is to be made

	lea	.FormStr1(pc),a0	; form the format string
	CALL	STRcopy
	lea	.FormStr2(pc),a0
	CALL	STRcopy
	move.l	a2,a0
	CALL	STRcopy
	lea	.FormStr3(pc),a0
	CALL	STRcopy

	tst.l	d5			; put up a formatting notice?
	beq	.NoPrompt		; nope - skip over

	lea	1(a1),a1		; address buffer just format string
	move.l	a1,a2			; hold onto this pointer

	lea	.FormatMessage(pc),a0	; create message for USER
	CALL	STRcopy
	lea	.DevStr(pc),a0
	CALL	STRcopy

	GET.l	TB_SYSBase,a6
	CALLROM	Forbid
	XCALL	SoftSpriteOff

	XCALL	GetDisplaySprite
	move.l	d0,d7
	bmi.s	.NoSpriteChange1

	XCALL	DisplayWaitSprite

.NoSpriteChange1:
	move.l	#220,d0			; draw our island backdrop
	move.l	#160,d1
	move.l	#300,d2
	move.l	#100,d3
	XCALL	DrawBorderBox
 ifeq 1
	GET.l	TB_ITUBase,a6
	GET.l	TB_RastPort,a0
	lea	.ImageStruct(pc),a1
	GET.w	TB_InterfaceDepth,ig_Depth(a1)
	CLEAR	d0
	CLEAR	d1
	CALLROM	DrawImage
 endc
	GET.l	TB_GFXBase,a6		; now put out the text message

	GET.l	TB_RastPort,a1
	move.l	#280+32,d0
	move.l	#204,d1
	CALLROM	Move

	move.l	a2,a0
	GET.l	TB_RastPort,a1
	CALL	STRlen
	CALLROM	Text

	GET.l	TB_RastPort,a1
	move.l	#300+25,d0
	move.l	#224,d1
	CALLROM	Move

	lea	.Waiting(pc),a0
	GET.l	TB_RastPort,a1
	CALL	STRlen
	CALLROM	Text

	XCALL	SoftSpriteOn
	GET.l	TB_SYSBase,a6
	CALLROM	Permit

.NoPrompt:
	GET.l	TB_SYSBase,a6		; make sure IDCMP shutdown except
	CALLROM	Forbid			; for diskchange IDCMP
	GET.l	TB_Window,a0
	move.l	wd_IDCMPFlags(a0),d6
	move.l	#DISKINSERTED+DISKREMOVED,d0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP
	GET.l	TB_SYSBase,a6
	CALLROM	Permit

	CLEAR	d4			; assume everything goes OK

	GET.l	TB_BootLock,d1		; assure we CurrentDir()ed to a
	GET.l	TB_DOSBase,a6		; valid directory
	CALLROM	CurrentDir

	move.l	d5,-(sp)		; This is a bug fix done July 3 1991
					; to fix formating from WB KT.
	lea	constring(pc),a0
	move.l	a0,d1
	move.l	#MODE_NEWFILE,D2
	CALLROM	Open
	move.l	d0,d5
	bne.s	133$
	moveq	#-5,d4			; else denote an error
	bra.s	134$
133$
	GET.l	TB_FileBuff,d1		; now fire up the format operation
	moveq.l	#0,d2
	move.l	d5,d3
	CALLROM	Execute
	move.l	d0,d0
	bne.s	888$
	moveq	#-5,d4			; else denote an error
888$
	move.l	d5,d1
	CALLROM	Close
134$
	move.l	(sp)+,d5

 ifeq 1
	GET.l	TB_FileBuff,d1		; now fire up the format operation
	CLEAR	d2
	CLEAR	d3
	CALLROM	Execute
	move.l	d0,d0			; how went/goes the operation?
	bne.s	.SeemsOK		; if OK - skip on

	moveq	#-5,d4			; else denote an error
 endc
.SeemsOK:
	GET.l	TB_SYSBase,a6		; restore original IDCMP
	CALLROM	Forbid
	GET.l	TB_Window,a0
	move.l	d6,d0
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP
	GET.l	TB_SYSBase,a6
	CALLROM	Permit

	tst.l	d5			; display need to be refreshed?
	beq.s	.ContOn			; nope - skip on

	CALLTL	ReDoDisplay		; else re-display whatever Switcher
*					; interface display is active

	tst.l	d7
	bmi.s	.NoSpriteChange2

	XCALL	DisplayNormalSprite

.NoSpriteChange2:
.ContOn:
	move.l	d4,d5			; setup return code

.Exit:
	REST	d2-d7/a2/a6		; restore work register
	rts

.ImageStruct:
	DC.w	240			; ig_LeftEdge
	DC.w	180			; ig_TopEdge
	DC.w	260			; ig_Width
	DC.w	60			; ig_Height
	DC.w	0	;MAXDISPLAYDEPTH filled in later ; ig_Depth
	DC.l	0			; ig_ImageData
	DC.b	0			; ig_PlanePick
	DC.b	0			; ig_PlaneOnOff
	DC.l	0			; ig_NextImage

.FormStr1:
	DC.b	'sys:system/Format <NIL: >NIL: Drive '

.DevStr:
	DC.b	'DF'
.UnitNum:
	DC.b	*-*,':',0

.FormStr2:
	DC.b	' Name "',0

.FormStr3:
	DC.b	'" NoIcons',0

.FormatMessage:
	DC.b	'Formatting ',0

.Waiting:
	DC.b	'Please Wait',0

constring	dc.b	'nil:',0,0

	CNOP	0,4

************************************************************
	IFD	CRAP4

*+*******
*+
*+ ToolBoxFill
*+
*+ This function fills in the ToolBox grid of the Switcher display with
*+ dummy ToolBox FastGadgets where vacancy exists.
*+
*+ void ToolBoxFill( ToolBoxFGLBase );
*+                    A0
*+
*+ APTR ToolBoxFGLBase:
*+   Pointer to the base of the FGL of the ToolBox FastGadgets representing
*+   the ToolBox grid you want to be filled in.
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. Requires
*+   a pointer to ToasterBase in A5 and is closely tied to the Switcher
*+   display system. This function directly renders into the display. The
*+   FGL base pointer you provide must point to a valid list of ToolBox
*+   FastGadgets. Also note that SoftSpriteOn/Off is NOT used in this
*+   routine. You must do that yourself.
*+
*+ Addendum 2/10/90:
*+ Addendum 11/28/90:
*+   Added a check to see if a ToolBox crouton is displayable. If it is not,
*+   then allow its vacancy to be filled in. This is primarily in those
*+   situations where the dummy crouton is installed in an otherwise empty
*+   ToolBox grid.
*+
*+*******

*+	IFNE	_CCODE
*+
*+	XDEF	_ToolBoxFill
*+_ToolBoxFill:
*+	move.l	4(sp),a0
*+	SAVE1	a5
*+	lea	_ToasterBase,a5
*+	CALL.s	ToolBoxFill
*+	REST1	a5
*+	rts
*+
*+	ENDC
*+
*+	XDEF	ToolBoxFill
*+ToolBoxFill:	; entry: TBFGLBase
*+*			  A0
*+	SAVE	d2/d3/a2-a4		; save work registers
*+
*+	move.l	sp,a3			; keep a copy of stack pointer
*+
*+	move.l	sp,d0			; longword align stack pointer
*+	and.b	#$FC,d0
*+	move.l	d0,sp
*+
*+	CLEAR	d0			; clear out occupancy array
*+	moveq	#TBFG_GRIDSIZE/4,d1
*+
*+.Loop1:
*+	move.l	d0,-(sp)
*+	dbf	d1,.Loop1
*+
*+	move.l	sp,a4			; now setup occupancy array
*+
*+.Loop2:
*+	move.l	(a0),d0			; another TB FG?
*+	beq.s	.ExitLoop2		; if end of list - skip out
*+
*+	move.l	d0,a0			; else address TB FG
*+
*+	tst.b	FG_DispFlag(a0)		; Addendum 11/28/90: crouton not
*+*					; displayable? - allow vacancy to be
*+*					; filled if so
*+	bne.s	.Loop2
*+
*+	CLEAR	d0			; get its position in the grid
*+	move.w	FG_IndexID(a0),d0
*+	divu	#TBFG_GRIDSIZE,d0
*+	swap	d0
*+
*+	move.b	#-1,0(a4,d0.w)		; denote the TB FG's occupancy
*+
*+	bra.s	.Loop2			; loop till done with list
*+
*+.ExitLoop2:
*+	CLEAR	d2			; now render dummy TB FG where there
*+	moveq	#TBFG_GRIDSIZE-1,d3	; are vacancies
*+
*+.Loop3:
*+	tst.b	(a4)+			; check for next grid position
*+*					; occupancy
*+	bne.s	.Loop3Tail		; if occupied - skip to next
*+
*+	lea	.DummyTBFG(pc),a0	; fill in the vacant spot
*+	move.w	d2,FG_IndexID(a0)
*+
*+	CALL	PutNewLocTB		; get dummy TB FG setup
*+
*+	lea	.DummyTBFG(pc),a0	; now display it
*+	GET.l	TB_Window,a1
*+;;	CLEARA	a2
*+	moveq	#1,d0
*+	CLEAR	d1
*+	CALL	DrawFastGList
*+
*+.Loop3Tail:
*+	addq.w	#1,d2			; bump to next location to inspect
*+	dbf	d3,.Loop3		; reloop till entire grid filled
*+
*+	move.l	a3,sp			; restore stack pointer
*+
*+	REST	d2/d3/a2-a4		; restore work registers
*+	rts				; return to caller
*+
*+.DummyTBFG:
*+
*+_w	SET	80
*+_h	SET	48
*+
*+	DC.l	0			; gg_NextGadget
*+	DC.w	*-*			; gg_LeftEdge
*+	DC.w	*-*			; gg_TopEdge
*+	DC.w	_w			; gg_Width
*+	DC.w	_h			; gg_Height
*+	DCB.b	gg_SIZEOF-gg_Flags,0	; clear rest of Gadget structure
*+	DC.w	DISPLAYMODE5		; FG_ModeType
*+	DC.w	_w/16-1			; FG_WWidth
*+	DC.w	_h-1			; FG_Height
*+	DC.w	DISPLAYWIDTH/8-_w/8	; FG_Modulus
*+	DC.l	*-*			; FG_Offset
*+	DC.l	._Img_1			; FG_Data
*+	DC.w	1			; FG_EntrySize
*+	DC.w	0			; FG_PTRIndex
*+	DC.l	._Img_PTRS		; FG_PTRTable
*+	DC.l	0			; FG_Function
*+	DC.b	0			; FG_LoadFlag
*+	DC.b	0			; FG_DispFlag
*+	DC.b	-1			; FG_MouseFlag
*+	DC.b	0			; FG_HiLiteVal
*+	DC.w	0			; FG_IndexID
*+	DC.w	0			; FG_HiLiteMask
*+	DC.w	0			; FG_BorderCon
*+	DC.w	0			; FG_TopSize
*+	DC.w	0			; FG_BotSize
*+	DC.w	0			; FG_LeftWSize
*+	DC.w	0			; FG_RightWSize
*+	DC.w	0			; FG_LeftMask
*+	DC.w	0			; FG_RightMask
*+	DC.w	0			; FG_Extra1
*+
*+	DCB.b	FG_SIZ-FG_Extra1-2,0
*+
*+._Img_PTRS:
*+	DC.l	._Img_1
*+
*+._Img_1:
*+ DC.W 4095,61440,0,65535,0,0,65535,0,0,65535,0,0
*+ DC.W 65520,15,0,8191,61439,4095,65535,65535,65535,65535,65535,65535
*+ DC.W 65535,65535,65535,65528,65527,65520,16383,57343,8191,65535,65535,65535
*+ DC.W 65535,65535,65535,65535,65535,65535,65532,65531,65520,32767,47104,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,29,65504
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,45056,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,13,65520,32767,45056,16383,65535,0,65535,65535,0,65535
*+ DC.W 65535,0,65535,65534,13,65520,32767,45056,16383,65535,0,65535
*+ DC.W 65535,0,65535,65535,0,65535,65534,13,65520,32767,45056,16383
*+ DC.W 65535,0,65535,65535,0,65535,65535,0,65535,65534,13,65520
*+ DC.W 32767,47104,16383,65535,0,65535,65535,0,65535,65535,0,65535
*+ DC.W 65534,29,65504,16383,57343,4096,65535,65535,0,65535,65535,0
*+ DC.W 65535,65535,0,65532,65531,0,8191,61439,0,65535,65535,0
*+ DC.W 65535,65535,0,65535,65535,0,65528,65527,0,4095,61440,0
*+ DC.W 65535,0,0,65535,0,0,65535,0,0,65520,15,0
*+ DC.W 0,65535,0,0,65535,0,0,65535,0,0,65535,0
*+ DC.W 0,65535,0,0,65535,0,0,65535,0,0,65535,0
*+ DC.W 0,65535,0,0,65535,0
*+
*+ ifeq 1		;2.0 empty crouton
*+
*+ DC.W 65535,32767,65535,65535,65535,65535,65535,65535,65533,65532,65535,32767
*+ DC.W 65535,65535,65535,65535,65535,65535,65529,65528,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,61440,32767,0,65535,0,65535,0,65535
*+ DC.W 1,65520,61440,32767,0,65535,0,65535,0,65535,1,65520
*+ DC.W 61440,32767,0,65535,0,65535,0,65535,1,65520,61440,32767
*+ DC.W 0,65535,0,65535,0,65535,1,65520,61440,32767,0,65535
*+ DC.W 0,65535,0,65535,1,65520,61440,32767,0,65535,0,65535
*+ DC.W 0,65535,1,65520,57344,24576,0,0,0,0,0,0
*+ DC.W 1,0,49152,16384,0,0,0,0,0,0,1,0
*+ endc
*+
	ENDC	;CRAP4
*******************************************************************

*+*******
*+
*+ ReadCurrentProject
*+
*+ This function reads the CurrentProject file assumed to be present in the
*+ Toaster ROOT directory.
*+
*+ LONG ReadCurrentProject();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns the project number from the CurrentProject
*+   file in D0 if all went OK. Returns a negative value if an error occured.
*+   Error code -1 is returned if the CurrentProject filed could not be
*+   opened. Error code -2 is returned if there was an error reading the
*+   file. If all goes OK, the project device name will be written into
*+   ToasterBase (only modified if all is OK) in addition to the return
*+   project value in D0. The condition codes will be set according to the
*+   result in D0. Requires a pointer to ToasterBase in A5, but is not
*+   otherwise closely tied to the Switcher display. Also this function will
*+   leave you in the directory you were in prior to this function call.
*+   If this function was successful, BuildProjectTable() will be called to
*+   build the Project string table.
*+
*+ Addendum 2/15/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr(). A return code of -3 occurs if BuildProjectTable failed.
*+ Addendum 4/12/90:
*+   No more return code -3 from BuildProjectTable().
*+
*+*******

	IFNE	_CCODE

	XDEF	_ReadCurrentProject
_ReadCurrentProject:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ReadCurrentProject
	REST1	a5
	rts

	ENDC

	XDEF	ReadCurrentProject
ReadCurrentProject:
	SAVE	d2-d6/a2/a6		; save work registers

	GET.l	TB_DOSBase,a6		; get DOSBase

	GET.l	TB_BootLock,d1		; get into the Toaster root directory
	CALLROM	CurrentDir
	move.l	d0,d6			; save previous directory

	lea	.FileName(pc),a0	; now attempt to open the
	move.l	a0,d1			; CurrentProject file
	move.l	#MODE_OLDFILE,d2
	CALLROM	Open
	move.l	d0,d5			; did the file open?
	bne.s	.OpenedFile		; if so skip on

	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-1,d4			; else place error code
	bra.s	.RestoreOldDir		; and start exit procedure

.OpenedFile:
	move.l	d5,d1			; read in the contents of the
	GET.l	TB_FileBuff,a2		; CurrentProject file
	move.l	a2,d2
	moveq	#3,d3
	CALLROM	Read
	cmp.l	d0,d3			; did info get read?
	beq.s	.ReadTheRest		; if so - keep going

.BadFileRead:
	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-2,d4			; if data couldn't be read - place
	bra.s	.CloseFile		; error code and start exit procedure

.ReadTheRest:
	CLEAR	d4
	move.w	(a2),d4			; get binary project number

	move.l	d5,d1			; now finish the file read by reading
	addq.l	#3,d2			; in the project device name
	lea	2(a2),a2
	move.b	(a2),d3
	addq.b	#1,d3
	CALLROM	Read
	cmp.l	d0,d3			; did the info get read in?
	bne.s	.BadFileRead

	move.l	a2,a0			; copy the project device Toaster
	GET.l	TB_ProjDev,a1		; string into ToasterBase
	CALL	STRcmp			; - but only if needed
	beq.s	.CloseFile		; skip on if no updating needed

	CALL	STRcopy

	CALL	BuildProjectTable	; build the initial project string
*					; table
;@@	bmi.s	.CloseFile		; jump on if OK - Addendum 3/26/90:
;@@					;                  removed this check
;@@	moveq	#-3,d4			; place an error code

.CloseFile:
	move.l	d5,d1			; close the CurrentProject file
	CALLROM	Close

.RestoreOldDir:
	move.l	d6,d1			; restore original directory
	CALLROM	CurrentDir

	move.l	d4,d0			; place return value
	REST	d2-d6/a2/a6		; restore work registers
	rts				; and return to caller

.FileName:
	DC.b	'Switcher_Support/CurrentProject',0

	CNOP	0,2

*+*******
*+
*+ WriteCurrentProject
*+
*+ This function writes out the CurrentProject file into the Toaster ROOT
*+ directory.
*+
*+ LONG WriteCurrentProject( ProjectNum );
*+  D0                        D0
*+
*+ LONG ProjectNum:
*+   Represents the Project Number and must be a value from 0-999.
*+
*+ Notes:
*+   Trashes D1,A0,A1. Returns the specified project number if all went OK.
*+   Returns a negative value if an error occured. Error code -1 is returned
*+   if the specified Project Number argument was invalid. Error code -2 is
*+   returned if the CurrentProject file could not be created in the Toaster
*+   ROOT directory. Error code -3 is returned if there was an error trying
*+   to write out the data to the CurrentProject file. If all goes OK, there
*+   will be a new CurrentProject file consisting of the Project Number
*+   specified and the project device name present in ToasterBase. The
*+   condition codes will be set according to the result in D0. Requires a
*+   pointer to ToasterBase in A5, but is not otherwise closely tied to the
*+   Switcher display.
*+
*+ Addendum 2/15/90:
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr(). Note: an return code of -1 has no associated
*+   TB_LastGlobalError value.
*+
*+*******

	IFNE	_CCODE

	XDEF	_WriteCurrentProject
_WriteCurrentProject:
	move.l	4(sp),d0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	WriteCurrentProject
	REST1	a5
	rts

	ENDC

	XDEF	WriteCurrentProject
WriteCurrentProject:	; entry: ProjectNum
*				  D0
	SAVE	d2-d6/a2/a6		; save work registers

	moveq	#-1,d4			; assume invalid Project Number
	cmp.l	#1000,d0		; is it?
	bcc.s	.Exit			; if it is - exit

	move.l	d0,d4			; else save Project Number
	GET.l	TB_FileBuff,a2		; get file buffer
	GET.l	TB_DOSBase,a6		; get DOSBase

	move.w	d0,(a2)			; create the CurrentProject file
	moveq	#4,d3			; contents in the buffer -
	GET.l	TB_ProjDev,a0		; also not the length
	add.b	(a0),d3
	lea	2(a2),a1
	CALL	STRcopy

	GET.l	TB_BootLock,d1		; get into the Toaster root directory
	CALLROM	CurrentDir
	move.l	d0,d6			; save previous directory

	lea	.FileName(pc),a0	; now attempt to open the new
	move.l	a0,d1			; CurrentProject file
	move.l	#MODE_NEWFILE,d2
	CALLROM	Open
	move.l	d0,d5			; did the file open?
	bne.s	.OpenedFile		; if so skip on

	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-2,d4			; else place error code
	bra.s	.RestoreOldDir		; and start exit procedure

.OpenedFile:
	move.l	d5,d1			; write out the contents of the
	move.l	a2,d2			; CurrentProject file
	CALLROM	Write
	cmp.l	d0,d3			; did info get read?
	beq.s	.CloseFile		; if so - keep going

	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-3,d4			; if data couldn't be written -
*					; place error code

.CloseFile:
	move.l	d5,d1			; close the CurrentProject file
	CALLROM	Close

.RestoreOldDir:
	move.l	d6,d1			; restore original directory
	CALLROM	CurrentDir

.Exit:
	move.l	d4,d0			; place return value
	REST	d2-d6/a2/a6		; restore work registers
	rts				; and return to caller

.FileName:
	DC.b	'Switcher_Support/CurrentProject',0

	CNOP	0,2

*****************************************************
* void NewUnloadToolbox(list#, TB)
*			d0     a5

	XDEF	NewUnloadToolbox
NewUnloadToolbox
	movem.l d0/a0,-(sp)

;;	DUMPHEXI.l	<list number=>,d0,<\>

	movea.l	TB_ToolBoxGrids(a5),a0

	add.l	d0,d0
	add.l	d0,d0
	lea.l	0(a0,d0.w),a0		;->list pointer
	move.l	(a0),d0			;first
	clr.l	(a0)
	bra.s	3$

2$:	move.l	(a0),d0			; get link to next TBFG
	CALLTL	RemoveTBFG		; remove the TBFG

3$	move.l	d0,a0			; assume another FG
	tst.l	d0			; another TBFG?
	bne.s	2$			; if so - reloop

666$	movem.l	(sp)+,d0/a0
	rts

*+*******
*+
*+ UnLoadToolBox
*+
*+ This function empties all of the ToolBox grids.
*+
*+ void UnLoadToolBox();
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. Requires
*+   a pointer to ToasterBase in A5. It is not tied closely to the Switcher
*+   display. This function does its dirty work by repeated calls to the
*+   RemoveTBFG() function, so see the docs on that function for more info.
*+
*+ Addendum 2/15/90:
*+ Addendum 9/16/90:
*+   Added code to unload LUT croutons that reside in the TB_LUTFGL. Also
*+   clears the TB_LUTFGL field in the manner described above for ToolBox
*+   FGLs.
*+ Addendum 3/26/91:
*+   Added code to handle an E ToolBox grid.
*+ Addendum 4/8/91:
*+   Added code to handle an F ToolBox grid.
*+
*+*******

	XDEF	UnLoadToolBox
UnLoadToolBox:
	SAVE	d0-d3/d0-a2			; save work registers

	move.l	TB_ToolBoxGrids(a5),a2
	move.l	TB_NUMGRIDS(a5),d3
	subq.l	#1,d3
666$
	move.l	(a2),a0
	bsr.s	1$
	clr.l	(a2)+
	dbf	d3,666$

	REST	d0-d3/d0-a2			; restore work registers
	rts				; and return to caller

1$:	move.l	a0,d0			; ToolBox FastGadget pointer NULL?
	bne.s	2$			; if not - skip on
	rts				; else ignore this code

2$:	move.l	(a0),d2			; get link to next TBFG

	CALLTL	RemoveTBFG		; remove the TBFG

	move.l	d2,d2			; another TBFG?
	move.l	d2,a0
	bne.s	2$			; if so - reloop
	rts				; else return to caller

*+*******
*+
*+ ClearToolBoxArea
*+
*+ This function clears the ToolBox grid area of the Switcher display to the
*+ specified Switcher background color.
*+
*+ void ClearToolBoxArea();
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1,and the condition codes. Nothing is returned.
*+   Requires a pointer to ToasterBase in A5 and is tied closely to the
*+   Switcher display.
*+
*+ Addendum 2/19/90:
*+
*+ NOTE: I don't think this is used by anyone anymore.  SKELL 9/18/92
*+*******

	IFNE	_CCODE

	XDEF	_ClearToolBoxArea
_ClearToolBoxArea:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ClearToolBoxArea
	REST1	a5
	rts

	ENDC

	XDEF	ClearToolBoxArea
ClearToolBoxArea:
	SAVE1	a6			; save a work register

	GET.l	TB_ITUBase,a6		; clear the ToolBox grid area to the
	GET.l	TB_RastPort,a0		; background area
	lea	.ClearImage(pc),a1
	GET.w	TB_InterfaceDepth,ig_Depth(a1)
	GET.w	TB_BGColor,ig_PlanePick(a1)	; assure PlanePick off while
*						; setting PlaneOnOff to the
*						; background color
	CLEAR	d0
	CLEAR	d1
	CALLROM	DrawImage

	REST1	a6			; restore the work register
	rts				; return to caller

.ClearImage:
	DC.w	TBFG_LEFTEDGE			; ig_LeftEdge
	DC.w	TBFG_TOPEDGE			; ig_TopEdge
	DC.w	TBFG_WIDTH*TBFG_GRIDACROSS	; ig_Width
	DC.w	TBFG_HEIGHT*TBFG_GRIDROWS	; ig_Height
	DC.w	0	;MAXDISPLAYDEPTH filled in later ; ig_Depth
	DC.l	0				; ig_ImageData
	DC.b	*-*				; ig_PlanePick
	DC.b	*-*				; ig_PlaneOnOff
	DC.l	0				; ig_NextImage

*************************************************************
* ULONG = WhatSlicesLoaded()
* SliceMask

	XDEF	WhatSlicesLoaded
WhatSlicesLoaded:
	movem.l	d1-d3/a0-a1,-(sp)

	moveq	#15,d1			; dump Slices specified in the
	moveq	#0,d2			; On/Off bit field - we assume that
	move.l	d2,d3
	DEA	TB_SliceFGL,a0		; Slice FG ordering never changes!

10$	move.l	(a0),d0			; next Slice FG exists?
	beq	666$			; skip out if not
	move.l	d0,a0			; address Slice FG
	cmp.w	#2,FG_EntrySize(a0)	; is it a On/Off Slice FG?
	bne	20$			; nope - skip on

	move.w	FG_PTRIndex(a0),d0	; is the Slice FG already off?
	beq	20$			; yup - skip on

	bset	d2,d3

20$	addq.w	#1,d2		; do next until we hit list end or
	dbra	d1,10$		; all Slices are done

666$	move.l	d3,d0
	movem.l	(sp)+,d1-d3/a0-a1
	rts

*************************************************************
	XDEF	ReadDefaultProject
ReadDefaultProject
	SAVE	d1-d2/a0-a1/a6
;;	DUMPMSG	<ReadDefaultProject>

	bsr	UnLoadToolBox	; remove old ToolBox grids

	moveq	#0,d0		;first list
	bra.s	NewReadDefaultProjectEntry

* FALLS THRU TO NEWREADDEFAULTPROJECT!!!!

*+*******
*+
*+ NewReadDefaultProject
*+
*+ This function reads the default Project file "DefaultProject" that exists
*+ in the Toaster ROOT directory and sets up the Toaster environment
*+ accordingly. This routine should only be used after an attempted
*+ ReadProject fails. No book is loaded with this routine.
*+
*+ LONG NewReadDefaultProject(List #);
*+  D0				d0
*+
*+ Notes:
*+   Returns zero in D0 if everything went OK. A negative error code is
*+   returned otherwise. Trashes D1,A0,A1, and the condition codes are set to
*+   the result returned in D0. Requires a pointer to ToasterBase in A5 and
*+   is tied closely to the Switcher display system. This function does not
*+   actually render into the Switcher display. Uses the TB_LastGlobalError
*+   field to pass back a DOS error code from IoErr(). A return code of -4
*+   has no associated TB_LastGlobalError value as it is not a DOS error.
*+   A return code of -3 should be treated likewise as its TB_LastGlobalError
*+   can be unpredictable. As of now there is a global __ONESHOT below that
*+   is for controlling whether the toolbox grids are to be dumped and
*+   re-filled by the croutons from the script file after the initial
*+   Switcher load. They are not dumped and re-filled in version 1.0 only.
*+   Now uses and requires the new file buffering system which enables
*+   (inconvieniently) this function to use but one common floppy. Because of
*+   the aforementioned common floppy, this function also will place up
*+   requesters internally, hopefully to allow the user to continue on with
*+   disk swapping. Because if the internal requesters, this function also
*+   monitors the floppy disk system to try to insure that the Toaster system
*+   is kept up to date.
*+   This function has had a long and kludgey history.
*+
*+ Addendum 4/25/90:
*+ Addendum 6/5/90:
*+   Added 32 bit field read directly after the FrameStore device for
*+   controlling the status of On/Off Slices.
*+ Addendum 7/5/90:
*+   Tweaked the project loading and user requester systems to give the user
*+   the option to keep a partially loaded project script along with whatever
*+   else can be salvaged along with it.
*+ Addendum 10/9/90:
*+   The 32 bit field defined earlier for controlling the status of On/Off
*+   Slices has now been split into two 16 bit fields. The second 16 bit
*+   field is the new 16 bit version of the On/Off Slice field. The first
*+   16 bit field (which was always zero in the 32 bit field versions and
*+   therefore allows us backward compatability) denotes the number of bytes
*+   to be read in between the following On/Off Slice 16 bit field and the
*+   start of the crouton script entries. This allows for at the moment to
*+   save/restore the border and matte colors in the project, with an eye to
*+   other possible additions. NOTE: The extension field must not exceed the
*+   size of the file buffer area it will be read into!!
*+ Addendum 11/28/90:
*+   Now when error -4 is returned to denote that no ToolBox croutons have
*+   been loaded, the Dummy crouton will have been installed as a fail safe.
*+   The Dummy crouton will also be loaded after an error -3 is registered.
*+
*+*******

	XDEF	NewReadDefaultProject
NewReadDefaultProject:
	SAVE	d1-d2/a0-a1/a6		:SEE ABOVE
;;	DUMPMSG	<NewReadDefaultProject>

	bsr	NewUnloadToolbox	; remove old ToolBox grids

*** SEE ABOVE
NewReadDefaultProjectEntry:
	move.l	d0,d2

;;	DUMPMSG	<NewReadDefaultProjectEntry>

	GET.l	TB_DOSBase,a6		; get DOS base in a6
	GET.l	TB_BootLock,d1		; get to Toast ROOT
	CALLROM	CurrentDir

	move.l	#1001,d0
	move.l	d2,d1		;list #
	PUT.w	d0,TB_ProjectNumber

	lea	.defaultname,a0

;;	DUMPMSG	<BeforeNewReadProjec>

	bsr	NewReadProject

	REST	d1-d2/a0-a1/a6
	rts

.defaultname	dc.b	'Switcher_Support/DefaultProject',0
	CNOP	0,2

*********************************************************************
* Here only for compatibility.  But now only does 1st linked list!

	XDEF	ReadProject
ReadProject
	SAVE	d1-d7/a0-a4/a6
	CALL	UnLoadToolBox		; remove old ToolBox grids

	moveq	#0,d1			;first list
	bra.s	NewReadProjectEntry

**** THIS FALLS THRU TO BELOW!!!!

*+*******
*+
*+ NewReadProject
*+
*+ This function reads the specified Project file and sets up the Toaster
*+ environment accordingly.
*+
*+ LONG NewReadProject( ProjectNum, List#, [filename] );
*+  D0                    D0          d1      a0
*+
*+ LONG ProjectNum:
*+   Should be a value between 0-999 and represents the project number of
*+   the project file to be loaded.
*+
*+	New for 4.0 if the project number >1000 then ReadProject will use
*+	the file name provided in a0
*+
*+ Notes:
*+   Returns the project number in D0 if everything went OK. A negative
*+   error code is returned otherwise. The condition
*+   codes are set to the result returned in D0. Requires a pointer to
*+   ToasterBase in A5 and is tied closely to the Switcher display system.
*+   Return codes of -1,-2, and -7 have no associated TB_LastGlobalError
*+   value as they are not DOS errors. Return code -6 also should be treated
*+   in a similar manner as the TB_LastGlobalError value can be
*+   unpredictable. There is for the moment a global __ONESHOT below that is
*+   for controlling whether the toolbox grids are to be dumped and re-filled
*+   by the croutons from the script file after the initial Switcher load.
*+   They are not dumped and re-filled in version 1.0 only. There is no error
*+   code related to the CG loading its book. Since the CG processing
*+   routines handle presenting a message to the user, it was deemed not
*+   neccessary to respond to the returned code. Now uses and requires the
*+   new file buffering system which enables (inconvieniently) this function
*+   to use but one common floppy. Because of the aforementioned common
*+   floppy, this function also will place up requesters internally,
*+   hopefully to allow the user to continue on with disk swapping. Because
*+   of the internal requesters, this function also monitors the floppy disk
*+   system to try to insure that the Toaster system is kept up to date.
*+   This function has had a long and kludgey history.
*+
*+ Addendum 4/25/90:
*+ Addendum 6/5/90:
*+   Added 32 bit field read directly after the FrameStore device for
*+   controlling the status of On/Off Slices.
*+ Addendum 7/5/90:
*+   Tweaked the project loading and user requester systems to give the user
*+   the option to keep a partially loaded project script along with whatever
*+   else can be salvaged along with it.
*+ Addendum 7/18/90:
*+   Defined __ONESHOT as 0 to enable dumping and loading of the ToolBox
*+   grids after the initial ToolBox load.
*+ Addendum 10/9/90:
*+   The 32 bit field defined earlier for controlling the status of On/Off
*+   Slices has now been split into two 16 bit fields. The second 16 bit
*+   field is the new 16 bit version of the On/Off Slice field. The first
*+   16 bit field (which was always zero in the 32 bit field versions and
*+   therefore allows us backward compatability) denotes the number of bytes
*+   to be read in between the following On/Off Slice 16 bit field and the
*+   start of the crouton script entries. This allows for at the moment to
*+   save/restore the border and matte colors in the project, with an eye to
*+   other possible additions. NOTE: The extension field must not exceed the
*+   size of the file buffer area it will be read into!!
*+ Addendum 11/28/90:
*+   Now when error -7 is returned to denote that no ToolBox croutons have
*+   been loaded, the Dummy crouton will have been installed as a fail safe.
*+   The Dummy crouton will also be loaded after an error -6 is registered.
*+ Addendum 1/30/91:
*+   Return code -7 is no more. This was done to allow Projects with no
*+   ToolBox FGs to be loaded without being persecuted with a requester
*+   denoting that no ToolBox FGs were loaded. Note however that
*+   ReadDefault() will as of this time still return an error code for no
*+   ToolBox FGs loaded.
*+
*+*******

	XDEF	NewReadProject
NewReadProject:	; entry: ProjectNum
*			  D0
	SAVE	d1-d7/a0-a4/a6		:SEE ABOVE !!!!
	move.l	d0,d3			;stash

;;	DUMPMSG	<Before NewReadProjec NewUnLoadToolBox>

	move.l	d1,d0			;list #
	bsr	NewUnloadToolbox	; remove old ToolBox grids
	move.l	d3,d0

*** SEE ABOVE !!!!!
NewReadProjectEntry:
;;	DUMPMSG	<----------------------------------------------->


	move.l	d0,d3			; setup return code for all OK
	move.l	d1,d6			;stash
	add.l	d6,d6
	add.l	d6,d6			;*4
	moveq	#0,d5			;assume lock failed

;;	DUMPMSG	<NewReadProjectEntry>

	CALLTL	DisplayWaitSprite

;;	DUMPMSG	<After DisplayWaitSprite>

	clr.l	TB_LastGlobalError(a5)

	cmp.l	#1000,d3		; is specified Project # valid?
	bcs.s	.OKProjectNum		; if it is - skip on

	lea	FullProjectName,a1
	CALL	STRcopy

;;	DUMPMSG	<After STRcopy>

	bra	.RealLoad

.OKProjectNum:

	move.l	d3,d1			; get Project comment string - also
*					; determines if Project really exists
*					; or not
	mulu	#14,d1
	GET.l	TB_ProjStrings,a2
	add.l	d1,a2
	move.b	(a2)+,d1
	not.b	d1
	bne.s	.OKComment		; continue if comment found -

	moveq	#-2,d3			; else setup error code
	bra	.Exit			; and exit

.OKComment:
;;	lea	.ProjectName(pc),a3	; build both project and
	lea	FullProjectName,a3
	lea	.BookName(pc),a4	; book filenames

	divu	#100,d0			; get 100s digit
	add.b	#'0',d0
	move.b	d0,(a3)+
	move.b	d0,(a4)+

	clr.w	d0			; get 10s digit
	swap	d0
	divu	#10,d0
	add.b	#'0',d0
	move.b	d0,(a3)+
	move.b	d0,(a4)+

	swap	d0			; get 1s digit
	add.b	#'0',d0
	move.b	d0,(a3)+
	move.b	d0,(a4)+

	lea	.ProjectSubSTR(pc),a0	; copy type to project filename
	move.l	a3,a1
	CALL	STRcopy
	move.l	a2,a0			; followed by file comment
	CALL	STRcopy

	lea	.BookSubSTR(pc),a0	; copy type to book filename
	move.l	a4,a1
	CALL	STRcopy
	move.l	a2,a0			; followed by file comment
	CALL	STRcopy

;;	DUMPMSG	<Before LockProject>

	CALL	LockProject		; get directory to where the project
	move.l	d0,d5			; hold onto project directory lock
					; file should be
	bne.s	.RealLoad		; if we got there - continue

	moveq	#-3,d3			; else setup error code
	bra	.Exit			; and exit

.RealLoad
;;	DUMPMSG	<After LockProject>

	movem.l	d0-d1/a0,-(sp)

;;	DUMPMSG	<Before SelectdStdEfx>

	bsr	SelectStdEfx
	DEA.l	TB_VTSetUp,a0
	ELHTEST_LUT	a0
	beq.s	10$		;still call LUToff just to be sure
	CALLTL	LUToff
	ELHGET_IS	a0,d0
	moveq	#0,d1
	CALLTL	Grab1Bank	;destroy LUT data
	bra.s	20$
10$	CALLTL	LUToff
20$	CALLTL	DoTakeNoKey
	movem.l	(sp)+,d0-d1/a0

;;	DUMPMSG	<After DoTakeNoKey>

;;	lea	.ProjectName(pc),a0	; attempt to open the project file
	lea	FullProjectName,a0

;;	DUMPMSG	<Before Open>

	move.l	a0,d1
	move.l	#MODE_OLDFILE,d2
	GET.l	TB_DOSBase,a6
	CALLROM	Open
	move.l	d0,d4			; hold onto filehandle for project
	bne.s	.OpenProject		; continue if project opened

	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-4,d3			; else setup error code
	bra	.FreePJLock		; and exit

.OpenProject:
;;	DUMPMSG	<Before InitFileBuffering>

	move.l	d4,a0			; buffer up the Project file
	CLEARA	a1
	CALL	InitFileBuffering

	GET.l	TB_FileBuff,a0	;<4K of system tags
	moveq.l	#4*(3+4+1),d0	;'Project',0 + 0L + 0000LONGs + TagListSize
	CALL	BuffRead
	cmpi.l	#4*(3+4+1),d0
	movem.l	(a0),d0-d2		;d2=version
	beq.s	.OKRead

.BadRead:
	moveq	#-5,d3			; else setup error code
	bra	.ClosePFile		; and exit

.OKRead
	cmpi.l	#'Proj',d0
	bne.s	.BadRead
	cmpi.l	#'ect'<<8,d1
	bne.s	.BadRead
	tst.l	d2
	bne.s	.BadRead	;jump if future file version

	move.l	4*(3+4)(a0),d0	;tag size
	cmpi.l	#1024*4,d0
	bhi.s	.BadRead

;;	GET.l	TB_FileBuff,a0	;<4K of system tags
	move.l	d0,d7
	CALL	BuffRead
	cmp.l	d7,d0
	bne.s	.BadRead

* a0->Tags near start of Project file
	GET.l	TB_SystemTags,a1
	bsr	ApplyTags2Lists
	tst.l	d0
	beq.s	.BadRead	;jump if unable to apply new system tags

	move.w	LoadedSlices,d7	;only care about 16 bits

**+ The following lines were removed when I switched to the new
**+ simplified Project file format for 4.0.
**+
**+	CALL	BuffGetChar		; now attempt to get new FS device name length
**+	bgt.s	.OKRead			; if valid so far - skip on
**+
**+.BadRead:
**+	moveq	#-5,d3			; else setup error code
**+	bra	.ClosePFile		; and exit
**+
**+.OKRead:
**+	cmp.b	#30,d0			; was Toaster string length OK? (30 max not including null, but including :)
**+	bhi.s	.BadRead		; - skip out if not
**+
**+	lea	.NewFSDevice(pc),a0	; place FS device name length
**+	move.b	d0,(a0)+
**+
**+	addq.b	#1,d0			; Include NULL at end of string
**+	move.l	d0,d2			; save this LONGWORD count value
**+	CALL	BuffRead		; read in the rest of FS device name
**+	cmp.l	d2,d0			; denote error if something
**+	bne.s	.BadRead		; went wrong
**+
**+	moveq	#3,d2			; read in Extension/On/Off bit fields
**+	CLEAR	d7
**+
**+.GetBitFieldLoop:
**+	CALL	BuffGetChar		; get next byte of bit field
**+	bmi.s	.BadRead		; if problems reading - jump out
**+	lsl.l	#8,d7			; else place next byte of field
**+	move.b	d0,d7
**+	dbf	d2,.GetBitFieldLoop	; reloop till done
**+
**+	move.l	d7,d0			; read in extension field - if any
**+	clr.w	d0
**+	swap	d0
**+	lea	.ExtensionFlag(pc),a0
**+	move.w	d0,(a0)
**+	beq.s	.NoExtension
**+
**+	cmp.l	#.EB-.ExtensionBuff,d0	; can we handle the field size?
**+	bhi.s	.BadRead		; ...if not
**+
**+	lea	.ExtensionBuff(pc),a0	; fields read into TB_FileBuff area
**+	move.l	d0,d2
**+	CALL	BuffRead
**+	cmp.l	d2,d0
**+	bne.s	.BadRead
**+
**+.NoExtension:
**+	lea	.NewFSDevice(pc),a0	; get new FS device string
**+	GET.l	TB_FSDev,a1		; and the current FS device name
**+	CALL	STRcmp			; compare them
**+	beq.s	.DoneFS			; if identical - skip on
**+
**+	CALL	STRcopy			; else copy new FS name into
**+*					; ToasterBase
**+;;	DUMPMSG	<Before BuildFSTable>
**+
**+
**+	CALL	BuildFSTable		; build new FS comment table
**+
**+.DoneFS:

* code section - Addendum 6/27/90: - handles book loading in the case of
* the CG ALREADY being present...


	clr.w	needcgloadflag		; assume FALSE for special case
*					; book load

**+ ifeq 1		;We no longer care if the CG was active.  We always dump
**+		;all slices on project load and load book after tool box
**+		;has loaded.
**+
**+
**+	moveq	#CGSLICEID,d0		; is the CG alive?
**+	DEA	TB_SliceFGL,a0		; (CG assumed to be an On/Off Slice)
**+	CALL	IndexFastG
**+	beq.s	.NoSpecialCase		; if not...
**+	move.l	d0,a0			; (CG will have a FG_PTRIndex of 0
**+	move.w	FG_PTRIndex(a0),d0	;  if Off - 1 if On)
**+	beq.s	.NoSpecialCase
**+	move.l	FG_Function(a0),d0	; check for function code also
**+	beq.s	.NoSpecialCase
**+ endc

	moveq	#CGSLICEID,d0		; CG is currently active - will it
	btst.l	d0,d7			; continue to be via new project?
	beq.s	.NoSpecialCase		; nope - skip on

	move.w	#-1,needcgloadflag	; else denote manual book loading
					; needed for this special case
.NoSpecialCase:
	moveq	#15,d1			; dump Slices specified in the
	CLEAR	d2			; On/Off bit field - we assume that
	DEA	TB_SliceFGL,a0		; Slice FG ordering never changes!

.UnLoadSlicesLoop:
	move.l	(a0),d0			; next Slice FG exists?
	beq	.NoMoreUnLoads		; skip out if not
	move.l	d0,a0			; address Slice FG
	cmp.w	#2,FG_EntrySize(a0)	; is it a On/Off Slice FG?
	bne	.UnLoadLoopEnd		; nope - skip on

;;	We now force all slices to unload on project load
;;	btst.l	d2,d7			; is this Slice to be FGC_UNLOADED?
;;	bne.s	.UnLoadLoopEnd		; nope - skip on

	move.w	FG_PTRIndex(a0),d0	; is the Slice FG already off?
	beq	.UnLoadLoopEnd		; yup - skip on

;;	DUMPMSG	<Before UnloadCrouton>

;;	DUMPUDEC.w	<unload slice#>,d2,<\>


	bsr	FGC_UnloadCommand

	CALLTL	InstallAVEI	;Unnecessary if we didn't have the Slice code.
				;Currently some Slices are doing InstallAVE on an Unload!!!

;;	move.l	FG_Function(a0),d0	; is there a function to call?
;;	beq.s	.UnLoadLoopEnd		; nope - skip on

*					; else we're FGC_UNLOADing this slice
;;	SAVE	d1-d7/a0/a5/a6
;;	move.l	d0,a1
;;	moveq	#FGC_UNLOAD,d0
;;	SAVE	d0/a0/a5
;;	jsr	(a1)			; get the Slice FG to shut down
;;	lea	12(sp),sp
;;	REST	d1-d7/a0/a5/a6

.UnLoadLoopEnd:
	addq.w	#1,d2			; do next until we hit list end or
	dbf	d1,.UnLoadSlicesLoop	; all Slices are done

.NoMoreUnLoads:


	move.w	TB_ProjectNumber(a5),-(sp)
	move.w	#-1,TB_ProjectNumber(a5)

	moveq	#15,d1			; load Slices specified in the
	CLEAR	d2			; On/Off bit field - we assume that
	DEA	TB_SliceFGL,a0		; Slice FG ordering never changes!

.LoadSlicesLoop:
	move.l	(a0),d0			; next Slice FG exists?
	beq	.NoMoreLoads		; skip out if not
	move.l	d0,a0			; address Slice FG
	cmp.w	#2,FG_EntrySize(a0)	; is it a On/Off Slice FG?
	bne	.LoadLoopEnd		; nope - skip on
	btst.l	d2,d7			; is this Slice to be FGC_LOADED?
	beq	.LoadLoopEnd		; nope - skip on

;;	DUMPUDEC.w	<asking for slice#>,d2,<\>

	move.w	FG_PTRIndex(a0),d0	; is the Slice FG already on?
	bne	.LoadLoopEnd		; yup - skip on

;;	DUMPMSG	<Before SelectKCrouton>

;;	DUMPUDEC.w	<SELECT/LOAD slice#>,d2,<\>

	bsr	FGC_SelectKCommand

;;	move.l	FG_Function(a0),d0	; is there a function to call?
;;	beq.s	.LoadLoopEnd		; nope - skip on

*					; else we're FGC_LOADing this slice

;;	PUT.w	#0,TB_ErrFlag		; first assure error flag reset

;;	SAVE	d1-d7/a0/a5/a6
;;	move.l	d0,a1
;;	moveq	#FGC_SELECTK,d0
;;	SAVE	d0/a0/a5
;;	jsr	(a1)			; get the Slice FG to load up
;;	lea	12(sp),sp
;;	REST	d1-d7/a0/a5/a6

.LoadLoopEnd:
	addq.w	#1,d2			; do next until we hit list end or
	dbf	d1,.LoadSlicesLoop	; all Slices are done

.NoMoreLoads:

	move.w	(sp)+,TB_ProjectNumber(a5)



**+ ifeq 1
**+	tst.w	needcgloadflag			; test for special case of manual
**+*					; book load
**+	beq.s	.NoBookLoaded		; if not the special case - skip
**+	lea	.BookName(pc),a0	; ask CG to load the specified book
**+	move.l	d5,a1
**+	XCALL	LoadCGBook
**+.NoBookLoaded:
**+ endc
**+;;	clr.b	SalvageFlag		; denote no savage initially

.NextEntryLoop:

* Always put into first grid???
	move.l	TB_ToolBoxGrids(a5),a0	; pointer to base of ToolBox
	lea	0(a0,d6.w),a0		;->particular linked list

;;	DUMPMSG	<Before ReadProjectEntry>

	XJSR	ReadProjectEntry	; process next ToolBox FastGagdet
*					; entry - if any
	bgt.s	.NextEntryLoop		; if all seems OK - reloop

					; if probable end of Project file -
	beq.s	.NELoopEnd		; break out of loop to continue

	cmp.l	#-3,d0			; non-recoverable internal FG error?
	beq.s	.AbortReadProj		; yup - abort the project load

.ExterRetry:
;;	move.b	SalvageFlag(pc),d0	; user want salvaging?
;;	bne.s	.NextEntryLoop		; yup - reloop for next

	lea	.Question(pc),a0	; else ask the USER whether or not
	CALL	ReqSystem		; he wants to continue
	bne.s	.AbortReadProj		; if not - skip out

;;	move.b	#-1,SalvageFlag		; else setup salvage flag
	PUT.l	#-1,TB_RequesterResult	; Always "Continue" on error requestes
	bra.s	.NextEntryLoop		; and reloop, skip future requesters

.AbortReadProj:
	moveq	#-6,d3			; else denote a non-recoverable error
;;	bra	.ClosePFile		; and exit/Addendum 11/28/90: removed

.NELoopEnd:

	PUT.l	#0,TB_RequesterResult	; Re-enable requesters

 ifeq 0
	tst.w	needcgloadflag		; test for special case of manual
*					; book load
;;	DUMPMSG	<Before LoadCGBook>

	beq.s	.NoBookLoaded		; if not the special case - skip
	CALLTL	ReDoDisplay
	CALLTL	InstallAVEI
	lea	.BookName(pc),a0	; ask CG to load the specified book
	move.l	d5,a1
	XCALL	LoadCGBook
.NoBookLoaded:
 endc

	move.l	TB_ToolBoxGrids(a5),a1	; try to insure that one of the
;	moveq	#TBFG_GRIDNUM-1,d1	; ToolBox FGs is selected and active
	move.l	TB_NUMGRIDS(a5),d1
	subq.l	#1,d1

.SelectLoop:
	move.l	(a1)+,d0
	beq.s	.NoTBFG
	bra.s	.SneakIn

.InnerLoop:
	move.l	FG_Function(a0),d0
	bne.s	.DoSelect
	move.l	(a0),d0

.SneakIn:
	move.l	d0,a0
	bne.s	.InnerLoop

.NoTBFG:
	dbf	d1,.SelectLoop

;;	tst.l	d3			; previous error code?
;;	bmi.s	.PreviousErr		; yup - keep it
;;	moveq	#-7,d3			; else setup error code
;;.PreviousErr:
	XREF	DummyICrouton		; Addendum 11/28/90: if no ToolBox
	lea	DummyICrouton,a0	; crouton(s) exist - use the dummy
	move.l	FG_Function(a0),d0	; (must exist)

;;	move.l	TB_ToolBoxGrids(a5),a1	;don't put dummy in grid
;;	move.l	a0,(a1)

;;	bra	.ClosePFile		; and exit/Addendum 11/28/90: removed

.DoSelect:
	GET.l	TB_EfxFG,d1		; CG controlling Toaster entity?
	beq.s	.DoSelect1		; ..if not

	moveq	#CGSLICEID,d1		; CG currently supposed to be alive?
	btst.l	d1,d7
	bne.s	.ASpecialCase		; ...if so

.DoSelect1:

* Commented this out so project editor wouldn't always select 1st effect
* on project load.
;;	SAVE	d3-d5/a0/a5/a6
;;	moveq	#FGC_SELECTQ,d1
;;	SAVE	d1/a0/a5
;;	move.l	d0,a0
;;	jsr	(a0)
;;	lea	12(sp),sp
;;	REST	d3-d5/a0/a5/a6
	CALLTL	SelectStdEfx


;;;;	PUT.l	a0,TB_EfxFG		; denote the chosen TBFG
;;;;					; (Not needed)

.ASpecialCase:

*-------------------------------------------
	IFD	CRAP5	;Don't think I need this stuff for 4.0

*+;;	DUMPMSG	<.ASpecialCase>
*+
*+	CLEAR	d0
*+	move.w	FG_IndexID(a0),d0
*+	divu	#TBFG_GRIDSIZE,d0
*+	move.l	d0,d2
*+	clr.w	d2
*+	swap	d2
*+	swap	d0
*+
*+	divu	#TBFG_GRIDACROSS,d2	; form new TB_NumPad value
*+	move.w	d2,d0
*+	addq.w	#1,d0
*+	add.w	d0,d0
*+	move.w	d0,d1
*+	add.w	d0,d0
*+	add.w	d0,d0
*+	add.w	d1,d0
*+	swap	d2
*+	addq.w	#1,d2
*+	add.w	d0,d2
*+	PUT.w	d2,TB_TBSelVal
*+
*+	GET.l	TB_CurrSelFG,a1		; TB NumPad system currently active?
*+	cmp.w	#TBSELID,FG_IndexID(a1)
*+	bne	.ClosePFile		; ...if not
*+
*+	swap	d0
*+	DEA	TB_GridSelFGL,a0
*+	CALL	IndexFastG
*+	beq	.ClosePFile
*+	move.l	d0,a0
*+	move.l	FG_Function(a0),d0
*+	beq	.ClosePFile
*+
*+
*+	bsr	FGC_SelectCommand	;was SelectCroutonQ or K pre 4.0
*+;;	SAVE	d2-d5/a5/a6
*+;;	moveq	#FGC_SELECTK,d1
*+;;	GET.l	TB_Window,a1
*+;;	move.l	wd_FirstGadget(a1),a1
*+;;	cmp.w	#'SW',gg_GadgetID(a1)
*+;;	beq.s	.SWScreenActive
*+;;	moveq	#FGC_SELECTQ,d1
*+;;
*+;;.SWScreenActive:
*+;;	SAVE	d1/a0/a5
*+;;	move.l	d0,a0
*+;;	jsr	(a0)
*+;;	lea	12(sp),sp
*+;;	REST	d2-d5/a5/a6
*+
*+	PUT.w	d2,TB_NumPadSec		; place new TB_NumPad value
*+	CALL	UpDateFC		; and TBFG comment
*+*					; render done on screen update
*+
*+
*+*					; Addendum 10/9/90:
*+	move.w	.ExtensionFlag(pc),d0	; any extension field to process?
*+	beq	.ClosePFile		; ...if not
*+
*+	lea	.ExtensionBuff(pc),a0	; deal with Matte color first....
*+	move.w	(a0)+,d0
*+	cmp.w	TB_ToastBGC(a5),d0
*+	beq.s	.NoMatteChange
*+
*+;;	DUMPMSG	<BGColorUpdate>
*+
*+	XCALL	BGColorUpdate
*+
*+.NoMatteChange:
*+	move.w	(a0),d0			; deal with Border color....
*+	cmp.w	TB_BorderC(a5),d0
*+	beq.s	.NoBorderChange
*+
*+;;	DUMPMSG	<BorderCUpdate>
*+
*+	XCALL	BorderCUpdate
*+
*+.NoBorderChange:

	ENDC	;CRAP5

*-------------------------------------------

.ClosePFile:

	move.l	d4,d1			; close down project file
	CALLROM	Close

;;	DUMPMSG	<InitDVEFastMem>

	XCALL	InitDVEFastMem		; re-setup the FAST memory chunk we
*					; used for Project file buffering

.FreePJLock:
;;	DUMPMSG	<before UnLock>

	move.l	d5,d1			; free up Project lock
	beq.s	.Exit
	CALLROM	UnLock

.Exit:
;;;	DUMPMSG	<DisplayNormalSprite>

	CALLTL	DisplayNormalSprite

******!!!!!!!!!********  HACK TO ALWAYS SUCCESSFUL
	move.l	#1,d3		;!!!!!!!!!!!!!!!!!

	bsr	WhatSlicesLoaded
	move.w	d0,LoadedSlices

;;	DUMPMSG	<After NewReadProjectEntry>

	move.l	d3,d0			; setup return code
	REST	d1-d7/a0-a4/a6
	rts

	CNOP	0,4
.Question:
;;	DC.l	.LostOne
	DC.l	.LoadOn
	dc.l	0
	DC.l	.NoSTR
	DC.l	.YesSTR

.ExtensionBuff:
	DS.b	16
.EB:

.ExtensionFlag:
	DS.w	1

;;.LostOne:
;;	DC.b	'Can not load an Effect',0

.LoadOn:
;;	DC.b	'Keep current Effects and continue project load?',0
	DC.b	'Continue the project load?',0

.YesSTR:
	DC.b	'YES',0

.NoSTR:
	DC.b	'NO',0

.ProjectSubSTR:
	DC.b	'.PJ.',0

.BookSubSTR:
	DC.b	'.BK.',0

;;.ProjectName:
;;	DS.b	20

.BookName:
	DS.b	20

.NewFSDevice:
	DS.b	32

;;SalvageFlag:
;;	DS.b	1

	CNOP	0,2
needcgloadflag	ds.w	1	;used to use d6

****************************************************************
* Here only for compatibility.  But now only does 1st linked list!

	XDEF	WriteProject
WriteProject:
	SAVE	d1-d7/a0-a4/a6
	moveq	#0,d1			;do 1st linked list
	bra	NewWriteProjectStart

**** THIS FALLS THRU TO BELOW!!!!

*+*******
*+
*+ NewWriteProject
*+
*+ This function writes the specified Project file from the Toaster
*+ environment currently in place.
*+
*+ LONG NewWriteProject( ProjectNum, List#, CommentSTR );
*+  D0                 	     D0       D1   	A0
*+
*+
*+	New for 4.0 if the project number >1000 the comment string is a
*+	full filename with path.
*+
*+
*+
*+ LONG ProjectNum:
*+   Should be a value between 0-999 and represents the project number of
*+   the project file to be saved.
*+
*+ APTR CommentSTR:
*+   Pointer to a C string of upto 12 characters and NULL that represents the
*+   suffix of the filename under which the specified project will be saved.
*+
*+ Notes:
*+   Returns the project number in D0 if everything went OK. A negative
*+   error code is returned otherwise. Trashes D1,A0,A1, and the condition
*+   codes are set to the result returned in D0. Requires a pointer to
*+   ToasterBase in A5 and is tied closely to the Switcher display system.
*+   In the case of error writing out the specified Project file or its
*+   associated Book, this routine will attempt to delete those files.
*+
*+ Addendum 2/23/90: Can handle internal TBFGs and AddOn data.
*+ Addendum 3/7/90:
*+   Now uses the TB_LastGlobalError field to pass back a DOS error code
*+   from IoErr(). Note: return code of -1 has no associated
*+   TB_LastGlobalError value.
*+ Addendum 4/12/90:
*+   Removed error code -6 which was related to the CG saving its book.
*+   Since the CG processing routines handle presenting a message to the
*+   user, it was deemed not neccessary to respond to the returned code.
*+   The Project file written out will not be deleted.
*+
*+ Addendum 6/5/90:
*+   Added 32 bit field written directly after the FrameStore device for
*+   controlling the status of On/Off Slices.
*+ Addendum 9/16/90:
*+   Added code to allow the writing out of LUT croutons from the TB_LUTFGL.
*+ Addendum 10/9/90:
*+   The 32 bit field defined earlier for controlling the status of On/Off
*+   Slices has now been split into two 16 bit fields. The second 16 bit
*+   field is the new 16 bit version of the On/Off Slice field. The first
*+   16 bit field (which was always zero in the 32 bit field versions and
*+   therefore allows us backward compatability) denotes the number of bytes
*+   to be written in between the following On/Off Slice 16 bit field and the
*+   start of the crouton script entries. This allows for at the moment to
*+   save/restore the border and matte colors in the project, with an eye to
*+   other possible additions. NOTE: The extension field must not exceed the
*+   4K size of the TB_FileBuff area it will be buffered into!!
*+
*+*******

	XDEF	NewWriteProject
NewWriteProject:
	SAVE	d1-d7/a0-a4/a6	;SEE ABOVE!!!!

****** SEE ABOVE!!!!!
NewWriteProjectStart
	DEBUGUDEC.l	DBNWP,<NewWriteProject: ProjectNum=>,d0,< >
	DEBUGUDEC.l	DBNWP,<List#=>,d1,<\>
	DEBUGTXT	DBNWP,<Name=>
	DEBUGSTR	DBNWP,(a0)
	DEBUGMSG	DBNWP,<>

	CALLTL	DisplayWaitSprite
	clr.l	TB_LastGlobalError(a5)

	move.l	d0,d6			; setup return code for all OK
	move.l	d1,d7			;grid list #
	add.l	d7,d7
	add.l	d7,d7			;*4
	moveq	#0,d4			;Assume lock failed

	cmp.l	#1000,d6		; is specified Project # valid?
	bcs.s	.makeprojectname

	lea	.ProjectName(pc),a1	; attempt to open new project file
	CALL	STRcopy

	bra	.realWrite
.makeprojectname
	DEBUGMSG	DBNWP,<making project & book names>

	move.l	a0,a2			; keep comment string pointer
	lea	.ProjectName(pc),a3	; build both project and
	lea	.BookName(pc),a4	; book filenames

	divu	#100,d0			; get 100s digit
	add.b	#'0',d0
	move.b	d0,(a3)+
	move.b	d0,(a4)+

	clr.w	d0			; get 10s digit
	swap	d0
	divu	#10,d0
	add.b	#'0',d0
	move.b	d0,(a3)+
	move.b	d0,(a4)+

	swap	d0			; get 1s digit
	add.b	#'0',d0
	move.b	d0,(a3)+
	move.b	d0,(a4)+

	lea	.ProjectSubSTR(pc),a0	; copy type to project filename
	move.l	a3,a1
	CALL	STRcopy
	move.l	a2,a0			; followed by file comment
	CALL	STRcopy

	lea	.BookSubSTR(pc),a0	; copy type to book filename
	move.l	a4,a1
	CALL	STRcopy
	move.l	a2,a0			; followed by file comment
	CALL	STRcopy

	DEBUGMSG	DBNWP,<before LockProject>

	CALL	LockProject		; get directory to where the project
	move.l	d0,d4			; hold onto project directory lock
					; file should go
	bne.s	.realWrite		; if we got there - continue

	moveq	#-2,d6			; else setup error code
	bra	.Exit			; and exit

.realWrite
	lea	.ProjectName(pc),a0	; attempt to open new project file

	DEBUGTXT	DBNWP,<before Open, FILE=>
	DEBUGSTR	DBNWP,0(a0)
	DEBUGMSG	DBNWP,<>

	move.l	a0,d1
	move.l	#MODE_NEWFILE,d2
	GET.l	TB_DOSBase,a6
	CALLROM	Open
	move.l	d0,d5			; hold onto filehandle for project
	bne.s	.OpenProject		; continue if project opened

	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-3,d6			; else setup error code
	bra	.FreePLock		; and exit

.OpenProject:
	bsr	WhatSlicesLoaded
	move.w	d0,LoadedSlices		; Make sure Tag is current

	GET.l	TB_FileBuff,d2		; Temporary write buffer
	movea.l	d2,a1
	move.l	#'Proj',(a1)+		;File identifier
	move.l	#'ect'<<8,(a1)+
	clr.l	(a1)+			;Version & rev = 4.0

	clr.l	(a1)+	;pad0
	clr.l	(a1)+	;pad1
	clr.l	(a1)+	;pad2
	clr.l	(a1)+	;pad3

	GET.l	TB_SystemTags,a0
	bsr	GetSizeOfListsUnsavedItems	;might be zero
	add.l	#4,d0				;end of tag list NULL
	move.l	d0,(a1)+

	move.l	d5,d1			; handle
;;	GET.l	TB_FileBuff,d2
	moveq	#4*(3+4+1),d3
	CALLROM	Write
	cmp.l	d0,d3
	bne	.BadWrite

	movea.l	d5,a0			;handle
	GET.l	TB_SystemTags,a1	;taglists

	bsr	WriteUnsavedTagLists
	beq	.BadWrite

	move.l	#0,-(sp)	;stash taglist end on stack
	move.l	sp,d2
	moveq	#4,d3
	move.l	d5,d1
	CALLROM	Write		; now write out tag list block
	addq.w	#4,sp
	cmp.l	d0,d3		; everything written out?
	bne	.BadWrite	; if not - denote the error

**+ The following was removed on 12-6-94 when I simplified
**+ the Project file format for 4.0 to use a System Tag list.
**+
**+	DEBUGMSG	DBNWP,<before Write device>
**+
**+	GET.l	TB_FSDev,a0		; now write out the FS device
**+	move.l	d5,d1
**+	move.l	a0,d2
**+	CLEAR	d3
**+	move.b	(a0),d3			;Length of string (not including NULL
**+	addq.b	#2,d3			;include length byte & NULL
**+	CALLROM	Write
**+	cmp.l	d0,d3			; was FS device name written out?
**+	beq.s	.WroteFSDev		; yup - skip on
**+
**+.BadWrite:
**+	CALLROM	IoErr			; get secondary error code from DOS
**+	PUT.l	d0,TB_LastGlobalError
**+
**+	moveq	#-4,d6			; else setup error code
**+	bra	.ClosePFile		; and exit
**+
**+.WroteFSDev:
**+	moveq	#16,d3			; size for extension field is 16...
**+	swap	d3			; Addendum 10/9/90:
**+
**+	bsr	WhatSlicesLoaded
**+	XREF	LoadedSlices
**+	move.w	d0,LoadedSlices
**+
**+	move.w	d0,d3
**+
**+	DEBUGMSG	DBNWP,<before write sliceflag>
**+
**+	move.l	d3,-(sp)		; save data on the stack
**+	move.l	d5,d1			; now write the bit field out
**+	move.l	sp,d2
**+	moveq	#4,d3
**+	CALLROM	Write
**+	lea	4(sp),sp
**+	cmp.l	d0,d3			; was the bit field written out?
**+	bne	.BadWrite		; nope - jump on error
**+
**+	GET.l	TB_FileBuff,a0		; form and write the extension area
**+*					; Addendum 10/9/90:
**+	move.w	TB_ToastBGC(a5),(a0)+
**+	move.w	TB_BorderC(a5),(a0)+
**+	CLEAR	d0			; force unused areas to zero....
**+	move.l	d0,(a0)+
**+	move.l	d0,(a0)+
**+	move.l	d0,(a0)
**+
**+	DEBUGMSG	DBNWP,<before write BGC & BorderC>
**+
**+	move.l	d5,d1			; write out the extension area
**+	GET.l	TB_FileBuff,d2
**+	moveq	#16,d3
**+	CALLROM	Write
**+	cmp.l	d0,d3
**+	bne	.BadWrite
**+
	move.l	TB_ToolBoxGrids(a5),a2	; now write out crouton script file
	lea	0(a2,d7.w),a3

	DEBUGHEXI.l	DBNWP,<ToolBoxGrids=>,a2,<\>
	DEBUGUDEC.w	DBNWP,<List#=>,d7,<\>
	DEBUGHEXI.l	DBNWP,<List=>,a3,<\>

	bra	.TBFG_OK

.TBFGLoop:
	DEBUGMSG	DBNWP,<Before WriteProjEntry>

	move.l	d0,a3			; attempt to write out next TBFG
	move.l	a3,a1			; into crouton script file
	move.l	d5,a0
	CALL	WriteProjEntry
	beq.s	.TBFG_OK

.BadWriteOut:
	moveq	#-5,d6			; else setup error code
	bra	.ClosePFile		; and exit

.BadWrite:
	CALLROM	IoErr			; get secondary error code from DOS
	PUT.l	d0,TB_LastGlobalError

	moveq	#-4,d6			; else setup error code
	bra	.ClosePFile		; and exit

.TBFG_OK:
	DEBUGHEXI.l	DBNWP,<NextFG=>,0(a3),<\>

	move.l	(a3),d0			; get next TBFG in the list - if any
	bne	.TBFGLoop		; reloop if another TBFG to do

	DEBUGMSG	DBNWP,<FG List finished>

*-------------------------------------
**+	GET.l	TB_LUTFGL,d0		; get first LUT crouton
**+	beq	.FinishedAll		; ...if none - skip on
**+
**+.LUTLoop:
**+	DEBUGMSG	DBNWP,<have a LUTFGL>
**+
**+	move.l	d0,a2			; address next LUT crouton
**+	move.l	a2,a1
**+	move.l	d5,a0
**+	CALL	WriteProjEntry
**+	bne	.BadWriteOut		; ...if an error occured
**+
**+	move.l	(a2),d0			; reloop till list empty
**+	bne.s	.LUTLoop
**+
**+.FinishedAll:
**+	DEBUGMSG	DBNWP,<before check to see if CG alive>
**+
**+	moveq	#CGSLICEID,d0		; is the CG alive?
**+	DEA	TB_SliceFGL,a0
**+	CALL	IndexFastG
**+	beq	.TermPFile		; if not - skip the CG section
**+	move.l	d0,a0			; (CG will have a FG_PTRIndex of 0
**+	move.w	FG_PTRIndex(a0),d0	;  if Off - 1 if On)
**+	beq.s	.TermPFile
**+
**+	DEBUGMSG	DBNWP,<before SaveCGBook>
**+
**+	lea	.BookName(pc),a0	; ask CG to save the specified book
**+	move.l	d4,a1
**+	XCALL	SaveCGBook
**+
**+;;	move.l	d0,d0
**+;;	beq.s	.TermPFile		; if book saved OK - continue
**+;;
**+;;	moveq	#-6,d6
**+;;	add.w	d0,d6			; else setup error code
**+

* write end of project file marker (=zero Entry size)
.TermPFile:
	DEBUGMSG	DBNWP,<before write end of project marker>

	move.l	#0,-(sp)	;stash taglist end on stack
	move.l	sp,d2
	moveq	#4,d3
	move.l	d5,d1
	CALLROM	Write		; now write out tag list block
	addq.w	#4,sp
	cmp.l	d0,d3		; everything written out?
	bne	.BadWriteOut	; if not - denote the error

.ClosePFile:
	DEBUGMSG	DBNWP,<before close>

	move.l	d5,d1			; close down project file
	CALLROM	Close

	tst.l	d6			; was there an error?
	bpl	.FreePLock		; if not continue

	DEBUGMSG	DBNWP,<error so deleting project & book>

	lea	.ProjectName(pc),a0	; else attempt to delete Project file
	move.l	a0,d1
	CALLROM	DeleteFile

	lea	.BookName(pc),a0	; and Book file
	move.l	a0,d1
	CALLROM	DeleteFile

.FreePLock:
	DEBUGMSG	DBNWP,<Unlocking Project drawer>

	move.l	d4,d1			; free up lock on project directory
	beq.s	.Exit
	CALLROM	UnLock

.Exit:
	DEBUGMSG	DBNWP,<befor DisplayNormalSprite>

	CALLTL	DisplayNormalSprite

	DEBUGMSG	DBNWP,<return from WriteProject>

	move.l	d6,d0			; setup return code
	REST	d1-d7/a0-a4/a6
	rts

.ProjectSubSTR:
	DC.b	'.PJ.',0

.BookSubSTR:
	DC.b	'.BK.',0

.BookName:
	DS.b	20

.ProjectName:
	xdef	FullProjectName
FullProjectName
	DS.b	368


	CNOP	0,2

*+*******
*+
*+ SetLibVector
*+
*+ This function replaces the specified library vector of the specified
*+ library much like the Exec SetFunction(), but without the additional
*+ checksumming of the library.
*+
*+ LONG SetLibVector(  Offset, Library, NewVector );
*+  D0                  D0      A0       A1
*+
*+ LONG Offset:
*+   The low signed 16 bits represents the usually negative offset from the
*+   specified library base addressing a vector that is to be changed.
*+
*+ APTR Library:
*+   Pointer to the specified library to be altered.
*+
*+ APTR NewVector:
*+   Pointer to the new function the modified library vector is to address.
*+
*+ Notes:
*+   Trashes D1,A0,A1, and the condtion codes. Returns the previous function
*+   vector in D0. Works ONLY on libararies with 6 byte absolute long
*+   vectors. This function does NO error checking. Since it does no library
*+   summing, it does not require that the specified library have a valid
*+   library base structure, such as Toaster auxillary libraries. Requires
*+   a pointer to ToasterBase in A5. It it not tied to the Switcher display
*+   system in any way.
*+
*+ Addendum 2/26/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_SetLibVector
_SetLibVector:
	movem.l	4(sp),d0/a0/a1
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	SetLibVector
	REST1	a5
	rts

	ENDC

	XDEF	SetLibVector
SetLibVector:	; entry: Offset, Library, NewVector
*			  D0      A0       A1
	SAVE	a2-a4/a6
	lea	2(a0,d0.w),a2
	move.l	a1,a3
	GET.l	TB_SYSBase,a6

	CALLROM	Forbid
	move.l	(a2),a4
	move.l	a3,(a2)
	CALLROM	Permit

	CALLROM	CacheClearU

	move.l	a4,d0
	REST	a2-a4/a6
	rts

*+*******
*+
*+ ReValidate
*+
*+ This function forces a re-validation on the specified floppy devices that
*+ are also known to the Switcher system.
*+
*+ void ReValidate( Mask );
*+                   D0
*+
*+ LONG Mask:
*+   Bits 0-3 correspond to floppy devices 0-3. If the corresponding bit is
*+   set for a floppy device AND it exists according to the floppy device
*+   allocation flag, it will be ReValidated by this function.
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. Requires
*+   a pointer to ToasterBase in A5, but is not closely tied to the Switcher
*+   display system. The mechanism used to force the re-validation of the
*+   specified floppy device is to issue an inhibit/un-inhibit pair of DOS
*+   packets to the controlling floppy device process.
*+
*+ Addendum 3/1/90:
*+ Addendum 3/5/90:
*+   This routine does not need to rebuild the Project/FrameStore string
*+   tables directly. As it turns out, sending an inhibit/un-inhibit pair of
*+   DOS packets seems to cause DOS to send out a DISKINSERTED/DISKREMOVED
*+   input event for each floppy device known to the Switcher system that
*+   was effected by ReValidate(). A DISKINSERTED/DISKREMOVED IDCMP message
*+   for each floppy device corresponds to whether a floppy disk is in/out
*+   of the floppy device.
*+ Addendum 4/4/90:
*+   This routine now uses FloppyDiskInfo() to insure that only the specified
*+   floppy devices that also actually have a disk inserted in them get
*+   re-validated.
*+
*+*******

	IFNE	_CCODE

	XDEF	_ReValidate
_ReValidate:
	move.l	4(sp),d0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ReValidate
	REST1	a5
	rts

	ENDC

	XDEF	ReValidate
ReValidate:	; entry: Mask
*			  D0
	SAVE	d2/a2-a4/a6

	move.b	d0,d2			; save request mask

	CALL	FloppyDiskInfo		; insure that only devices with
	lsr.w	#8,d0			; a disk in them get re-validated
	and.b	d0,d2

	GET.l	TB_SYSBase,a6		; get our reply port
	CLEARA	a1
	CALLROM	FindTask
	move.l	d0,a2
	lea	pr_MsgPort(a2),a2

	lea	.StandardPacket(pc),a3	; address standard packet

	and.w	TB_FloppyAlloc(a5),d2	; get floppy allocation AND request

	btst.l	#0,d2			; floppy 0 allocated and requested?
	beq.s	.No0			; skip if not

	lea	.DeviceSelect(pc),a0
	move.b	#'0',(a0)		; setup drive name

	CALL.s	.RebuildAll		; do it all

.No0:
	btst.l	#1,d2			; floppy 1 allocated and requested?
	beq.s	.No1			; skip if not

	lea	.DeviceSelect(pc),a0
	move.b	#'1',(a0)		; setup drive name

	CALL.s	.RebuildAll		; do it all

.No1:
	btst.l	#2,d2			; floppy 2 allocated and requested?
	beq.s	.No2			; skip if not

	lea	.DeviceSelect(pc),a0
	move.b	#'2',(a0)		; setup drive name

	CALL.s	.RebuildAll		; do it all

.No2:
	btst.l	#3,d2			; floppy 3 allocated and requested?
	beq.s	.No3			; skip if not

	lea	.DeviceSelect(pc),a0
	move.b	#'3',(a0)		; setup drive name

	CALL.s	.RebuildAll		; do it all

.No3:
	REST	d2/a2-a4/a6
	rts

.RebuildAll:
	move.l	a2,sp_Pkt+dp_Port(a3)	; setup our reply port

	moveq	#-1,d0			; denote inhibit flag set
	move.l	d0,sp_Pkt+dp_Arg1(a3)

	GET.l	TB_DOSBase,a6		; get message port of floppy device
	lea	.DeviceName(pc),a0	; task to send packet to
	move.l	a0,d1
	CALLROM	DeviceProc
	move.l	d0,a4			; we assume this works!

	GET.l	TB_SYSBase,a6		; send the inhibit packet
	move.l	a4,a0
	move.l	a3,a1
	CALLROM	PutMsg
	move.l	a2,a0
	CALLROM	WaitPort		; wait for responce
	move.l	a2,a0
	CALLROM	GetMsg			; remove it from the port

	move.l	a2,sp_Pkt+dp_Port(a3)	; setup our reply port

	CLEAR	d0			; denote inhibit flag reset
	move.l	d0,sp_Pkt+dp_Arg1(a3)

	move.l	a4,a0			; send the un-inhibit packet
	move.l	a3,a1
	CALLROM	PutMsg
	move.l	a2,a0
	CALLROM	WaitPort		; wait for responce
	move.l	a2,a0
	JUMPROM	GetMsg			; remove it from the port
*					; and return to caller

	CNOP	0,4

.StandardPacket:
	DC.l	0		; LN_SUCC
	DC.l	0		; LN_PRED
	DC.b	NT_MESSAGE	; LN_TYPE
	DC.b	0		; LN_PRI
	DC.l	.Packet		; LN_NAME
	DC.l	0		; MN_REPLYPORT
	DC.w	sp_SIZEOF	; MN_LENGTH
.Packet:
	DC.l	.StandardPacket	; dp_Link
	DC.l	*-*		; dp_Port
	DC.l	ACTION_INHIBIT	; dp_Type
	DC.l	0		; dp_Res1
	DC.l	0		; dp_Res2
	DC.l	0		; dp_Arg1
	DC.l	0		; dp_Arg2
	DC.l	0		; dp_Arg3
	DC.l	0		; dp_Arg4
	DC.l	0		; dp_Arg5
	DC.l	0		; dp_Arg6
	DC.l	0		; dp_Arg7

.DeviceTSName:
	DC.b	4
.DeviceName:
	DC.b	'DF'
.DeviceSelect:
	DC.b	*-*
	DC.b	':',0

	CNOP	0,2


*+*******
*+
*+ InitFileBuffering
*+
*+ This function buffers the specified input, output, or input/output files.
*+
*+ void InitFileBuffering( Input, Output );
*+                          A0     A1
*+
*+ APTR Input:
*+   Pointer to a DOS filehandle representing the input file to be buffered.
*+   NULL denotes no input file.
*+
*+ APTR Output:
*+   Pointer to a DOS filehandle representing the output file to be buffered.
*+   NULL denotes no output file.
*+
*+ Notes:
*+   Trashes D0,D1,A0,A1, and the condition codes. Returns nothing. This
*+   function uses the large FAST memory chunk allocated at Toaster startup
*+   time for file buffering. This FAST memory chunk is usually dedicated to
*+   hold a large lookup table for the DV effects system. This means that all
*+   file buffering operations must be atomic, that is, nothing else in the
*+   Toaster system, DV effects in particular, can take place while using the
*+   FAST memory chunk for file buffering. Also when through with all file
*+   buffering operations, it is imperative to restore the FAST memory chunk
*+   to usefulness by making a call to the ToasterBase function
*+   InitDVEFastMem(). If both input and output files are specified for
*+   buffering, then the FAST memory chunk will be equally divided for
*+   buffering both file streams. If only an input or output file is
*+   specified, then the entire FAST memory chunk will be used for buffering
*+   the file stream. This function requires a pointer to ToasterBase in A5
*+   and is closely tied to the Switcher system. NOTE: This function is NOT
*+   re-entrant and/or re-usable.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_InitFileBuffering
_InitFileBuffering:
	movem.l	4(sp),a0/a1
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	InitFileBuffering
	REST1	a5
	rts

	ENDC

	XDEF	InitFileBuffering
InitFileBuffering:	; entry: Input, Output
*				  A0     A1

	SAVE	a3/a4			; save work registers

	lea	FileBufferInfo(pc),a4	; get addressing to control struct

	move.l	a4,a3			; clear the structure to 0
	CLEAR	d0
	moveq	#FBI_SIZ/4-1,d1

.Loop:
	move.l	d0,(a3)+
	dbf	d1,.Loop

	move.l	a0,FBI_InputFH(a4)	; place specified input file
	beq.s	.NoInput		; if NULL - skip on

	addq.w	#4,d0			; else bump index

.NoInput:
	move.l	a1,FBI_OutputFH(a4)	; place specified output file
	beq.s	.NoOutput		; if NULL - skip on

	addq.w	#8,d0			; else bump index

.NoOutput:
	move.l	.Table(pc,d0.w),a0	; use index to jump to proper handler
	jmp	(a0)

	CNOP	0,4
.Table:
	DC.l	.Exit			; if no input and no output
	DC.l	.HandleInput		; input only
	DC.l	.HandleOutput		; output only
	DC.l	.HandleInputOutput	; input and output

.HandleInput:
	GET.l	TB_FASTMemSIZE,FBI_InputBuffSize(a4)
	GET.l	TB_FASTMem,d0
	move.l	d0,FBI_InputBuff(a4)
	move.l	d0,FBI_InputBuffPos(a4)
	bra.s	.Exit

.HandleOutput:
	GET.l	TB_FASTMemSIZE,d0
	move.l	d0,FBI_OutputBuffSize(a4)
	move.l	d0,FBI_OutputBuffCount(a4)
	GET.l	TB_FASTMem,d0
	move.l	d0,FBI_OutputBuff(a4)
	move.l	d0,FBI_OutputBuffPos(a4)
	bra.s	.Exit

.HandleInputOutput:
	GET.l	TB_FASTMemSIZE,d0
	lsr.l	#1,d0
	move.l	d0,FBI_InputBuffSize(a4)
	move.l	d0,FBI_OutputBuffSize(a4)
	move.l	d0,FBI_OutputBuffCount(a4)
	GET.l	TB_FASTMem,d1
	move.l	d1,FBI_InputBuff(a4)
	move.l	d1,FBI_InputBuffPos(a4)
	add.l	d0,d1
	move.l	d1,FBI_OutputBuff(a4)
	move.l	d1,FBI_OutputBuffPos(a4)

.Exit:
	REST	a3/a4			; restore work registers
	rts				; and return to caller

FileBufferInfo:
.FBI:
	DATASYM	FBI_InputFH,.FBI
	DS.l	1
	DATASYM	FBI_OutputFH,.FBI
	DS.l	1
	DATASYM	FBI_InputBuff,.FBI
	DS.l	1
	DATASYM	FBI_OutputBuff,.FBI
	DS.l	1
	DATASYM	FBI_InputBuffPos,.FBI
	DS.l	1
	DATASYM	FBI_OutputBuffPos,.FBI
	DS.l	1
	DATASYM	FBI_InputBuffCount,.FBI
	DS.l	1
	DATASYM	FBI_OutputBuffCount,.FBI
	DS.l	1
	DATASYM	FBI_InputBuffSize,.FBI
	DS.l	1
	DATASYM	FBI_OutputBuffSize,.FBI
	DS.l	1
	DATASYM	FBI_SIZ,.FBI

*+*******
*+
*+ BuffInput
*+
*+ This function is primarily an internal routine to support transparent
*+ input buffering. It may be called directly to insure a buffer is loaded.
*+
*+ LONG BuffInput();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. The condition codes will be setup to the result in D0.
*+   D0 will be clear if all went well, -1 if a DOS error occured. In the
*+   event of an error, the DOS IoErr() will be placed in TB_LastGlobalError.
*+   This function requires a pointer to ToasterBase in A5, and is closely
*+   tied to the Toaster system. This function also requires that the
*+   FileBufferInfo data structure be filled out and valid.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuffInput
_BuffInput:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuffInput
	REST1	a5
	rts

	ENDC

	XDEF	BuffInput
BuffInput:
	SAVE	d2/d3/a4/a6		; save work registers

	lea	FileBufferInfo(pc),a4	; address control data structure

	move.l	FBI_InputBuffSize(a4),d3	; get buffer size
	move.l	FBI_InputBuff(a4),d2		; get buffer address
	move.l	d2,FBI_InputBuffPos(a4)		; reset current buffer poz
	move.l	FBI_InputFH(a4),d1		; get input filehandle
	GET.l	TB_DOSBase,a6			; get DOS base
	CALLROM	Read				; attempt to fill the buffer
*						; or read the rest of file
	bmi.s	.Error				; skip on DOS error

	CLEAR	d2				; else assume everything OK
	move.l	d0,FBI_InputBuffCount(a4)	; place amount read in
	bra.s	.Exit				; and jump to exit

.Error:
	moveq	#-1,d2			; else denote an error
	CALLROM	IoErr			; get error from DOS
	PUT.l	d0,TB_LastGlobalError	; and save it

.Exit:
	move.l	d2,d0			; place return code
	REST	d2/d3/a4/a6		; restore work registers
	rts				; return to caller

*+*******
*+
*+ BuffGetChar
*+
*+ This function gets the next input character from the active input file
*+ with complete and transparent buffering.
*+
*+ LONG BuffGetChar();
*+  D0
*+
*+ Notes:
*+   The condition codes will be setup to the result in D0.
*+   D0 will be a long value of the character read in if all went OK. -2 will
*+   be returned if the end of file was reached. -1 will be returned if a
*+   DOS error occured. In the event of a DOS error, the DOS IoErr() will
*+   have been placed in TB_LastGlobalError. This function requires a pointer
*+   to ToasterBase in A5, and is closely tied to the Toaster system. This
*+   function also requires that the FileBufferInfo data structure be filled
*+   out and valid.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuffGetChar
_BuffGetChar
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuffGetChar
	REST1	a5
	rts

	ENDC

	XDEF	BuffGetChar
BuffGetChar:
	SAVE	d1/a0-a1/a4			; save a work register

	lea	FileBufferInfo(pc),a4	; address control information

	move.l	FBI_InputBuffCount(a4),d0	; any chars left in buffer?
	bne.s	.GetNextChar			; if so - skip on

	CALL.s	BuffInput		; buffer in more input
	bmi.s	.Exit			; skip out with error code -1

	move.l	FBI_InputBuffCount(a4),d1	; any chars in buffer?
	bne.s	.GetNextChar0			; yup - skip on

	moveq	#-2,d0			; else denote EOF
	bra.s	.Exit

.GetNextChar:
	CLEAR	d0			; clear off result register

.GetNextChar0:
	move.l	FBI_InputBuffPos(a4),a0		; get next character
	move.b	(a0)+,d0

	move.l	a0,FBI_InputBuffPos(a4)		; place new buffer position
	subq.l	#1,FBI_InputBuffCount(a4)	; decrement number of chars
*						; left in the buffer

	move.l	d0,d0			; assure ccr to result in D0

.Exit:
	REST	d1/a0-a1/a4		; restore the work register
	rts

*+*******
*+
*+ BuffRead
*+
*+ This function gets the next specified block size of characters from the
*+ active input file stream with complete and transparent buffering.
*+
*+ LONG BuffRead( Count, Buffer );
*+  D0             D0     A0
*+
*+ LONG Count:
*+   Longword value that denotes how many characters are to be read from the
*+   active input file stream. This value should be a positive longword
*+   value, in particular, not -1, so that an error can be discerned.
*+
*+ APTR Buffer:
*+   Pointer to the buffer where the inputted characters are to be placed.
*+
*+ Notes:
*+   The condition codes will be setup to the result in D0.
*+   D0 will be the number of characters read in if all went OK. A return
*+   value of less than what was requested indicates that the EOF was
*+   reached before the request was filled. -1 will be returned if a
*+   DOS error occured. In the event of a DOS error, the DOS IoErr() will
*+   have been placed in TB_LastGlobalError. This function requires a pointer
*+   to ToasterBase in A5, and is closely tied to the Toaster system. This
*+   function also requires that the FileBufferInfo data structure be filled
*+   out and valid. Note: This routine can handle the case of Count as 0.
*+   Important note: Do not use this function if you wish to retry a read
*+   operation that was previously unsuccessful. Because of the intermediate
*+   buffering provided by this system, and the fact that this function does
*+   not return the number of characters that may have been read before an
*+   error occurs, there is no way to reset the various file pointers. Use
*+   BuffGetChar() in your own controlled loop instead.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuffRead
_BuffRead:
	movem.l	4(sp),d0/a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuffRead
	REST1	a5
	rts

	ENDC

	XDEF	BuffRead
BuffRead:	; entry: Count, Buffer
*			  D0     A0

	SAVE	d1-d3/a0-a2			; save work registers

	move.l	d0,d3				; save count
	beq.s	.Exit				; if 0 - early exit
	CLEAR	d2				; setup counter
	move.l	a0,a2				; save buffer pointer

.Loop:
	CALL	BuffGetChar			; get another input char
	bmi.s	.BreakLoop			; break loop if no char

	move.b	d0,(a2)+			; place the char
	addq.l	#1,d2				; bump up buffer count
	cmp.l	d2,d3				; are we finished?
	bne.s	.Loop				; continue if not
	bra.s	.NormalExit			; jump on to finish

.BreakLoop:
	cmp.l	#-1,d0				; did a DOS error occur?
	bne.s	.NormalExit			; if not - jump on to finish

	move.l	d0,d0				; else denote the DOS error
	bra.s	.Exit				; and exit

.NormalExit:
	move.l	d2,d0				; place read in count in D0

.Exit:
	REST	d1-d3/a0-a2			; restore work registers
	rts					; return to caller

*+*******
*+
*+ BuffOutput
*+
*+ This function is primarily an internal routine to support transparent
*+ output buffering, but it should be called at the end of output operations
*+ so that the buffer is flushed out to the output stream.
*+
*+ LONG BuffOutput();
*+  D0
*+
*+ Notes:
*+   Trashes D1,A0,A1. The condition codes will be setup to the result in D0.
*+   D0 will be clear if all went well, -1 if a DOS error occured. In the
*+   event of an error, the DOS IoErr() will be placed in TB_LastGlobalError.
*+   Error code -2 is returned if not all of the data was written out, and
*+   no DOS error occured. Should not normally be seen. This function
*+   requires a pointer to ToasterBase in A5, and is closely tied to the
*+   Toaster system. This function also requires that the FileBufferInfo
*+   data structure be filled out and valid. Important note: This function
*+   can be retried if error code returned is -1, but NOT on error code -2.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuffOutput
_BuffOutput:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuffOutput
	REST1	a5
	rts

	ENDC

	XDEF	BuffOutput
BuffOutput:
	SAVE	d2/d3/a4/a6		; save work registers

	lea	FileBufferInfo(pc),a4	; address control data structure

	move.l	FBI_OutputBuffSize(a4),d3	; get total buffer size
	sub.l	FBI_OutputBuffCount(a4),d3	; get buffer size to write
	move.l	FBI_OutputBuff(a4),d2		; get buffer address
	move.l	FBI_OutputFH(a4),d1		; get output filehandle
	GET.l	TB_DOSBase,a6			; get DOS base
	CALLROM	Write				; attempt to write out buffer
	tst.l	d0			; DOS error occur?
	bpl.s	.NoDOSErr		; if not - skip on

	CALLROM	IoErr			; get error from DOS
	PUT.l	d0,TB_LastGlobalError	; and save it
	moveq	#-1,d0			; denote an error occured
	bra.s	.Exit			; and exit

.NoDOSErr:
	sub.l	d3,d0			; was all of the data written out?
	beq.s	.OKWrite		; if all OK - jump on

	moveq	#-2,d0			; else denote that not all of the
*					; data was written out
	bra.s	.Exit			; and exit

.OKWrite:
	move.l	FBI_OutputBuffSize(a4),FBI_OutputBuffCount(a4)	; reset
*								; buffer
*								; count
	move.l	FBI_OutputBuff(a4),FBI_OutputBuffPos(a4)	; reset
*								; current
*								; buffer poz
	move.l	d0,d0			; denote all OK

.Exit:
	REST	d2/d3/a4/a6		; restore work registers
	rts				; return to caller

*+*******
*+
*+ BuffPutChar
*+
*+ This function outputs the specified character to the active output file
*+ with complete and transparent buffering.
*+
*+ LONG BuffPutChar( Data );
*+  D0                D0
*+
*+ LONG Data:
*+   The low byte contains the data character to be written.
*+
*+ Notes:
*+   Trashes D1,A0,A1. The condition codes will be setup to the result in D0.
*+   D0 will be cleared if all went OK. -1 will be returned if a DOS error
*+   occured. In the event of a DOS error, the DOS IoErr() will have been
*+   placed in TB_LastGlobalError. Error code -2 is returned if not all of
*+   the data was written out, and no DOS error occured. Should not normally
*+   be seen. This function requires a pointer to ToasterBase in A5, and is
*+   closely tied to the Toaster system. This function also requires that the
*+   FileBufferInfo data structure be filled out and valid. NOTE: After the
*+   last use of this function to output data an output stream, it is
*+   neccessary to make a call to the BuffOutput() function to insure that
*+   the buffer is flushed to the output stream.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuffPutChar
_BuffPutChar
	move.l	4(sp),d0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuffPutChar
	REST1	a5
	rts

	ENDC

	XDEF	BuffPutChar
BuffPutChar:	; entry: Data
*			  D0

	SAVE1	a4			; save a work register

	lea	FileBufferInfo(pc),a4	; address control information

	move.l	FBI_OutputBuffCount(a4),d1	; any room left in buffer?
	bne.s	.PutNextChar0			; if so - skip on

	SAVE1	d0			; save the data
	CALL.s	BuffOutput		; write the current buffer out
	beq.s	.PutNextChar		; skip on if all went OK

	lea	4(sp),sp		; clear off the stack
	bra.s	.Exit			; exit with return code in D0

.PutNextChar:
	REST1	d0				; restore the data

.PutNextChar0:
	move.l	FBI_OutputBuffPos(a4),a0	; place the data
	move.b	d0,(a0)+

	move.l	a0,FBI_OutputBuffPos(a4)	; place new buffer position
	subq.l	#1,FBI_OutputBuffCount(a4)	; decrement number of open
*						; char slots left in buffer

	CLEAR	d0			; assure clean bill of health

.Exit:
	REST1	a4			; restore the work register
	rts

*+*******
*+
*+ BuffWrite
*+
*+ This function attempts to write the specified block size of characters to
*+ the active output file stream with complete and transparent buffering.
*+
*+ LONG BuffWrite( Count, Buffer );
*+  D0              D0     A0
*+
*+ LONG Count:
*+   Longword value that denotes how many characters are to be written to the
*+   active output file stream. This value should be a positive longword
*+   value, in particular, not -1, so that an error can be discerned.
*+
*+ APTR Buffer:
*+   Pointer to the buffer where the output characters reside.
*+
*+ Notes:
*+   Trashes D1,A0,A1. The condition codes will be setup to the result in D0.
*+   D0 will be the number of characters written out if all went OK. A return
*+   value of less than what was requested indicates a wierd error condition
*+   that should not be seen too often. -1 will be returned if a
*+   DOS error occured. In the event of a DOS error, the DOS IoErr() will
*+   have been placed in TB_LastGlobalError. This function requires a pointer
*+   to ToasterBase in A5, and is closely tied to the Toaster system. This
*+   function also requires that the FileBufferInfo data structure be filled
*+   out and valid. Note: This routine can handle the case of Count as 0.
*+   Important note: Do not use this function if you wish to retry a write
*+   operation that was previously unsuccessful. Because of the intermediate
*+   buffering provided by this system, and the fact that this function does
*+   not return the number of characters that may have been written before an
*+   error occurs, there is no way to reset the various file pointers. Use
*+   BuffPutChar() in your own controlled loop instead. However, if
*+   BuffPutChar() returns -2, DO NOT attempt to retry an output operation.
*+
*+ Addendum 4/13/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_BuffWrite
_BuffWrite:
	movem.l	4(sp),d0/a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	BuffWrite
	REST1	a5
	rts

	ENDC

	XDEF	BuffWrite
BuffWrite:	; entry: Count, Buffer
*			  D0     A0

	SAVE	d2/d3/a2			; save work registers

	move.l	d0,d3				; save count
	beq.s	.Exit				; if 0 - early exit
	CLEAR	d2				; setup counter
	move.l	a0,a2				; save buffer pointer

.Loop:
	move.l	(a2)+,d0			; get next output char
	CALL.s	BuffPutChar			; and put it out
	bmi.s	.BreakLoop			; break loop on problem

	addq.l	#1,d2				; bump up buffer count
	cmp.l	d2,d3				; are we finished?
	bne.s	.Loop				; continue if not
	bra.s	.NormalExit			; jump on to finish

.BreakLoop:
	cmp.l	#-1,d0				; did a DOS error occur?
	bne.s	.NormalExit			; if not - jump on to finish

	move.l	d0,d0				; else denote the DOS error
	bra.s	.Exit				; and exit

.NormalExit:
	move.l	d2,d0				; place write in count in D0

.Exit:
	REST	d2/d3/a2			; restore work registers
	rts					; return to caller

*+***
*+
*+ ReqSystem
*+
*+ This little private function handles putting up a requester for USER
*+ intervention, and all responsibilities that need to be handled.
*+
*+ LONG ReqSystem( ArrayPointer );
*+  D0              A0
*+
*+ APTR ArrayPointer:
*+   A pointer to an array of 4 string pointer making up the text body of
*+   the requester.
*+
*+ Returns non-0 if TRUE (Left button) was selected,
*+  0 if FALSE (Right Button) was selected. Also returns
*+ FALSE if requester didn't open. Also returns TRUE if a diskchange occurs.
*+ Trashes D1,A0,A1.
*+
*+ Addendum 4/20/90:
*+   This function is known to support the following functions:
*+   NewReadProject(), Readroject(), and OpenCroutonLibraries().
*+   This routine is tailor-made for the routines just mentioned.
*+   See SwitcherAutoRequest() immediatedly below this function for the
*+   public version of this function.
*+
*+***

ReqSystem:
	moveq	#1,d0
	CALL.s	SwitcherAutoRequest
	ble.s	.ExitFALSE

	moveq	#-1,d0			; denote TRUE
	rts				; return to caller

.ExitFALSE:
	CLEAR	d0			; denote FALSE
	rts				; return to caller

*+*******
*+
*+ SwitcherAutoRequest
*+
*+ This subroutine sets up, displays, and returns the results of the Switcher
*+ requester cooked to your specified args.
*+
*+ LONG SwitcherAutoRequest( ControlFlag, ArrayPointer );
*+  D0                        D0           A0
*+
*+ LONG ControlFlag:
*+   This LONG value controls if DISKINSERTED/DISKREMOVED IDCMP	messages are
*+   to be allowed to return TRUE or FALSE from this function. If specified
*+   as 0, then DISKINSERTED/DISKREMOVED IDCMP messages will not be allowed
*+   to return TRUE or FALSE from this function. The DoSwitcherRequester()
*+   function will not exit until the USER selects TRUE or FALSE. If
*+   the ControlFlag is specified as a positive value, then
*+   DISKINSERTED/DISKREMOVED IDCMP messages will be allowed to return TRUE
*+   from this function. If the ControlFlag is specified as a negative value,
*+   then DISKINSERTED/DISKREMOVED IDCMP messages will be allowed to return
*+   FALSE from this function.
*+ APTR ArrayPointer:
*+   Pointer to an array of 4 string pointers to be used in the Switcher
*+   requester as text.
*+
*+ Notes:
*+   The condition codes will be setup to the result
*+   returned in D0. Requires a pointer to ToasterBase in A5 and is closely
*+   tied to the Switcher display system and floppy disk updating system.
*+   The result returned in D0 is basically the same as used in
*+   DoSwitcherRequester().
*+   D0 = 1 if TRUE (Left Button) selected or diskchange occured
*+    when the ControlFlag was specified as a positive value.
*+   D0 = 0 if the requester could not be rendered.
*+   D0 = -1 if FALSE (Right Button) selected or diskchange occured when
*+    the ControlFlag was specified as a negative value.
*+
*+ Addendum 4/27/90:
*+
*+*******

	IFNE	_CCODE

	XDEF	_SwitcherAutoRequest
_SwitcherAutoRequest:
	movem.l	4(sp),d0/a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	SwitcherAutoRequest
	REST1	a5
	rts

	ENDC

	XDEF	SwitcherAutoRequest
SwitcherAutoRequest:	; entry: ControlFlag, ArrayPointer
*				  D0	       A0

	SAVE	d1/a0-a3				; save work registers

	CLEAR	d1				; assume no extra IDCMP...

	move.l	d0,d0				; extra IDCMP specified?
	beq.s	.DoIt				; nope - we're set - jump

	bmi.s	.Nega				; if to bug CANCEL - skip on

	move.l	#DISKINSERTED+DISKREMOVED,d0	; else denote extra IDCMP
	bra.s	.DoIt				; to return TRUE

.Nega:
	CLEAR	d0				; else denote extra IDCMP
	move.l	#DISKINSERTED+DISKREMOVED,d1	; to return FALSE

.DoIt:
	movem.l	(a0),a0-a3
	XCALL	DoSwitcherRequester

	REST	d1/a0-a3			; restore work registers
	rts

*+***************************************************************************
*+
*+ MouseOn
*+
*+ This function turns mouse movement IDCMP on and sets pertinent
*+ controlling flags in ToasterBase as well
*+
*+ void MouseOn();
*+
*+ Notes:
*+   Trashes only the condition codes, all registers are preserved. Requires
*+   a pointer to ToasterBase in A5.
*+
*+ Addendum 9/7/90:
*+
*+***************************************************************************

	IFNE	_CCODE

	XDEF	_MouseOn
_MouseOn:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	MouseOn
	REST1	a5
	rts

	ENDC

	XDEF	MouseOn
MouseOn:
	addq.w	#1,TB_MouseNest(a5)		; is mouse already disabled?
	bne.s	.ExitQ				; ...if so

	SAVE	d0/d1/a0/a1/a6			; save work registers

	GET.l	TB_SYSBase,a6			; keep others out
	CALLROM	Forbid

	GET.l	TB_Window,a0			; get pointer to window
	or.l	#REPORTMOUSE,wd_Flags(a0)	; report mouse flag on
	move.l	wd_IDCMPFlags(a0),d0		; save original IDCMP flags
	PUT.l	d0,TB_OrgIDCMP
	or.l	#MOUSEMOVE,d0			; add MOUSEMOVE to IDCMP
	GET.l	TB_ITUBase,a6
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6
	CALLROM	Permit

	REST	d0/d1/a0/a1/a6			; restore work registers

.ExitQ:
	rts					; return to caller

*+***************************************************************************
*+
*+ MouseOff
*+
*+ This function turns mouse movement IDCMP off and sets pertinent
*+ controlling flags in ToasterBase as well
*+
*+ void MouseOff();
*+
*+ Notes:
*+   Trashes only the condition codes, all registers are preserved. Requires
*+   a pointer to ToasterBase in A5.
*+
*+ Addendum 9/7/90:
*+
*+***************************************************************************

	IFNE	_CCODE

	XDEF	_MouseOff
_MouseOff:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	MouseOff
	REST1	a5
	rts

	ENDC

	XDEF	MouseOff
MouseOff:
	subq.w	#1,TB_MouseNest(a5)		; is mouse still enabled?
	bpl.s	.ExitQ				; ...if so

	SAVE	d0/d1/a0/a1/a6			; save work registers

	GET.l	TB_SYSBase,a6			; keep others out
	CALLROM	Forbid

	GET.l	TB_Window,a0			; get pointer to window
	and.l	#~REPORTMOUSE,wd_Flags(a0)	; report mouse flag off
	GET.l	TB_OrgIDCMP,d0			; set IDCMP flags to
	GET.l	TB_ITUBase,a6			; what they were
	CALLROM	ModifyIDCMP

	GET.l	TB_SYSBase,a6
	CALLROM	Permit

	REST	d0/d1/a0/a1/a6			; restore work registers

.ExitQ:
	rts					; return to caller

*+***************************************************************************
*+
*+ void FlashVideoOn();
*+
*+ This function replaces the imagery in the Switcher Freeze FG so that the
*+ word "FREEZE" will flash and renders this new image if it thinks the
*+ Switcher interface is up.
*+
*+ Notes: Saves all registers but trashes the condition codes. Requires a
*+   pointer to ToasterBase in A5.
*+
*+ Addendum 9/12/90:
*+
*+***************************************************************************

	IFNE	_CCODE

	XDEF	_FlashVideoOn
_FlashVideoOn:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FlashVideoOn
	REST1	a5
	rts

	ENDC

	XDEF	FlashVideoOn
FlashVideoOn:
	SAVE	d0/d1/a0-a2/a6

	DEA	TB_TransFGL,a0		; find the freeze FG
	moveq	#FRLVID,d0
	CALL	IndexFastG
	beq.s	.ExitQ			; ...if not found

	move.l	d0,a2
	move.w	#DISPLAYMODE0,FG_ModeType(a2)	; setup the special
	move.l	FG_PTRTable(a2),a0		; alternate image
	move.l	4(a0),FG_Data(a2)

	GET.l	TB_Window,a0		; determine if the Switcher screen
	move.l	wd_FirstGadget(a0),a0	; is up
	cmp.w	#'SW',gg_GadgetID(a0)
	bne.s	.ExitQ			; ...if not on Switcher screen

	GET.l	TB_SYSBase,a6		; render the new image
	CALLROM	Forbid
	XCALL	SoftSpriteOff

	move.l	a2,a0
	moveq	#1,d0
	CLEAR	d1
	GET.l	TB_Window,a1
;;	move.l	d1,a2
	CALL	DrawFastGList

	XCALL	SoftSpriteOn
	CALLROM	Permit

.ExitQ:
	REST	d0/d1/a0-a2/a6
	rts

*+***************************************************************************
*+
*+ void FlashVideoOff();
*+
*+ This function restore the original imagery in the Switcher Freeze FG and
*+ renders this new image if it thinks the Switcher interface is up.
*+
*+ Notes: Saves all registers but trashes the condition codes. Requires a
*+   pointer to ToasterBase in A5.
*+
*+ Addendum 9/12/90:
*+
*+***************************************************************************

	IFNE	_CCODE

	XDEF	_FlashVideoOff
_FlashVideoOff:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FlashVideoOff
	REST1	a5
	rts

	ENDC

	XDEF	FlashVideoOff
FlashVideoOff:
	SAVE	d0/d1/a0-a2/a6

	DEA	TB_TransFGL,a0		; find the freeze FG
	moveq	#FRLVID,d0
	CALL	IndexFastG
	beq.s	.ExitQ			; ...if not found

	move.l	d0,a2
	move.w	#DISPLAYMODE2,FG_ModeType(a2)	; setup the
	move.l	FG_PTRTable(a2),a0		; original image
	move.l	(a0),FG_Data(a2)

	GET.l	TB_Window,a0		; determine if the Switcher screen
	move.l	wd_FirstGadget(a0),a0	; is up
	cmp.w	#'SW',gg_GadgetID(a0)
	bne.s	.ExitQ			; ...if not on Switcher screen

	GET.l	TB_SYSBase,a6		; render the original image
	CALLROM	Forbid
	XCALL	SoftSpriteOff

	move.l	a2,a0
	moveq	#1,d0
	CLEAR	d1
	GET.l	TB_Window,a1
;;	move.l	d1,a2
	CALL	DrawFastGList

	XCALL	SoftSpriteOn
	CALLROM	Permit

.ExitQ:
	REST	d0/d1/a0-a2/a6
	rts

*+***************************************************************************
*+
*+ void CancelCG();
*+
*+ This function assures that the controlling crouton entity IS NOT the CG.
*+ If the CG is found to be the controlling crouton entity, then an attempt
*+ to find a ToolBox grid crouton will be made. If the attempt is
*+ successful, that ToolBox crouton will be made the controlling crouton
*+ entity via an FGC_SELECTQ. If the attempt fails, the controlling crouton
*+ was not the CG, or the CG FG could not be found (should never happen),
*+ then this function is a NOP. Trashes the condition codes. No registers
*+ are altered. Requires a pointer to ToasterBase in A5.
*+
*+ Addendum 9/22/90:
*+
*+***************************************************************************

	IFNE	_CCODE

	XDEF	_CancelCG
_CancelCG:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	CancelCG
	REST1	a5
	rts

	ENDC

	XDEF	CancelCG
CancelCG:
	SAVE	d0/d1/a0/a1

	CALLTL	KillAlphaKey	;if any

	DEA	TB_SliceFGL,a0
	moveq	#CGSLICEID,d0
	CALL	IndexFastG
	beq.s	.ExitQ

	cmp.l	TB_EfxFG(a5),d0
	bne.s	.ExitQ

	bsr	SelectStdEfx	;select the 1st crouton we can find

.ExitQ:
	REST	d0/d1/a0/a1
	rts

*****************************************************************************
*
* extra long ULongMultiply( Multiplicand, Multiplier);
*   (64)                       (32)          (32)
*   D1/D0                       D0            D1
*
* This function does a 32 bit x 32 bit unsigned multiply giving a 64 bit
* result in D1/D0 (D1 has high 32 bits - D0 the low 32 bits). No registers
* other than D0/D1 are altered. The condition codes are trashed. Does not
* need a pointer to ToasterBase as it is not tied to the Switcher in any way.
*
* Addendum 10/31/90:
*
****************************************************************************`

	IFNE	_CCODE

	XDEF	_ULongMultiply
_ULongMultiply:
	movem.l	4(sp),d0/d1

	ENDC

	XDEF	ULongMultiply
ULongMultiply:
	movem.l	d2-d5,-(sp)

	move.l	d0,d2

	mulu	d1,d0		; Multiplier.l * Multiplicand.l -> D0

	move.l	d2,d3
	move.l	d1,d4
	swap	d3
	swap	d4
	mulu	d4,d3		; Multiplier.h * Multiplicand.h -> D3

	mulu	d2,d4		; Multiplicand.l * Multiplier.h -> D4

	swap	d2
	mulu	d1,d2		; Multiplier.l * Multiplicand.h -> D2

	move.l	d3,d1
	moveq	#0,d3
	swap	d2
	move.w	d2,d3
	clr.w	d2

	moveq	#0,d5
	swap	d4
	move.w	d4,d5
	clr.w	d4

	add.l	d2,d0
	addx.l	d3,d1

	add.l	d4,d0
	addx.l	d5,d1

	movem.l	(sp)+,d2-d5
	rts

*********
*
* CreateInterrupt
*
* APTR CreateInterrupt( (ULONG) PaulaBit, D0 (8)
*  D0                   (LONG)  Priority, D1 (8)
* (32)                  (APTR)  Name,     A0 (32)
*                       (APTR)  Data,     A1 (32)
*                       (APTR)  Code );   A2 (32)
*
* PaulaBit:
*   Specifies interrupt installation. This will be via AddIntServer() on
*   those Paula bits that represent servers in the Amiga system, by
*   AddIntVector() on Paula bits that represent handlers in the Amiga system,
*   or no istallation if not a valid Paula bit.
* Priority:
*   Specifies the priority of the interrupt structure. Mostly useful only
*   for interrupt servers.
* Name:
*   Specifies the node name of the interrupt structure.
* Data:
*   Specifies the data vector of the interrupt structure.
* Code:
*   Specifies the code vector of the interrupt structure.
*
* If everything goes OK a pointer to the interrupt structure will be returned
* in D0, else NULL will be returned. The Z flag will reflect the result in
* D0. No other registers will be altered. This function may install a
* interrupt server or handler, but it does nothing to insure that the
* corresponding Paula bit is enabled for interrupts. This function
* dynamically allocates an interrupt structure plus some for control fields.
* If you obtain an interrupt structure and install a interrupt handler/server
* using CreateInterrupt(), you are strongly suggested to use
* DeleteInterrupt() to clean everything up. This function assumes that
* interrupts with Paula bits designated as being server lists are to be
* installed as servers with AddIntServer(). If your intention is to take over
* a server list with an interrupt handler, you cannot use this function.
* A pointer to ToasterBase is not needed as this function is not tied to the
* Switcher in any way.
*
* Addendum 10/31/90:
*
*********

	IFNE	_CCODE

	XDEF	_CreateInterrupt
_CreateInterrupt:
	SAVE1	a2
	movem.l	8(sp),d0/d1/a0-a2
	CALL.s	CreateInterrupt
	REST1	a2
	rts

	ENDC

	XDEF	CreateInterrupt
CreateInterrupt:

	SAVE	d1-d5/a0/a1/a6
	move.l	d0,d2
	move.l	d1,d3
	move.l	a0,d4
	move.l	a1,d5
	moveq	#IS_SIZE+6,d0
	move.l	#MEMF_PUBLIC+MEMF_CLEAR,d1
	CALLROM	AllocMem,(ABSSYSBASE).w
	move.l	d0,d0
	beq.s	99$
	move.l	d0,a1
	move.b	#NT_INTERRUPT,LN_TYPE(a1)
	move.b	d3,LN_PRI(a1)
	move.l	d4,LN_NAME(a1)
	move.l	d5,IS_DATA(a1)
	move.l	a2,IS_CODE(a1)
	cmp.l	#16,d2
	bcs.s	10$
	move.w	#-1,IS_SIZE+4(a1)
	bra.s	99$
10$:
	move.l	d2,d0
	move.l	a1,d2
	move.w	d0,IS_SIZE+4(a1)
	move.w	#$A038,d1
	btst.l	d0,d1
	beq.s	20$
	moveq	#-1,d1
	move.l	d1,IS_SIZE(a1)
	pea	30$(pc)
	JUMPROM	AddIntServer
20$:
	CALLROM	SetIntVector
	move.l	d2,a0
	move.l	d0,IS_SIZE(a0)
30$:
	move.l	d2,d0
99$:
	REST	d1-d5/a0/a1/a6
	rts

*********
*
* DeleteInterrupt
*
* void DeleteInterrupt( (APTR) Interrupt );
*                               A0
*                              (32)
*
* This function using the specified interrupt structure removes the resources
* earlier allocated and installed by CreateInterrupt(). Nothing is returned
* and no registers are altered, although the interrupt structure pointed to
* by A0 will no longer be valid. This function depends on additional private
* fields allocated and filled out by CreateInterrupt() in order to provide
* cleanup services so the interrupt structure passed into this function MUST
* have come from CreateInterrupt(). This function does not disable the
* corresponding Paula bit of the interrupt. It is strongly suggested that
* you disable the Paula bit of interrupt handlers before calling this
* function. A pointer to ToasterBase is not needed as this function is not
* tied to the Switcher in any way.
*
* Addendum 10/31/90:
*
*********

	IFNE	_CCODE

	XDEF	_DeleteInterrupt
_DeleteInterrupt:
	move.l	4(sp),a0

	ENDC

	XDEF	DeleteInterrupt
DeleteInterrupt:

	SAVE	d0/d1/a0-a2/a6
	move.l	a0,a2
	move.l	(ABSSYSBASE).w,a6
	CLEAR	d0
	move.w	IS_SIZE+4(a2),d0
	bmi.s	20$
	move.l	IS_SIZE(a2),d1
	bmi.s	10$
	move.l	d1,a1
	pea	20$(pc)
	JUMPROM	SetIntVector
10$:
	move.l	a2,a1
	CALLROM	RemIntServer
20$:
	move.l	a2,a1
	moveq	#IS_SIZE+6,d0
	CALLROM	FreeMem
	REST	d0/d1/a0-a2/a6
	rts

*****************************************************************************
*
* Quotient/Remainder ULongDivide( Dividend, Divisor );
*   (64)     (32)                   (64)      (32)
*   D1/D0     D2                    D1/D0      D2
*
* This function performs a 64 bit / 32 bit unsigned divide giving a 64 bit
* quotient (D1/D0) and a 32 bit remainder (D2). No registers other than D0-D2
* are altered. The condition codes are trashed. Does not need a pointer to
* ToasterBase as it is not tied to the Switcher in any way. Also in regards
* to the 64 bit dividend and quotient , the high 32 bits are in D1 - the low
* 32 bits in D0. In the case of a divide by zero, zero is returned as both
* the quotient and the remainder.
*
* Addendum 11/1/90:
*
*****************************************************************************

	IFNE	_CCODE

	XDEF	_ULongDivide
_ULongDivide:
	movem.l	4(sp),d0-d2

	ENDC

	XDEF	ULongDivide
ULongDivide:
	tst.l	d2		; trying to divide by 0? (only special case)
	bne.s	.No0Divide	; ...if not

	CLEAR	d0		; else return quotient and remainder fields 0
	CLEAR	d1
	rts

.No0Divide:
	SAVE	d3-d6		; save work registers

	move.l	d2,d4		; setup divisor registers
	CLEAR	d5

	move.l	d0,d2		; setup dividend registers - D2 will end up
	move.l	d1,d3		; with the remainder

	CLEAR	d0		; clear out quotient (result) registers
	CLEAR	d1

	CLEAR	d6		; clear shift count register

.GetShiftCountLoop:
	add.w	d0,d0		; clear extend flag

	cmp.l	d5,d3		; determine if divisor should be shifted left
	bcs.s	.BackUp		; a bit position
	bne.s	.ShiftIt

	cmp.l	d4,d2
	bcs.s	.BackUp

.ShiftIt:
	addq.w	#1,d6		; bump up count of divisor shift positions

	add.l	d4,d4		; shift the divisor left a bit
	addx.l	d5,d5
	bcc.s	.GetShiftCountLoop	; reloop IF no overflow

.BackUp:
	roxr.l	#1,d5		; back up the divisor right a bit position
	roxr.l	#1,d4

	subq.w	#1,d6		; decrement shift count
	bmi.s	.EarlyOut	; early exit if divisor > dividend

.PerformDivideLoop:
	add.l	d0,d0		; shift quotient (results) so far left a
	addx.l	d1,d1		; bit position

	addq.w	#1,d0		; assume current divisor can subtract into
*				; the current dividend

	sub.l	d4,d2		; subtract current divisor into current
	subx.l	d5,d3		; dividend
	bcc.s	.NoUndo		; ...if current divisor <= current dividend

	add.l	d4,d2		; else restore positive dividend
	addx.l	d5,d3

	subq.w	#1,d0		; and remove subtract count from quotient

.NoUndo:
	lsr.l	#1,d5		; shift the divisor right a bit position for
	roxr.l	#1,d4		; the next iterative subtraction

	dbf	d6,.PerformDivideLoop	; reloop for shift count

.EarlyOut:
	REST	d3-d6		; restore work registers
	rts

*****************************************************************************
*
* LONG GetFrameFreeCount();
* (32)
*  D0
*
* This function interrogates the currently selected FrameStore device and
* returns the approximate number of FrameStores the device has room to hold.
* In the case of an error -1 is returned. The maximum value returned by this
* function is the maximum positive 32 bit value, even if the device can hold
* more than this amount. This function alters no registers other than D0,
* the condition codes will be set to result in D0, and it requires a
* pointer to ToasterBase in A5.
*
* Addendum 11/2/90:
*
*****************************************************************************

APPROX_FS_SIZE	SET	toef_SizeOf+4096

	IFNE	_CCODE

	XDEF	_GetFrameFreeCount
_GetFrameFreeCount:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	GetFrameFreeCount
	REST1	a5
	rts

	ENDC

	XDEF	GetFrameFreeCount
GetFrameFreeCount:
	SAVE	d1-d3/a0-a2/a6		; save work registers

	GET.l	TB_FSDev,a0		; pointer to FS device toaster string
	cmp.b	#4,(a0)+		; and determine is device is 'RAM:'
	bne.s	.NotRam
	cmp.b	#'R',(a0)+
	bne.s	.NotRam
	cmp.b	#'A',(a0)+
	bne.s	.NotRam
	cmp.b	#'M',(a0)+
	bne.s	.NotRam

*					; at this point we're looking at the
*					; ram device

	GET.l	TB_SYSBase,a6		; get total available ram
	CLEAR	d1
	CALLROM	AvailMem
	CLEAR	d1			; clear upper 32 bits of dividend
	sub.l	#64*1024,d0		; keep a 64K cushion of memory
	bpl.s	.FinishUp		; ...if still some memory left

	CLEAR	d0			; else denote no room for frames
	bra	.Exit

.NotRam:
	GET.l	TB_FSDev,a0		; attempt to lock the FS device
	lea	1(a0),a0
	move.l	a0,d1
	move.l	#ACCESS_READ,d2
	GET.l	TB_DOSBase,a6
	CALLROM	Lock
	move.l	d0,d3			; preserve lock - if any
	beq.s	.ErrorExit		; ...error if no lock

	move.l	sp,a2			; save original SP
	lea	-id_SIZEOF(sp),sp	; get InfoData structure
	move.l	sp,d0			; (longword aligned)
	and.b	#$FC,d0
	move.l	d0,sp

	move.l	d3,d1			; attempt to fill out the InfoData
	move.l	sp,d2			; structure with the FS device
	CALLROM	Info
	move.l	d0,d2			; save return code

	move.l	d3,d1			; free FS device lock
	CALLROM	UnLock

	tst.l	d2			; was info filled out OK?
	beq.s	.ErrorExitExtra		; nope - skip out

	move.l	id_DiskType(sp),d0		; Addendum 4/24/91:
	clr.b	d0				; fix for 2.0 file system
	cmp.l	#ID_DOS_DISK,d0			; DOS type disk?
	bne.s	.ErrorExitExtra			; ...if not

	cmp.l	#ID_VALIDATED,id_DiskState(sp)	; device validated?
	bne.s	.ErrorExitExtra			; ...if not

	move.l	id_NumBlocks(sp),d0		; else get number of bytes
	sub.l	id_NumBlocksUsed(sp),d0		; left unused on FS device
	move.l	id_BytesPerBlock(sp),d1
	CALL	ULongMultiply

	move.l	a2,sp			; restore stack

.FinishUp:
	move.l	#APPROX_FS_SIZE,d2	; get frame size divisor
	CALL	ULongDivide		; get approx # of frames in D1/D0

	tst.l	d1
	bne.s	.DoMondo		;...if larger than max frame count
	tst.l	d0
	bpl.s	.Exit			;...if frame count is OK

.DoMondo:
	move.l	#$7FFFFFFF,d0		; force max frame count

.Exit:
	REST	d1-d3/a0-a2/a6		; restore work registers
	rts

.ErrorExitExtra:
	move.l	a2,sp			; restore stack

.ErrorExit:
	moveq	#-1,d0			; denote an error occured
	REST	d1-d3/a0-a2/a6		; restore work registers
	rts

*****************************************************************************
*
* void StringToUpper(char *String);
*                           (32)
*                            A0
*
* Converts the specified string to contain only uppercase letters.
* The condition codes are trashed but no registers are altered. Does not
* require a pointer to ToasterBase in A5.
*
* Addendum 11/15/90:
*
****************************************************************************`

	IFNE	_CCODE

	XDEF	_StringToUpper
_StringToUpper:

	ENDC

	XDEF	StringToUpper
StringToUpper:
	SAVE	d0/a0

.Loop:
	move.b	(a0)+,d0
	beq.s	.Exit

	cmp.b	#'a',d0
	bcs.s	.Loop

	cmp.b	#'z',d0
	bhi.s	.Loop

	and.b	#$DF,d0
	move.b	d0,-1(a0)
	bra.s	.Loop

.Exit:
	REST	d0/a0
	rts

*****************************************************************************
*
* void ImageryOff()
*
* This function disables the SoftSprite system, interface rendering, and
* mouse and keyboard IDCMP for the Switcher screen. This function should be
* used ONLY when the Switcher Screen is active as the IDCMP and rendering
* may not be disabled outside of the primary Switcher Screen environment.
* Requires a pointer to ToasterBase in A5. The condition codes are trashed,
* but no registers are altered. This function does nest.
*
* Addendum 12/7/90:
* Addendum 4/11/91:
*   Now keyboard IDCMP is allowed. No mouse movement. Both mouse buttons
*   will activate the TBar.
*
*****************************************************************************

	IFNE	_CCODE

	XDEF	_ImageryOff
_ImageryOff:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ImageryOff
	REST1	a5
	rts

	ENDC

	XDEF	ImageryOff
ImageryOff:
	addq.w	#1,ICount
	bne.s	.ExitQ
;	tst.b	TB_Flags(a5)
;	bmi.s	.ExitQ

	SAVE	d0/d1/a0/a1

	btst.b	#4,TB_DisplayRenderMode(a5)	;are we in sequence because already off
	bne.s	1$

	GET.w	TB_InterfaceDepth,d0	;save
	clr.w	TB_InterfaceDepth(a5)		;no depth

***!!! I think I need this
;;	XJSR	SendProjectEditRenderMessage	;assume Editor loaded (won't bomb if not)
* Use ReDoDisplay() to re-enable the Editor after ImageryOn has occured
	PUT.w	d0,TB_InterfaceDepth	;restore

1$	bset.b	#IMAGERY_ONOFF_BIT,TB_Flags(a5)
	XCALL	SoftSpriteAudioOff

	REST	d0/d1/a0/a1

.ExitQ:
	rts

*****************************************************************************
*
* void ImageryOn()
*
* This function enables the SoftSprite system, interface rendering, and
* mouse and keyboard IDCMP for the Switcher screen.
* Requires a pointer to ToasterBase in A5. The condition codes are trashed,
* but no registers are altered. This function does nest.
*
* Addendum 12/7/90:
*
*****************************************************************************

	IFNE	_CCODE

	XDEF	_ImageryOn
_ImageryOn:
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	ImageryOn
	REST1	a5
	rts

	ENDC

	XDEF	ImageryOn
ImageryOn:
	btst.b	#IMAGERY_ONOFF_BIT,TB_Flags(a5)	;safty check to hide bugs
	bne.s	10$				;jump if not on
	move.l	a0,-(sp)
	lea	ICount(pc),a0
	move.w	#-1,(a0)			;force nest count to be correct
	move.l	(sp)+,a0
	bra.s	.ExitQ

10$	subq.w	#1,ICount
	bpl.s	.ExitQ

;	tst.b	TB_Flags(a5)
;	beq.s	.ExitQ

	SAVE	d0/d1/a0/a1

	bclr.b	#IMAGERY_ONOFF_BIT,TB_Flags(a5)
	XCALL	SoftSpriteAudioOn

	REST	d0/d1/a0/a1

.ExitQ:
	rts

	XDEF	ICount
ICount	dc.w	-1

	CNOP	0,4

*+***************************************************************************
*+
*+ BOOL CancelNonStdEfx();
*+
*+ This function assures that the controlling crouton entity is a standard
*+ crouton that lives by the standard set of rules.
*+ If a non-standard effect, such as Non-transitional effect, is currently
*+ the controlling crouton entity, then it must attempt
*+ to find a decent ToolBox grid crouton. If the attempt is
*+ successful, that ToolBox crouton will be made the controlling crouton
*+ entity via an FGC_SELECTQ.  We assume the first crouton in the grid is
*+ an exceptable crouton. Trashes the condition codes. No registers
*+ are altered. Requires a pointer to ToasterBase in A5.
*+ Returns TRUE if a new effect was selected. FALSE if same one still in
*+ control.  FALSE doesn't necessarily mean the resulting effect is non-std.
*+ It may have been std to begin with.
*+ TRUE does mean that the old was effect was non-std.
*+
*+ Addendum 9/22/90:
*+
*+***************************************************************************

	XDEF	CancelNonStdEfx

CancelNonStdEfx:
	movem.l	d1-d7/a0-a6,-(sp)

	GET.l	TB_EfxFG,d0
	beq.s	666$

	movea.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	666$

	movem.l	a0/a5,-(sp)
	move.l	#FGC_STDEFX,-(sp)
	move.l	d0,a0
	jsr	(a0)

	move.l	4(sp),d1	;-> original
	lea	12(sp),sp
	moveq	#0,d0
	cmp.l	TB_EfxFG(a5),d1
	beq.s	666$
	moveq	#1,d0

666$	movem.l	(sp)+,d1-d7/a0-a6
	rts

************************************************************
* Select the first crouton we can find.  Lets assume it is a standard
* effects crouton.

	XDEF	SelectStdEfx

SelectStdEfx:

	SAVE	d0/d1/a0/a1

**** THIS NOW ALWAYS SELECTS THE INTERNAL CROUTON!!!!!!!
	IFD	OLDSELECTSTDEFX

	move.l	TB_ToolBoxGrids(a5),a1
;	moveq	#TBFG_GRIDNUM-1,d1
	move.l	TB_NUMGRIDS(a5),d1
	subq.l	#1,d1

.SelectLoop:
	move.l	(a1)+,d0
	beq.s	.NoTBFG
	bra.s	.SneakIn

.InnerLoop:
	move.l	FG_Function(a0),d0
	bne.s	.DoSelect
	move.l	(a0),d0

.SneakIn:
	move.l	d0,a0
	bne.s	.InnerLoop

.NoTBFG:
	dbf	d1,.SelectLoop
;;	bra.s	.ExitQ

	ENDC	;OLDSELECTSTDEFX

*-----------------------------

	xref	DummyICrouton
	lea	DummyICrouton,a0	;if no effects are found select internal
	move.l	FG_Function(a0),d0

.DoSelect:
	cmpa.l	TB_EfxFG(a5),a0
	beq	.ExitQ		;don't need to reselect myself

	bsr	FGC_SelectCommand	;was SelectCroutonQ pre 4.0

;;	SAVE	d2-d7/a0/a2-a6
;;	moveq	#FGC_SELECTQ,d1
;;	SAVE	d1/a0/a5
;;	move.l	d0,a0
;;	jsr	(a0)
;;	lea	12(sp),sp
;;	REST	d2-d7/a0/a2-a6

	DEBUGHEXI.l DBDHLS,<SelectStdEfx FG=>,a0,<\>
	PUT.l	a0,TB_EfxFG

.ExitQ:
	REST	d0/d1/a0/a1
	rts

*******************************************
	xdef	_cuntsetjmp
_cuntsetjmp
	MOVEA.L     0004(A7),A0
	MOVEM.L     D1-D7/A1-A7,0004(A0)
	MOVE.L      0000(A7),0000(A0)
;	MOVEA.L     0004,A1
;	BTST        #0004,0129(A1)
;	BEQ.B       Exit
;	FMOVEM.X    FP0-FP7,003C(A0)
	MOVEQ       #00,D0
	RTS

	xdef	_cuntlongjmp
_cuntlongjmp
    MOVE.L      0008(A7),D0
    MOVEA.L     0004(A7),A0
    TST.L       D0
    BNE.B       Cunt
    ADDQ.L      #1,D0
Cunt
;    MOVEA.L     0004,A1
;    BTST        #0004,0129(A1)
;    BEQ.B       0046
;    FMOVEM.X    003C(A0),FP0-FP7
    MOVEM.L     0004(A0),D1-D7/A1-A7
    MOVE.L      0000(A0),0000(A7)
	rts

**********************************************************
**********************************************************
**********************************************************
	XDEF	InsertTB,DeleteTB,PlaceTBFG
InsertTB
DeleteTB
PlaceTBFG
	rts

	ALLDUMPS
	CNOP	0,2

**********************************************************

	SECTION	,DATA

	XDEF	SystemTags
	XDEF	LoadedSlices

SystemTags:
	TAG_START

	dc.l	TAGID_LoadedSlices!(1<<(TAGCTRL_UNSAVED+16))
LoadedSlices	EQU	*+2		;word value
	dc.l	0

	TAG_END		;end of tag list


	END
