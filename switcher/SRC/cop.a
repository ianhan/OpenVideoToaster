********************************************************************
* cop.a
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
* $Id: cop.a,v 2.73 1995/09/13 10:59:30 Holt Exp $
*
* $Log: cop.a,v $
*Revision 2.73  1995/09/13  10:59:30  Holt
*fixed algowipe1 effects.
*
*Revision 2.72  1995/02/17  16:32:08  Kell
**** empty log message ***
*
*Revision 2.71  1995/02/17  15:40:44  Kell
**** empty log message ***
*
*Revision 2.70  1995/02/16  20:25:58  Kell
*SetUpShallowAVEInterface now understands interlaced BMs starting on any line and for any height.  Added Reset AVEI routines.  SetupAVEInterface now using TB_InterfaceDepth instead of hardcoded (though this function is never called?).
*
*Revision 2.69  1995/02/12  05:10:12  Kell
*Some grays changed from $666 to $555 to match the current color01.
*
*Revision 2.68  1995/02/12  05:09:16  Kell
*New SetupWipeCopList1 for use during sequencing to hide the interface.
*
*Revision 2.67  1995/01/26  22:08:58  Kell
*New SetUpShallowAVEInterface.  So I have control over # of interface planes or key planes.
*
*Revision 2.66  1995/01/24  11:51:49  Kell
*Now won't blow up if no CMap is supplied with SimpleBM
*
*Revision 2.65  1994/12/15  17:41:17  Kell
*AVE and SSBM now have variable Intreq bits set at start.  Uses TB_CopListIntreq .
*
*Revision 2.64  1994/07/27  19:26:37  Kell
**** empty log message ***
*
*Revision 2.63  1994/07/01  12:37:00  Kell
*Fixed parentesis bugs that were detected by new GenAm
*
*Revision 2.62  94/03/09  10:11:07  Kell
**** empty log message ***
*
*Revision 2.61  93/12/02  20:22:40  Kell
**** empty log message ***
*
*Revision 2.60  93/11/19  23:44:04  Kell
**** empty log message ***
*
*Revision 2.59  93/11/16  02:11:35  Kell
*Fixed preview overlay grays during Algorithmic FX on AA machines.       
*Fixed flashes on Matte during DoSaveWrite, so it won't flash Matte when 
*loading StillStores if Matte was shown, or if Matte is already Black and
*you are readering to a displayed bank.  Also hacked in new 64 color palettes.
*
*Revision 2.58  93/11/06  04:25:56  Kell
**** empty log message ***
*
*Revision 2.57  93/11/05  18:44:10  Turcotte
*Changes to make switcher interface 6 bitplanes
*
*Revision 2.56  93/09/27  19:16:28  Kell
**** empty log message ***
*
*Revision 2.55  93/06/09  15:45:12  Turcotte
*Removed SERDEBUG
*
*Revision 2.54  93/06/08  07:02:01  Kell
*Fixes to TB_DoSafeWriteRGB bugs
*
*Revision 2.53  93/06/07  15:40:11  Kell
*DoSafeWrite not using TB_DoSafeWriteRGB correctly.  Also, sets border
*color to this, if no palette supplied.
*
*Revision 2.52  93/06/05  07:37:50  Kell
*
*Now DoSafeWrite supports a color for the writing areas.
*
*Revision 2.51  93/06/04  17:04:30  Kell
*Now uses $666 for color1 on non-AA machines
*
*Revision 2.50  93/05/13  20:15:15  Kell
*Fixed defpalette & num colors on DoSafeWrite when palette is not supplied
*
*Revision 2.47  93/05/08  19:01:20  Kell
*Fixed DoLineWrite & FieldWrite stuff for AA machines.
*
*Revision 2.46  93/05/07  00:08:45  Kell
*Now handles two field SimpleBMCopList
*
*Revision 2.45  93/05/05  22:37:10  Kell
*Fixed Preview Overlay palette bug.
*
*Revision 2.44  93/04/17  09:54:18  Kell
*Fixed WipeInterface CopList for AA machines.
*
*Revision 2.42  93/04/17  05:33:55  Kell
*Fixed bugs in InstallIKey for the CG.
*
*Revision 2.41  93/04/17  00:15:50  Turcotte
**** empty log message ***
*
*Revision 2.40  93/04/16  04:01:25  Turcotte
**** empty log message ***
*
*Revision 2.39  93/04/01  18:26:44  Kell
**** empty log message ***
*
*Revision 2.37  93/03/30  23:49:04  Kell
*Fixed Soft2HardColor to preserve the genlock transparency bit.
*
*Revision 2.36  93/03/26  08:04:32  Kell
*Fixes to InstallSimpleBMCopList to work with anysize BM, and window limits
*
*Revision 2.35  93/03/25  06:28:10  Kell
*SBM coplist bplcon0 values now enable special bplcon3 bits on AA machines.
*
*Revision 2.34  93/03/23  00:06:40  Kell
**** empty log message ***
*
*Revision 2.33  93/03/18  21:08:37  Kell
**** empty log message ***
*
*Revision 2.32  93/03/18  15:18:46  Kell
*Moved DVE & ReadScanline chip stuff to below FrameLoadingBuff at top of ChipMem.
*
*Revision 2.31  93/03/16  02:20:22  Kell
*Fixed TwoFICopList palette problem and wait to y,112 bug.
*
*Revision 2.30  93/03/11  23:44:33  Kell
**** empty log message ***
*
*Revision 2.29  93/03/11  17:00:31  Kell
*Changed all MemoryMapCopLists and MemoryMapPlanes to use the top of ChipMme.
*
*Revision 2.28  93/03/03  14:53:48  Kell
*Now using Black sprite on AA machines.
*
*Revision 2.27  93/03/01  21:50:05  Kell
**** empty log message ***
*
*Revision 2.26  93/02/28  06:34:20  Kell
*Fixed palettes for Preview Overlay.
*
*Revision 2.25  93/02/28  02:52:56  Kell
*DVEs now are 4x.  Wipes still 1x but work good on A4000.
*
*Revision 2.24  93/02/25  13:06:26  Kell
**** empty log message ***
*
*Revision 2.23  93/02/24  23:49:18  Kell
*Fixed TwoFieldInterface cop list for AA Toaster.
*
*Revision 2.22  93/02/24  03:33:48  Kell
*More fixes & routines for the AA Toaster. Got DVE & Wipe EFX sort of working.
*
*Revision 2.21  93/02/13  14:25:35  Kell
*Major changes for AA chip support
*
*Revision 2.20  93/01/22  10:31:34  Kell
*Added DoSyncWrite function. DoSafeWrites subroutine now passes the
*appropriate values of LUST & SA.  752 wide writes speed up by 33%.
*
*Revision 2.19  92/12/23  18:09:23  Kell
*Put in negative Modulo into SimpleBM stuff for repeating a line of data.
*
*Revision 2.18  92/12/23  15:39:02  Kell
*makeserver
*
*Revision 2.17  92/12/23  15:38:19  Kell
**** empty log message ***
*
*Revision 2.16  92/12/23  15:36:30  Kell
**** empty log message ***
*
*Revision 2.15  92/12/23  15:32:17  Kell
**** empty log message ***
*
*Revision 2.13  92/12/23  15:26:47  Kell
**** empty log message ***
*
*Revision 2.12  92/12/23  15:20:12  Kell
**** empty log message ***
*
*Revision 2.11  92/12/23  14:32:40  Kell
**** empty log message ***
*
*Revision 2.10  92/12/23  11:18:47  Kell
*Fixed SimpleBMCopLists modulos on super bitmaps.
*
*Revision 2.9  92/12/22  01:47:34  Kell
*Fixed bugs in the SimpleBMCopList scroll for superbitmap scrolls.
*
*Revision 2.8  92/12/17  18:34:56  Kell
*Removed SERDEBUG statements
*
*Revision 2.7  92/12/17  17:45:59  Kell
*BPLCON0 hacks for A2000/4000
*
*Revision 2.6  92/12/16  10:40:23  Kell
*Took out JFINCHs special debug statements
*
*Revision 2.5  92/12/16  09:47:56  Finch
*Fixing Scroll With Kell.
*
*
*Revision 2.4  92/12/08  17:10:00  Finch
**** empty log message ***
*
*Revision 2.3  92/11/17  21:48:58  Kell
*Fixed SimpleBMCopList to support 32 color palettes,
*though this will mess up the sprite.  Fixed #palette
*colors bug for HAM & HalfBrite.
*
*Revision 2.2  92/11/12  19:21:09  Kell
*SimpleBMCopList now supports upto 6 planes & ViewModes.
*
*Revision 2.1  92/09/17  23:59:40  Kell
*Hacked all 4 field coplists to function as 2 field
*
*Revision 2.0  92/05/18  21:18:21  Hartford
**** empty log message ***
*
*********************************************************************
**************************************************************
* Create and Modify Dynamic Copper Lists for Video Toaster
* By S.R. Kell,   NewTek, Inc     Oct 1989 
**************************************************************

	include	'assembler.i'
;;	include	"RAM:conditional.i"

	include	"exec/types.i"
	include	"hardware/custom.i"
	include "hardware/intbits.i"
	include	"graphics/gfxbase.i"
	include	"graphics/gfx.i"
	include "graphics/view.i"

	include	"macros.i"
	include	"custom.i"
	include "copper.i"
	include "cop.i"
	include "rect.i"
	include	"vthand.i"
	include "instinct.i"
	include "vtdebug.i"
	include "serialdebug.i"

	include	"lib/exec_lib.i"

;;SERDEBUG	set	1
;;CLIDEBUG	set	1

;;DEBUGDSW	SET	1	;debug DoSafeWrite (requires SERDEBUG)
;;CCODE	SET	1

	IFND	AACHIPS
NUMINTERFACEPLANES	SET	2
	ENDC
	IFD	AACHIPS
NUMINTERFACEPLANES	SET	6
	ENDC

*****************************************************
* NOTE!!!!! When these routines where written, it was unknown which of these
* routines would actually endup in ToastBase, so to make it easy to split
* these effects off from TB, many of the functions do addressing relative
* to A5 -> TB base register.  It would make more since for the TB routines
* to do direct addressing of other TB routines, data etc. !!!!!!!
*******************************************************  

	XCCODE	MemoryMapCopLists
	XCODE	MemoryMapPlanes

 	XCCODE	InitDVECopList1	;InitCopperLists
	XCCODE	SetUpDVECopList1
	XCCODE	InitDVEInterface1
	XCCODE	SetUpDVEInterface1

 	XCCODE	InitDVECopList2	;InitCopperLists
	XCCODE	SetUpDVECopList2

* AVE=Analog Video Effects, though we can use this with LinearDVE also
	XCCODE	InitAVECopLists
	XCCODE	SetUpAVECopList
	XCCODE	InitAVEInterfaces
	XCODE	SetUpAVEInterface
	XCODE	SetUpShallowAVEInterface

	XCCODE	Init2FI
	XCODE	SetUp2FI

	XCCODE	InitWipeInterface1	;for interface or no interface
	XCCODE	SetUpWipeInterface1
	XCODE	SetUpWipeCopList1	;no interface

	XCCODE	InitReadCopList

	XCCODE	InitFieldWrite
	XCCODE	SetUpFieldWrite

	XCCODE	InitSafeWrite
	XCODE	DoSafeWrite,OldDoSafeWrite,DoSyncWrite

	XCCODE	InitSimpleBMCopLists
	XCODE	SetUpSimpleBMCopList
	XCODE	SetupSBMCopListAA

	XCCODE	SetUpEntrySprites
	XCCODE	SetUpELHEntrySprites

	XCODE	AttachSprite1
	XCODE	AttachSprite0
	XCODE	AttachSprites
	XCODE	Soft2HardColor

	XDATA	AVEspr0Tbl,AVEIspr0Tbl,DVEspr0Tbl,DVE2spr0Tbl
        XDATA	DVEIspr0Tbl,WipeIspr0Tbl,WipeIFourFieldTBL,SBMsprTbl
	XDATA	AVEFourFieldTBL,AVEIFourFieldTBL,TwoFI4FieldTBL,TwoFIspr0Tbl	
	XDATA	CompRSLPalFlag,DVEIFourFieldTBL,SBM4FieldTBL

	XREF	AVEBPLCON0_1,AVEBPLCON0_2
	XREF	AVEI_IBPLCON0_1,AVEI_IBPLCON0_2,AVEI_IIBPLCON0_1,AVEI_IIBPLCON0_2
	XREF	AVEI_IBPLCON0_1b,AVEI_IBPLCON0_2b,AVEI_IIBPLCON0_1b,AVEI_IIBPLCON0_2b
	XREF	ReadBPLCON0_1,ReadBPLCON0_2,FWBPLCON0_1,FWBPLCON0_2
	XREF	SWBPLCON0_1,SWBPLCON0_2,SWBPLCON0_3,SWBPLCON0_4
	XREF	SWBPLCON0_5,SWBPLCON0_6,SWBPLCON0_7,SWBPLCON0_8
	XREF	SWBPLCON0_9,SWBPLCON0_10,SWBPLCON0_11,SWBPLCON0_12
	XREF	SBMBPLCON0_1,SBMBPLCON0_2,SBMBPLCON0_1b,SBMBPLCON0_2b
	XREF	TFBPLCON0_1,TFBPLCON0_2,TFBPLCON0_3,TFBPLCON0_4
	XREF	TFBPLCON0_5,TFBPLCON0_6,TFBPLCON0_7,TFBPLCON0_8

	SECTION	,CODE

***********************************************************
* ~InitDVECopList1(->copbuf, ->TB)
*		     a0      a5
	IFD	CCODE
_InitDVECopList1
	move.l	a5,-(sp)
	movem.l	8(sp),a0/a5
	bra.s	InitDVECopList1
	movea.l	(sp)+,a5
	rts
	ENDC

InitDVECopList1:
 	STRUCTURE  DVECopList1,0
 	  movem.l  d0-d2/a0-a1,-(sp)
	  movea.l  a0,a1	       ;save ->copbuff	
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

* Here is the variable header stuff
	LABEL     DVECL1_Spr0pt1
          CPMOVEREGL   spr0pth       ;fill values in later
          CPMOVEREGL   spr1pth

	LABEL	DVECL1_Bpl1pth
          CPMOVEREGW   bpl1pth       ;fill in later
          CPMOVEREGW   bpl2pth       ;fill in later

	IFND	AACHIPS
	CPMOVE	0,beamcon0	;make sure beamcon0 is ok, necessary?
	CPMOVE	NEWDENISE,bplcon3 ;fix new Denise right edge problem

          CPMOVE   ((21<<8)!92),diwstrt
          CPMOVE   (((262<<8)&$ff00)!(458-256)),diwstop
	ENDC

	IFD	AACHIPS
* window start & stops are put her to prevent premature starts
	AAdiwstrt	AAwindowStartX,AAwindowStartY					
        CPMOVE		AAvalue,diwstrt

	AAdiwstop	AAwindowStopX,AAwindowStopY
        CPMOVE		AAvalue,diwstop

	AAdiwhigh	AAwindowStartX,AAwindowStopX,AAwindowStartY,AAwindowStopY
	CPMOVE		AAvalue,diwhigh
	ENDC

	  move.l   a1,d0
	  add.l	   #DVECL1_Body,d0
	  CPMOVERL d0,cop1lc		;->copper list body

	IFND	AACHIPS
*----------------
*;I=most sig nibble, B=least sig nibble,  NOTE: The data must be complemented
          CPMOVE   $229,color00  ;I=1 B=1
          CPMOVE   $227,color01  ;I=1 B=0
          CPMOVE   $228,color02  ;I=0 B=1
          CPMOVE   $226,color03  ;I=0 B=0

* Low contrast sprite. 
*;;          CPMOVE   $776,color16   I=0 B=0 G=0 R=0 ;transparent
          CPMOVE   $876,color17   ;I=0 B=0 G=0 R=1
          CPMOVE   $786,color18   ;I=0 B=0 G=1 R=0
          CPMOVE   $886,color19   ;I=0 B=0 G=1 R=1
          CPMOVE   $778,color20   ;I=0 B=1 G=0 R=0
          CPMOVE   $878,color21   ;I=0 B=1 G=0 R=1
          CPMOVE   $788,color22   ;I=0 B=1 G=1 R=0
          CPMOVE   $888,color23   ;I=0 B=1 G=1 R=1
          CPMOVE   $777,color24   ;I=1 B=0 G=0 R=0
          CPMOVE   $877,color25   ;I=1 B=0 G=0 R=1
          CPMOVE   $787,color26   ;I=1 B=0 G=1 R=0
          CPMOVE   $887,color27   ;I=1 B=0 G=1 R=1
          CPMOVE   $779,color28   ;I=1 B=1 G=0 R=0
          CPMOVE   $879,color29   ;I=1 B=1 G=0 R=1
          CPMOVE   $789,color30   ;I=1 B=1 G=1 R=0
          CPMOVE   $889,color31   ;I=1 B=1 G=1 R=1
	ENDC	

	IFD	AACHIPS

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

;;          CPMOVE   $555,color00  ;I/G0=1 B/R0=1
;;          CPMOVE   $555,color01  ;I/G0=1 B/R0=0
;;          CPMOVE   $555,color02  ;I/G0=0 B/R0=1
;;          CPMOVE   $555,color03  ;I/G0=0 B/R0=0

          CPMOVE   BLANKGRAY,color00  ;I/G0=1 B/R0=1
          CPMOVE   BLANKGRAY,color01  ;I/G0=1 B/R0=0
          CPMOVE   BLANKGRAY,color02  ;I/G0=0 B/R0=1
          CPMOVE   BLANKGRAY,color03  ;I/G0=0 B/R0=0
	
	AAbplcon3	0,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   $110,color00  ;I/G0=1 B/R0=1
          CPMOVE   $010,color01  ;I/G0=1 B/R0=0
          CPMOVE   $100,color02  ;I/G0=0 B/R0=1
          CPMOVE   $000,color03  ;I/G0=0 B/R0=0

	AAbplcon3	7,1	;bank 7, upper nibble
	CPMOVE	AAvalue,bplcon3

*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $000,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1

	AAbplcon3	7,0	;bank 7, upper nibble
	CPMOVE	AAvalue,bplcon3
*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $600,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $024,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $624,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $101,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $701,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $125,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $725,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $012,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $612,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $036,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $636,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $113,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $713,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $137,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $737,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
	ENDC

	IFND	AACHIPS
          CPMOVE   ((64>>1)&$fc),ddfstrt
          CPMOVE   ((424>>1)&$fc),ddfstop
          CPMOVE   ((7<<4)!7),bplcon1   ;scroll
          CPMOVE   -96,bpl1mod
          CPMOVE   -96,bpl2mod
          CPMOVE   $24,bplcon2         ;sprite priority over bm
	ENDC

	IFD	AACHIPS
	AAddfstrt	AA768fetchStart
        CPMOVE	AAvalue,ddfstrt

	AAddfstop	AA768fetchStop
        CPMOVE	AAvalue,ddfstop

	AAbplcon1	AAbmscroll,AAbmscroll
        CPMOVE	AAvalue,bplcon1   	;scroll (put sprite left of bm)

        CPMOVE   	-(768/8),bpl1mod
        CPMOVE   	-(768/8),bpl2mod

        CPMOVE 	AAbplcon2,bplcon2	;sprite priority over bm
	CPMOVE	AAbplcon4,bplcon4	;sprite colors = 240-255

	CPMOVE	AA768fetchMode,fmode
	ENDC

	  CPMOVE   0,copjmp1		;jump to body
*;---------------------------------------------------------
	LABEL	DVECL1_Main
	  CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

	LABEL     DVECL1_Spr0pt2
          CPMOVEREGL   spr0pth       ;fill values in later, freeze/live
          CPMOVEREGL   spr1pth	    ;usually same as Spr1pt1		

*;---------
	LABEL	DVECL1_Body
 	  move.l   a1,d0
	  add.l	   #DVECL1_Main,d0
	  CPMOVERL d0,cop1lc		;->main copper list

	STRUCT     DVECL1_Spr2pt,4*12
	  move.l   TB_EffectsBase+EFB_SpriteData(a5),d0
	  add.l	   #ESD_SpriteNull,d0	

	  move.w   #spr2pth,d1
	  moveq	   #5,d2		;null out sprites 2-7	  	  
10$	  move.w   d1,(a0)+
	  swap	   d0		;msw	
	  move.w   d0,(a0)+

          addq.w   #2,d1
          move.w   d1,(a0)+
          swap     d0		;lsw
	  move.w   d0,(a0)+

          addq.w   #2,d1
	  dbra	   d2,10$
*;---------

	LABEL     DVECL1_Bpl1ptl1
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl2ptl       ;fill in later, null line

;;* had this upto 3.1          CPWAIT   21,0

	IFND	AACHIPS
	move.w	#%1010000000000000,d0
	ENDC

	IFD	AACHIPS
	AAbplcon0	2,1,0,0		;depth=2, HiRes, non-HAM, no ERSY
	move.w	#AAvalue,d0
	ENDC

	or.w	TB_BPLCON0orBits(a5),d0
	CPMOVERW d0,bplcon0		;modes & 2 planes
	
	LABEL DVECL1_wait1
	    CPWAITNOPL
*          CPWAIT   255,111      ;make 255,111 or 0,0 or forever
*          CPWAIT   0,0          ;fill in later

	LABEL     DVECL1_Bpl1ptl2
          CPMOVEREGW   bpl1ptl       ;fill in later, effect line
          CPMOVEREGW   bpl2ptl       ;fill in later, effect line

	LABEL DVECL1_wait2
	    CPWAITNOPL
*          CPWAIT   255,111      ;make 255,111 or 0,0 later
*          CPWAIT   0,0          ;fill in later

	LABEL     DVECL1_Bpl1ptl3
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl2ptl       ;fill in later, null line

*;I don't think there's anything to gain by turning off DMA here = zero planes

            CPEND

	movem.l	(sp)+,d0-d2/a0-a1
	rts

	LABEL	DVECL1_SIZEOF
	
***********************************************************
* ~SetUpDVECopList1(->SetUpDVE structure)

	IFD	CCODE
_SetUpDVECopList1	movea.l	4(sp),a0
	ENDC
	
SetUpDVECopList1	movem.l	d0-d1/a0-a3,-(sp)
	movea.l	a0,a1			;->structure
	movea.l	SUDVE_DBCopLists(a1),a2	;->DBcoplist
	move.w	(a2),d0			;current
	movea.l	DB_Data(a2,d0.w),a2	;->coplist	

	lea	DVECL1_Spr0pt1(a2),a0
	movea.l	SUDVE_DBSprite0E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

	lea	DVECL1_Spr0pt2(a2),a0
	movea.l	SUDVE_DBSprite0R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

*;----
	lea	DVECL1_Bpl1pth(a2),a0
	movea.l	SUDVE_DBPlanePtrs(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	;**PlanePtrs
	move.l	a3,-(sp)		;save

	movea.l	(a3),a3			;*PlanePtrs for null line
	move.l	(a3)+,d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,d1		;null plane0 lsw
	swap	d0
	CPMOVEVALW	d0	;bpl1pth
	move.l	(a3),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	swap	d0
	CPMOVEVALW	d0	;bpl2pth
	swap	d0		;null plane1 lsw
	
	lea	DVECL1_Bpl1ptl1(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d0	;null plane 1
	
	lea	DVECL1_Bpl1ptl3(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d0	;null plane 1

	lea	DVECL1_Bpl1ptl2(a2),a0
	movea.l	(sp)+,a3	;restore **planeprs
	movea.l	4(a3),a3	;*Planeptrs for effect planes
	move.l	(a3)+,d0
	
	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 0
	move.l	(a3),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 1
	
*;----
	lea	DVECL1_wait1(a2),a0
	movea.l	SUDVE_CompBitMapList(a1),a3
	tst.b	DVE1CBML_MiddleBM(a3)
	bmi.s	5$			;wait forever, only top given
	tst.b	DVE1CBML_MiddleRows(a3)
	beq.s	5$			;wait forever, effect not present

	moveq	#0,d0
	move.b	DVE1CBML_TopRows(a3),d0
	addi.w	#21,d0			;actual wait line	
	cmpi.w	#255,d0
	bhi.s	10$		;jump if top below wait 255
	CPWAITVAL	#1	;wait 0,0
	bra.s	12$

5$	CPWAITVAL	#((255<<8)!(127<<1)!1)   ;wait forever
	bra.s		666$

	
10$	CPWAITVAL	#((255<<8)!(111<<1)!1)   ;wait to 255,111

12$       lsl.w     #8,d0
			 ori.w	#(0<<1)!1,d0
		
;;          btst      #8,d0
;;          bne.s     16$                  ;jump if odd line
;;          ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;          bra.s     18$
;;16$       ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

18$       CPWAITVAL d0		         ;wait to top of effect
	
*;----
	lea	DVECL1_wait2(a2),a0
	moveq	#0,d0	
	move.b	DVE1CBML_TopRows(a3),d0
	add.b	DVE1CBML_MiddleRows(a3),d0

	addi.w	#21,d0			;actual wait line	
	cmpi.w	#255,d0
	bhi.s	20$		;jump if top below wait 255
	CPWAITVAL	#1	;wait 0,0
	bra.s	22$	
20$	CPWAITVAL	#((255<<8)!(111<<1)!1)   ;wait to 255,111
        andi.w    #$ff,d0

22$       lsl.w     #8,d0
			 ori.w	#(0<<1)!1,d0

;;          btst      #8,d0
;;         bne.s     26$                  ;jump if odd line
;;          ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;          bra.s     28$
;;26$       ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

28$       CPWAITVAL d0		         ;wait to top of effect
	

666$	movem.l	(sp)+,d0-d1/a0-a3	
	rts

******************************************************************
* ~InitDVEInterface1(->copbuf, ->InterfacePlanes, ->TB)
*		     a0			a1	  a5
	IFD	CCODE
_InitDVEInterface1
	move.l	a5,-(sp)
	movem.l	8(sp),a0-a1/a5
	bra.s	InitDVEInterface1
	movea.l	(sp)+,a5
	rts
	ENDC

InitDVEInterface1:
 	STRUCTURE  DVEInterface1,0
 	  movem.l  d0-d2/a0-a2,-(sp)
	  movea.l  a0,a2	       ;save ->copbuff	
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

* Here is the variable header stuff
	LABEL     DVEI1_Spr0pt1
          CPMOVEREGL   spr0pth       ;fill values in later
          CPMOVEREGL   spr1pth

	LABEL	DVEI1_Bpl1pth
	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1pth       ;fill in later, null line
          CPMOVEREGW   bpl3pth       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2pth       ;fill in later, null line
          CPMOVEREGW   bpl4pth       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2pth       ;fill in later, null line
          CPMOVEREGW   bpl4pth       ;fill in later, null line
          CPMOVEREGW   bpl6pth       ;fill in later, null line
	ENDC
		  
	IFND	AACHIPS
	CPMOVE	0,beamcon0	;make sure beamcon0 is ok, necessary?
	CPMOVE	NEWDENISE,bplcon3 ;fix new Denise right edge problem

          CPMOVE   ((21<<8)!92),diwstrt
          CPMOVE   (((262<<8)&$ff00)!(458-256)),diwstop
	ENDC

	IFD	AACHIPS
* window start & stops are put her to prevent premature starts
	AAdiwstrt	AAwindowStartX,AAwindowStartY					
        CPMOVE		AAvalue,diwstrt

	AAdiwstop	AAwindowStopX,AAwindowStopY
        CPMOVE		AAvalue,diwstop

	AAdiwhigh	AAwindowStartX,AAwindowStopX,AAwindowStartY,AAwindowStopY
	CPMOVE		AAvalue,diwhigh
	ENDC

 LABEL DVEI1_LATCH
;;	  move.l a2,d0
;;         add.l	#DVEI1_IBody,d0
;;	  CPMOVERL d0,cop1lc		;->copper list 1 body
          CPMOVEREGL   cop1lc    ;fill values in later

	IFND	AACHIPS
*----------------
*;I=most sig nibble, B=least sig nibble,  NOTE: The data must be complemented
           CPMOVE   $009,color00	;IB=1,1
           CPMOVE   $007,color01	;IB=1,0
           CPMOVE   $849,color02
           CPMOVE   $847,color03

           CPMOVE   $008,color04	;IB=0,1
           CPMOVE   $006,color05
           CPMOVE   $848,color06
           CPMOVE   $846,color07	;IB=0,0

	   CPMOVE   $7b9,color08
           CPMOVE   $7b7,color09
           CPMOVE   $ff9,color10
           CPMOVE   $ff7,color11

           CPMOVE   $7b8,color12
           CPMOVE   $7b6,color13
           CPMOVE   $ff8,color14
           CPMOVE   $ff6,color15

* Low contrast sprite. 
*;;          CPMOVE   $776,color16   I=0 B=0 G=0 R=0 ;transparent
          CPMOVE   $876,color17   ;I=0 B=0 G=0 R=1
          CPMOVE   $786,color18   ;I=0 B=0 G=1 R=0
          CPMOVE   $886,color19   ;I=0 B=0 G=1 R=1
          CPMOVE   $778,color20   ;I=0 B=1 G=0 R=0
          CPMOVE   $878,color21   ;I=0 B=1 G=0 R=1
          CPMOVE   $788,color22   ;I=0 B=1 G=1 R=0
          CPMOVE   $888,color23   ;I=0 B=1 G=1 R=1
          CPMOVE   $777,color24   ;I=1 B=0 G=0 R=0
          CPMOVE   $877,color25   ;I=1 B=0 G=0 R=1
          CPMOVE   $787,color26   ;I=1 B=0 G=1 R=0
          CPMOVE   $887,color27   ;I=1 B=0 G=1 R=1
          CPMOVE   $779,color28   ;I=1 B=1 G=0 R=0
          CPMOVE   $879,color29   ;I=1 B=1 G=0 R=1
          CPMOVE   $789,color30   ;I=1 B=1 G=1 R=0
          CPMOVE   $889,color31   ;I=1 B=1 G=1 R=1

	ENDC	

*-------------------------------------------------------------------
	IFD	AACHIPS

	IFEQ	NUMINTERFACEPLANES-2

* plane 4 = msb of interface
* plane 3 = G0 = msb of digital
* plane 2 = lsb of interface
* plane 1 = R0 = lsb of digital

DVEIcolor0	set	$000
DVEIcolor1	set	$555
DVEIcolor2	set	$aaa
DVEIcolor3	set	$fff

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIcolor0,color00
          CPMOVE   DVEIcolor0,color01
          CPMOVE   DVEIcolor1,color02
          CPMOVE   DVEIcolor1,color03
          CPMOVE   DVEIcolor0,color04
          CPMOVE   DVEIcolor0,color05
          CPMOVE   DVEIcolor1,color06
          CPMOVE   DVEIcolor1,color07
          CPMOVE   DVEIcolor2,color08
          CPMOVE   DVEIcolor2,color09
          CPMOVE   DVEIcolor3,color10
          CPMOVE   DVEIcolor3,color11
          CPMOVE   DVEIcolor2,color12
          CPMOVE   DVEIcolor2,color13
          CPMOVE   DVEIcolor3,color14
          CPMOVE   DVEIcolor3,color15

	AAbplcon3	0,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

           CPMOVE   $110,color00  ;I/G0=1 B/R0=1 G/G1=0 R/R1=0
           CPMOVE   $010,color01  ;I/G0=1 B/R0=0 G/G1=0 R/R1=0
           CPMOVE   $310,color02  ;I/G0=1 B/R0=1 G/G1=0 R/R1=1
           CPMOVE   $210,color03  ;I/G0=1 B/R0=0 G/G1=0 R/R1=1
           CPMOVE   $100,color04  ;I/G0=0 B/R0=1 G/G1=0 R/R1=0
           CPMOVE   $000,color05  ;I/G0=0 B/R0=0 G/G1=0 R/R1=0
           CPMOVE   $300,color06  ;I/G0=0 B/R0=1 G/G1=0 R/R1=1
           CPMOVE   $200,color07  ;I/G0=0 B/R0=0 G/G1=0 R/R1=1
	   CPMOVE   $130,color08  ;I/G0=1 B/R0=1 G/G1=1 R/R1=0
           CPMOVE   $030,color09  ;I/G0=1 B/R0=0 G/G1=1 R/R1=0
           CPMOVE   $330,color10  ;I/G0=1 B/R0=1 G/G1=1 R/R1=1
           CPMOVE   $230,color11  ;I/G0=1 B/R0=0 G/G1=1 R/R1=1
           CPMOVE   $120,color12  ;I/G0=0 B/R0=1 G/G1=1 R/R1=0
           CPMOVE   $020,color13  ;I/G0=0 B/R0=0 G/G1=1 R/R1=0
           CPMOVE   $320,color14  ;I/G0=0 B/R0=1 G/G1=1 R/R1=1
           CPMOVE   $220,color15  ;I/G0=0 B/R0=0 G/G1=1 R/R1=1
	
	ENDC	;IFEQ	NUMINTERFACEPLANES-2

*---------------------------------
	IFEQ	NUMINTERFACEPLANES-3

* plane 5 = msb of interface
* plane 4 = G0 = msb of digital
* plane 3 = middle bit of interface
* plane 2 = R0 = lsb of digital
* plane 1 = lsb of interface

DVEIcolor0	set	$000
DVEIcolor1	set	$666
DVEIcolor2	set	$999
DVEIcolor3	set	$ddd
DVEIcolor4	set	$333
DVEIcolor5	set	$555
DVEIcolor6	set	$cb7
DVEIcolor7	set	$fe7

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIcolor0,color00
          CPMOVE   DVEIcolor1,color01
          CPMOVE   DVEIcolor0,color02
          CPMOVE   DVEIcolor1,color03
          CPMOVE   DVEIcolor2,color04
          CPMOVE   DVEIcolor3,color05
          CPMOVE   DVEIcolor2,color06
          CPMOVE   DVEIcolor3,color07
          CPMOVE   DVEIcolor0,color08
          CPMOVE   DVEIcolor1,color09
          CPMOVE   DVEIcolor0,color10
          CPMOVE   DVEIcolor1,color11
          CPMOVE   DVEIcolor2,color12
          CPMOVE   DVEIcolor3,color13
          CPMOVE   DVEIcolor2,color14
          CPMOVE   DVEIcolor3,color15

          CPMOVE   DVEIcolor4,color16
          CPMOVE   DVEIcolor5,color17
          CPMOVE   DVEIcolor4,color18
          CPMOVE   DVEIcolor5,color19
          CPMOVE   DVEIcolor6,color20
          CPMOVE   DVEIcolor7,color21
          CPMOVE   DVEIcolor6,color22
          CPMOVE   DVEIcolor7,color23
          CPMOVE   DVEIcolor4,color24
          CPMOVE   DVEIcolor5,color25
          CPMOVE   DVEIcolor4,color26
          CPMOVE   DVEIcolor5,color27
          CPMOVE   DVEIcolor6,color28
          CPMOVE   DVEIcolor7,color29
          CPMOVE   DVEIcolor6,color30
          CPMOVE   DVEIcolor7,color31

	AAbplcon3	0,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3
				;OLlsm  DVElsb OLmsb  DVEmsb
          CPMOVE   $110,color00	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   $310,color01	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   $010,color02	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   $210,color03	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   $130,color04	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   $330,color05	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   $030,color06	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   $230,color07	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   $100,color08	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   $300,color09	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   $000,color10	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   $200,color11	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   $120,color12	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   $320,color13	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   $020,color14	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   $220,color15	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3

          CPMOVE   $110,color16	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   $130,color17	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   $010,color18	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   $030,color19	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   $330,color20	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   $310,color21	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   $230,color22	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   $210,color23	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   $100,color24	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   $120,color25	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   $000,color26	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   $020,color27	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   $320,color28	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3 
          CPMOVE   $300,color29	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   $220,color30	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   $200,color31	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1

	ENDC	;IFEQ	NUMINTERFACEPLANES-3

*---------------------------------
*!
	IFEQ	NUMINTERFACEPLANES-6

* plane 7 = msb of interface
* plane 6 = duplicate of plane 4
* plane 5 = next to msb of interface
* plane 4 = G0 = msb of digital
* plane 3 = next to lsb of interface
* plane 2 = R0 = lsb of digital
* plane 1 = lsb of interface

DVEIhigh00	set	VThigh00
DVEIhigh01	set	VThigh01
DVEIhigh02	set	VThigh02
DVEIhigh03	set	VThigh03
DVEIhigh04	set	VThigh04
DVEIhigh05	set	VThigh05
DVEIhigh06	set	VThigh06
DVEIhigh07	set	VThigh07
DVEIhigh08	set	VThigh08
DVEIhigh09	set	VThigh09
DVEIhigh10	set	VThigh10
DVEIhigh11	set	VThigh11
DVEIhigh12	set	VThigh12
DVEIhigh13	set	VThigh13
DVEIhigh14	set	VThigh14
DVEIhigh15	set	VThigh15

DVEIlow00	set	(VTlow00&$ccf)
DVEIlow01	set	(VTlow01&$ccf)
DVEIlow02	set	(VTlow02&$ccf)
DVEIlow03	set	(VTlow03&$ccf)
DVEIlow04	set	(VTlow04&$ccf)
DVEIlow05	set	(VTlow05&$ccf)
DVEIlow06	set	(VTlow06&$ccf)
DVEIlow07	set	(VTlow07&$ccf)
DVEIlow08	set	(VTlow08&$ccf)
DVEIlow09	set	(VTlow09&$ccf)
DVEIlow10	set	(VTlow10&$ccf)
DVEIlow11	set	(VTlow11&$ccf)
DVEIlow12	set	(VTlow12&$ccf)
DVEIlow13	set	(VTlow13&$ccf)
DVEIlow14	set	(VTlow14&$ccf)
DVEIlow15	set	(VTlow15&$ccf)

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIhigh00,color00
          CPMOVE   DVEIhigh01,color01
          CPMOVE   DVEIhigh00,color02
          CPMOVE   DVEIhigh01,color03
          CPMOVE   DVEIhigh02,color04
          CPMOVE   DVEIhigh03,color05
          CPMOVE   DVEIhigh02,color06
          CPMOVE   DVEIhigh03,color07
          CPMOVE   DVEIhigh00,color08
          CPMOVE   DVEIhigh01,color09
          CPMOVE   DVEIhigh00,color10
          CPMOVE   DVEIhigh01,color11
          CPMOVE   DVEIhigh02,color12
          CPMOVE   DVEIhigh03,color13
          CPMOVE   DVEIhigh02,color14
          CPMOVE   DVEIhigh03,color15

          CPMOVE   DVEIhigh04,color16
          CPMOVE   DVEIhigh05,color17
          CPMOVE   DVEIhigh04,color18
          CPMOVE   DVEIhigh05,color19
          CPMOVE   DVEIhigh06,color20
          CPMOVE   DVEIhigh07,color21
          CPMOVE   DVEIhigh06,color22
          CPMOVE   DVEIhigh07,color23
          CPMOVE   DVEIhigh04,color24
          CPMOVE   DVEIhigh05,color25
          CPMOVE   DVEIhigh04,color26
          CPMOVE   DVEIhigh05,color27
          CPMOVE   DVEIhigh06,color28
          CPMOVE   DVEIhigh07,color29
          CPMOVE   DVEIhigh06,color30
          CPMOVE   DVEIhigh07,color31

	AAbplcon3	0,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

						;OLlsm  DVElsb OLmsb  DVEmsb
          CPMOVE   DVEIlow00!$110,color00	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow01!$310,color01	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow00!$010,color02	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow01!$210,color03	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow02!$130,color04	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow03!$330,color05	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow02!$030,color06	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow03!$230,color07	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow00!$100,color08	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow01!$300,color09	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow00!$000,color10	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow01!$200,color11	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow02!$120,color12	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow03!$320,color13	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow02!$020,color14	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow03!$220,color15	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3

          CPMOVE   DVEIlow04!$110,color16	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow05!$130,color17	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow04!$010,color18	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow05!$030,color19	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow06!$330,color20	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow07!$310,color21	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow06!$230,color22	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow07!$210,color23	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow04!$100,color24	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow05!$120,color25	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow04!$000,color26	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow05!$020,color27	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow06!$320,color28	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow07!$300,color29	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow06!$220,color30	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow07!$200,color31	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1

	AAbplcon3	1,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIhigh00,color00
          CPMOVE   DVEIhigh01,color01
          CPMOVE   DVEIhigh00,color02
          CPMOVE   DVEIhigh01,color03
          CPMOVE   DVEIhigh02,color04
          CPMOVE   DVEIhigh03,color05
          CPMOVE   DVEIhigh02,color06
          CPMOVE   DVEIhigh03,color07
          CPMOVE   DVEIhigh00,color08
          CPMOVE   DVEIhigh01,color09
          CPMOVE   DVEIhigh00,color10
          CPMOVE   DVEIhigh01,color11
          CPMOVE   DVEIhigh02,color12
          CPMOVE   DVEIhigh03,color13
          CPMOVE   DVEIhigh02,color14
          CPMOVE   DVEIhigh03,color15

          CPMOVE   DVEIhigh04,color16
          CPMOVE   DVEIhigh05,color17
          CPMOVE   DVEIhigh04,color18
          CPMOVE   DVEIhigh05,color19
          CPMOVE   DVEIhigh06,color20
          CPMOVE   DVEIhigh07,color21
          CPMOVE   DVEIhigh06,color22
          CPMOVE   DVEIhigh07,color23
          CPMOVE   DVEIhigh04,color24
          CPMOVE   DVEIhigh05,color25
          CPMOVE   DVEIhigh04,color26
          CPMOVE   DVEIhigh05,color27
          CPMOVE   DVEIhigh06,color28
          CPMOVE   DVEIhigh07,color29
          CPMOVE   DVEIhigh06,color30
          CPMOVE   DVEIhigh07,color31

	AAbplcon3	1,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIlow00!$110,color00	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow01!$310,color01	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow00!$010,color02	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow01!$210,color03	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow02!$130,color04	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow03!$330,color05	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow02!$030,color06	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow03!$230,color07	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow00!$100,color08	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow01!$300,color09	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow00!$000,color10	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow01!$200,color11	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow02!$120,color12	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow03!$320,color13	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow02!$020,color14	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow03!$220,color15	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3

          CPMOVE   DVEIlow04!$110,color16	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow05!$130,color17	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow04!$010,color18	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow05!$030,color19	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow06!$330,color20	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow07!$310,color21	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow06!$230,color22	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow07!$210,color23	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow04!$100,color24	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow05!$120,color25	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow04!$000,color26	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow05!$020,color27	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow06!$320,color28	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow07!$300,color29	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow06!$220,color30	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow07!$200,color31	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1


	AAbplcon3	2,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIhigh08,color00
          CPMOVE   DVEIhigh09,color01
          CPMOVE   DVEIhigh08,color02
          CPMOVE   DVEIhigh09,color03
          CPMOVE   DVEIhigh10,color04
          CPMOVE   DVEIhigh11,color05
          CPMOVE   DVEIhigh10,color06
          CPMOVE   DVEIhigh11,color07
          CPMOVE   DVEIhigh08,color08
          CPMOVE   DVEIhigh09,color09
          CPMOVE   DVEIhigh08,color10
          CPMOVE   DVEIhigh09,color11
          CPMOVE   DVEIhigh10,color12
          CPMOVE   DVEIhigh11,color13
          CPMOVE   DVEIhigh10,color14
          CPMOVE   DVEIhigh11,color15

          CPMOVE   DVEIhigh12,color16
          CPMOVE   DVEIhigh13,color17
          CPMOVE   DVEIhigh12,color18
          CPMOVE   DVEIhigh13,color19
          CPMOVE   DVEIhigh14,color20
          CPMOVE   DVEIhigh15,color21
          CPMOVE   DVEIhigh14,color22
          CPMOVE   DVEIhigh15,color23
          CPMOVE   DVEIhigh12,color24
          CPMOVE   DVEIhigh13,color25
          CPMOVE   DVEIhigh12,color26
          CPMOVE   DVEIhigh13,color27
          CPMOVE   DVEIhigh14,color28
          CPMOVE   DVEIhigh15,color29
          CPMOVE   DVEIhigh14,color30
          CPMOVE   DVEIhigh15,color31

	AAbplcon3	2,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIlow08!$110,color00	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow09!$310,color01	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow08!$010,color02	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow09!$210,color03	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow10!$130,color04	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow11!$330,color05	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow10!$030,color06	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow11!$230,color07	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow08!$100,color08	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow09!$300,color09	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow08!$000,color10	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow09!$200,color11	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow10!$120,color12	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow11!$320,color13	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow10!$020,color14	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow11!$220,color15	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3

          CPMOVE   DVEIlow12!$110,color16	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow13!$130,color17	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow12!$010,color18	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow13!$030,color19	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow14!$330,color20	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow15!$310,color21	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow14!$230,color22	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow15!$210,color23	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow12!$100,color24	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow13!$120,color25	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow12!$000,color26	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow13!$020,color27	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow14!$320,color28	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow15!$300,color29	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow14!$220,color30	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow15!$200,color31	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1

	AAbplcon3	3,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIhigh08,color00
          CPMOVE   DVEIhigh09,color01
          CPMOVE   DVEIhigh08,color02
          CPMOVE   DVEIhigh09,color03
          CPMOVE   DVEIhigh10,color04
          CPMOVE   DVEIhigh11,color05
          CPMOVE   DVEIhigh10,color06
          CPMOVE   DVEIhigh11,color07
          CPMOVE   DVEIhigh08,color08
          CPMOVE   DVEIhigh09,color09
          CPMOVE   DVEIhigh08,color10
          CPMOVE   DVEIhigh09,color11
          CPMOVE   DVEIhigh10,color12
          CPMOVE   DVEIhigh11,color13
          CPMOVE   DVEIhigh10,color14
          CPMOVE   DVEIhigh11,color15

          CPMOVE   DVEIhigh12,color16
          CPMOVE   DVEIhigh13,color17
          CPMOVE   DVEIhigh12,color18
          CPMOVE   DVEIhigh13,color19
          CPMOVE   DVEIhigh14,color20
          CPMOVE   DVEIhigh15,color21
          CPMOVE   DVEIhigh14,color22
          CPMOVE   DVEIhigh15,color23
          CPMOVE   DVEIhigh12,color24
          CPMOVE   DVEIhigh13,color25
          CPMOVE   DVEIhigh12,color26
          CPMOVE   DVEIhigh13,color27
          CPMOVE   DVEIhigh14,color28
          CPMOVE   DVEIhigh15,color29
          CPMOVE   DVEIhigh14,color30
          CPMOVE   DVEIhigh15,color31

	AAbplcon3	3,0	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

          CPMOVE   DVEIlow08!$110,color00	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow09!$310,color01	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow08!$010,color02	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow09!$210,color03	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow10!$130,color04	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow11!$330,color05	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow10!$030,color06	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow11!$230,color07	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow08!$100,color08	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow09!$300,color09	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow08!$000,color10	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow09!$200,color11	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow10!$120,color12	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow11!$320,color13	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow10!$020,color14	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow11!$220,color15	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3

          CPMOVE   DVEIlow12!$110,color16	;R/R1=0 B/R0=1 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow13!$130,color17	;R/R1=0 B/R0=1 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow12!$010,color18	;R/R1=0 B/R0=0 G/G1=0 I/G0=1 PvOl=0
          CPMOVE   DVEIlow13!$030,color19	;R/R1=0 B/R0=0 G/G1=1 I/G0=1 PvOl=2
          CPMOVE   DVEIlow14!$330,color20	;R/R1=1 B/R0=1 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow15!$310,color21	;R/R1=1 B/R0=1 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow14!$230,color22	;R/R1=1 B/R0=0 G/G1=1 I/G0=1 PvOl=3
          CPMOVE   DVEIlow15!$210,color23	;R/R1=1 B/R0=0 G/G1=0 I/G0=1 PvOl=1
          CPMOVE   DVEIlow12!$100,color24	;R/R1=0 B/R0=1 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow13!$120,color25	;R/R1=0 B/R0=1 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow12!$000,color26	;R/R1=0 B/R0=0 G/G1=0 I/G0=0 PvOl=0
          CPMOVE   DVEIlow13!$020,color27	;R/R1=0 B/R0=0 G/G1=1 I/G0=0 PvOl=2
          CPMOVE   DVEIlow14!$320,color28	;R/R1=1 B/R0=1 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow15!$300,color29	;R/R1=1 B/R0=1 G/G1=0 I/G0=0 PvOl=1
          CPMOVE   DVEIlow14!$220,color30	;R/R1=1 B/R0=0 G/G1=1 I/G0=0 PvOl=3
          CPMOVE   DVEIlow15!$200,color31	;R/R1=1 B/R0=0 G/G1=0 I/G0=0 PvOl=1

	ENDC	;IFEQ	NUMINTERFACEPLANES-6

*---------------------------------

	AAbplcon3	7,1	;bank 7, upper nibble
	CPMOVE	AAvalue,bplcon3

*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $000,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1

	AAbplcon3	7,0	;bank 7, upper nibble
	CPMOVE	AAvalue,bplcon3
*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $600,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $024,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $624,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $101,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $701,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $125,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $725,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $012,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $612,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $036,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $636,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $113,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $713,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $137,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $737,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1

	ENDC	;IFD	AACHIPS
*-------------------------------------------------------------------

	IFND	AACHIPS
          CPMOVE   ((64>>1)&$fc),ddfstrt
          CPMOVE   ((424>>1)&$fc),ddfstop
          CPMOVE   ((7<<4)!7),bplcon1   ;scroll
          CPMOVE   -96,bpl1mod
          CPMOVE   96,bpl2mod
          CPMOVE   $24,bplcon2         ;sprite priority over bm
	ENDC

	IFD	AACHIPS
	AAddfstrt	AA768fetchStart
        CPMOVE	AAvalue,ddfstrt

	AAddfstop	AA768fetchStop
        CPMOVE	AAvalue,ddfstop

	AAbplcon1	AAbmscroll,AAbmscroll
        CPMOVE	AAvalue,bplcon1   	;scroll (put sprite left of bm)

	IFEQ	NUMINTERFACEPLANES-2
        CPMOVE   	-(768/8),bpl1mod
        CPMOVE   	(768/8),bpl2mod
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
        CPMOVE   	(768/8),bpl1mod
        CPMOVE   	-(768/8),bpl2mod
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
        CPMOVE   	(768/8),bpl1mod
        CPMOVE   	-(768/8),bpl2mod
	ENDC

        CPMOVE 	AAbplcon2,bplcon2	;sprite priority over bm
	CPMOVE	AAbplcon4,bplcon4	;sprite colors = 240-255

	CPMOVE	AA768fetchMode,fmode
	ENDC

	  CPMOVE  0,copjmp1		;jump to body

*;-------------
 LABEL	DVEI1_I
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

	LABEL     DVEI1_Spr0pt2I
          CPMOVEREGL   spr0pth       ;fill values in later, freeze/live
          CPMOVEREGL   spr1pth	    ;usually save as Spr1pt1		

 LABEL	DVEI1_IBody
	  move.l a2,d0
          add.l	#DVEI1_II,d0
	  CPMOVERL d0,cop1lc		;->main copper list

	move.l	(a1),d0

	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC

	IFEQ	NUMINTERFACEPLANES-2
	CPMOVERL	d0,bpl2pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVERL	d0,bpl1pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVERL	d0,bpl1pth
	ENDC

	move.l	4(a1),d0

	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC
	
	IFEQ	NUMINTERFACEPLANES-2
	CPMOVERL	d0,bpl4pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVERL	d0,bpl3pth
	move.l	8(a1),d0
	add.l	#96,d0
	CPMOVERL	d0,bpl5pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVERL	d0,bpl3pth
	move.l	8(a1),d0
	add.l	#96,d0
	CPMOVERL	d0,bpl5pth
	move.l	12(a1),d0
	add.l	#96,d0
	CPMOVERL	d0,bpl7pth
	ENDC

*;---------
	STRUCT     DVEI1_Spr2ptI,4*12
	  move.l   TB_EffectsBase+EFB_SpriteData(a5),d0
	  add.l	   #ESD_SpriteNull,d0	

	  move.w   #spr2pth,d1
	  moveq	   #5,d2		;null out sprites 2-7	  	  
10$	  move.w   d1,(a0)+
	  swap	   d0		;msw	
	  move.w   d0,(a0)+

          addq.w   #2,d1
          move.w   d1,(a0)+
          swap     d0		;lsw
	  move.w   d0,(a0)+

          addq.w   #2,d1
	  dbra	   d2,10$
*;---------

	LABEL     DVEI1_Bpl1ptl1I

	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

;;* had this up upto 3.1          CPWAIT   21,0

	IFND	AACHIPS
	move.w	#%1100000000000000,d0
	ENDC

	IFD	AACHIPS
	IFEQ	NUMINTERFACEPLANES-2
	AAbplcon0	4,1,0,0		;depth=4, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	AAbplcon0	5,1,0,0		;depth=5, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	AAbplcon0	7,1,0,0		;depth=7, HiRes, non-HAM, no ERSY
	ENDC
	move.w	#AAvalue,d0
	ENDC

	or.w	TB_BPLCON0orBits(a5),d0
	CPMOVERW d0,bplcon0		;modes & 4 planes

	LABEL DVEI1_wait1I
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 or forever 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     DVEI1_Bpl1ptl2I
	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

	LABEL DVEI1_wait2I
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     DVEI1_Bpl1ptl3I
	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

          CPEND
*;-------------
 LABEL	DVEI1_II
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

	LABEL     DVEI1_Spr0pt2II
          CPMOVEREGL   spr0pth       ;fill values in later, freeze/live
          CPMOVEREGL   spr1pth	    ;usually same as Spr1pt1		

 LABEL	DVEI1_IIBody
	move.l	a2,d0
	add.l	#DVEI1_I,d0
	  CPMOVERL d0,cop1lc		;->main copper list

	move.l	(a1),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	IFEQ	NUMINTERFACEPLANES-2
	CPMOVERL	d0,bpl2pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVERL	d0,bpl1pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVERL	d0,bpl1pth
	ENDC

	move.l	4(a1),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	IFEQ	NUMINTERFACEPLANES-2
	CPMOVERL	d0,bpl4pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVERL	d0,bpl3pth

	move.l	8(a1),d0
	CPMOVERL	d0,bpl5pth
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVERL	d0,bpl3pth

	move.l	8(a1),d0
	CPMOVERL	d0,bpl5pth
	move.l	12(a1),d0
	CPMOVERL	d0,bpl7pth
	ENDC

*;---------
	STRUCT     DVEI1_Spr2ptII,4*12
	  move.l   TB_EffectsBase+EFB_SpriteData(a5),d0
	  add.l	   #ESD_SpriteNull,d0	

	  move.w   #spr2pth,d1
	  moveq	   #5,d2		;null out sprites 2-7	  	  
15$	  move.w   d1,(a0)+
	  swap	   d0		;msw	
	  move.w   d0,(a0)+

          addq.w   #2,d1
          move.w   d1,(a0)+
          swap     d0		;lsw
	  move.w   d0,(a0)+

          addq.w   #2,d1
	  dbra	   d2,15$
*;---------

	LABEL     DVEI1_Bpl1ptl1II
	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

;;* had this upto 3.1          CPWAIT   21,0

	IFND	AACHIPS
	move.w	#%1100000000000000,d0
	ENDC

	IFD	AACHIPS
	IFEQ	NUMINTERFACEPLANES-2
	AAbplcon0	4,1,0,0		;depth=4, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	AAbplcon0	5,1,0,0		;depth=5, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	AAbplcon0	7,1,0,0		;depth=7, HiRes, non-HAM, no ERSY
	ENDC
	move.w	#AAvalue,d0
	ENDC

	or.w	TB_BPLCON0orBits(a5),d0
	CPMOVERW d0,bplcon0		;modes & 4 planes

	LABEL DVEI1_wait1II
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 or forever 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     DVEI1_Bpl1ptl2II
	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

	LABEL DVEI1_wait2II
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     DVEI1_Bpl1ptl3II
	IFEQ	NUMINTERFACEPLANES-2
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

          CPEND

	movem.l	(sp)+,d0-d2/a0-a2
	rts
	
	LABEL	DVEI1_SIZEOF

***********************************************************
* ~SetUpDVEInterface1(->SetUpDVE structure)

	IFD	CCODE
_SetUpDVEInterface1	movea.l	4(sp),a0
	ENDC

SetUpDVEInterface1	movem.l	d0-d1/a0-a3,-(sp)
	movea.l	a0,a1			;->structure
	movea.l	SUDVE_DBCopLists(a1),a2	;->DBcoplist
	move.w	(a2),d0			;current
	movea.l	DB_Data(a2,d0.w),a2	;->coplist	

	lea	DVEI1_Spr0pt1(a2),a0
	movea.l	SUDVE_DBSprite0E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite0R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)

	movea.l	SUDVE_DBSprite1R(a1),a3
	move.w	(a3),d1			;current
	movea.l	DB_Data(a3,d1.w),a3	
	move.l	a3,d1
	move.l	#SPRITE1CTRL241,(a3)

	lea	DVEI1_Spr0pt2I(a2),a0
	CPMOVEVALL	d0
	swap	d0
	CPMOVEVALL	d1
	swap	d1

	lea	DVEI1_Spr0pt2II(a2),a0
	CPMOVEVALL	d0
	CPMOVEVALL	d1

*;----
*;assumes all low/high order bitplane data is each within a 64K block
	lea	DVEI1_Bpl1pth(a2),a0
	movea.l	SUDVE_DBPlanePtrs(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	;**PlanePtrs
	move.l	a3,-(sp)		;save

	movea.l	(a3),a3			;*PlanePtrs for null line
	move.l	(a3)+,d0			;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,d1		;null plane0 lsw
	swap	d0
	CPMOVEVALW	d0	;bpl1pth (2 on AA)
	move.l	(a3),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	swap	d0
	CPMOVEVALW	d0	;bpl3pth (4 on AA)

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;bpl6pth (6 on AA)
	ENDC

	swap	d0		;null plane1 lsw

*;----	
* d1=lsp of data, d0->msp of data
	lea	DVEI1_Bpl1ptl1I(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d0	;null plane 1
	
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;null plane 2
	ENDC
	
	
	lea	DVEI1_Bpl1ptl1II(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d0	;null plane 1
	
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;null plane 2
	ENDC

*;---	
	lea	DVEI1_Bpl1ptl3I(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d0	;null plane 1

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;null plane 2
	ENDC

	lea	DVEI1_Bpl1ptl3II(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d0	;null plane 1

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;null plane 2
	ENDC
*;---
	lea	DVEI1_Bpl1ptl2I(a2),a0
	movea.l	(sp)+,a3	;restore **planeprs
	movea.l	4(a3),a3	;*Planeptrs for effect planes
	move.l	(a3)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,d1
	CPMOVEVALW	d0	;effect plane 0
	move.l	(a3),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 1
	
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;null plane 2
	ENDC

	lea	DVEI1_Bpl1ptl2II(a2),a0
	CPMOVEVALW	d1	;effect plane 0
	CPMOVEVALW	d0	;effect plane 1

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;null plane 2
	ENDC
*;----
	movea.l	SUDVE_CompBitMapList(a1),a3
	tst.b	DVE1CBML_MiddleBM(a3)
	bmi.s	5$			;wait forever, only top given
	tst.b	DVE1CBML_MiddleRows(a3)
	beq.s	5$			;wait forever, effect not present

	moveq	#0,d0
	move.b	DVE1CBML_TopRows(a3),d0
	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
   ori.w	#(0<<1)!1,d0
 
;;       btst      #8,d0
;;        bne.s     16$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     18$
;;16$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

18$	cmpi.w	#255,d1
	bhi.s	10$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	DVEI1_wait1I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	lea	DVEI1_wait1II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	12$

5$	move.w	#(255<<8)!(127<<1)!1,d0	;wait forever
	lea	DVEI1_wait1I(a2),a0
	CPWAITVAL	d0
	lea	DVEI1_wait1II(a2),a0
	CPWAITVAL	d0
	bra	666$

	
10$
	IFND	AACHIPS
	move.w	#(255<<8)!(15<<1)!1,d1	;wait to 255,15
	ENDC
	IFD	AACHIPS
	move.w	#(255<<8)!(111<<1)!1,d1	;wait to 255,111
	ENDC

	lea	DVEI1_wait1I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	lea	DVEI1_wait1II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

*;----
12$	moveq	#0,d0	

	move.b	DVE1CBML_TopRows(a3),d0
	add.b	DVE1CBML_MiddleRows(a3),d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
   ori.w		#(0<<1)!1,d0
;;        btst      #8,d0
;;        bne.s     26$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     28$
;;26$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

28$	cmpi.w	#255,d1
	bhi.s	20$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	DVEI1_wait2I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	lea	DVEI1_wait2II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	666$
	
20$
	IFND	AACHIPS
	move.w	#(255<<8)!(15<<1)!1,d1	;wait to 255,15
	ENDC
	IFD	AACHIPS
	move.w	#(255<<8)!(111<<1)!1,d1	;wait to 255,111
	ENDC

	lea	DVEI1_wait2I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	lea	DVEI1_wait2II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

666$	movem.l	(sp)+,d0-d1/a0-a3	
	rts

************************************************************************
* ~InitAVECopLists(->TB)

	IFD	CCODE
_InitAVECopLists
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	InitAVECopLists
	movea.l	(sp)+,a5
	rts
	ENDC	

InitAVECopLists	movem.l	d0-d1/a0-a1,-(sp)
	GET.w	TB_BPLCON0orBits,d0
	or.w	d0,AVEBPLCON0_1
	or.w	d0,AVEBPLCON0_2

	XLEA	AVECL1,a0
	XMEA	AVECopListBody1,d0
	move.w	d0,4(a0)
	swap	d0
	move.w	d0,(a0)

	XLEA	AVECL2,a0
	XMEA	AVECopListBody2,d0
	move.w	d0,4(a0)
	swap	d0
	move.w	d0,(a0)

	XLEA	AVECopListMain1,a0
	move.l	a0,d0
	move.w	d0,26(a0)
	swap	d0
	move.w	d0,22(a0)

	XLEA	AVECopListMain2,a1
	move.l	a1,d0
	move.w	d0,26(a1)
	swap	d0
	move.w	d0,22(a1)
		
	XMEA.l	NarrowBMNull,d0
	move.w	d0,34(a0)
	move.w	d0,34(a1)
	swap	d0
	move.w	d0,30(a0)
	move.w	d0,30(a1)

	move.l	TB_EffectsBase+EFB_SpriteData(a5),d0
	add.l	#ESD_SpriteNull,d0
	lea	38(a0),a0
	lea	38(a1),a1
	moveq	#5,d1
10$	move.w	d0,4(a0)
	move.w	d0,4(a1)
	swap	d0
	move.w	d0,(a0)
	move.w	d0,(a1)
	swap	d0
	addq.w	#8,a0
	addq.w	#8,a1
	dbra	d1,10$

	movem.l	(sp)+,d0-d1/a0-a1
	rts

************************************************************************
* ~InitAVEInterfaces(->TB)
*		    a5
	IFD	CCODE
_InitAVEInterfaces
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	InitAVEInterfaces
	movea.l	(sp)+,a5
	rts
	ENDC	

InitAVEInterfaces:
	movem.l	d0-d1/a0-a1,-(sp)
	XLEA	AVEInterfaceMainI1,a0	;->spr0pth
	XLEA	AVEInterfaceMainII1,a1
	bsr.s	100$
	
	XLEA	AVEInterfaceMainI2,a0	;->spr0pth
	XLEA	AVEInterfaceMainII2,a1
	bsr.s	100$

	movem.l	(sp)+,d0-d1/a0-a1
	rts

;------------
100$
;;	GET.w	TB_BPLCON0orBits,d0
;;	or.w	d0,AVEI_IBPLCON0_1(a0)
;;	or.w	d0,AVEI_IBPLCON0_2(a0)
;;	or.w	d0,AVEI_IIBPLCON0_1(a1)
;;	or.w	d0,AVEI_IIBPLCON0_2(a1)

;link cop1jmps
	move.l	a1,d0
	move.w	d0,5*4+6(a0)
	swap	d0
	move.w	d0,5*4+2(a0)

	move.l	a0,d0
	move.w	d0,5*4+6(a1)
	swap	d0
	move.w	d0,5*4+2(a1)

;nullify sprites
	move.l	TB_EffectsBase+EFB_SpriteData(a5),d1
	add.l	#ESD_SpriteNull,d1	

	IFND	AACHIPS
	lea	15*4+2(a0),a0	;->spr2pth
	lea	15*4+2(a1),a1
	ENDC

	IFD	AACHIPS
	lea	(15+8)*4+2(a0),a0  ;->spr2pth
	lea	(15+8)*4+2(a1),a1
	ENDC

	moveq	#5,d0
10$	move.w	d1,4(a0)
	move.w	d1,4(a1)
	swap	d1
	move.w	d1,(a0)
	move.w	d1,(a1)
	swap	d1
	addq.w	#8,a0
	addq.w	#8,a1
	dbra	d0,10$
	rts

************************************************************************
* ~InitReadCopList(->TB)

	IFD	CCODE
_InitReadCopList
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	InitReadCopList
	movea.l	(sp)+,a5
	rts
	ENDC	

InitReadCopList	movem.l	d0-d1/a0-a2,-(sp)
	GET.w	TB_BPLCON0orBits,d0
	or.w	d0,ReadBPLCON0_1
	or.w	d0,ReadBPLCON0_2

	XLEA	ReadLCH1,a0     ;copper list pointer
	XLEA	ReadMain1,a1

	move.l	a1,d0
	move.w	d0,6(a0)
	swap	d0
	move.w	d0,2(a0)

	XLEA	ReadLCH2,a0     ;copper list pointer
	XLEA	ReadMain2,a2

	move.l	a2,d0
	move.w	d0,6(a0)
	swap	d0
	move.w	d0,2(a0)

	move.l	TB_EffectsBase+EFB_SpriteData(a5),d0
	move.l	d0,d1
	add.l	#ESD_Sprite1Linear,d0
	move.w	d0,18(a1)
	swap	d0
	move.w	d0,14(a1)

	move.w	d0,14(a2)
	swap	d0
	move.w	d0,18(a2)

	lea	22(a1),a1
	lea	22(a2),a2
	moveq	#5,d0
      	add.l	#ESD_SpriteNull,d1      ;null sprite pointers
70$	move.w	d1,4(a1)
	move.w	d1,4(a2)
	swap	d1
	move.w	d1,(a1)
	move.w	d1,(a2)
	swap	d1
	addq.w	#8,a1
	addq.w	#8,a2
	dbra	d0,70$

	movem.l	(sp)+,d0-d1/a0-a2
	rts

************************************************************************
* ~InitFieldWrite(->TB)
*		  a5

	IFD	CCODE
_InitFieldWrite
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	InitFieldWrite
	movea.l	(sp)+,a5
	rts
	ENDC	

InitFieldWrite	movem.l	d0-d1/a0-a1,-(sp)
	GET.w	TB_BPLCON0orBits,d0
	or.w	d0,FWBPLCON0_1
	or.w	d0,FWBPLCON0_2

	XLEA	FWSPR1,a0
	XLEA	FWSPR2,a1
	
	move.l	TB_EffectsBase+EFB_SpriteData(a5),d0
	add.l	#ESD_SpriteNull,d0

	moveq	#5,d1
10$	move.w	d0,4(a0)
	move.w	d0,4(a1)
	swap	d0
	move.w	d0,(a0)
	move.w	d0,(a1)
	swap	d0
	addq.w	#8,a0
	addq.w	#8,a1
	dbra	d1,10$

	movem.l	(sp)+,d0-d1/a0-a1
	rts

****************************************************************
* ~SetUpFieldWrite(->FieldWrite structure)

	XREF	FWMOD,FWPLANES,FWSCROLL

	IFD	CCODE
_SetUpFieldWrite
	  movea.l	4(sp),a0
	ENDC

SetUpFieldWrite	movem.l	d0-d1/a0-a2,-(sp)
	move.w	FW_PixelsWide(a0),d0
	bne.s	5$
	moveq	#-96,d0
	bra.s	30$

5$	subi.w	#768,d0	;width needs to be divisible by 16 (MUST be 768 on AA machine)
	asr.w	#3,d0	;768=0, 752=-2, 736=-4

30$	movea.l	FW_CopList(a0),a1
	move.w	d0,FWMOD(a1)	;modulo
	move.w	d0,FWMOD+4(a1)	;modulo

	movea.l	FW_Sprite0(a0),a2
	move.l	a2,d0
	move.l	#SPRITE0CTRL241,(a2)
	move.w	d0,10(a1)	;sprite0 entry
	swap	d0
	move.w	d0,6(a1)

	movea.l	FW_Sprite1(a0),a2
	move.l	a2,d0
	move.l	#SPRITE1CTRL241,(a2)
	move.w	d0,18(a1)	;sprite1 entry
	swap	d0
	move.w	d0,14(a1)

	IFD	AACHIPS
	AAbplcon1	AAbmscroll,AAbmscroll
        move.w	#AAvalue,FWSCROLL(a1)	   	;scroll (put sprite left of bm)
	cmpi.b	#2,FW_ActiveSync(a0)
	bne.s	35$

* It's a zipper write
	AAbplcon1 ((AAbmscroll)-(16*2)),((AAbmscroll)-(16*2))
        move.w	#AAvalue,FWSCROLL(a1) 	;shift left 16 HIRES pixels

	ENDC

35$	lea	FWPLANES(a1),a1
	movea.l	FW_Planes(a0),a2
	moveq	#3,d0
40$	move.l	(a2)+,d1	;planeptrs

	IFND	AACHIPS
	subq.l	#4,d1
	ENDC

	move.w	d1,4(a1)
	swap	d1
	move.w	d1,(a1)
	addq.w	#8,a1
	dbra	d0,40$	
	
	move.l	FW_AfterCopList(a0),d0
	move.w	d0,4(a1)	;aftercop
	swap	d0
	move.w	d0,(a1)

666$	movem.l	(sp)+,d0-d1/a0-a2
	rts

************************************************************************
* ~InitSafeWrite(->TB)
*		  a5

	IFD	CCODE
_InitSafeWrite
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	InitSafeWrite
	movea.l	(sp)+,a5
	rts
	ENDC	

InitSafeWrite	movem.l	d0-d1/a0-a1,-(sp)
	GET.w	TB_BPLCON0orBits,d0	
	XLEA	SafeWriteCopList1,a0
	bsr.s	100$
	XLEA	SafeWriteCopList2,a0
	bsr.s	100$

	XLEA	SWSPR1,a0
	XLEA	SWSPR2,a1
	
	move.l	TB_EffectsBase+EFB_SpriteData(a5),d0
	add.l	#ESD_SpriteNull,d0

	moveq	#5,d1
10$	move.w	d0,4(a0)
	move.w	d0,4(a1)
	swap	d0
	move.w	d0,(a0)
	move.w	d0,(a1)
	swap	d0
	addq.w	#8,a0
	addq.w	#8,a1
	dbra	d1,10$

	movem.l	(sp)+,d0-d1/a0-a1
	rts

100$	or.w	d0,SWBPLCON0_1(a0)
	or.w	d0,SWBPLCON0_2(a0)
	or.w	d0,SWBPLCON0_3(a0)
	or.w	d0,SWBPLCON0_4(a0)
	or.w	d0,SWBPLCON0_5(a0)
	or.w	d0,SWBPLCON0_6(a0)
	or.w	d0,SWBPLCON0_7(a0)
	or.w	d0,SWBPLCON0_8(a0)
	or.w	d0,SWBPLCON0_9(a0)
	or.w	d0,SWBPLCON0_10(a0)
	or.w	d0,SWBPLCON0_11(a0)
	or.w	d0,SWBPLCON0_12(a0)
	rts

************************************************************************
* ~OldDoSafeWrite(->dataBM, ->InterfaceBM, ->TB, startWrite#,
*    	         a0	      a1	a5	d0
* 	        interfaceTop, Bank, dataBMModulo)
*  		    d1	       d2	d3
* I would like to kill OldDoSafeWrite, and DoBlockWrite.  It is recommended,
* that you use DoSafeWrite for your writing needs.

OldDoSafeWrite:
	movem.l	d0-d5/a2,-(sp)
	move.l	d2,d4	;bank
	moveq	#0,d2	;AM
	movea.l	d2,a2	;->Palette = NULL
	exg	d0,d3
	sub.w	#21,d1

	IFD	AACHIPS
	moveq	#1,d5	;On AA chips, this function won't do a zipper write!!
	ENDC

	bsr.s	DoSafeWrite
	movem.l	(sp)+,d0-d5/a2
	rts

************************************************************************
* ~DoSafeWrite(->dataBM, ->CustomBM, ->Palette, ->TB,
*		a0	    a1	        a2       a5
*	      dataBMModulo, CustomBMTop, AM/BM, startWrite#, Bank, [zipperFlag])
*		   d0            d1        d2       d3        d4	d5
*-----------------------------------------------------------------------
* HERE ARE THE OLD PARAMETERS, BEFORE 5-23-91 = v1.0 A/B/C, NAB91
* OLD PARAMS ==> DoSafeWrite(->dataBM, ->InterfaceBM, ->TB, startWrite#,
* OLD PARAMS ==>   	         a0	      a1	a5	d0
* OLD PARAMS ==>	        interfaceTop, Bank, dataBMModulo)
* OLD PARAMS ==>		    d1	       d2	d3
* You may still use these parameters if you CALLTL OldDoSafeWrite().
* I would like to kill OldDoSafeWrite, and DoBlockWrite.  It is recommended,
* that you use DoSafeWrite for your writing needs.

* This writes lines of data to the Toaster, and allows not only a standard
* GrayScale 4 color interlaced (2 field) BM to be displayed in the
* "Safe Area", but also allows a custom 2 field, 1-4 Hires Planes BM to
* be displayed in the user defined "Safe Area".  So, while writing you may
* leave Alpha Planes, TDE planes (?), or Latch Wipe Planes visable.
* The special purpose safe area planes are of course optional.
* All registers are preserved.
*
* Before this is entered, you MUST be in a frozen DVE state, and normally not
* in the middle of a standard effects transition.  That is AVEI, AVE, AVEC,
* are installed, or some special 1 or 2 field SimpleBM is being used to show
* an interface or key between two sources.
* Currently, I assume LINP on entry (normal non-TDE, non-LUT state).  In the
* future, I may support non-LINP line numbers in the sprite for TDE or LUT?
*
* No toaster control bits are altered in the safe area, or altered on
* return from this routine.  To prevent transparency in the sprite, it is
* assumed that WERB is high,
* and NOSNOW ! MB0 ! MA0 ! MP0 is also high.  These conditions are always
* satisfied by the normal state of the toaster.
*
* As usual, I assume the parameters you give me are correct, I don't waste
* time doing error checking.  Garbage in = Garbage out.
*
* The data in the dataBM is the same interlaced format as used by the older
* DoBlockWrite() routine.
* That is, scan line 0 = Most  Significant Nibble of Normal Video (I or II)
*	   scan line 1 = Least Significant Nibble of Normal Video (I or II)
* 	   scan line 2 = Most  Sign. Nibble of Complemented Video (III or IV)
*	   scan line 3 = Least Sign. Nibble of Complemented Video (III or IV)
*	     repeat for more lines ......
*
* The dataBM data is arranged so plane0 = least significant bit of a nibble
*
* If the data is arranged with N7, N6, N5, N4, N3, N2, N1, N0, C7, C6, C5
* C4, C3, C2, C1, C0, etc. as it might be if loaded from an ILBM file, then
* you can set dataBMModulo to 3*92 (for 736 pixels wide), so that the
* bitmap hardware will automatically pick out NH, NL, CH, CL etc,
* automatically "deinterleaving". N=Normal data, C=Complimented data
* 7-0 = bit significants.  H=high nibble, L=low nibble.
* Normally, dataBMModulo is 0.
*
* ->CustomBM points to your custom interlaced HiRes BitMap.  It can
*  contain your user interface, and/or Alpha Key.
* If you don't want any interface/Alpha Key, then ->CustomBM must be NULL.
*
* When supplying a CustomBM, CustomBMTop must be between 8 and 240 and
* corresponds to diwstartY-21.  The interface can never extend into the top
* 8 lines of a full vertical overscan display.
* For a standard 400 line high CustomBM, CustomBMTop = 22.
* If ->CustomBM is NULL, then CustomBMTop will be ignored.  
*
* bm_Depth(dataBM) is always 4
* bm_BytesPerRow(dataBM) is 92, 94, or 96 (ONLY 96 supported on AA Chips)
* OLD! 92 will not affect the zipper area, 94 & 96 will write the zipper area too.
* NEW! Zipper writing depends on d5 = ZipperFlag
*
* bm_Rows(dataBM) is always divisable by four = WH
*
* bm_Depth(CustomBM) is 1 to 4 planes (upto 8 planes on AA Chips)
* bm_BytesPerRow(CustomBM) is 92, 94, or 96 (ONLY 96 supported on AA Chips)
* bm_Rows(CustomBM) is always divisable by two = IH, and I assume the
* interlaced BMs top line = field II !!!!!!!!!!
*
* If ->CustomBM is NULL, then WH may be between 0 and 232 (=0 to 58 lines)
*
* If a CustomBM is supplied, then there are 2 possible cases:
*   Case1: CustomBMTop - WH > 7 = Only top area is used for writing.
*	then WH + IH/2 must be less than 233
*
*   Case2: CustomBMTop - WH < 8 = Both top and bottom areas used.
*	then WH + IH/2 must be less than 225
*	So for a typically positioned 400 line high interface, max WH = 24,
*	which amounts to 6 toaster interlace lines.
*
* ->Palette points to a table of RGB WORDs on ECS and pre-ESC machines.
* On AA chip machines it points to a table of longs with the following
* nibble format: 0 RH GH BH  0 RL GL BL
* The table contains the palette for the CustomBM, plus a color used in
* the "NON-SAFE" vertical areas, which I will call the OverScanColor.
*  The last element in the table is
* always the OverScanColor.  If ->Palette is NULL, then the standard 
* switcher interface colors (4 colors) will be used, and the OverScanColor
* will be the same as for the Switchers "surface" color (color 1).
* The OverScanColor is usually only important if the switcher is doing some
* type of keying, and the keying is determined by the Amiga's RGB,
* i.e. DIBGR, DIB, DG, RGQUAD, QUAF.  The RGB color you use will depend
* on which keying mode you are in, and which side of the Fader you want
* passed thru in the "NON-SAFE" areas.  Because you typically want to show
* BackGround video in the NON-SAFE areas, and normally the BackGround is
* being passed thru AM, you will want an RGB color that sets the Fader to 0.
*
* bm_Depth(CustomBM)   #PaletteColors
*     0 (no CustomBM)		1
*     1				3
*     2				5
*     3				9
*     4				17
*
* FOR AA Machines
*     5				33
*     6				65
*     7				129
*     8    			257
*
* AM/BM flag indicates which side of the Fader should be passed thru to
* MainOut, during the "NON-SAFE" areas. 0 = AM, 1=BM.  When you aren't
* trying to keep a BitMap Alpha Key up during the write, and you aren't
* in an effects transition, the normal state of the Toaster has both
* the AM and BM sides of the fader passing thru the same video source, so
* the state of this flag is arbitrary, but if some form of keying is being
* shown on MainOut, then you need to decide which source to show in the
* NON-SAFE areas.  Normally, you will want to show the BackGround video
* as opposed to the ForeGround video, and typically the BackGround source
* is being passed thru the AM side, so you would want to use a flag of 0.
*
* startWrite# must be between 0 and 480 = toaster interlaced line number.
* This is the top line # of a block of interlaced lines to be rendered.
* Line 0 is NTSCs 1/2 scanline at the top of the Active Picture.  For
* picture rendering, YOU MUST AVOID LINE 0!!!!.  ONLY RENDER TO LINES 1-480!!
*
* Bank is 0 for rendering to DV1, and 1 for DV2.
*
* On AA & ECS Chip machines, you need to supply the ZipperFlag flag.
* Inother words, for 3.0 always specify the zipperflag!
* If this is 1 when using < 752 wide data (AA chips use a 768 wide bitmap) = zipper write is avoided.
* If this is 0 when using > 736 wide data (AA chips use a 768 wide bitmap) = does zipper write.
*
* The Toasters output during the WRITING AREAS follows the following logic:
* If writing to a bank shown on program: AM & BM are set to MATTE
* If writing to a bank shown on preview: PV is set to MATTE
* When MATTE is used in the writing areas, Black MATTE is used, unless
* MATTE was shown on program, in which case, programs MATTE is used.
* Because the toasters hardware currently is unable to rapidly change
* to Black MATTE from some other color, it is advised that the programmer
* set MATTE to black before multiple calls to DoSafeWrite.
* The PVMute will be unaltered during writing.
*
* This write routine will return at the beginning of the field that actually
* sends the data out to the toaster.  So, if you aren't double buffering the
* dataBM then you must do one Wait4Top() before you alter the dataBM planes.
* If you are double buffering the dataBM, you may call this routine multiple
* times without any Wait4Top()s, and it might just write at 60 times a sec?
*
* If you are calling this routine in a tight loop, it is recommended that
* you do a CALLTL AllInterruptsOff/On() around the loop!!  This will speed
* the loop up 2 fold.
*
* After the writing field, the previous CopperList will be restored.
* For this to work, you must be sure TB_CurrentCopList(->TB), and
* TB_CurrentFourFieldTBL(->TB) are upto date, before you call this routine.
* Though, if you are using AVE, AVEI, AVEC you won't have to worry.
*
* NOTE!!! This uses hardcoded sprites for ELH stuff!  So, if the toaster
* hardware bits are redefined, a programmer might be in for a job.

	XREF	SWOS1,SWOS2,SWOS2b,SWOS2c
	XREF	SWOS3,SWOS3b,SWOS4,SWOS5,SWOS6
	XREF	SWOS7,SWOS7b,SWOS8,SWOS9
	XREF	SWOS10,SWOS10b,SWOS11,SWOS12
	XREF	SWOS12b,SWOS12c,SWOS13,SWOS13b
	XREF	SWOS13c,SWOS14,SWOS14b,SWOS15
	XREF	SWOS16,SWOS17,SWOS17b,SWOS18,SWOS19
	XREF	SWOS20,SWOS21,SWOS22,SWOS22b
	XREF	SWOS23,SWOS24

	IFD	AACHIPS
	XREF	SWOS2d,SWOS3a,SWOS16b,SWOS17c
	ENDC

DoSafeWrite:
	move.w	d7,-(sp)
	move.w	#0,d7	;no zipper, no sync
	bsr.s	dswsub

	cmpi.w	#92,bm_BytesPerRow(a0)
	bls.s	100$	;jump if no zipper write needed, <= 736 pixels

* > 736 pixels may or maynot require zipper write
* Used to look at BitMap width, now there's a zipper flag.
	tst.w	d5
	bne.s	100$	;jump if no zipper write needed, < 752 pixels of data

* probaly have >= 752 pixels worth of data.
	move.w	#1,d7	;zipper, no sync

	IFND	AACHIPS
	movem.l	d5/a3,-(sp)

	lea	bm_Planes(a0),a3
	moveq	#3,d5
10$	addq.l	#2,(a3)+
	dbra	d5,10$

	bsr.s	dswsub

	lea	bm_Planes(a0),a3
	moveq	#3,d5
20$	subq.l	#2,(a3)+
	dbra	d5,20$

	movem.l	(sp)+,d5/a3
	ENDC	;IFND AACHIPS

	IFD	AACHIPS
	bsr.s	dswsub
	ENDC
	
100$	move.w	(sp)+,d7
	rts

*---------------------
DoSyncWrite:
	move.w	d7,-(sp)
	move.w	#2,d7	;sync write
	bsr.s	dswsub
100$	move.w	(sp)+,d7
	rts

**************************************************
* if d7=0 then no zipper, no sync
* if d7=1 then do zipper, no sync
* if d7=2 then sync write
dswsub	movem.l	d0-d6/a0-a4/a6,-(sp)	;d7 is unaltered!

	exg	d0,d3	;revariabling for new routine

	ror.l	#8,d4	;save shifted bank

	lea	TB_EffectsBase+EFB_VTSprites1(a5),a2
	GETCURRENTANDFLIP a2	;flip sprite1
	lea	TB_EffectsBase+EFB_VTSprites0(a5),a3
	GETCURRENTANDFLIP a3	;flip sprite0
	movem.l	a2-a3,-(sp)	;stash sprite ptrs

	move.l	#SPRITE1CTRL241,(a2)+
	move.l	#SPRITE0CTRL241,(a3)+

	bsr	dswsprchng	;prepare sprite for write


;;	CALLTL	SendELH2Toaster	;!!!!!!!!!!

;----------
* do line#s for top & bottom writes
	move.l	a1,d3
	bne.s	2$
	move.w	#240,d1	;lowest interface position (off bottom)

2$	move.w	bm_Rows(a0),d3   ;WH always divisible by four!
	sub.w	#(4+4),d1  ;#of scan lines you can use for writing on top >=0

	cmp.w	d1,d3
	ble.s	3$

* top write >= 0, and bottom write > 0
	exg	d1,d3	;can't do everything on top, but do as much as we can
	sub.w	d3,d1	;Bottom

	movem.l	(sp),a4/a6
	movem.w	d1/d3,-(sp)	;save # of lines top & bottom
	add.w	d1,d1
	add.w	d1,d1
	neg.w	d1
 	lea	((240-4)*4)+4(a4),a4
	lea	0(a4,d1.w),a4
	lea	((240-4)*4)+4(a6),a6
	lea	0(a6,d1.w),a6
	move.w	(sp),d1		;restore d1
	movem.l	a4/a6,-(sp)
	bra.s	4$
	
* all contained in top write, no bottom write
3$	moveq	#0,d1	;# write rows on bottom
	movem.w	d1/d3,-(sp)	;save # of lines top & bottom

4$	subq.w	#1,d3	;#top rows-1
	bne.s	9$	;some top data

* only bottom data
	move.w	d1,d3	;bottom # of lines
	subq.w	#1,d3
	moveq	#0,d1
	movem.l	(sp)+,a2/a3

9$	moveq	#3,d5
	lsr.w	#1,d0	;startInterlaceLine#>>1 = toaster line#
	bcs.s	10$	;jump if field I first
	bra.s	6$	

5$	addq.w	#1,d0

* field II first
6$	lea	tblII(pc),a4	
	move.l	d0,d6		;line#
	ror.l	#4,d6
	ror.w	#4,d6

* lines for fields II/IV
7$	move.l	d6,(a2)+
	move.l	(a4)+,(a3)+
	subq.w	#1,d5
	dblt	d3,7$
	andi.w	#%11,d5
	tst.w	d3
	blt.s	8$
	dbra	d3,15$
	bra.s	20$

; d3 exausted
8$	move.w	d1,d3	;bottom # of lines
	beq.s	100$
	moveq	#0,d1
	movem.l	(sp)+,a2/a3
	dbra	d3,7$	;will always branch

* field I first
10$	lea	tblI(pc),a4
	move.l	d0,d6		;line#
	ror.l	#4,d6
	ror.w	#4,d6

* lines for fields I/III
15$	move.l	d6,(a2)+
	move.l	(a4)+,(a3)+
	subq.w	#1,d5
16$	dblt	d3,15$
	andi.w	#%11,d5
	tst.w	d3
	blt.s	20$
	dbra	d3,5$
	addq.w	#1,d0
	lea	tblII(pc),a4	
	move.l	d0,d6		;line#
	ror.l	#4,d6
	ror.w	#4,d6
	bra.s	8$

* d3 exausted
20$	move.w	d1,d3	;bottom # of lines
	beq.s	100$
	moveq	#0,d1
	movem.l	(sp)+,a2/a3
	dbra	d3,15$	;will always branch

*-------------
*			etc
*			LONG =  ;a2			48	;->Palette
*			LONG =  ;a1 			44	;->CustomBM
*			LONG =  ;a0 			40	;->dataBM
*			LONG =  ;d6			36
*			LONG =  ;d5 			32	
*			LONG =  ;d4 			28	;Bank
*			LONG =  ;d3 			24	;startWrite#
*			LONG =  ;d2 			20	;AM/BM
*			LONG =  ;d1 			16	;CustomBMTop
*			LONG =	;d0			12	;dataBMModulo
*			LONG = 	;a3 = sprite0 RG	8
*			LONG =	;a2 = sprite1 IB	4
*		 	WORD = 	;# rows data top	2
*	stack bottom 	WORD =	;# rows data bottom 	0

d0ptr	set	12
d1ptr	set	16
d3ptr	set	24
a2ptr	set	48

* after top & bottom write line #s
100$	movem.l	4(sp),a2/a3	;restore sprite ptrs
	move.w	2(sp),d1	;# rows on top >= 0
	add.w	d1,d1
	add.w	d1,d1
	lea	4+4*4(a2,d1.w),a2
	lea	4+4*4(a3,d1.w),a3
	bsr	dswsprrest	;restore headers

	move.l	a1,d0
	beq.s	130$		;only do write, no interface.

	movem.l	4(sp),a2/a3	;restore sprite ptrs
	move.l	d1ptr(sp),d0	;interface top
	add.w	d0,d0
	add.w	d0,d0
	lea	4(a2,d0.w),a2	;->top of interface
	lea	4(a3,d0.w),a3

	move.w	bm_Rows(a1),d0
	lsr.w	#1,d0		;only half of the lines

* leaving garbage in the 0 plane depth areas
	move.l	#$f000f000,d1	;not an ELH, 255 dummy line #
	move.l	#(VTI_ENONE<<16)!VTI_FREEZE,d3	;CERB off

	bra.s	110$
105$	move.l	d1,(a2)+
	move.l	d3,(a3)+
110$	dbra	d0,105$

	tst.w	(sp)
	beq.s	130$		;jump if no bottom write

	movem.l	4(sp),a2/a3	;restore sprite ptrs
	move.w	#(240-8)*4,d0
	move.w	(sp),d1		;data bottom
	add.w	d1,d1
	add.w	d1,d1		;*4
	sub.w	d1,d0
	lea	4(a2,d0.w),a2	;->top of bottom ELH stuff
	lea	4(a3,d0.w),a3
	
	bsr	dswsprchng	;prepare sprite for write

	move.w	(sp),d0	;# rows on bottom
	add.w	d0,d0
	add.w	d0,d0
	lea	0(a2,d0.w),a2
	lea	0(a3,d0.w),a3

	bsr	dswsprrest	;restore headers
	move.l	#$f000f000,(a2)+ ;not an ELH
	move.l	#(VTI_ENONE<<16)!VTI_FREEZE,(a3)+	;CERB off

	IFD	CRAP
	movem.l	4(sp),a2/a3
	addq.w	#4,a2
	addq.w	#4,a3
	moveq	#23,d0
112$	move.l	#$ffffffff,(a2)
	move.l	#$ffffffff,(a3)
	lea	40(a2),a2
	lea	40(a3),a3
	dbra	d0,112$
	ENDC

130$:

	IFD	DEBUGDSW
	add.l	#1,DoSafeCount

	tst.b	dswdebug
	beq	135$

;;	cmpi.l	#200,DoSafeCount	;PUT COUNT HERE
;;	bne.s	135$

	movem.l	4(sp),a2/a3	;restore sprite ptrs
;;	DUMPUDEC.l	<\DoSafeCount>,DoSafeCount

;;	DUMPHEXI.l <Sprite0>,a3
;;	DUMPMEM	<DoSafeWrites Sprite0>,(a3),#48	;#((241*4)+8)

;;	DUMPHEXI.l <Sprite1>,a2
;;	DUMPMEM	<DoSafeWrites Sprite1>,(a2),#48	;#((241*4)+8)

;;	lea	TB_EffectsBase+EFB_SafeWriteCopLists(a5),a6
;;	GETCURRENT	a6
;;	DUMPMEM <spr0h/l spr1h/l>,SWOS1-2(a6),#16

	ENDC	;DEBUGDSW

*--------------- sprites finished ----------------------------------

135$

;;	cmpi.w	#36,TB_ClipASec(a5)
;;	bne	136$

;;	movem.l	4(sp),a2/a3	;restore sprite ptrs

;;	DUMPHEXI.l <Sprite0=>,a3
;;	DUMPMEM	<DoSafeWrites Sprite0>,(a3),#((241*4)+8)	;#((241*4)+8)

;;	DUMPHEXI.l <Sprite1=>,a2
;;	DUMPMEM	<DoSafeWrites Sprite1>,(a2),#((241*4)+8)	;#((241*4)+8)
136$

	lea	TB_EffectsBase+EFB_SafeWriteCopLists(a5),a6
	GETCURRENTANDFLIP	a6

	IFD	AACHIPS
	
	AAbplcon1	AAbmscroll,AAbmscroll
        move.w	#AAvalue,SWOS3b(a6)	   	;scroll (put sprite left of bm)
        move.w	#AAvalue,SWOS17b(a6)

	cmpi.w	#1,d7	;zipper write ?
	bne.s	1333$

*-----------
	IFD	CRAP
	moveq	#0,d0
	GET.b	TB_ClipASec+1,d0
	ext.w	d0
	move.w	#AAbmscroll,d1
	add.w	d0,d1

	   move.w	d1,d0
	   lsr.w	#4,d0	;put h6 & h7 in bits 2 & 3
	   lsr.w	#1,d1	   		  
	   roxr.w	#1,d0	;bit 0
	   lsr.w	#1,d1	;h2/3/4/5 ok   		  
	   roxr.w	#1,d0	;bit 1 (h6/7 now in bits 0/1, h0/1 in bits 6/7 
	   rol.w	#6,d0
	   lsl.w	#4,d0
	   andi.w	#$f00,d0	;h7/6/1/0 ok
	   andi.w	#$00f,d1	;killed old h6/7
	   or.w		d0,d1
	   move.w	d1,d0
	   lsl.w	#4,d0
	   or.w		d0,d1
	
        move.w	d1,SWOS3b(a6) 	;shift left 16 HIRES pixels
        move.w	d1,SWOS17b(a6)
	bra.s	1333$

	ENDC	;IFD	CRAP
*-----------

* It's a zipper write
	AAbplcon1 ((AAbmscroll)-(16*2)),((AAbmscroll)-(16*2))
        move.w	#AAvalue,SWOS3b(a6) 	;shift left 16 HIRES pixels
        move.w	#AAvalue,SWOS17b(a6)

1333$ ;;	move.l	#$05550655,d0
      ;;	move.l	#$06660000,d0

	GET.w	TB_DoSafeWriteRGB,d0
	swap	d0
	clr.w	d0

	ENDC

	IFND	AACHIPS
	move.w	#$842,d0	;=assume default vertical border color
	ENDC

	move.l	a2ptr(sp),d1	;->palette
	bne	133$		;jmp if palette given

	move.l	a1,d1
	beq	1388$		;jmp no palette, no interface given

* CASE 1: no palette but do have user interface
* This will use the default gray border color (not TB_DoSafeWriteRGB!)
	lea	defpalette(pc),a2 ;standard palette (assume 2 monitor)
	tst.w	TB_UserOn(a5)
	bne.s	1334$
	lea	defpaletteBW(pc),a2	;B/W palette
	bra.s	1334$		;no palette, but do have interface
	
* palette supplied, d1->palette
133$	movea.l	d1,a2
134$
	IFND	AACHIPS
	move.w	(a2),d0
	ENDC
	IFD	AACHIPS
	move.l	(a2),d0	;assume no interface, so only one palette color
	ENDC

	move.l	a1,d1
	bne.s	1334$

* CASE 2: falls here if palette but no interface, d0=border

* CASE 3: jmps to here if no palette, no interface given, d0=default border
1388$	
	IFD	AACHIPS
	bsr	fixwritepalette
	bsr	fixspritepalette	;uses d2-d3/a3-a4
	ENDC

	bra	138$	;jmp if palette given, but no interface given
	
* a2->palette, a1->CustomBM
* CASE 4: Interface & palette both supplied
* What about a AA HAM interface?????????????????????????!!!!!!!!!!!
1334$	moveq	#0,d1
	move.b	bm_Depth(a1),d1
	moveq	#1,d0
	lsl.w	d1,d0

	move.w	d0,d1
	add.w	d0,d0
	
	IFND	AACHIPS
	  move.w 0(a2,d0.w),d0	;vertical overscan border color
	ENDC

	IFD	AACHIPS
	  add.w	 d0,d0
	  move.l 0(a2,d0.w),d0	;vertical overscan border color
	ENDC

* d0=border color
* d1= # of custom colors
* a2->palette (starting at color 00)

	IFD	AACHIPS
	
	bsr	fixwritepalette

	cmpi.w	#240,d1
	bhi.s	779$	;don't fix sprite palette if picture trashes it anyway

	bsr	fixspritepalette 	;uses d2-d3/a3-a4

779$	cmpi.w	#16,d1
	bls.s	7730$	; <= 16 custom colors

* atleast 32 custom colors
	lea	16*4(a2),a3	;->color 16
	lea	SWOS2c+16*4(a6),a4
	moveq	#16-1,d2

7721$	move.l	(a3)+,d3
	move.w	d3,(32+1)*4(a4)	;lower nibbles
	swap	d3
	move.w	d3,(a4)		;upper nibbles
	addq.w	#4,a4
	dbra	d2,7721$

* a3->color 32 of palette, 
	lea	(32+2)*4(a4),a4	;next set of 32 copper writes
	move.w	d1,d2
	sub.w	#32,d2	;might be zero (can't be negative)
	bra.s	7725$

7710$	move.l	(a3)+,d5
	move.w	d5,(32+1)*4(a4)	;lower nibbles
	swap	d5
	move.w	d5,(a4)		;upper nibbles

	addq.w	#4,a4

	subq.w	#1,d3
	bne.s	7720$
	lea	(32+2)*4(a4),a4	;skip over bplcon3 moves & upper nibbles
7725$	moveq	#32,d3
7720$	dbra	d2,7710$

7730$	cmpi.w	#16,d1
	bls.s	132$		;jump if no more than 16 colors
	moveq	#16,d1

	ENDC	;IFD	AACHIPS

* d1= # of custom colors

132$	subq.w	#2,d1	;# of colors to move -1, starting at color1

	IFND	AACHIPS
	lea	2(a2),a3		;->CustomBM palette color 1
	ENDC
	IFD	AACHIPS
	lea	4(a2),a3
	ENDC

	lea	SWOS10b(a6),a4		

131$
	IFND	AACHIPS
	move.w	(a3)+,(a4)
	ENDC
	IFD	AACHIPS
	move.l	(a3)+,d2
	move.w	d2,16*4(a4)	;low nibble
	swap	d2
	move.w	d2,(a4)		;high nibble
	ENDC

	addq.w	#4,a4
	dbra	d1,131$

	IFND	AACHIPS
	move.w	(a2),SWOS12c(a6)	;CustomBM Color00
	ENDC
	IFD	AACHIPS
	move.l	(a2),d2
	move.w	d2,SWOS12c+8(a6)
	swap	d2
	move.w	d2,SWOS12c(a6)

	ENDC
	
* d0=border color
138$
	IFND	AACHIPS
	move.w	d0,SWOS2c(a6)	
	move.w	d0,SWOS7b(a6)	
	move.w	d0,SWOS14b(a6)	
	move.w	d0,SWOS22b(a6)	
	ENDC
	IFD	AACHIPS
	move.w	d0,SWOS2c+33*4(a6)		;low nibbles
	move.w	d0,SWOS7b+8(a6)	
	move.w	d0,SWOS14b+8(a6)	
	move.w	d0,SWOS22b+8(a6)	
	swap	d0
	move.w	d0,SWOS2c(a6)		;high nibbles
	move.w	d0,SWOS7b(a6)	
	move.w	d0,SWOS14b(a6)	
	move.w	d0,SWOS22b(a6)	
	ENDC

	move.l	8(sp),d0	;Sprite0
	move.w	d0,SWOS1+4(a6)
	swap	d0
	move.w	d0,SWOS1(a6)

	move.l	4(sp),d0	;Sprite1
	move.w	d0,SWOS1+12(a6)
	swap	d0
	move.w	d0,SWOS1+8(a6)

* Need to return to the correct field of the current coplist (see LATCH)
* The CurrentCopList header will get repeated, so look out for EntrySprites!

	GET.l	TB_CurrentCopList,d0

	IFD	DEBUGDSW
	ISLMBUP
	bne.s	139$
	move.b	#1,dswdebug
139$	tst.b	dswdebug
	beq.s	140$
	move.l	a6,d0			;repeat indefinatly
	ENDC	;DEBUGDSW

140$	move.w	d0,SWOS2+4(a6)
	swap	d0
	move.w	d0,SWOS2(a6)

* fix the vertical window stop later if no bottom write
	IFND	AACHIPS
	move.w	#((262<<8)&$ff00)!(511-256),SWOS2b(a6)
	ENDC
	IFD	AACHIPS
	AAdiwstop	AAwindowStopX,AAwindowStopY
	move.w	#AAvalue,SWOS2b(a6)
	AAdiwhigh	AAwindowStartX,AAwindowStopX,AAwindowStartY,AAwindowStopY
	move.w	#AAvalue,SWOS2b+4(a6)
	ENDC

	XMEA.l	NarrowBMNull,d0
	move.w	d0,SWOS3+4(a6)
	move.w	d0,SWOS8+4(a6)
	move.w	d0,SWOS15+4(a6)
	move.w	d0,SWOS23+4(a6)
	swap	d0
	move.w	d0,SWOS3(A6)
	move.w	d0,SWOS8(a6)
	move.w	d0,SWOS15(a6)
	move.w	d0,SWOS23(a6)

	moveq	#0,d0
	move.w	bm_BytesPerRow(a0),d0
	sub.l	#96,d0			;-4 for 736, 0 for 768 (only 768 on AA chips)
	add.l	d0ptr(sp),d0		;modulo
	move.w	d0,SWOS4(a6)
	move.w	d0,SWOS18(a6)
	move.w	d0,SWOS4+4(a6)
	move.w	d0,SWOS18+4(a6)

	lea	SWOS5(a6),a2
	lea	SWOS19(a6),a3
	move.w	bm_BytesPerRow(a0),d0
	add.l	d0ptr(sp),d0		;modulo
	mulu.w	2(sp),d0		;rows top
	lea	bm_Planes(a0),a4
	moveq	#3,d1
150$	move.l	(a4)+,d2

	IFND	AACHIPS
	subq.l	#4,d2
	ENDC

	move.w	d2,4(a2)
	swap	d2
	move.w	d2,(a2)
	swap	d2
	add.l	d0,d2
	move.w	d2,4(a3)
	swap	d2
	move.w	d2,(a3)
	addq.w	#8,a2
	addq.w	#8,a3
	dbra	d1,150$

;------------- do waits -----------
	move.w	#1,SWOS6(a6)	;wait to 0,0
	move.w	2(sp),d0	;rows top
	add.w	#21+4,d0
	lsl.w	#8,d0
	bcc.s	155$

	IFND	AACHIPS
	move.w	#$ff1f,SWOS6(a6) ;wait to 255,15
	ENDC
	IFD	AACHIPS
	move.w	#$ffdf,SWOS6(a6) ;wait to 255,111
	ENDC

155$	addq.w	#1,d0		;set low order bit
	move.w	d0,SWOS6+4(a6)	;(21+4+DT),0

;;	GET.w	TB_ClipASec,d1
;;	cmpi.w	#128,d1
;;	beq.s	157$
;;	andi.w	#$fc,d1
;;	move.w	d1,SWOS7-2(a6)

;;	GET.w	TB_ClipASec,d1
;;	cmpi.w	#128,d1
;;	beq.s	157$
;;	add.w	d1,d1
;;	or.w	d1,d0
;;	bra.s	158$

157$	ori.w	#19<<1,d0	;must be at least >= 17 after sprite
158$	move.w	d0,SWOS7(a6)	;(21+4+DT),19

	andi.w	#$ff01,d0	;clear horizontal wait
	addi.w	#$0100,d0
	move.w	d0,SWOS9(a6)	;(21+4+DT+1),0

	move.w	#1,SWOS10(a6)	;wait to 0,0
	addi.w	#$0226,d0
	bcc.s	160$
	move.w	#$ffdf,SWOS10(a6) ;wait to 255,111
160$	move.w	d0,SWOS10+4(a6)	;(21+4+DT+3),19

	move.w	#$ffff,SWOS12b(a6) ;wait to 255,127 forever
	move.l	a1,d0
	beq	290$

	move.l	d1ptr(sp),d0	;interfaceTop
	add.w	#21,d0
	subq.w	#1,d0
	lsl.w	#8,d0

	ori.w	#(114*2)+1,d0	;NOTE! Same on both AA & ECS!
	move.w	d0,SWOS12b(a6)	;(21+4+DT+4+ZT-1),114

	andi.w	#$ff01,d0	;clear horizontal position
	add.w	#$0100,d0
	move.w	d0,SWOS13(a6)	;(21+4+DT+4+ZT),0

* What about LORES or HAM???? !!!!!!
	moveq	#0,d1
	move.b	bm_Depth(a1),d1

	IFD	AACHIPS
	cmpi.w	#8,d1
	bne.s	162$
	move.w	#%1000001000010100,d1	;hires, color, lace, 8 planes
	bra.s	163$
	ENDC

162$	ror.w	#4,d1
	ori.w	#%1000001000000100,d1	;hires, color, lace
163$	or.w	TB_BPLCON0orBits(a5),d1 ;modes & 1-4 planes
	move.w	d1,SWOS13b(a6)	;bplcon0

	move.w	#1,SWOS13c(a6)	;wait 0,0
	move.w	bm_Rows(a1),d1
	lsr.w	#1,d1		;only half of the lines
	subq.w	#1,d1		;ptr to last line of interface
	lsl.w	#8,d1
	add.w	d1,d0
	bcc.s	165$
	move.w	#$ffdf,SWOS13c(a6)	;wait to 255,111 (assume < 4 planes)

	IFND	AACHIPS
	cmpi.b	#4,bm_Depth(a1)
	bcs.s	165$			;jump if < 4 planes
	move.w	#$ff1f,SWOS13c(a6)	;wait to 255,15 (4 planes)
	ENDC

165$	move.w	d0,SWOS13c+4(a6)	;(21+4+DT+4+ZT+I-1),0

	ori.w	#109<<1,d0	;horizontal position same for AA & ESC	
	move.w	d0,SWOS14(a6)	;(21+4+DT+4+ZT+I-1),109

	tst.w	(sp)
	bne.s	170$		;jump if some bottom write
	move.w	#$ffff,SWOS16(a6) ;wait to 255,127 forever
	bra	280$
	
170$	move.w	#240+21-4-4,d0
	sub.w	(sp),d0		;bottom rows
	move.w	d0,d1		;save
	lsl.w	#8,d0
	addq.w	#1,d0		;set low order bit
	move.w	d0,SWOS16(a6)	;(21+4+DT+4+ZT+I+ZB),0

	addq.w	#3,d1
	cmpi.w	#$ff,d1
	bls.s	180$
	move.w	#$ffdf,SWOS17(a6) ;wait to 255,111
	andi.w	#$ff,d1
	bra.s	190$
180$	move.w	#1,SWOS17(a6)	;wait to 0,0
190$	move.w	d1,d0
	lsl.w	#8,d0
	ori.w	#$27,d0
	move.w	d0,SWOS17+4(a6)	;(21+4+DT+4+ZT+I+ZB+3),19 	

	andi.w	#$ff01,d0	;clear horizontal position
	add.w	#$0100,d0
	move.w	d0,SWOS20(a6)	;(21+4+DT+4+ZT+I+ZB+4),0

	addq.w	#1,d1
	add.w	(sp),d1		;bottom rows
	cmpi.w	#$ff,d1
	bls.s	200$

	IFND	AACHIPS
	move.w	#$ff1f,SWOS21(a6) ;wait to 255,15
	ENDC
	IFD	AACHIPS
	move.w	#$ffdf,SWOS21(a6) ;wait to 255,111
	ENDC

	andi.w	#$ff,d1
	bra.s	210$
200$	move.w	#1,SWOS21(a6)	;wait to 0,0
210$	move.w	d1,d0
	lsl.w	#8,d1
	addq.w	#1,d1		;set low order bit
	move.w	d1,SWOS21+4(a6)	;(21+4+DT+4+ZT+I+ZB+4+DB-256),0

	ori.w	#$26,d1
	move.w	d1,SWOS22(a6)	;(21+4+DT+4+ZT+I+ZB+4+DB-256),19

	andi.w	#$ff01,d1	;clear horizontal position
	add.w	#$0100,d1
	move.w	d1,SWOS24(a6)	;(21+4+DT+4+ZT+I+ZB+4+DB+1-256),0
;------------------------
	bra.s	285$

* no bottom write, but do have interface
280$	move.l	d1ptr(sp),d0	;interface top
	add.w	#21,d0
	move.w	bm_Rows(a1),d2
	lsr.w	#1,d2		;only half of rows
	add.w	d2,d0		;interface bottom+1

	IFD	AACHIPS
	move.w	d0,d2	;stash vertical stop
	ENDC

	lsl.w	#8,d0
	
	IFND	AACHIPS
	ori.w	#(458-256),d0
	ENDC
	IFD	AACHIPS
	ori.w	#(AAwindowStartX>>2)&$ff,d0
	ENDC

	move.w	d0,SWOS2b(a6)	;diwstop

	IFD	AACHIPS
	andi.w	#$700,d2
	AAdiwhigh	AAwindowStartX,AAwindowStopX,AAwindowStartY,0
	ori.w	#AAvalue,d2
	move.w	d2,SWOS2b+4(a6)	
	ENDC

285$	move.w	bm_BytesPerRow(a1),d2
	lea	bm_Planes(a1),a4

	move.w	d2,d0
	cmpi.w	#768/8,d0
	beq.s	286$
	subq.w	#2,d0	;assume 752
	cmpi.w	#(736/8)-2,d0
	bne.s	286$
	subq.w	#2,d0

286$	move.w	d0,SWOS11(a6)
	move.w	d0,SWOS11+4(a6)

* I am not using the standard InstallField routine because I don't want
* ToastBase to know about this coplist.  This coplist is short term, so
* don't messup TB_CurrentCopList, of TB_CurrentInstallField
	
* no interface or bottom write
290$	CALLTL	AllInterruptsOff
	lea	_custom,a0

	GET.l	TB_CurrentCopList,a2
	GET.l	TB_CurrentFourFieldTBL,a3
	
* It is too risky to install a copper list near the end of a field,
* so I will wait for a safer region.
300$	move.w	vposr(a0),d0
	btst.l	#0,d0	;was it in lower 256 lines of field
	bne.s	300$	;jump if not in safe region

* The following delay makes sure that the current copper list
* is actually executing before I try to install a new coplist.
* And that I am beyond the copper interrupt instruction
* and any coplch move instructions.
310$ 	move.b	vhposr(a0),d0
	cmpi.b	#COPINITDONE,d0	;needs to be after any potential cop1jmps
	bcs.s	310$	;jump if too near field start

	move.w	vposr(a0),d0
	btst.l	#15,d0
	bne.s	320$	;jump if on field II/IV

* NOTE!!! This code assumes that TB_CurrentFourFieldTBL is correct.  Though,
* I don't supply this option with all effects copper lists, just AVE, AVEI,
* WipeI.  And it currently doesn't honor the 4 field nature of this
* table, it just assumes a two field copperlist! Though this could be fixed
* easily enough in the future if needed.

* Field I/III
* show field II = even lines
	move.l	FFTBL_Tbl(a3),d0	;body offset, install field I after
	move.l	a1,d1
	beq.s	330$

	moveq	#0,d3
	move.b	bm_Depth(a1),d3
	subq.w	#1,d3
	lea	SWOS12(a6),a1

315$	move.l	(a4)+,d1

	IFND	AACHIPS
	subq.l	#4,d1
	ENDC

	move.w	d1,4(a1)
	swap	d1
	move.w	d1,(a1)
	addq.w	#8,a1
	dbra	d3,315$

	bra.s	330$

* Field II/IV
* show field I = odd lines
320$	move.l	FFTBL_Tbl+4(a3),d0	;body offset, install field II after
	move.l	a1,d1
	beq.s	330$


	IFND	AACHIPS
	subq.w	#4,d2
	ENDC

	ext.l	d2

	moveq	#0,d3
	move.b	bm_Depth(a1),d3
	subq.w	#1,d3
	lea	SWOS12(a6),a1

325$	move.l	(a4)+,d1
	add.l	d2,d1
	move.w	d1,4(a1)
	swap	d1
	move.w	d1,(a1)
	addq.w	#8,a1
	dbra	d3,325$

; a1->interface, a2->CurrentCopList, a3->CurrentFourFieldTBL, d0=CopListOffset
330$	add.l	a2,d0			;->body
	move.l	FFTBL_Latch(a3),d1 ;latch offset FIX WHEN TWO FIELD COPLIST
	move.w	d0,6(a2,d1.l)
	swap	d0
	move.w	d0,2(a2,d1.l)

	move.l    a6,cop1lc(a0)
	CALLTL	Wait4Top	;previous write may still be in progress	

	IFD	DEBUGDSW
	ISLMBUP
	bne.s	333$
	move.b	#1,dswdebug
333$	tst.b	dswdebug
	beq.s	340$

	LEDON
	tst.w	TB_EffectsBase+EFB_SafeWriteCopLists+DB_Current(a5)
	beq.s	334$	;jump if editable coplist = 0, shown = 1
	LEDOFF

334$	ISRMBUP
	beq.s	336$
	ISLMBUP
	bne.s	334$
335$	ISLMBUP
	beq.s	335$
	bra.s	340$
336$	clr.b	dswdebug
	
	IFD	CRAP
;; This call requires linking with the DumpC.o module. I don't have the
;; source for that code, but an .o file can be found among the 3.1 OBJs.
	CALLTL	AllInterruptsOn
	movem.l	a0/a6,-(sp)
	movea.l	a6,a0	;->coplist
	GET.l	TB_DOSBase,a6
	XCALL	DumpCopperList
	movem.l	(sp)+,a0/a6
	bra.s	341$
	ENDC

	ENDC	;DEBUGDSW

340$	CALLTL	AllInterruptsOn

341$	lea	d0ptr(sp),sp
	movem.l	(sp)+,d0-d6/a0-a4/a6
	rts

	IFD	AACHIPS
;--------------------------------------------------------
* uses d2-d3/a4
fixwritepalette
	GET.w	TB_DoSafeWriteRGB,d2

	moveq	#15-1,d3
	lea	SWOS2c+4(a6),a4
1361$	move.w	d2,(a4)
	addq.w	#4,a4
	dbra	d3,1361$

	move.w	d2,SWOS3a(a6)
	move.w	d2,SWOS17c(a6)

	moveq	#15-1,d3
	lea	SWOS16b(a6),a4
1362$	move.w	d2,(a4)
	addq.w	#4,a4
	dbra	d3,1362$
	rts

;--------------------------------------------------------
* a6->coplist, TRASHES SOME REGISTERS
* uses d2-d3/a3-a4
fixspritepalette:
	lea	NormalSpritePalette(pc),a3
	lea	SWOS2d(a6),a4
	moveq	#16-1,d2
10$	move.l	(a3)+,d3
	move.w	d3,(32+1)*4(a4)	;lower nibbles
	swap	d3
	move.w	d3,(a4)		;upper nibbles
	addq.w	#4,a4
	dbra	d2,10$
	rts
	ENDC

;--------------------------------------------------------
* Fix-up Sprites for write.
* Never have to worry about transparency since I = $ff00
* d2=AM/BM, d4=bank

dswsprchng:

* Headers EH3, EH1, EH2, EH0 (BI Sprite1)
	DEA.l		TB_VTSetUp,a4

;;	ELHSET_BRIDGE	a4	;!!!!!!!!!!
;;	ELHCLEAR_AFR	a4	;!!!!!!!!!!

	moveq		#0,d5

	ELHGET_AM	a4,d3
	cmpi.w		#VTI_AM_ENCODER,d3
	bne.s		91$
	moveq		#1,d5
	bra.s		92$
91$	ELHGET_BM	a4,d3
	cmpi.w		#VTI_BM_ENCODER,d3
	bne.s		92$
	moveq		#1,d5

92$	ELHGET_CDS	a4,d3
	cmpi.w	#VTI_CDS_LUMKEY,d3
	bne.s	79$

* write during standard LumKeying	
	ELHGET_AM	a4,d3
	tst.l		d4	;bank
	bne.s	75$		;jump if writing to bank 1
	
	cmpi.w	#VTI_AM_DAC0,d3
	bne.s	72$
	addq.w	#2,d5
72$	ELHGET_BM	a4,d3
	cmpi.w	#VTI_BM_DAC0,d3
	bra.s	77$

75$	cmpi.w	#VTI_AM_DAC1,d3
	bne.s	76$
	addq.w	#2,d5
76$	ELHGET_BM	a4,d3
	cmpi.w	#VTI_BM_DAC1,d3
77$	bne.s	10$
	addq.w	#4,d5
	bra.s	10$

* writing during non-lumkeying
79$	tst.w		d2
	bne.s		1$	
	ELHGET_AM	a4,d3
	bra.s	2$
1$	ELHGET_BM	a4,d3
	
2$	tst.l		d4	;bank
	bne.s		5$

* writing to bank 0
	tst.w		d2
	bne.s		80$	
	cmpi.w		#VTI_AM_DAC0,d3
	bne.s		3$
	bra.s		81$

80$	cmpi.w		#VTI_BM_DAC0,d3
	bne.s		3$

81$	addq.w		#4+2,d5	

3$	ELHGET_PV	a4,d3
	cmpi.w		#VTI_PV_DAC0,d3
	bne.s		10$	
	addq.w		#8,d5
	bra.s		10$

* writing to bank 1
5$	tst.w		d2
	bne.s		82$	
	cmpi.w		#VTI_AM_DAC1,d3
	bne.s		7$
	bra.s		83$

82$	cmpi.w		#VTI_BM_DAC1,d3
	bne.s		7$

83$	addq.w		#4+2,d5	

7$	ELHGET_PV	a4,d3
	
	cmpi.w		#VTI_PV_DAC1,d3
	bne.s		10$
	addq.w		#8,d5	
		
10$	tst.w	d5
	beq.s	11$		;jump if don't need matte

	btst.l	#0,d5
	bne.s	11$		;jump if can't change matte (being shown)

	ELHGET_MA	a4,d3
	bne.s	11$		;jump if not already black
	
	ELHGET_MB	a4,d3
	bne.s	11$		;jump if not already black

	ELHTEST_NOSNOW	a4
	beq.s	11$		;jump if snow is currently enabled

* already NOSNOW and Black		
	bset.l	#0,d5		;so don't mess with Matte registers

* d5 bit 0=matte is used on Main, so don't change matte to black
*          or don't need to change it to black (already black)
*    bit 1=use matte in Main overscan AM
*    bit 2=use matte in Main overscan BM
*    bit 3=use matte in PV overscan

;----------------------------

11$	move.w	d5,savedswmatteflags	;stash away

	move.l	#$f0000000,d3	;no transparency line number
	move.l	#$f0007000,d6	;do nothing

	tst.w	d5
	beq.s	25$	;jump if don't need matte

	btst.l	#0,d5
	bne	25$	;jump if can't use black matte

	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH3B(a5),d3
	ori.w	#$fe00,d3	;snow unchanged
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH3R(a5),d6
	andi.w	#~VTF_CERB,d6

* EH3 BI, No snow, set MB to black
	ori.w	#$0100,d3	;no snow	
	andi.l	#~((VTF_MB)<<16),d3
* EH3 RG, set MA to black
	andi.w	#~(VTF_MA),d6

25$	move.l	d3,(a2)+
	move.l	d6,(a3)+

;----------------------------
* EH1 BI, no trasparency in sprite, keep termination as is
	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH1B(a5),d3
	ori.w	#$ff00,d3	;probably not necessary
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH1R(a5),d6
	andi.w	#~(VTF_USERON!VTF_CERB),d6

	tst.w	d5
	beq.s	30$	;jump if don't need matte (no change to matte/encoder)

	btst.l	#0,d5
	bne.s	30$	;jump if can't change matte/encoder (being shown)

	ori.l	#VTF_MATTE<<16,d6	

30$	btst.l	#3,d5
	beq.s	35$			;jump if PV is OK during write

* EH1 RG, USERON off, MATTE on, PV to MATTE
	andi.l	#~VTF_PV,d6
	ori.l	#(VTI_PV_ENCODER<<VTB_PV),d6

35$	move.l	d3,(a2)+
	move.l	d6,(a3)+

;----------------------------
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH2R(a5),d6
	andi.l	#~((VTF_AMWIPE<<16)!VTF_ISWIPE!VTF_CERB),d6

	ELHGET_CDS	a4,d3
	cmpi.w	#VTI_CDS_LUMKEY,d3
	bne.s	37$

* lumkey in use
	btst.l	#1,d5
	beq.s	60$
* EH2 RG, set AM to MATTE, no wipe modes, IS as is
	andi.l	#~(VTF_AM<<16),d6
	ori.l	#((VTI_AM_ENCODER<<VTB_AM)<<16),d6

60$	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH2B(a5),d3
	andi.l	#~(VTF_BMWIPE<<16),d3
	ori.w	#$ff00,d3

	btst.l	#2,d5
	beq.s	45$
* EH2 BI, set BM to MATTE, no wipe modes, no transp. in sprite
	move.l	#((VTI_BM_ENCODER<<VTB_BM)<<16)!$ff00,d3
	bra.s	45$

* non lumkey
37$	andi.w	#%110,d5
	bne.s	40$	;jump if need matte during write on main

	tst.w	d2
	beq.s	36$	;jump if AM in write area
	andi.l	#~(VTF_AM<<16),d6
	moveq		#0,d3
	ELHGET_BM	a4,d3
	lsl.w	#VTB_AM,d3
	swap	d3
	or.l	d3,d6

36$	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH2B(a5),d3
	andi.l	#~(VTF_BMWIPE<<16),d3
	ori.w	#$ff00,d3

	tst.w	d2
	bne.s	45$	;jump if BM in write area

	move.l	d6,(a3)+
	andi.l	#~(VTF_BM<<16),d3
	moveq		#0,d6
	ELHGET_AM	a4,d6
	lsl.w	#VTB_BM,d6
	swap	d6
	or.l	d6,d3
	bra.s	46$

* EH2 BI, set BM to MATTE, no wipe modes, no transp. in sprite
40$	move.l	#((VTI_BM_ENCODER<<VTB_BM)<<16)!$ff00,d3
* EH2 RG, set AM to MATTE, no wipe modes, IS as is
	andi.l	#~(VTF_AM<<16),d6
	ori.l	#((VTI_AM_ENCODER<<VTB_AM)<<16),d6

45$	move.l	d6,(a3)+
46$	move.l	d3,(a2)+

;----------------------------


;;	IFD	CRAP
* EH0 BI, BRIDGE off?, S/A Active unchanged, LUST=NOPAIRS set appropriately
	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH0B(a5),d3

;;	andi.l	#~(VTF_BRIDGE<<16),d3
;;	ori.l	#(VTF_SA<<16)!$ff00,d3

	andi.l	#~(VTF_LUT<<16),d3	;LUT
	ori.l	#((VTF_BRIDGE!VTF_SA)<<16)!$f000!VTF_LUST,d3 ;assume no zipper, active write
	btst.l	#0,d7
	beq.s	47$
	andi.w	#~VTF_LUST,d3		;zipper write!
47$	btst.l	#1,d7
	beq.s	48$
	andi.l	#~(VTF_SA<<16),d3	;sync write!
48$	move.l	d3,(a2)+

* WERB (prevents transparency)
* EH0 RG, LKEC LINP ABSE WERB = x101, LINR AFR AFP OBR = 1010
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH0R(a5),d3
	andi.l	#~(((VTF_AFR!VTF_OBR)<<16)!VTF_ABSE!VTF_CERB),d3
	ori.l	#((VTF_LINR!VTF_AFP)<<16)!VTF_LINP!VTF_WERB,d3
	or.l	d4,d3	;bank
	move.l	d3,(a3)+		
;;	ENDC



	IFD	CRAP
* EH1 BI, no trasparency in sprite, keep termination as is
	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH1B(a5),d3
	ori.w	#$ff00,d3	;probably not necessary
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH1R(a5),d6
	andi.w	#~(VTF_USERON!VTF_CERB),d6

	cmpi.w	#1,d5
	bls.s	50$			;jump if don't need matte
	ori.l	#VTF_MATTE<<16,d6	

50$	btst.l	#2,d5
	beq.s	55$			;jump if PV is OK during write

* EH1 RG, USERON off, MATTE on, PV to MATTE
	andi.l	#~VTF_PV,d6
	ori.l	#(VTI_PV_ENCODER<<VTB_PV),d6

55$	move.l	d3,(a2)+
	move.l	d6,(a3)+
	ENDC

	rts

savedswmatteflags	dc.w	0
			ds.w	1	;pad

;--------------------------------------------------------
* restore ELHs
dswsprrest:

* Headers EH0, EH2, EH1, EH3 (BI Sprite1)
	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH0B(a5),d3
	ori.w	#$f000,d3	;intensity of line# on, to prevent transparency
	move.l	d3,(a2)+	:NOPAIRS unchanged

;;	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH1B(a5),d3
;;	ori.w	#$f000,d3	;intensity of line# on, to prevent transparency
;;	move.l	d3,(a2)+

	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH2B(a5),d3
	ori.w	#$f000,d3	;intensity of line# on, to prevent transparency
	move.l	d3,(a2)+
	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH1B(a5),d3
	ori.w	#$f000,d3	;intensity of line# on, to prevent transparency
	move.l	d3,(a2)+

	move.l	#$f0000000,d3	;no transparency line number

	move.w	savedswmatteflags,d0	
	beq.s	10$	;jump if don't need matte

	btst.l	#0,d0
	bne	10$	;jump if can't use black matte

	move.l	TB_VTSetUp+VTSU_BI+SUBI_EH3B(a5),d3
	ori.w	#$f000,d3	;intensity of line# on, to prevent transparency
10$	move.l	d3,(a2)+


* Headers EH0, EH2, EH1, EH3 (RG Sprite0)
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH0R(a5),d3
	andi.l	#~((VTF_OBR<<16)!VTF_CERB),d3	;turn CERB off if it was on
	or.l	d4,d3	;bank, preserve needed bank	
	move.l	d3,(a3)+

;;	move.l	TB_VTSetUp+VTSU_RG+SURG_EH1R(a5),d3
;;	andi.w	#~VTF_CERB,d3	;turn CERB off if it was on
;;	move.l	d3,(a3)+

	move.l	TB_VTSetUp+VTSU_RG+SURG_EH2R(a5),d3
	andi.w	#~VTF_CERB,d3	;turn CERB off if it was on
	move.l	d3,(a3)+
	move.l	TB_VTSetUp+VTSU_RG+SURG_EH1R(a5),d3
	andi.w	#~VTF_CERB,d3	;turn CERB off if it was on
	move.l	d3,(a3)+

	move.l	#$f0007000,d3	;do nothing

	tst.w	d0
	beq.s	25$	;jump if don't need matte

	btst.l	#0,d0
	bne	25$	;jump if can't use black matte

	move.l	TB_VTSetUp+VTSU_RG+SURG_EH3R(a5),d3
	andi.w	#~VTF_CERB,d3	;turn CERB off if it was on
25$	move.l	d3,(a3)+
	rts

tblII	dc.l	$f000d000
	dc.l	$f0009000
	dc.l	$f000f000
	dc.l	$f000b000
tblI	dc.l	$f000c000
	dc.l	$f0008000
	dc.l	$f000e000
	dc.l	$f000a000

	IFND	AACHIPS
defpaletteBW	dc.w	$000,BLANKGRAY,$999,$ddd,BLANKGRAY
defpalette	dc.w	$000,$842,$7bc,$fff,$842
	ENDC

	IFD	AACHIPS

	IFEQ	NUMINTERFACEPLANES-6
defpaletteBW
defpalette
	dc.l	(VTrgb00&$fff0ddf)!$000
	dc.l	(VTrgb01&$fff0ddf)!$200
	dc.l	(VTrgb02&$fff0ddf)!$020
	dc.l	(VTrgb03&$fff0ddf)!$220
	dc.l	(VTrgb04&$fff0ddf)!$000
	dc.l	(VTrgb05&$fff0ddf)!$020
	dc.l	(VTrgb06&$fff0ddf)!$220
	dc.l	(VTrgb07&$fff0ddf)!$200
	dc.l	(VTrgb08&$fff0ddf)!$000
	dc.l	(VTrgb09&$fff0ddf)!$200
	dc.l	(VTrgb10&$fff0ddf)!$020
	dc.l	(VTrgb11&$fff0ddf)!$220
	dc.l	(VTrgb12&$fff0ddf)!$000
	dc.l	(VTrgb13&$fff0ddf)!$020
	dc.l	(VTrgb14&$fff0ddf)!$220
	dc.l	(VTrgb15&$fff0ddf)!$200
	dc.l	(VTrgb16&$fff0ddf)!$000
	dc.l	(VTrgb17&$fff0ddf)!$200
	dc.l	(VTrgb18&$fff0ddf)!$020
	dc.l	(VTrgb19&$fff0ddf)!$220
	dc.l	(VTrgb20&$fff0ddf)!$000
	dc.l	(VTrgb21&$fff0ddf)!$020
	dc.l	(VTrgb22&$fff0ddf)!$220
	dc.l	(VTrgb23&$fff0ddf)!$200
	dc.l	(VTrgb24&$fff0ddf)!$000
	dc.l	(VTrgb25&$fff0ddf)!$200
	dc.l	(VTrgb26&$fff0ddf)!$020
	dc.l	(VTrgb27&$fff0ddf)!$220
	dc.l	(VTrgb28&$fff0ddf)!$000
	dc.l	(VTrgb29&$fff0ddf)!$020
	dc.l	(VTrgb30&$fff0ddf)!$220
	dc.l	(VTrgb31&$fff0ddf)!$200
	dc.l	(VTrgb32&$fff0ddf)!$000
	dc.l	(VTrgb33&$fff0ddf)!$200
	dc.l	(VTrgb34&$fff0ddf)!$020
	dc.l	(VTrgb35&$fff0ddf)!$220
	dc.l	(VTrgb36&$fff0ddf)!$000
	dc.l	(VTrgb37&$fff0ddf)!$020
	dc.l	(VTrgb38&$fff0ddf)!$220
	dc.l	(VTrgb39&$fff0ddf)!$200
	dc.l	(VTrgb40&$fff0ddf)!$000
	dc.l	(VTrgb41&$fff0ddf)!$200
	dc.l	(VTrgb42&$fff0ddf)!$020
	dc.l	(VTrgb43&$fff0ddf)!$220
	dc.l	(VTrgb44&$fff0ddf)!$000
	dc.l	(VTrgb45&$fff0ddf)!$020
	dc.l	(VTrgb46&$fff0ddf)!$220
	dc.l	(VTrgb47&$fff0ddf)!$200
	dc.l	(VTrgb48&$fff0ddf)!$000
	dc.l	(VTrgb49&$fff0ddf)!$200
	dc.l	(VTrgb50&$fff0ddf)!$020
	dc.l	(VTrgb51&$fff0ddf)!$220
	dc.l	(VTrgb52&$fff0ddf)!$000
	dc.l	(VTrgb53&$fff0ddf)!$020
	dc.l	(VTrgb54&$fff0ddf)!$220
	dc.l	(VTrgb55&$fff0ddf)!$200
	dc.l	(VTrgb56&$fff0ddf)!$000
	dc.l	(VTrgb57&$fff0ddf)!$200
	dc.l	(VTrgb58&$fff0ddf)!$020
	dc.l	(VTrgb59&$fff0ddf)!$220
	dc.l	(VTrgb60&$fff0ddf)!$000
	dc.l	(VTrgb61&$fff0ddf)!$020
	dc.l	(VTrgb62&$fff0ddf)!$220
	dc.l	(VTrgb63&$fff0ddf)!$200

	dc.l	(VTrgb01&$fff0ddf)!$200	;color01

	ENDC	;IFEQ NUMINTERFACEPLANES-6

	IFEQ	NUMINTERFACEPLANES-3	
defpaletteBW
defpalette	dc.l	$00000000,$06660200,$09990020,$0ddd0220
		dc.l	$03330000,$05550020,$0cb70220,$0fe70200
		dc.l	$06660200
	ENDC

	IFEQ	NUMINTERFACEPLANES-2	; This was the two bitplane pallete on AA.
defpaletteBW
defpalette	dc.l	$00000000,$06660200,$09990020,$0ddd0220
		dc.l	$06660200
	ENDC

	ENDC	;IFD AACHIPS

****************************************************************
* ~InitSimpleBMCopLists()

	XREF	SBM1,SBM2,SBM3,SBM4,SBM5,SBM6,SBM7,SBM8,SBM9
	XREF	SBM4b,SBM5b,SBM6b,SBM9b,SBM8b

	IFD	AACHIPS
	XREF	SBM1b
	ENDC

	IFD	CCODE
_InitSimpleBMCopLists
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	InitSimpleBMCopLists
	movea.l	(sp)+,a5
	rts
	ENDC	

InitSimpleBMCopLists	movem.l	d0-d1/a0-a3,-(sp)
	XLEA	SimpleBMCopList1,a0
	XLEA	SimpleBMCopList2,a1

	GET.w	TB_BPLCON0orBits,d0
	or.w	d0,SBMBPLCON0_1(a0)
	or.w	d0,SBMBPLCON0_2(a0)
	or.w	d0,SBMBPLCON0_1(a1)
	or.w	d0,SBMBPLCON0_2(a1)
	or.w	d0,SBMBPLCON0_1b(a0)
	or.w	d0,SBMBPLCON0_2b(a0)
	or.w	d0,SBMBPLCON0_1b(a1)
	or.w	d0,SBMBPLCON0_2b(a1)
	
*-------------
* THESE NEED TO BE DETERMINED AT INSTALL TIME
	XMEA	SBMBody1,d0
	move.w	d0,SBM2+4(a0)
	swap	d0
	move.w	d0,SBM2(a0)

	XMEA	SBMBody2,d0
	move.w	d0,SBM2+4(a1)
	swap	d0
	move.w	d0,SBM2(a1)
*-------------

	XMEA	SBMMain1b,d0
	move.w	d0,SBM4+4(a0)
	swap	d0
	move.w	d0,SBM4(a0)

	XMEA	SBMMain1,d0
	move.w	d0,SBM4b+4(a0)
	swap	d0
	move.w	d0,SBM4b(a0)

	XMEA	SBMMain2b,d0
	move.w	d0,SBM4+4(a1)
	swap	d0
	move.w	d0,SBM4(a1)

	XMEA	SBMMain2,d0
	move.w	d0,SBM4b+4(a1)
	swap	d0
	move.w	d0,SBM4b(a1)

	lea	SBM6b(a0),a2	
	lea	SBM6b(a1),a3	
	lea	SBM6(a0),a0	
	lea	SBM6(a1),a1	

	move.l	TB_EffectsBase+EFB_SpriteData(a5),d0
	add.l	#ESD_SpriteNull,d0

	moveq	#5,d1
10$	move.w	d0,4(a0)
	move.w	d0,4(a1)
	move.w	d0,4(a2)
	move.w	d0,4(a3)
	swap	d0
	move.w	d0,(a0)
	move.w	d0,(a1)
	move.w	d0,(a2)
	move.w	d0,(a3)
	swap	d0
	addq.w	#8,a0
	addq.w	#8,a1
	addq.w	#8,a2
	addq.w	#8,a3
	dbra	d1,10$

	movem.l	(sp)+,d0-d1/a0-a3
	rts

****************************************************************
* ~SetUpSimpleBMCopList(->SUSBM struct,TopBMrow,TopCRTrow,#CRTrows,Scroll)
*			 a0		d0	 d1	   d2	      d3
* TopBMrow	= Which row of BM is the top of the effect, a signed value
* TopCRTrow	= Which row of Display is the top of the effect, >= 0, <= 240
* #CRTrows	= # of Display rows to use for the effect, >= 0, <= 241
* Scroll LONG	= On non AA chips = 140ns lowres pixel signed shift amount
*		= On AA chips     = 35ns super hires pixel signed shift amount
*
* On nonAA machines, if TopCRTrow isn't zero, or #CRTrows is less than the
* displays height, then you will need special Sprite Ctrl words to position
* the sprites, or you may get the top or bottom of the sprites cut off, since
* these simple CopLists were unable to display the sprite above or below
* the effect region. Though this could be fixed as in the TwoFieldCopLists.
* Also, this is not a problem on AA machines, since we can display the
* sprite outside the window limits.
*
* The ERSY bit in the ViewModes in the SUSBM structure now determine
* if Color0pixelsw or Bit15pixelsw should be used in BPLCON2.

	XREF	SBMSPR,SBMSPRb

	STRUCTURE	susbmcl,0
		WORD	susbmcl_res
		WORD	susbmcl_ddfstrt
		WORD	susbmcl_ddfstop
		WORD	susbmcl_ossub
		WORD	susbmcl_osasr
		WORD	susbmcl_osadd
		WORD	susbmcl_scsub
		WORD	susbmcl_modulo

* horizontal position to wait to on line 255 when waiting to bottom 6 lines
		IFND	AACHIPS

		WORD	susbmcl_wait0	;zero planes
		WORD	susbmcl_wait1
		WORD	susbmcl_wait2
		WORD	susbmcl_wait3
		WORD	susbmcl_wait4	;four planes

		ENDC


	LABEL	susbmcl_SIZEOF

susbmtbl ;res, ddfstrt, ddfstop, ossub, oslsr, osadd, scsub, modulo, wait0, wait1 wait2 wait3 wait4 	

	IFND	AACHIPS
	 dc.w	768,((71>>1)&$fc),((424>>1)&$fc),1,3,-6,1,0,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(108<<1)!1,(255<<8)!(15<<1)!1
	 dc.w	752,((71>>1)&$fc),((424>>1)&$fc),1,3,-6,1,2,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(108<<1)!1,(255<<8)!(15<<1)!1
	 dc.w	736,((71>>1)&$fc),((424>>1)&$fc),1,3,-6,1,4,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(108<<1)!1,(255<<8)!(15<<1)!1
	 dc.w	384,((63>>1)&$fc),((416>>1)&$fc),9,4,-4,1,0,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1
	 dc.w	368,((71>>1)&$fc),((408>>1)&$fc),1,4,-2,1,0,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1,(255<<8)!(111<<1)!1
	 dc.w	-1	;end of table

NormalSpritePalette
	dc.w	$776,$876,$786,$886,$778,$878,$788,$888
	dc.w	$777,$877,$787,$887,$779,$879,$789,$889

	ENDC	;IFND AACHIPS

	IFD	AACHIPS
	 dc.w	768,(AA768fetchStart>>1)&$fe,(AA768fetchStop>>1)&$fe,68,7,AA768byteOffset-8,4,AA768modulo
	 dc.w	384,(AA384fetchStart>>1)&$fe,(AA384fetchStop>>1)&$fe,196,8,AA384byteOffset-8,132,AA384modulo
	 dc.w	-1	;end of table

	CNOP	0,4

NormalSpritePalette	;Hardware Palette (vs Software)
	dc.l	$00000000	  ;transparent!
	dc.l	$00000600
	dc.l	$00000024
	dc.l	$00000624
	dc.l	$00000101
	dc.l	$00000701
	dc.l	$00000125
	dc.l	$00000725
	dc.l	$00000012
	dc.l	$00000612
	dc.l	$00000036
	dc.l	$00000636
	dc.l	$00000113
	dc.l	$00000713
	dc.l	$00000137
	dc.l	$00000737

* G0/B1 and R0/B0 bits are complemented to work with complemented Sprite1
* This is necessary because color 0 of BitMap is shown when the
* sprites are transparent. Color 0 has this bits high.
ComplementedSpritePalette	;Hardware Palette (vs Software)
	dc.l	%000100010011 ;color16 G0/B1=1 R0/B0=1 B2/G1=0 R2/R1=0 ;transparent
	dc.l	%011100010011 ;color17 G0/B1=1 R0/B0=1 B2/G1=0 R2/R1=1
	dc.l	%000100110111 ;color18 G0/B1=1 R0/B0=1 B2/G1=1 R2/R1=0
	dc.l	%011100110111 ;color19 G0/B1=1 R0/B0=1 B2/G1=1 R2/R1=1
	dc.l	%000000010010 ;color20 G0/B1=1 R0/B0=0 B2/G1=0 R2/R1=0
	dc.l	%011000010010 ;color21 G0/B1=1 R0/B0=0 B2/G1=0 R2/R1=1
	dc.l	%000000110110 ;color22 G0/B1=1 R0/B0=0 B2/G1=1 R2/R1=0
	dc.l	%011000110110 ;color23 G0/B1=1 R0/B0=0 B2/G1=1 R2/R1=1
	dc.l	%000100000001 ;color24 G0/B1=0 R0/B0=1 B2/G1=0 R2/R1=0
	dc.l	%011100000001 ;color25 G0/B1=0 R0/B0=1 B2/G1=0 R2/R1=1
	dc.l	%000100100101 ;color26 G0/B1=0 R0/B0=1 B2/G1=1 R2/R1=0
	dc.l	%011100100101 ;color27 G0/B1=0 R0/B0=1 B2/G1=1 R2/R1=1
	dc.l	%000000000000 ;color28 G0/B1=0 R0/B0=0 B2/G1=0 R2/R1=0
	dc.l	%011000000000 ;color29 G0/B1=0 R0/B0=0 B2/G1=0 R2/R1=1
	dc.l	%000000100100 ;color30 G0/B1=0 R0/B0=0 B2/G1=1 R2/R1=0
	dc.l	%011000100100 ;color31 G0/B1=0 R0/B0=0 B2/G1=1 R2/R1=1

	ENDC	;IFD AACHIPS

*---------------------------------------------------
******************************************************************
* SetUpSimpleBMCopList(->SUSBM struct,TopBMrow,TopCRTrow,#CRTrows,Scroll,diwstopX.diwstrtX,diwstopY.diwstrtY)
*			 a0		d0	 d1	   d2	    d3         d4               d5
* see above for explaination of these parameters
* Same as SetUpSimpleBMCopList with additional d4/d5 parameters.
* The window parameters only function on AA machines.
* d4=diwstopX.diwstrtX d5=diwstopY.diwstrtY
* 
SetupSBMCopListAA	movem.l	d0-d7/a1-a4/a6,-(sp)
	bra.s	susbmclstrt

******************************************************************
* SetUpSimpleBMCopList(->SUSBM struct,TopBMrow,TopCRTrow,#CRTrows,Scroll)
*			 a0		d0	 d1	   d2	      d3
* see above for explaination of these parameters
******************************************************************
	XREF	SSBMintreq1,SSBMintreq2,SSBMintreq3

SetUpSimpleBMCopList	movem.l	d0-d7/a1-a4/a6,-(sp) ;see above!!!!

	IFD	AACHIPS
* When not doing custom window cropping (see SetupSBMCopListAA), we will
* open up the window as large as the display can stand.  We position the
* BM vertically by setting BPLCON0 to BM depth at the start of the desired
* destination row.

	move.l	#(AAwindowStopX<<16)!AAwindowStartX,d4
	move.l	#(AAwindowStopY<<16)!AAwindowStartY,d5
	ENDC

susbmclstrt:

;;	DUMPREG <startof susbmcl, a0, d0-d3,d4-d5>
;;	DUMPMEM	 <SUSBM>,0(a0),#SUSBM_SIZEOF

	lea	susbmtbl(pc),a4
	move.w	SUSBM_CRTwidth(a0),d6

5$	move.w	(a4),d7
	bmi	666$		;error !!! Not a known resolution	
	cmp.w	d7,d6
	beq.s	6$
	lea	susbmcl_SIZEOF(a4),a4
	bra.s	5$

* a4->susbmtbl data
6$	movea.l	SUSBM_DBCopLists(a0),a1
	GETCURRENT	a1
		
	GET.w	TB_CopListIntreq,d6
	move.w	d6,SSBMintreq1(a1)
	move.w	d6,SSBMintreq2(a1)
	move.w	d6,SSBMintreq3(a1)

*---------------------------

	IFD	AACHIPS
* d4=stopX.strtX d5=stopY.strtY
* calculate diwstrt	
* (((strtY<<8)&$ff00)!((strtX>>2)&$ff))	
	move.w	d5,d6
	lsl.w	#8,d6
	move.w	d4,d7
	lsr.w	#2,d7
	andi.w	#$ff,d7
	or.w	d7,d6
	move.w	d6,SBM1b(a1)

* calculate diwstop	
* (((stopY<<8)&$ff00)!((stopX>>2)&$ff))	
	swap	d4
	swap	d5
	move.w	d5,d6
	lsl.w	#8,d6
	move.w	d4,d7
	lsr.w	#2,d7
	andi.w	#$ff,d7
	or.w	d7,d6
	move.w	d6,SBM1b+4(a1)
	
* d4=strtX.stopX d5=strtY.stopY
* calculate diwhigh	
* ((strtY>>8)&$7)!
* ((stopY<<0)&$700)!
* ((strtX>>5)&$20)!
* ((strtX<<3)&$18)!
* ((stopX<<3)&$2000)!
* ((stopX<<11)&$1800)

	move.w	d5,d6
	andi.w	#$700,d6
	move.w	d4,d7
	lsl.w	#3,d7
	andi.w	#$2000,d7
	or.w	d7,d6
	move.w	d4,d7
	ror.w	#5,d7		;lsl #11
	andi.w	#$1800,d7
	or.w	d7,d6
	swap	d4
	swap	d5
	lsr.w	#8,d5
	andi.w	#$7,d5
	or.w	d5,d6
	move.w	d4,d5
	lsr.w	#5,d5
	andi.w	#$20,d5
	or.w	d5,d6
	lsl.w	#3,d4
	andi.w	#$18,d4
	or.w	d4,d6
	move.w	d6,SBM1b+8(a1)
	ENDC

*---------------------------

	movea.l	SUSBM_DBSprite0E(a0),a2
	GETCURRENT	a2
	move.l	a2,d4
	move.l	#SPRITE0CTRL241,(a2) ;on nonAA Amigas it's BOGUS IF d1 != 0 !!!!!
	move.w	d4,SBM1+4(a1)
	swap	d4
	move.w	d4,SBM1(a1)

	movea.l	SUSBM_DBSprite1E(a0),a2
	GETCURRENT	a2
	move.l	a2,d4
	move.l	#SPRITE1CTRL241,(a2) ;on nonAA Amigas it's BOGUS IF d1 != 0 !!!!!
	move.w	d4,SBM1+12(a1)
	swap	d4
	move.w	d4,SBM1+8(a1)

	movea.l	SUSBM_DBSprite0R(a0),a2
	GETCURRENT	a2
	move.l	a2,d4
	move.l	#SPRITE0CTRL241,(a2) ;on nonAA Amigas it's BOGUS IF d1 != 0 !!!!!
	move.w	d4,6+SBMSPR(a1)
	move.w	d4,6+SBMSPRb(a1)
	swap	d4
	move.w	d4,2+SBMSPR(a1)
	move.w	d4,2+SBMSPRb(a1)

	movea.l	SUSBM_DBSprite1R(a0),a2
	GETCURRENT	a2
	move.l	a2,d4
	move.l	#SPRITE1CTRL241,(a2) ;on nonAA Amigas it's BOGUS IF d1 != 0 !!!!!
	move.w	d4,14+SBMSPR(a1)
	move.w	d4,14+SBMSPRb(a1)
	swap	d4
	move.w	d4,10+SBMSPR(a1)
	move.w	d4,10+SBMSPRb(a1)
	
*---------------
	move.w	#V_HAM,d5
	and.w	SUSBM_ViewModes(a0),d5
	beq.s	90$		;jump if not HAM
	
	moveq	#16,d4		;assume 6 bit HAM palette
	
	IFD	AACHIPS
	   cmpi.w	#6,SUSBM_Depth(a0)
	   beq.s	8$
	   moveq	#64,d4		;must be 8 bit HAM
	ENDC	

	bra.s	8$	

90$
	IFND	AACHIPS
* NOTE!! EXTRA_HALFBRITE IS NOT A GOOD MODE ON THE AA CHIP SET.  USE
* A STANDARD NON-HALFBRITE MODE WITH A STANDARD SIZE PALETTE!!!
	   moveq	#32,d4	;assume EHB palette
	   move.w	#V_EXTRA_HALFBRITE,d5	;will mess up sprite palette!!!
	   and.w	SUSBM_ViewModes(a0),d5
	   bne.s	9$
	ENDC

	moveq	#1,d4
	move.w	SUSBM_Depth(a0),d5  ;5 planes will mess up sprite palette!!!!!
	lsl.w	d5,d4

	IFND	AACHIPS
	   cmpi.w	#16,d4
	ENDC
	IFD	AACHIPS
	   cmpi.w	#240,d4
	ENDC
	   bhi.s	9$

* make sure the sprite colors or O.K.
	IFND	AACHIPS
8$	lea	NormalSpritePalette(pc),a2
	lea	SBM3(a1),a3
	moveq	#16-1,d5
11$	move.w	(a2)+,(a3)
	addq.w	#4,a3
	dbra	d5,11$

9$	move.l	SUSBM_ColorMap(a0),d5
	beq.s	21$		;don't blow up if no ColorMap
	movea.l	d5,a2
	lea	SBM7(a1),a3
	bra.s	20$

10$	move.w	(a2)+,(a3)
	addq.w	#4,a3
20$	dbra	d4,10$
	ENDC

	IFD	AACHIPS

8$	lea	NormalSpritePalette(pc),a2
	tst.w	CompRSLPalFlag	;HACK only known to ReadScanLine routine!
	beq.s	999$	
	move.w	#0,CompRSLPalFlag	;only good for one SBM call
	lea	ComplementedSpritePalette(pc),a2	

999$	lea	SBM3(a1),a3
	moveq	#16-1,d5
11$	move.l	(a2)+,d6
	move.w	d6,(32+1)*4(a3)	;lower nibbles
	swap	d6
	move.w	d6,(a3)		;upper nibbles
	addq.w	#4,a3
	dbra	d5,11$

9$	move.l	SUSBM_ColorMap(a0),d5
	beq.s	21$		;don't blow up if no ColorMap
	movea.l	d5,a2
	lea	SBM7(a1),a3
	bra.s	25$

10$	move.l	(a2)+,d6
	move.w	d6,(32+1)*4(a3)	;lower nibbles
	swap	d6
	move.w	d6,(a3)		;upper nibbles

	addq.w	#4,a3
	subq.w	#1,d5
	bne.s	20$
	lea	(32+2)*4(a3),a3	;skip over bplcon3 moves & upper nibbles
25$	moveq	#32,d5
20$	dbra	d4,10$

	ENDC	

*-------------------------------------------------
* The amount to add to the planeptrs = HorzOffset
* The nibble to stuff into the scroll register BPLCON1 = ScrollNibble
* The requested Scroll amount = Scroll
* HorzOffset and ScrollNibble are functions of Scroll and BM resolution.
* I use the following equations:
* 
* BMres   HorzOffset = osadd - [(Scroll-ossub)>>osasr]*fetch
*
* AA768		     = -8 - [(Scroll-68)>>7]*8   ;ossub was 64 ??
* AA384		     = -8 - [(Scroll-196)>>8]*8  ;ossub was 225 ??
*
* ECS
*  768	             = -6 - [(Scroll-1)>>3]*2
*  752	             = -6 - [(Scroll-1)>>3]*2
*  736	             = -6 - [(Scroll-1)>>3]*2
*  384	             = -4 - [(Scroll-9)>>4]*2
*  368	             = -2 - [(Scroll-1)>>4]*2
*
*  	ScrollNibble = [(1<<osasr)-1] & (Scroll-scsub)
*
* AA768		     = [(1<<7)-1] & (Scroll-4) 
* AA384		     = [(1<<8)-1] & (Scroll-132) 
*
* ECS
*  768		     = [(1<<3)-1] & (Scroll-1)
*  752		     = [(1<<3)-1] & (Scroll-1)
*  736		     = [(1<<3)-1] & (Scroll-1)
*  384		     = [(1<<4)-1] & (Scroll-1)
*  368		     = [(1<<4)-1] & (Scroll-1)
*
* After I coded this, I decided to Negate the supplied Scroll value.
* If you use a non-negated scroll in the above equations, a positive
* scroll will move the bm right.  Though, with the currently negated
* scroll, a positive scroll will move the bm left, so we can look farther
* to the right.
	
21$	moveq	#1,d5
	move.w	susbmcl_osasr(a4),d6

	ext.l	d6
	lsl.w	d6,d5
	subq.w	#1,d5

	neg.l	d3	;I want positive scroll to move the BM left!!!!

;;	DUMPSDEC.l	<is=>,d3,< >

	move.w	d3,d4
	sub.w	susbmcl_scsub(a4),d4	;all ECS bitmaps need a scroll of 15 or 7 for 0 position
					;AA bitmaps require $7C
	and.w	d5,d4	;scroll nibble (byte on AA chips)

;;	DUMPUDEC.w	<sn=>,d4,<>
;;	DUMPHEXI.w	</>,d4,< >

	IFND	AACHIPS
	   move.w	d4,d5
	   lsl.w	#4,d4
	   or.w		d5,d4
	ENDC

	IFD	AACHIPS
* GET AA CHIP BPLCON1 SCROLL VALUE
* NOTE! I bet this could be optimized a bit
	   move.w	d4,d5
	   lsr.w	#4,d5	;put h6 & h7 in bits 2 & 3
	   lsr.w	#1,d4	   		  
	   roxr.w	#1,d5	;bit 0
	   lsr.w	#1,d4	;h2/3/4/5 ok   		  
	   roxr.w	#1,d5	;bit 1 (h6/7 now in bits 0/1, h0/1 in bits 6/7 
	   rol.w	#6,d5
	   lsl.w	#4,d5
	   andi.w	#$f00,d5	;h7/6/1/0 ok
	   andi.w	#$00f,d4	;killed old h6/7
	   or.w		d5,d4
	   move.w	d4,d5
	   lsl.w	#4,d5
	   or.w		d5,d4
	ENDC
	   
;;	DUMPHEXI.w	<b1=>,d4,< >
	move.w	d4,SBM8(a1)	;scroll

	move.w	susbmcl_ossub(a4),d4
	ext.l	d4
	sub.l	d4,d3

	asr.l	d6,d3
	add.l	d3,d3

	IFD	AACHIPS
	add.l	d3,d3
	add.l	d3,d3
	ENDC

	move.w	susbmcl_osadd(a4),d4

	ext.l	d4
	sub.l	d3,d4	;hor offset

;;	DUMPSDEC.l	<ho=>,d4,< >

	move.w	SUSBM_BMwidth(a0),d3
	lsr.w	#3,d3
	tst.w	SUSBM_Modulo(a0)  ;assume negative modulo = repeat line!!!
	blt.s	29$
	add.w	SUSBM_Modulo(a0),d3

* The Modulo is typically zero on non-interlaced data.
* It is typically equal to the SUSBM_BMwidth/8 on interlaced data.


29$
;;	DUMPSDEC.w	<bpr=>,d3,< >
;;	DUMPSDEC.w	<rows=>,d0,< >

	muls.w	d3,d0
	
;;	DUMPSDEC.l	<hor=>,d0,< >
;;	DUMPSDEC.l	<vert=>,d4,< >

	add.l	d4,d0		;vert+hor offset

	

*----------------------------------------------------
;;	DUMPSDEC.l	<vh=>,d0,<\>

	lea	SUSBM_DBPlanes(a0),a2
	GETCURRENT a2
	lea	SBM5(a1),a3		;field I (1 line down)
	lea	SBM5b(a1),a6		;field II 

	move.w	SUSBM_Modulo(a0),d5
	ext.l	d5
	bpl.s	32$
	moveq	#0,d5		;not really interlaced if negative modulo	

32$	move.w	SUSBM_Depth(a0),d3
	bra	40$

30$	move.l	(a2)+,d4		;plane0 of preset0

;;	DUMPHEXI.l	<ptr1=>,d4,< >

	add.l	d0,d4

;;	DUMPHEXI.l	<ptr2=>,d4,<\>

	move.w	d4,4(a6)	;Field II
	swap	d4
	move.w	d4,(a6)
	swap	d4
	
	add.l	d5,d4		;add on modulo for 2nd field
	move.w	d4,4(a3)	;Field I
	swap	d4
	move.w	d4,(a3)

	addq.w	#8,a3
	addq.w	#8,a6

40$	dbra	d3,30$
	
	move.w	SUSBM_BMwidth(a0),d0
	sub.w	SUSBM_CRTwidth(a0),d0
	asr.w	#3,d0
	add.w	SUSBM_Modulo(a0),d0
	sub.w	susbmcl_modulo(a4),d0

	move.w	d0,SBM8+4(a1)	;modulo
	move.w	d0,SBM8+8(a1)	;modulo

	move.w	susbmcl_ddfstrt(a4),SBM8+12(a1)	;ddfstrt
	move.w	susbmcl_ddfstop(a4),SBM8+16(a1)	;ddfstop
	
	move.w	TB_BPLCON0orBits(a5),d0

	cmpi.w	#512,SUSBM_CRTwidth(a0)
	blt.s	60$	;jump if lores
	bset	#15,d0	;hires
60$	move.w	SUSBM_Depth(a0),d3

	IFD	AACHIPS
	   bset		#0,d0	;enable special bplcon3 bits		

	   cmpi.w	#8,d3
	   bne.s	62$
	   bset		#4,d0	;8 planes
	   bra.s	63$
	ENDC

62$	ror.w	#4,d3
	or.w	d3,d0		;depth
	
63$	move.w	SUSBM_ViewModes(a0),d3

	bclr	#2,SBM8b(a1)		;clear ZDCTEN
	btst.l	#GENLOCK_VIDEO,d3
	bne.s	64$			;jump if want color 0 pixelsw
	bset	#2,SBM8b(a1)		;set ZDCTEN = Bit15 pixelsw

64$	andi.w	#V_HAM!V_EXTRA_HALFBRITE,d3
	or.w	d3,d0		;modes
	move.w	d0,SBM9+10(a1)	;bplcon0
	move.w	d0,SBM9b+10(a1)	;bplcon0
	
	IFND	AACHIPS
	   move.w	SUSBM_Depth(a0),d3
	   add.w	d3,d3
	   move.w	susbmcl_wait0(a4,d3.w),d3
	ENDC

	IFD	AACHIPS
	   move.w	#$ffdf,d3 ;all depths and resolutions
	ENDC

	add.w	#21,d1
	move.w	d1,d0
	move.w	#1,SBM9(a1)	;wait to 0,0
	move.w	#1,SBM9b(a1)	;wait to 0,0
	lsl.w	#8,d0
	bcc.s	70$
	move.w	d3,SBM9(a1) ;wait to 255,111
	move.w	d3,SBM9b(a1) ;wait to 255,111
70$	addq.w	#1,d0		;set low order bit
	move.w	d0,SBM9+4(a1)	;(21+Top),0
	move.w	d0,SBM9b+4(a1)	;(21+Top),0

	move.w	#1,SBM9+12(a1)	;wait to 0,0
	move.w	#1,SBM9b+12(a1)	;wait to 0,0
	add.w	d2,d1
	lsl.w	#8,d1
	bcc.s	80$
	move.w	d3,SBM9+12(a1) ;wait to 255,111
	move.w	d3,SBM9b+12(a1) ;wait to 255,111
80$	addq.w	#1,d1		;set low order bit
	move.w	d1,SBM9+16(a1)	;(21+EFFECT),0
	move.w	d1,SBM9b+16(a1)	;(21+EFFECT),0
	
666$	movem.l	(sp)+,d0-d7/a1-a4/a6
	rts

************************************************************************
* ~Init2FI(->TB)
*		    a5

	XREF	TwoFieldInterface1,TwoFieldInterface2
	XREF	TFOS1,TFOS2,TFOS3
	XREF	TFOS1I,TFOS2I,TFOS3I,TFOS4I
	XREF	TFOS5I,TFOS6I,TFOS7I,TFOS8I
	XREF	TFOS9I,TFOS10I,TFOS11I,TFOS12I
	XREF	TFOS13I,TFOS14I,TFOS15I,TFOS16I
	XREF	TFOS17I,TFOS18I
	XREF	TFOS1II,TFOS2II,TFOS3II,TFOS4II
	XREF	TFOS5II,TFOS6II,TFOS7II,TFOS8II
	XREF	TFOS9II,TFOS10II,TFOS11II,TFOS12II
	XREF	TFOS13II,TFOS14II,TFOS15II,TFOS16II
	XREF	TFOS17II,TFOS18II

	IFD	AACHIPS
	XREF	TFOS3Ib
	ENDC

	IFD	CCODE
_Init2FI
	move.l	a5,-(sp)
	movea.l	8(sp),a5
	bsr.s	Init2FI
	movea.l	(sp)+,a5
	rts
	ENDC	

Init2FI movem.l	d0-d1/a0-a1,-(sp)
	GET.w	TB_BPLCON0orBits,d0
	lea	TwoFieldInterface1,a0
	bsr.s	100$
	
	lea	TwoFieldInterface2,a0
	bsr.s	100$

	movem.l	(sp)+,d0-d1/a0-a1
	rts

;------------
100$	move.w	d0,-(sp)
	or.w	d0,TFBPLCON0_1(a0)
	or.w	d0,TFBPLCON0_2(a0)
	or.w	d0,TFBPLCON0_3(a0)
	or.w	d0,TFBPLCON0_4(a0)
	or.w	d0,TFBPLCON0_5(a0)
	or.w	d0,TFBPLCON0_6(a0)
	or.w	d0,TFBPLCON0_7(a0)
	or.w	d0,TFBPLCON0_8(a0)

;link field I and II cop1jmps
	lea	TFOS1II(a0),a1
	move.l	a1,d0		;->II
	move.w	d0,TFOS3I+4(a0)
	swap	d0
	move.w	d0,TFOS3I(a0)

	lea	TFOS1I(a0),a1
	move.l	a1,d0		;->I
	move.w	d0,TFOS3II+4(a0)
	swap	d0
	move.w	d0,TFOS3II(a0)

;fix up null plane ptrs
	XMEA.l	NarrowBMNull,d0
	move.w	d0,TFOS6I+4(a0)
	move.w	d0,TFOS6II+4(a0)
	move.w	d0,TFOS17I+4(a0)
	move.w	d0,TFOS17II+4(a0)
	swap	d0
	move.w	d0,TFOS6I(a0)
	move.w	d0,TFOS6II(a0)
	move.w	d0,TFOS17I(a0)
	move.w	d0,TFOS17II(a0)

;nullify sprites
	move.l	TB_EffectsBase+EFB_SpriteData(a5),d1
	add.l	#ESD_SpriteNull,d1	
	lea	TFOS4II(a0),a1	;->spr2pth
	lea	TFOS4I(a0),a0
	moveq	#5,d0
10$	move.w	d1,4(a0)
	move.w	d1,4(a1)
	swap	d1
	move.w	d1,(a0)
	move.w	d1,(a1)
	swap	d1
	addq.w	#8,a0
	addq.w	#8,a1
	dbra	d0,10$

	move.w	(sp)+,d0
	rts

****************************************************************
* ~SetUp2FI(->SUAVE struct,->CustomBM, ->Palette, ->TB, CustomBMTop)
*              a0              a1         a2       a5       d0

SetUp2FI	movem.l	d0-d4/a1-a4/a6,-(sp)
	movea.l	SUAVE_DBCopLists(a0),a6
	GETCURRENT	a6
		
;-------------------------------------------
* do wait stuff
	move.w	#$ffff,TFOS7I(a6)  ; Assume no interface
	move.w	#$ffff,TFOS7II(a6) ; wait to 255,127 forever
	
	move.l	a1,d1
	beq	100$		;jmp if no interface given

* interface given
* if the BMTop is at 0, then the following 2 waits will occur on line 20
	move.w	#1,TFOS7I(a6)		;wait to 0,0
	move.w	#1,TFOS7II(a6)		;wait to 0,0
	add.w	#20,d0
	lsl.w	#8,d0
	bcc.s	10$
	move.w	#$ffdf,TFOS7I(a6)	;wait to 255,111 (0 or 1 planes)
	move.w	#$ffdf,TFOS7II(a6)	;wait to 255,111
10$	ori.w	#(19*2)+1,d0	;must be at least >= 19 = after sprite
	move.w	d0,TFOS7I+4(a6)		;(21+ZT-1),19
	move.w	d0,TFOS7II+4(a6)	;(21+ZT-1),19

	andi.w	#$ff01,d0		;clear horizontal position
	ori.w	#(112*2),d0

	move.w	d0,TFOS10I(a6)		;(21+ZT-1),112
	move.w	d0,TFOS10II(a6)		;(21+ZT-1),112

	move.w	#1,TFOS12I(a6)		;wait to 0,0
	move.w	#1,TFOS12II(a6)		;wait to 0,0
	andi.w	#$ff01,d0		;clear horizontal position
	add.w	#$0100,d0		;(21+ZT),0
	bcc.s	20$
	move.w	#$ffdf,TFOS12I(a6)	;wait to 255,111 (1 plane)
	move.w	#$ffdf,TFOS12II(a6)	;wait to 255,111
20$	move.w	d0,TFOS12I+4(a6)	;(21+ZT),0
	move.w	d0,TFOS12II+4(a6)	;(21+ZT),0

	move.w	#1,TFOS14I(a6)		;wait to 0,0
	move.w	#1,TFOS14II(a6)		;wait to 0,0
	sub.w	#$0100,d0		;(21+ZT-1),0
	move.w	bm_Rows(a1),d1
	lsr.w	#1,d1			;de-interlace
	lsl.w	#8,d1
	add.w	d1,d0
	bcc.s	30$
	move.w	#$ffdf,TFOS14I(a6)	;wait to 255,111 (assume < 4 planes)
	move.w	#$ffdf,TFOS14II(a6)	;wait to 255,111
	cmpi.b	#4,bm_Depth(a1)

	IFND	AACHIPS
	bcs.s	30$			;jump if < 4 planes
	move.w	#$ff1f,TFOS14I(a6)	;wait to 255,15 (4 planes)
	move.w	#$ff1f,TFOS14II(a6)	;wait to 255,15
	ENDC

30$	move.w	d0,TFOS14I+4(a6)	;(21+ZT+I-1),0
	move.w	d0,TFOS14II+4(a6)	;(21+ZT+I-1),0


	ori.w	#(109*2),d0
	move.w	d0,TFOS15I(a6)		;(21+ZT+I-1),109
	move.w	d0,TFOS15II(a6)		;(21+ZT+I-1),109

	move.w	#1,TFOS18I(a6)		;wait to 0,0
	move.w	#1,TFOS18II(a6)		;wait to 0,0
	andi.w	#$ff01,d0		;clear horizontal position
	add.w	#$0100,d0		;(21+ZT+I),0
	bcc.s	40$
	move.w	#$ffdf,TFOS18I(a6)	;wait to 255,111 (0 planes)
	move.w	#$ffdf,TFOS18II(a6)	;wait to 255,111
40$	move.w	d0,TFOS18I+4(a6)	;(21+ZT+I),0
	move.w	d0,TFOS18II+4(a6)	;(21+ZT+I),0

;-------------------------------------------
* do palette stuff
100$
	IFND	AACHIPS
	move.w	#$842,d0	;=assume default vertical border color
	ENDC
	IFD	AACHIPS
;;	move.l	#$05550000,d0
	move.l	#BLANKGRAYHW,d0
	ENDC

	move.l	a2,d1		;->palette
	bne.s	133$		;jmp if palette given		

* no palette given
	move.l	a1,d1
	beq	138$		;jmp no palette, no interface given

* no palette given, but do have interface
	lea	defpalette(pc),a2 ;standard palette (assume 2 monitor)
	tst.w	TB_UserOn(a5)
	bne.s	133$
	lea	defpaletteBW(pc),a2	;B/W palette

* palette supplied (may or may not have interface)
133$
	IFND	AACHIPS
	move.w	(a2),d0
	ENDC
	IFD	AACHIPS
	move.l	(a2),d0
	ENDC

	move.l	a1,d1
	beq.s	138$		;jmp if palette given, but no interface given
	
* Interface & palette both supplied
	moveq	#0,d1
	move.b	bm_Depth(a1),d1
	moveq	#1,d0
	lsl.w	d1,d0

	move.w	d0,d1
	add.w	d0,d0

	IFND	AACHIPS
	move.w	0(a2,d0.w),d0	;vertical overscan border color
	ENDC

	IFD	AACHIPS
	add.w	d0,d0
	move.l	0(a2,d0.w),d0
	ENDC

	subq.w	#2,d1
	
* a2->palette, d1=#colors-1 for colors 1 thru x

	IFND	AACHIPS
	move.w	(a2),TFOS11I(a6)	;CustomBM Color00
	move.w	(a2)+,TFOS11II(a6)	;CustomBM Color00

	lea	TFOS3(a6),a3		
131$	move.w	(a2)+,(a3)
	addq.w	#4,a3
	dbra	d1,131$
	ENDC

	IFD	AACHIPS
	move.l	(a2)+,d2
	move.w	d2,TFOS11I+8(a6)
	move.w	d2,TFOS11II+8(a6)
	swap	d2
	move.w	d2,TFOS11I(a6)
	move.w	d2,TFOS11II(a6)

	cmpi.w	#240-2,d1
	bhi.s	329$	;jump if palette disrupted

	lea	TFOS3Ib(a6),a3	;color 240
	lea	NormalSpritePalette(pc),a4
	moveq	#16-1,d2
321$	move.l	(a4)+,d3
	move.w	d3,(32+1)*4(a3)	;lower nibbles
	swap	d3
	move.w	d3,(a3)		;upper nibbles
	addq.w	#4,a3
	dbra	d2,321$

* don't bother fixing sprite colors
329$	lea	TFOS3(a6),a3
	moveq	#31,d2
	move.w	#(31+1)*4,d4
322$	move.l	(a2)+,d3
	move.w	d3,0(a3,d4.w)	;lower nibbles
	swap	d3
	move.w	d3,(a3)		;upper nibbles

	addq.w	#4,a3
	subq.w	#1,d2
	bne.s	320$
	lea	4(a3,d4.w),a3	;skip over bplcon3 moves & upper nibbles
	moveq	#32,d2
	move.w	#(32+1)*4,d4
320$	dbra	d1,322$

	ENDC

* no palette & no interface jumps here
138$
	IFD	AACHIPS
	move.w	d0,TFOS5I+8(a6)
	move.w	d0,TFOS5II+8(a6)	
	move.w	d0,TFOS16I+8(a6)	
	move.w	d0,TFOS16II+8(a6)	
	swap	d0
	ENDC

	move.w	d0,TFOS5I(a6)	
	move.w	d0,TFOS5II(a6)	
	move.w	d0,TFOS16I(a6)	
	move.w	d0,TFOS16II(a6)	

;-------------------------------------------
* do bm size/depth/modulos stuff
	move.l	a1,d0
	beq.s	200$		;jmp if no interface given

	moveq	#0,d1
	move.b	bm_Depth(a1),d1

	IFD	AACHIPS
	cmpi.w	#8,d1
	bne.s	11$
	moveq	#1<<4,d2	;8 planes
	bra.s	12$
	ENDC

11$	move.w	d1,d2
	ror.w	#4,d2

12$	bset	#15,d2	;set HIRES bit
	or.w	TB_BPLCON0orBits(a5),d2  ;modes & 1-4 planes
	
	move.w	d2,TFOS13I(a6)
	move.w	d2,TFOS13II(a6)

	move.w	bm_BytesPerRow(a1),d2
	ext.l	d2
	
	move.w	d2,d0
	cmpi.w	#768/8,d0
	beq.s	140$
	subq.w	#2,d0	;assume 752
	cmpi.w	#(736/8)-2,d0
	bne.s	140$
	subq.w	#2,d0

140$	move.w	d0,TFOS8I(a6)		;modulo
	move.w	d0,TFOS8II(a6)
	move.w	d0,TFOS8I+4(a6)
	move.w	d0,TFOS8II+4(a6)

;-------------------------------------------
* do planeptr stuff
	lea	TFOS9I(a6),a2		
	lea	TFOS9II(a6),a3		
	
	lea	bm_Planes(a1),a1
	bra.s	190$
180$	move.l	(a1)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,4(a3)
	swap	d0
	move.w	d0,(a3)
	swap	d0

	add.l	d2,d0
	move.w	d0,4(a2)
	swap	d0
	move.w	d0,(a2)

	addq.w	#8,a2
	addq.w	#8,a3

190$	dbra	d1,180$

;-------------------------------------------
* do sprite stuff
200$	movea.l	SUAVE_DBSprite0E(a0),a1
	GETCURRENT	a1
	move.l	a1,d0
	move.l	#SPRITE0CTRL241,(a1)
	move.w	d0,TFOS1+4(a6)
	swap	d0
	move.w	d0,TFOS1(a6)

	movea.l	SUAVE_DBSprite1E(a0),a1
	GETCURRENT	a1
	move.l	a1,d0
	move.l	#SPRITE1CTRL241,(a1)
	move.w	d0,TFOS1+12(a6)
	swap	d0
	move.w	d0,TFOS1+8(a6)

	movea.l	SUAVE_DBSprite0R(a0),a1
	GETCURRENT	a1
	move.l	a1,d0
	move.l	#SPRITE0CTRL241,(a1)
	move.w	d0,TFOS2I+4(a6)
	move.w	d0,TFOS2II+4(a6)
	swap	d0
	move.w	d0,TFOS2I(a6)
	move.w	d0,TFOS2II(a6)

	movea.l	SUAVE_DBSprite1R(a0),a1
	GETCURRENT	a1
	move.l	a1,d0
	move.l	#SPRITE1CTRL241,(a1)
	move.w	d0,TFOS2I+12(a6)
	move.w	d0,TFOS2II+12(a6)
	swap	d0
	move.w	d0,TFOS2I+8(a6)
	move.w	d0,TFOS2II+8(a6)

	movem.l	(sp)+,d0-d4/a1-a4/a6
	rts

***************************************************************
* ~SetUpEntrySprites(->CopList, ->Sprite0E, ->Sprite1E)
*
	IFD	CCODE
_SetUpEntrySprites	move.l	a2,-(sp)
	movem.l	8(sp),a0-a2
	bsr.s	SetUpEntrySprites
	movea.l	(sp)+,a2
	ENDC	

SetUpEntrySprites	move.l	d0,-(sp)
	move.l	a1,d0
	move.w	d0,10(a0)	;->spr0pt
	swap	d0
	move.w	d0,6(a0)

	move.l	a2,d0
	move.w	d0,18(a0)	;->spr1pt
	swap	d0
	move.w	d0,14(a0)
	
	move.l	(sp)+,d0
	rts

****************************************************************
* ~SetUpELHEntrySprites(->CopList, ->TB)
*			  a0	  a5
	IFD	CCODE
_SetUpELHEntrySprites	move.l	a5,-(sp)
	movem.l	8(sp),a0/a5
	bsr.s	SetUpELHEntrySprites
	movea.l	(sp)+,a5
	ENDC	

SetUpELHEntrySprites	movem.l	a1/a2,-(sp)
	lea	TB_EffectsBase+EFB_ELHSprites0(a5),a1
	GETCURRENT	a1
	lea	TB_EffectsBase+EFB_ELHSprites1(a5),a2
	GETCURRENT	a2
	bsr.s	SetUpEntrySprites
	movem.l	(sp)+,a1/a2
	rts

****************************************************************
* ~SetUpAVECopList(->SUAVE struct, color)
*				   d0
* When running on the AA chip set, d0 is a ULONG value, else its a UWORD.

	XREF	AVESPR,AVE_COLOR,AVEintreq1,AVEintreq2

	IFD	CCODE
_SetUpAVECopList move.l	4(sp),a0
	ENDC	

SetUpAVECopList:
	movem.l	d0-d1/a1-a2,-(sp)

	movea.l	SUAVE_DBCopLists(a0),a1
	GETCURRENT	a1
		
	GET.w	TB_CopListIntreq,d1
	move.w	d1,AVEintreq1(a1)
	move.w	d1,AVEintreq2(a1)

	IFND	AACHIPS

	move.w	d0,AVE_COLOR(a1)
	move.w	d0,AVE_COLOR+4(a1)	;not really necessary

	ENDC	;IFND AACHIPS

	IFD	AACHIPS
	
	bsr	Soft2HardColor

	move.w	d0,AVE_COLOR+12(a1)
	move.w	d0,AVE_COLOR+16(a1)	;not really necessary
	swap	d0
	move.w	d0,AVE_COLOR(a1)
	move.w	d0,AVE_COLOR+4(a1)	;not really necessary

	ENDC	;IFND AACHIPS

	movea.l	SUAVE_DBSprite0E(a0),a2
	GETCURRENT	a2
	move.l	a2,d0
	move.l	#SPRITE0CTRL241,(a2)
	move.w	d0,10(a1)
	swap	d0
	move.w	d0,6(a1)

	movea.l	SUAVE_DBSprite1E(a0),a2
	GETCURRENT	a2
	move.l	a2,d0
	move.l	#SPRITE1CTRL241,(a2)
	move.w	d0,18(a1)
	swap	d0
	move.w	d0,14(a1)

	movea.l	SUAVE_DBSprite0R(a0),a2
	GETCURRENT	a2
	move.l	a2,d0
	move.l	#SPRITE0CTRL241,(a2)
	move.w	d0,6+AVESPR(a1)
	swap	d0
	move.w	d0,2+AVESPR(a1)

	movea.l	SUAVE_DBSprite1R(a0),a2
	GETCURRENT	a2
	move.l	a2,d0
	move.l	#SPRITE1CTRL241,(a2)
	move.w	d0,14+AVESPR(a1)
	swap	d0
	move.w	d0,10+AVESPR(a1)

	movem.l	(sp)+,d0-d1/a1-a2
	rts


****************************************************************
* ~SetUpShallowAVEInterface(->SUAVE struct,->palette,->keyBM,->TB,KeyTop,InterfaceDepth,KeyDepth)
*			          a0	       a1	a2     a5   d0      d1            d2
*
* The ->keyBM may be NULL, but the ->palette must always exist!
* On 1-26-95 KeyTop is an interlaced number 0-479 (0=NTSC 21I)
* It was a non-interlaced number (0-239)
* So I no longer require the key to start with a Field II line.
* Nor do I require an even number of KeyBM lines.
*
* The half line on NTSC 20II can not have a key BM
*
* KeyTop = 0 = NTSC 21 I  = FieldI  WAIT 21 (WAIT 22 II)  =first full line
* KeyTop = 1 = NTSC 21 II = FieldII WAIT 22 (WAIT 22 I)  
* KeyTop = 2 = NTSC 22 I  = FieldI  WAIT 22 (WAIT 23 II) 
* KeyTop = 3 = NTSC 22 II = FieldII WAIT 23 (WAIT 23 I)  
*	etc.

SetUpShallowAVEInterface:
;;	DUMPREG	<SetUpShallowAVEInterface=>

	movem.l	d0-d6/a0-a6,-(sp)

	move.l	d0,d6		;stash KeyTop
	move.l	d1,d4		;interface depth
	move.l	d2,d5		;key depth

	movea.l	SUAVE_DBCopLists(a0),a3
	GETCURRENT	a3
			
;---- fix sprites
	movea.l	SUAVE_DBSprite0E(a0),a4
	GETCURRENT	a4
	move.l	a4,d1
	move.l	#SPRITE0CTRL241,(a4)
	move.w	d1,10(a3)
	swap	d1
	move.w	d1,6(a3)

	movea.l	SUAVE_DBSprite1E(a0),a4
	GETCURRENT	a4
	move.l	a4,d1
	move.l	#SPRITE1CTRL241,(a4)
	move.w	d1,18(a3)
	swap	d1
	move.w	d1,14(a3)

	movea.l	SUAVE_DBSprite0R(a0),a4
	GETCURRENT	a4
	move.l	a4,d1
	move.l	#SPRITE0CTRL241,(a4)

	move.w	d1,6+AVEISPR1(a3) ;Could of looked at CopListSpr0Tbl for offsets
	swap	d1
	move.w	d1,2+AVEISPR1(a3)
	swap	d1

	move.w	d1,6+AVEISPR2(a3)
	swap	d1
	move.w	d1,2+AVEISPR2(a3)

	movea.l	SUAVE_DBSprite1R(a0),a4
	GETCURRENT	a4
	move.l	a4,d1
	move.l	#SPRITE1CTRL241,(a4)

	move.w	d1,14+AVEISPR1(a3)
	swap	d1
	move.w	d1,10+AVEISPR1(a3)
	swap	d1

	move.w	d1,14+AVEISPR2(a3)
	swap	d1
	move.w	d1,10+AVEISPR2(a3)

;-----------------
;;	move.l	a1,d2
;;	bne.s	9$	;jump if palette given
;;	lea	StandardPalette(pc),a1	;four color palette
;;9$

;---- fix bplcon0 for Interface non-safe areas
	move.l	d4,d1	;not totally correct for 8 planes of interface (see below)
	ror.w	#4,d1

	bset	#15,d1		;set HIRES bit
	or.w	TB_BPLCON0orBits(a5),d1

	move.w	d1,AVEI_IBPLCON0_1b(a3)
	move.w	d1,AVEI_IBPLCON0_2b(a3)
	move.w	d1,AVEI_IIBPLCON0_1b(a3)
	move.w	d1,AVEI_IIBPLCON0_2b(a3)

*----------
;;	moveq	#(1<<NUMINTERFACEPLANES),d1	;assume no key (always at least 2 planes of Interface)
	moveq	#1,d1
	lsl.w	d4,d1	;bogus if no interface & nokey!!

	move.l	a2,d2
	beq	19$	;jump if no key given	

* a2->key, a1->palette
;Key given
10$

;;	moveq	#0,d2
;;	move.b	bm_Depth(a2),d2
;;	addq.w	#NUMINTERFACEPLANES,d2
	move.l	d4,d2
	add.w	d5,d2

;---- fix bplcon0 for Interface+Key

	IFD	AACHIPS
	cmpi.w	#8,d2
	bne.s	11$
	moveq	#1<<4,d1	;8 planes
	bra.s	12$
	ENDC

11$	move.w	d2,d1
	ror.w	#4,d1

12$	bset	#15,d1		;set HIRES bit
	or.w	TB_BPLCON0orBits(a5),d1

	move.w	d1,AVEI_I+10(a3)
	move.w	d1,AVEI_II+10(a3)

;---- # of palette colors
	moveq	#1,d1
	lsl.w	d2,d1

*------------------------------------------------
* a0->SUAVE, a1->palette, a2->KeyBM, a3->CopList
* d0=Top, d1=number of colors
* make sure the sprite colors or O.K.

19$	subq.w	#1,d1

	IFND	AACHIPS
	lea	AVEI_PALETTE(a3),a4
20$	move.w	(a1)+,(a4)
	addq.w	#4,a4
	dbra	d1,20$
	ENDC

	IFD	AACHIPS
	cmpi.w	#240,d1
	bhi.s	29$	;jump if palette disrupted

	lea	AVEI_PALETTE+((7*(64+2)*4)+16*4)(a3),a4	;color 240
	lea	NormalSpritePalette(pc),a6
	moveq	#16-1,d2
21$	move.l	(a6)+,d3
	move.w	d3,(32+1)*4(a4)	;lower nibbles
	swap	d3
	move.w	d3,(a4)		;upper nibbles
	addq.w	#4,a4
	dbra	d2,21$

* don't bother fixing sprite colors
29$	lea	AVEI_PALETTE(a3),a4
	moveq	#32,d2
22$	move.l	(a1)+,d3
	move.w	d3,(32+1)*4(a4)	;lower nibbles
	swap	d3
	move.w	d3,(a4)		;upper nibbles

	addq.w	#4,a4
	subq.w	#1,d2
	bne.s	20$
	lea	(32+2)*4(a4),a4	;skip over bplcon3 moves & upper nibbles
	moveq	#32,d2
20$	dbra	d1,22$

	ENDC	

;---- fix waits	
	move.l	a2,d1
	bne.s	25$

;no key
	move.w	#$ffff,AVEI_I(a3)	;wait forever 255,127
	move.w	#$ffff,AVEI_II(a3)	
	bra	60$

;key given
25$	move.w	#1,AVEI_I(a3)	;wait to 0,0
	move.w	#1,AVEI_II(a3)	;wait to 0,0

	move.w	#1,AVEI_I+12(a3)	;wait to 0,0
	move.w	#1,AVEI_II+12(a3)	;wait to 0,0


* Do Field II Top first
	move.w	d6,d0		;assume field II top
	btst	#0,d0		;jump if top line is field II
	bne.s	27$
	addq.w	#1,d0		;top field II line
27$	lsr.w	#1,d0		;Field line
	add.w	#22,d0
	lsl.w	#8,d0
	bcc.s	30$

	move.w	#$ffdf,AVEI_II(a3)	;wait to 255,111 (2 planes)
30$	addq.w	#1,d0			;set lsb always
	move.w	d0,AVEI_II+4(a3)	;wait to (21+T),0


* Do Field II Bottom next
	move.w	d6,d0
	add.w	bm_Rows(a2),d0  ;assume beyond field II bottom
	btst	#0,d0		;jump if bottom line is field II
	bne.s	31$
	addq.w	#1,d0		;bottom field II line
31$	lsr.w	#1,d0		;Field line
	add.w	#22,d0
	lsl.w	#8,d0
	bcc.s	32$

	move.w	#$ffdf,AVEI_II+12(a3)

	IFND	AACHIPS

;;	cmpi.b	#4,bm_Depth(a2)		;this old code didn't even add all the planes together!!!
	move.w	d4,d3
	add.w	d5,d3			;total depth
	cmpi.b	#4,d3

	bcs.s	32$			;jump if < 4 planes
	move.w	#$ff1f,AVEI_II+12(a3)
	ENDC

32$	addq.w	#1,d0			;set lsb always
	move.w	d0,AVEI_II+16(a3)


* Do Field I Top next
	move.w	d6,d0		;assume field I top
	btst	#0,d0		;jump if top line is field I
	beq.s	227$
	addq.w	#1,d0		;top field I line
227$	lsr.w	#1,d0		;Field line
	add.w	#21,d0
	lsl.w	#8,d0
	bcc.s	230$

	move.w	#$ffdf,AVEI_I(a3)	;wait to 255,111 (2 planes)
230$	addq.w	#1,d0			;set lsb always
	move.w	d0,AVEI_I+4(a3)		;wait to (21+T),0


* Do Field I Bottom last
	move.w	d6,d0
	add.w	bm_Rows(a2),d0  ;assume beyond field I bottom
	btst	#0,d0		;jump if bottom line is field I
	beq.s	231$
	addq.w	#1,d0		;bottom field I line
231$	lsr.w	#1,d0		;Field line
	add.w	#21,d0
	lsl.w	#8,d0
	bcc.s	232$

	move.w	#$ffdf,AVEI_I+12(a3)

	IFND	AACHIPS

;;	cmpi.b	#4,bm_Depth(a2)		;this old code didn't even add all the planes together!!!
	move.w	d4,d3
	add.w	d5,d3			;total depth
	cmpi.b	#4,d3

	bcs.s	232$			;jump if < 4 planes
	move.w	#$ff1f,AVEI_I+12(a3)
	ENDC

232$	addq.w	#1,d0			;set lsb always
	move.w	d0,AVEI_I+16(a3)


;------------ fix planeptrs

60$	lea	AVEI_IBODY+10(a3),a1	;bpl1pth
	lea	AVEI_IIBODY+10(a3),a6

	lea.l	TB_CHIPMem+4*0(a5),a0	;interface planes
	
* Do Interface Planes first
	bra.s	200$

190$	move.l	(a0)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC
	
	move.w	d0,4(a6)
	swap	d0
	move.w	d0,(a6)
	swap	d0

	add.l	#96,d0		;hard coded width of 768
	move.w	d0,4(a1)
	swap	d0
	move.w	d0,(a1)
	
	addq.w	#8,a1
	addq.w	#8,a6

200$	dbra	d4,190$

* Do Key Planes last (requested depth may be less than actual BM depth)
	move.l	a2,d0
	beq.s	333$	;jump if no key given	

	lea	bm_Planes(a2),a0
	moveq	#0,d0
	move.b	bm_Depth(a2),d0
	sub.w	d5,d0		;how deep to go
	add.w	d0,d0
	add.w	d0,d0		;*4
	adda.w	d0,a0		;skip low order planes
	bra.s	300$

290$	move.l	(a0)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.l	d0,d1		;assume d0=Field I
	add.l	#96,d1		;hard coded width of 768  (assume Field II)
	btst	#0,d6
	beq.s	295$		;jump if top line is field I
	exg.l	d0,d1

295$	move.w	d1,4(a6)	;field II
	swap	d1
	move.w	d1,(a6)

	move.w	d0,4(a1)	;Field I
	swap	d0
	move.w	d0,(a1)
	
	addq.w	#8,a1
	addq.w	#8,a6

300$	dbra	d5,290$

333$
;; This call requires linking with the DumpC.o module. I don't have the
;; source for that code, but an .o file can be found among the 3.1 OBJs.
;;	movem.l	a0/a6,-(sp)
;;	movea.l	a3,a0	;->coplist
;;	GET.l	TB_DOSBase,a6
;;	XCALL	DumpCopperList
;;	movem.l	(sp)+,a0/a6

	movem.l	(sp)+,d0-d6/a0-a6
	rts



	XREF AVEISPR1,AVEISPR2,AVEISPR3,AVEISPR4
	XREF AVEI_IBODY,AVEI_IIBODY
	XREF AVEI_I,AVEI_II
	XREF AVEI_PALETTE

****************************************************************
* ~SetUpAVEInterface(->SUAVE struct,->palette,->keyBM,->TB,KeyTop)
*			a0		a1	a2   a5   d0
*
* The ->keyBM may be NULL, but the ->palette must always exist!
* On 1-26-95 KeyTop is an interlaced number 0-479 (0=NTSC 21I)
* It was a non-interlaced number (0-239)
* So I no longer require the key to start with a Field II line.

* Will create what ever depth interface is in TB_InterfaceDepth
* This allows the Interface depth to be changed on the fly.
* NOTE!!!! THIS ISN'T BEING CALLED ANYMORE!!!
* Instead SetUpShallowAVEInterface() handles all combinations of AVEI depth/elh/key
* And its called from the InstallShallowIKey depth/elh/key routines.

SetUpAVEInterface
	movem.l	d1-d2,-(sp)
	moveq	#0,d1
	GET.w	TB_InterfaceDepth,d1
	move.l	a2,d2
	beq.s	10$		;jump if no KeyBM
	moveq	#0,d2
	move.b	bm_Depth(a2),d2
10$	bsr	SetUpShallowAVEInterface
	movem.l	(sp)+,d1-d2
	rts

***********************************************************
* If your using AVEI with a DIB/DIBGR key, this will reset
* it to non-key, and normal NUMINTERFACEPLANES.
* If you want to update the Interface or Toaster hardware call KillAlphaKey.
* 
* NOTE! DON'T EXPECT KillAlphaKey() to work after this.  If you want a
* ReDoDisplay() + InstallAVEI to get it w/o a key, please call KillAlphaKey() instead of ResetAVEI.

	XDEF	ResetAVEI
ResetAVEI
	tst.l	TB_CurrentAlphaBM(a5)
	beq.s	10$
	GET.l	TB_CurrentAlphaBM,stashCurrentAlphaBM
	GET.w	TB_InterfaceDepth,stashInterfaceDepth
	clr.l	TB_CurrentAlphaBM(a5)
	PUT.w	#NUMINTERFACEPLANES,TB_InterfaceDepth
10$	rts

***********************************************************
* If you had a Key but temporarily went to a Standard AVEI via ResetAVEI()
* you may once again get back the key with this.
	XDEF	ResetAVEIkey
ResetAVEIkey
	PUT.w	stashInterfaceDepth(pc),TB_InterfaceDepth
	PUT.l	stashCurrentAlphaBM(pc),TB_CurrentAlphaBM

	rts

stashCurrentAlphaBM	dc.l	0
stashInterfaceDepth	dc.w	0
			dc.w	0	;NOT USED	

******************************************************************
* ~InitWipeInterface1(->copbuf, ->InterfacePlanes, ->TB)
*		     a0			a1	  a5
	IFD	CCODE
_InitWipeInterface1
	move.l	a5,-(sp)
	movem.l	8(sp),a0-a1/a5
	bra.s	InitWipeInterface1
	movea.l	(sp)+,a5
	rts
	ENDC

InitWipeInterface1:
 	STRUCTURE  WipeInterface1,0
 	  movem.l  d0-d2/a0-a2,-(sp)
	  movea.l  a0,a2	       ;save ->copbuff	
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

* Here is the variable header stuff
	LABEL     WIPEI1_Spr0pt1	;only for ELH usage	
          CPMOVEREGL   spr0pth       ;fill values in later
          CPMOVEREGL   spr1pth

	LABEL	WIPEI1_Bpl2pth
          CPMOVEREGW   bpl2pth       ;fill in later, actual wipe bm		  

	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4pth       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4pth       ;fill in later, null line
          CPMOVEREGW   bpl6pth       ;fill in later, null line
	ENDC

	IFND	AACHIPS
	CPMOVE	0,beamcon0	;make sure beamcon0 is ok, necessary?
	CPMOVE	NEWDENISE,bplcon3 ;fix new Denise right edge problem

          CPMOVE   ((21<<8)!92),diwstrt
          CPMOVE   (((262<<8)&$ff00)!(458-256)),diwstop
	ENDC

	IFD	AACHIPS
* window start & stops are put her to prevent premature starts
	AAdiwstrt	AAwindowStartX,AAwindowStartY					
        CPMOVE		AAvalue,diwstrt

	AAdiwstop	AAwindowStopX,AAwindowStopY
        CPMOVE		AAvalue,diwstop

	AAdiwhigh	AAwindowStartX,AAwindowStopX,AAwindowStartY,AAwindowStopY
	CPMOVE		AAvalue,diwhigh
	ENDC

 LABEL WIPEI1_LATCH
          CPMOVEREGL   cop1lc    ;fill values in later

*----------------

	IFND	AACHIPS
 LABEL WIPEI1_COLORS
           CPMOVE   $006,color00	;IB=0,0	;can getted stomped on!!!
           CPMOVE   $846,color01	;IB=0,0
           CPMOVE   $009,color02	;IB=1,1	;can getted stomped on!!!
           CPMOVE   $849,color03	;IB=1,1
           CPMOVE   $7b6,color04	;IB=0,0
           CPMOVE   $ff6,color05	;IB=0,0
           CPMOVE   $7b9,color06	;IB=1,1
           CPMOVE   $ff9,color07	;IB=1,1

* Low contrast sprite. 
*;;          CPMOVE   $776,color16   I=0 B=0 G=0 R=0 ;transparent
          CPMOVE   $876,color17   ;I=0 B=0 G=0 R=1
          CPMOVE   $786,color18   ;I=0 B=0 G=1 R=0
          CPMOVE   $886,color19   ;I=0 B=0 G=1 R=1
          CPMOVE   $778,color20   ;I=0 B=1 G=0 R=0
          CPMOVE   $878,color21   ;I=0 B=1 G=0 R=1
          CPMOVE   $788,color22   ;I=0 B=1 G=1 R=0
          CPMOVE   $888,color23   ;I=0 B=1 G=1 R=1
          CPMOVE   $777,color24   ;I=1 B=0 G=0 R=0
          CPMOVE   $877,color25   ;I=1 B=0 G=0 R=1
          CPMOVE   $787,color26   ;I=1 B=0 G=1 R=0
          CPMOVE   $887,color27   ;I=1 B=0 G=1 R=1
          CPMOVE   $779,color28   ;I=1 B=1 G=0 R=0
          CPMOVE   $879,color29   ;I=1 B=1 G=0 R=1
          CPMOVE   $789,color30   ;I=1 B=1 G=1 R=0
          CPMOVE   $889,color31   ;I=1 B=1 G=1 R=1
	ENDC
*----------------

	IFD	AACHIPS

	IFEQ	NUMINTERFACEPLANES-2

* plane 3 = msb of interface
* plane 2 = lsb of wipe
* plane 1 = lsb of interface

WipeIcolor0	set	$000
WipeIcolor1	set	$555
WipeIcolor2	set	$aaa
WipeIcolor3	set	$fff

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

 LABEL WIPEI1_COLORS
           CPMOVE   WipeIcolor0,color00	;can getted stomped on!!!
           CPMOVE   WipeIcolor1,color01
           CPMOVE   WipeIcolor0,color02	;can getted stomped on!!!
           CPMOVE   WipeIcolor1,color03
           CPMOVE   WipeIcolor2,color04
           CPMOVE   WipeIcolor3,color05
           CPMOVE   WipeIcolor2,color06
           CPMOVE   WipeIcolor3,color07

	AAbplcon3	0,0	;bank 0, lower nibble
	CPMOVE	AAvalue,bplcon3
           CPMOVE   $000,color00	;I/B1=0,B/B0=0,G/G1=0,R/R1=0
           CPMOVE   $200,color01	;I/B1=0,B/B0=0,G/G1=0,R/R1=1
           CPMOVE   $003,color02	;I/B1=1,B/B0=1,G/G1=0,R/R1=0
           CPMOVE   $203,color03	;I/B1=1,B/B0=1,G/G1=0,R/R1=1
           CPMOVE   $020,color04	;I/B1=0,B/B0=0,G/G1=1,R/R1=0
           CPMOVE   $220,color05	;I/B1=0,B/B0=0,G/G1=1,R/R1=1
           CPMOVE   $023,color06	;I/B1=1,B/B0=1,G/G1=1,R/R1=0
           CPMOVE   $223,color07	;I/B1=1,B/B0=1,G/G1=1,R/R1=1

	ENDC	;IFEQ	NUMINTERFACEPLANES-2

*---------------------------------
	IFEQ	NUMINTERFACEPLANES-3

* plane 4 = lsb of wipe		;repeated (only one bit)
* plane 3 = msb of interface
* plane 2 = lsb of wipe
* plane 1 = lsb of interface

WipeIcolor0	set	$000
WipeIcolor1	set	$666
WipeIcolor2	set	$999
WipeIcolor3	set	$ddd
WipeIcolor4	set	$333
WipeIcolor5	set	$555
WipeIcolor6	set	$cb7
WipeIcolor7	set	$fe7

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

 LABEL WIPEI1_COLORS
           CPMOVE   WipeIcolor0,color00	;can getted stomped on!!!
           CPMOVE   WipeIcolor1,color01
           CPMOVE   WipeIcolor0,color02	;can getted stomped on!!!
           CPMOVE   WipeIcolor1,color03
           CPMOVE   WipeIcolor2,color04
           CPMOVE   WipeIcolor3,color05
           CPMOVE   WipeIcolor2,color06
           CPMOVE   WipeIcolor3,color07
           CPMOVE   WipeIcolor0,color08
           CPMOVE   WipeIcolor1,color09
           CPMOVE   WipeIcolor0,color10
           CPMOVE   WipeIcolor1,color11
           CPMOVE   WipeIcolor2,color12
           CPMOVE   WipeIcolor3,color13
           CPMOVE   WipeIcolor2,color14
           CPMOVE   WipeIcolor3,color15

           CPMOVE   WipeIcolor4,color16
           CPMOVE   WipeIcolor5,color17
           CPMOVE   WipeIcolor4,color18
           CPMOVE   WipeIcolor5,color19
           CPMOVE   WipeIcolor6,color20
           CPMOVE   WipeIcolor7,color21
           CPMOVE   WipeIcolor6,color22
           CPMOVE   WipeIcolor7,color23
           CPMOVE   WipeIcolor4,color24
           CPMOVE   WipeIcolor5,color25
           CPMOVE   WipeIcolor4,color26
           CPMOVE   WipeIcolor5,color27
           CPMOVE   WipeIcolor6,color28
           CPMOVE   WipeIcolor7,color29
           CPMOVE   WipeIcolor6,color30
           CPMOVE   WipeIcolor7,color31

	AAbplcon3	0,0	;bank 0, lower nibble
	CPMOVE	AAvalue,bplcon3
					;OLlsm  OLmsb  DIBmsb DIBlsb
           CPMOVE   $000,color00	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0 
           CPMOVE   $200,color01	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1 
           CPMOVE   $003,color02	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0 
           CPMOVE   $203,color03	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1 
           CPMOVE   $020,color04	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2 
           CPMOVE   $220,color05	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3 
           CPMOVE   $023,color06	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2 
           CPMOVE   $223,color07	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3 
           CPMOVE   $000,color08	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0 
           CPMOVE   $200,color09	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1 
           CPMOVE   $003,color10	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0 
           CPMOVE   $203,color11	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1 
           CPMOVE   $020,color12	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2 
           CPMOVE   $220,color13	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3 
           CPMOVE   $023,color14	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2 
           CPMOVE   $223,color15	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3 

           CPMOVE   $000,color16	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0 
           CPMOVE   $020,color17	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2 
           CPMOVE   $003,color18	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0 
           CPMOVE   $023,color19	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2 
           CPMOVE   $220,color20	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3 
           CPMOVE   $200,color21	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1 
           CPMOVE   $223,color22	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3 
           CPMOVE   $203,color23	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1 
           CPMOVE   $000,color24	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0 
           CPMOVE   $020,color25	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2 
           CPMOVE   $003,color26	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0 
           CPMOVE   $023,color27	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2 
           CPMOVE   $220,color28	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3 
           CPMOVE   $200,color29	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1 
           CPMOVE   $223,color30	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3 
           CPMOVE   $203,color31	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1 

	ENDC	;IFEQ	NUMINTERFACEPLANES-3
	
*---------------------------------
* *!
	IFEQ	NUMINTERFACEPLANES-6

* plane 7 = msb of interface
* plane 6 = lsb of wipe		;repeated (only one bit)
* plane 5 = next to msb of interface
* plane 4 = lsb of wipe		;repeated (only one bit)
* plane 3 = next to lsb of interface
* plane 2 = lsb of wipe
* plane 1 = lsb of interface

WipeIhigh00	set	VThigh00
WipeIhigh01	set	VThigh01
WipeIhigh02	set	VThigh02
WipeIhigh03	set	VThigh03
WipeIhigh04	set	VThigh04
WipeIhigh05	set	VThigh05
WipeIhigh06	set	VThigh06
WipeIhigh07	set	VThigh07
WipeIhigh08	set	VThigh08
WipeIhigh09	set	VThigh09
WipeIhigh10	set	VThigh10
WipeIhigh11	set	VThigh11
WipeIhigh12	set	VThigh12
WipeIhigh13	set	VThigh13
WipeIhigh14	set	VThigh14
WipeIhigh15	set	VThigh15

WipeIlow00	set	(VTlow00&$ddc)
WipeIlow01	set	(VTlow01&$ddc)
WipeIlow02	set	(VTlow02&$ddc)
WipeIlow03	set	(VTlow03&$ddc)
WipeIlow04	set	(VTlow04&$ddc)
WipeIlow05	set	(VTlow05&$ddc)
WipeIlow06	set	(VTlow06&$ddc)
WipeIlow07	set	(VTlow07&$ddc)
WipeIlow08	set	(VTlow08&$ddc)
WipeIlow09	set	(VTlow09&$ddc)
WipeIlow10	set	(VTlow10&$ddc)
WipeIlow11	set	(VTlow11&$ddc)
WipeIlow12	set	(VTlow12&$ddc)
WipeIlow13	set	(VTlow13&$ddc)
WipeIlow14	set	(VTlow14&$ddc)
WipeIlow15	set	(VTlow15&$ddc)

	AAbplcon3	0,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

 LABEL WIPEI1_COLORS
           CPMOVE   WipeIhigh00,color00	;can getted stomped on!!!
           CPMOVE   WipeIhigh01,color01
           CPMOVE   WipeIhigh00,color02	;can getted stomped on!!!
           CPMOVE   WipeIhigh01,color03
           CPMOVE   WipeIhigh02,color04
           CPMOVE   WipeIhigh03,color05
           CPMOVE   WipeIhigh02,color06
           CPMOVE   WipeIhigh03,color07
           CPMOVE   WipeIhigh00,color08
           CPMOVE   WipeIhigh01,color09
           CPMOVE   WipeIhigh00,color10
           CPMOVE   WipeIhigh01,color11
           CPMOVE   WipeIhigh02,color12
           CPMOVE   WipeIhigh03,color13
           CPMOVE   WipeIhigh02,color14
           CPMOVE   WipeIhigh03,color15

           CPMOVE   WipeIhigh04,color16
           CPMOVE   WipeIhigh05,color17
           CPMOVE   WipeIhigh04,color18
           CPMOVE   WipeIhigh05,color19
           CPMOVE   WipeIhigh06,color20
           CPMOVE   WipeIhigh07,color21
           CPMOVE   WipeIhigh06,color22
           CPMOVE   WipeIhigh07,color23
           CPMOVE   WipeIhigh04,color24
           CPMOVE   WipeIhigh05,color25
           CPMOVE   WipeIhigh04,color26
           CPMOVE   WipeIhigh05,color27
           CPMOVE   WipeIhigh06,color28
           CPMOVE   WipeIhigh07,color29
           CPMOVE   WipeIhigh06,color30
           CPMOVE   WipeIhigh07,color31

	AAbplcon3	0,0	;bank 0, lower nibble
	CPMOVE	AAvalue,bplcon3
	 					;OLlsm  OLmsb  DIBmsb DIBlsb
           CPMOVE   WipeIlow00!$000,color00	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow01!$200,color01	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow00!$003,color02	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow01!$203,color03	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow02!$020,color04	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow03!$220,color05	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow02!$023,color06	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow03!$223,color07	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow00!$000,color08	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow01!$200,color09	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow00!$003,color10	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow01!$203,color11	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow02!$020,color12	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow03!$220,color13	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow02!$023,color14	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow03!$223,color15	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3

           CPMOVE   WipeIlow04!$000,color16	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow05!$020,color17	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow04!$003,color18	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow05!$023,color19	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow06!$220,color20	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow07!$200,color21	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow06!$223,color22	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow07!$203,color23	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow04!$000,color24	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow05!$020,color25	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow04!$003,color26	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow05!$023,color27	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow06!$220,color28	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow07!$200,color29	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow06!$223,color30	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow07!$203,color31	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1

	AAbplcon3	1,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

           CPMOVE   WipeIhigh00,color00
           CPMOVE   WipeIhigh01,color01
           CPMOVE   WipeIhigh00,color02
           CPMOVE   WipeIhigh01,color03
           CPMOVE   WipeIhigh02,color04
           CPMOVE   WipeIhigh03,color05
           CPMOVE   WipeIhigh02,color06
           CPMOVE   WipeIhigh03,color07
           CPMOVE   WipeIhigh00,color08
           CPMOVE   WipeIhigh01,color09
           CPMOVE   WipeIhigh00,color10
           CPMOVE   WipeIhigh01,color11
           CPMOVE   WipeIhigh02,color12
           CPMOVE   WipeIhigh03,color13
           CPMOVE   WipeIhigh02,color14
           CPMOVE   WipeIhigh03,color15

           CPMOVE   WipeIhigh04,color16
           CPMOVE   WipeIhigh05,color17
           CPMOVE   WipeIhigh04,color18
           CPMOVE   WipeIhigh05,color19
           CPMOVE   WipeIhigh06,color20
           CPMOVE   WipeIhigh07,color21
           CPMOVE   WipeIhigh06,color22
           CPMOVE   WipeIhigh07,color23
           CPMOVE   WipeIhigh04,color24
           CPMOVE   WipeIhigh05,color25
           CPMOVE   WipeIhigh04,color26
           CPMOVE   WipeIhigh05,color27
           CPMOVE   WipeIhigh06,color28
           CPMOVE   WipeIhigh07,color29
           CPMOVE   WipeIhigh06,color30
           CPMOVE   WipeIhigh07,color31

	AAbplcon3	1,0	;bank 0, lower nibble
	CPMOVE	AAvalue,bplcon3
           CPMOVE   WipeIlow00!$000,color00	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow01!$200,color01	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow00!$003,color02	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow01!$203,color03	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow02!$020,color04	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow03!$220,color05	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow02!$023,color06	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow03!$223,color07	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow00!$000,color08	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow01!$200,color09	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow00!$003,color10	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow01!$203,color11	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow02!$020,color12	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow03!$220,color13	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow02!$023,color14	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow03!$223,color15	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3

           CPMOVE   WipeIlow04!$000,color16	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow05!$020,color17	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow04!$003,color18	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow05!$023,color19	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow06!$220,color20	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow07!$200,color21	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow06!$223,color22	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow07!$203,color23	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow04!$000,color24	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow05!$020,color25	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow04!$003,color26	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow05!$023,color27	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow06!$220,color28	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow07!$200,color29	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow06!$223,color30	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow07!$203,color31	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1

	AAbplcon3	2,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

           CPMOVE   WipeIhigh08,color00
           CPMOVE   WipeIhigh09,color01
           CPMOVE   WipeIhigh08,color02
           CPMOVE   WipeIhigh09,color03
           CPMOVE   WipeIhigh10,color04
           CPMOVE   WipeIhigh11,color05
           CPMOVE   WipeIhigh10,color06
           CPMOVE   WipeIhigh11,color07
           CPMOVE   WipeIhigh08,color08
           CPMOVE   WipeIhigh09,color09
           CPMOVE   WipeIhigh08,color10
           CPMOVE   WipeIhigh09,color11
           CPMOVE   WipeIhigh10,color12
           CPMOVE   WipeIhigh11,color13
           CPMOVE   WipeIhigh10,color14
           CPMOVE   WipeIhigh11,color15

           CPMOVE   WipeIhigh12,color16
           CPMOVE   WipeIhigh13,color17
           CPMOVE   WipeIhigh12,color18
           CPMOVE   WipeIhigh13,color19
           CPMOVE   WipeIhigh14,color20
           CPMOVE   WipeIhigh15,color21
           CPMOVE   WipeIhigh14,color22
           CPMOVE   WipeIhigh15,color23
           CPMOVE   WipeIhigh12,color24
           CPMOVE   WipeIhigh13,color25
           CPMOVE   WipeIhigh12,color26
           CPMOVE   WipeIhigh13,color27
           CPMOVE   WipeIhigh14,color28
           CPMOVE   WipeIhigh15,color29
           CPMOVE   WipeIhigh14,color30
           CPMOVE   WipeIhigh15,color31

	AAbplcon3	2,0	;bank 0, lower nibble
	CPMOVE	AAvalue,bplcon3
           CPMOVE   WipeIlow08!$000,color00	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow09!$200,color01	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow08!$003,color02	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow09!$203,color03	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow10!$020,color04	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow11!$220,color05	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow10!$023,color06	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow11!$223,color07	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow08!$000,color08	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow09!$200,color09	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow08!$003,color10	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow09!$203,color11	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow10!$020,color12	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow11!$220,color13	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow10!$023,color14	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow11!$223,color15	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3

           CPMOVE   WipeIlow12!$000,color16	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow13!$020,color17	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow12!$003,color18	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow13!$023,color19	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow14!$220,color20	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow15!$200,color21	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow14!$223,color22	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow15!$203,color23	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow12!$000,color24	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow13!$020,color25	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow12!$003,color26	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow13!$023,color27	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow14!$220,color28	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow15!$200,color29	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow14!$223,color30	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow15!$203,color31	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1

	AAbplcon3	3,1	;bank 0, upper nibble
	CPMOVE	AAvalue,bplcon3

           CPMOVE   WipeIhigh08,color00
           CPMOVE   WipeIhigh09,color01
           CPMOVE   WipeIhigh08,color02
           CPMOVE   WipeIhigh09,color03
           CPMOVE   WipeIhigh10,color04
           CPMOVE   WipeIhigh11,color05
           CPMOVE   WipeIhigh10,color06
           CPMOVE   WipeIhigh11,color07
           CPMOVE   WipeIhigh08,color08
           CPMOVE   WipeIhigh09,color09
           CPMOVE   WipeIhigh08,color10
           CPMOVE   WipeIhigh09,color11
           CPMOVE   WipeIhigh10,color12
           CPMOVE   WipeIhigh11,color13
           CPMOVE   WipeIhigh10,color14
           CPMOVE   WipeIhigh11,color15

           CPMOVE   WipeIhigh12,color16
           CPMOVE   WipeIhigh13,color17
           CPMOVE   WipeIhigh12,color18
           CPMOVE   WipeIhigh13,color19
           CPMOVE   WipeIhigh14,color20
           CPMOVE   WipeIhigh15,color21
           CPMOVE   WipeIhigh14,color22
           CPMOVE   WipeIhigh15,color23
           CPMOVE   WipeIhigh12,color24
           CPMOVE   WipeIhigh13,color25
           CPMOVE   WipeIhigh12,color26
           CPMOVE   WipeIhigh13,color27
           CPMOVE   WipeIhigh14,color28
           CPMOVE   WipeIhigh15,color29
           CPMOVE   WipeIhigh14,color30
           CPMOVE   WipeIhigh15,color31

	AAbplcon3	3,0	;bank 0, lower nibble
	CPMOVE	AAvalue,bplcon3
           CPMOVE   WipeIlow08!$000,color00	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow09!$200,color01	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow08!$003,color02	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow09!$203,color03	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow10!$020,color04	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow11!$220,color05	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow10!$023,color06	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow11!$223,color07	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow08!$000,color08	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow09!$200,color09	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow08!$003,color10	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow09!$203,color11	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow10!$020,color12	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow11!$220,color13	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow10!$023,color14	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow11!$223,color15	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3

           CPMOVE   WipeIlow12!$000,color16	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow13!$020,color17	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow12!$003,color18	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow13!$023,color19	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow14!$220,color20	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow15!$200,color21	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow14!$223,color22	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow15!$203,color23	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1
           CPMOVE   WipeIlow12!$000,color24	;R/R1=0 G/G1=0 I/B1=0 B/B0=0 PvOl=0
           CPMOVE   WipeIlow13!$020,color25	;R/R1=0 G/G1=1 I/B1=0 B/B0=0 PvOl=2
           CPMOVE   WipeIlow12!$003,color26	;R/R1=0 G/G1=0 I/B1=1 B/B0=1 PvOl=0
           CPMOVE   WipeIlow13!$023,color27	;R/R1=0 G/G1=1 I/B1=1 B/B0=1 PvOl=2
           CPMOVE   WipeIlow14!$220,color28	;R/R1=1 G/G1=1 I/B1=0 B/B0=0 PvOl=3
           CPMOVE   WipeIlow15!$200,color29	;R/R1=1 G/G1=0 I/B1=0 B/B0=0 PvOl=1
           CPMOVE   WipeIlow14!$223,color30	;R/R1=1 G/G1=1 I/B1=1 B/B0=1 PvOl=3
           CPMOVE   WipeIlow15!$203,color31	;R/R1=1 G/G1=0 I/B1=1 B/B0=1 PvOl=1

	ENDC	;IFEQ	NUMINTERFACEPLANES-6
	
*---------------------------------

	AAbplcon3	7,1	;bank 7, upper nibble
	CPMOVE	AAvalue,bplcon3

*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $000,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $000,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $000,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $000,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $000,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1

	AAbplcon3	7,0	;bank 7, upper nibble
	CPMOVE	AAvalue,bplcon3
*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $600,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $024,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $624,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $101,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $701,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $125,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $725,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $012,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $612,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $036,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $636,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $113,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $713,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $137,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $737,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1

	ENDC	;IFD	AACHIPS
*-------------------------------------------------------------------

	IFND	AACHIPS
          CPMOVE   ((64>>1)&$fc),ddfstrt
          CPMOVE   ((424>>1)&$fc),ddfstop
          CPMOVE   ((7<<4)!7),bplcon1   ;scroll
          CPMOVE   96,bpl1mod
          CPMOVE   -96,bpl2mod
          CPMOVE   $24,bplcon2         ;sprite priority over bm
	ENDC

	IFD	AACHIPS
	AAddfstrt	AA768fetchStart
        CPMOVE	AAvalue,ddfstrt

	AAddfstop	AA768fetchStop
        CPMOVE	AAvalue,ddfstop

	AAbplcon1	AAbmscroll,AAbmscroll
        CPMOVE	AAvalue,bplcon1   	;scroll (put sprite left of bm)

        CPMOVE   	(768/8),bpl1mod
        CPMOVE   	-(768/8),bpl2mod

        CPMOVE 	AAbplcon2,bplcon2	;sprite priority over bm
	CPMOVE	AAbplcon4,bplcon4	;sprite colors = 240-255

	CPMOVE	AA768fetchMode,fmode
	ENDC

	  CPMOVE  0,copjmp1		;jump to body

*;-------------
 LABEL	WIPEI1_I
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

	LABEL     WIPEI1_Spr0pt2I	;for ELH usage only
          CPMOVEREGL   spr0pth       ;fill values in later, freeze/live
          CPMOVEREGL   spr1pth	    ;usually save as Spr1pt1		

 LABEL	WIPEI1_IBody
	  move.l a2,d0
          add.l	#WIPEI1_II,d0
	  CPMOVERL d0,cop1lc		;->main copper list

	move.l	(a1),d0
	
	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC

	CPMOVERL	d0,bpl1pth
	move.l	4(a1),d0

	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC

	CPMOVERL	d0,bpl3pth

	IFEQ	NUMINTERFACEPLANES-3

	move.l	8(a1),d0

	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC

	CPMOVERL	d0,bpl5pth
	
	ENDC

	IFEQ	NUMINTERFACEPLANES-6

	move.l	8(a1),d0

	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC

	CPMOVERL	d0,bpl5pth

	move.l	12(a1),d0

	IFND	AACHIPS
	add.l	#96-4,d0
	ENDC
	IFD	AACHIPS
	add.l	#96,d0
	ENDC

	CPMOVERL	d0,bpl7pth
	
	ENDC

*;---------
	STRUCT     WIPEI1_Spr2ptI,4*12
	  move.l   TB_EffectsBase+EFB_SpriteData(a5),d0
	  add.l	   #ESD_SpriteNull,d0	

	  move.w   #spr2pth,d1
	  moveq	   #5,d2		;null out sprites 2-7	  	  
10$	  move.w   d1,(a0)+
	  swap	   d0		;msw	
	  move.w   d0,(a0)+

          addq.w   #2,d1
          move.w   d1,(a0)+
          swap     d0		;lsw
	  move.w   d0,(a0)+

          addq.w   #2,d1
	  dbra	   d2,10$
*;---------

	LABEL     WIPEI1_Bpl2ptl1I
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

;;* had this upto 3.1          CPWAIT   21,0

	IFND	AACHIPS
	move.w	#%1011000000000000,d0
	ENDC

	IFD	AACHIPS
	IFEQ	NUMINTERFACEPLANES-2
	AAbplcon0	3,1,0,0		;depth=3, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	AAbplcon0	5,1,0,0		;depth=5, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	AAbplcon0	7,1,0,0		;depth=7, HiRes, non-HAM, no ERSY
	ENDC
	move.w	#AAvalue,d0
	ENDC

	or.w	TB_BPLCON0orBits(a5),d0

 LABEL WIPEI1_BPLCON01
	CPMOVERW d0,bplcon0		;modes & 3 planes

	LABEL WIPEI1_wait1I
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 or forever 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     WIPEI1_Bpl2ptl2I
          CPMOVEREGW   bpl2ptl       ;fill in later, effect line
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

	LABEL WIPEI1_wait2I
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     WIPEI1_Bpl2ptl3I
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

          CPEND
*;-------------
 LABEL	WIPEI1_II
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

	LABEL     WIPEI1_Spr0pt2II
          CPMOVEREGL   spr0pth       ;fill values in later, freeze/live
          CPMOVEREGL   spr1pth	    ;usually same as Spr1pt1		

 LABEL	WIPEI1_IIBody
	move.l	a2,d0
	add.l	#WIPEI1_I,d0
	  CPMOVERL d0,cop1lc		;->main copper list

	move.l	(a1),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVERL	d0,bpl1pth
	move.l	4(a1),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVERL	d0,bpl3pth

	IFEQ	NUMINTERFACEPLANES-3
	move.l	8(a1),d0
	CPMOVERL	d0,bpl5pth
	ENDC

	IFEQ	NUMINTERFACEPLANES-6
	move.l	8(a1),d0
	CPMOVERL	d0,bpl5pth
	move.l	12(a1),d0
	CPMOVERL	d0,bpl7pth
	ENDC

*;---------
	STRUCT     WIPEI1_Spr2ptII,4*12
	  move.l   TB_EffectsBase+EFB_SpriteData(a5),d0
	  add.l	   #ESD_SpriteNull,d0	

	  move.w   #spr2pth,d1
	  moveq	   #5,d2		;null out sprites 2-7	  	  
15$	  move.w   d1,(a0)+
	  swap	   d0		;msw	
	  move.w   d0,(a0)+

          addq.w   #2,d1
          move.w   d1,(a0)+
          swap     d0		;lsw
	  move.w   d0,(a0)+

          addq.w   #2,d1
	  dbra	   d2,15$
*;---------

	LABEL     WIPEI1_Bpl2ptl1II
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

;;* had this upto 3.1          CPWAIT   21,0

	IFND	AACHIPS
	move.w	#%1011000000000000,d0
	ENDC

	IFD	AACHIPS
	IFEQ	NUMINTERFACEPLANES-2
	AAbplcon0	3,1,0,0		;depth=3, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	AAbplcon0	5,1,0,0		;depth=5, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	AAbplcon0	7,1,0,0		;depth=7, HiRes, non-HAM, no ERSY
	ENDC
	move.w	#AAvalue,d0
	ENDC

	or.w	TB_BPLCON0orBits(a5),d0

 LABEL WIPEI1_BPLCON02
	CPMOVERW d0,bplcon0		;modes & 3 planes

	LABEL WIPEI1_wait1II
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 or forever 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     WIPEI1_Bpl2ptl2II
          CPMOVEREGW   bpl2ptl       ;fill in later, effect line
	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

	LABEL WIPEI1_wait2II
	    CPWAITNOPL
*;;          CPWAIT   255,15      ;make 255,15 or 0,0 
*;;          CPWAIT   0,0          ;fill in later

	LABEL     WIPEI1_Bpl2ptl3II
          CPMOVEREGW   bpl2ptl       ;fill in later, null line

	IFEQ	NUMINTERFACEPLANES-3
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
          CPMOVEREGW   bpl4ptl       ;fill in later, null line
          CPMOVEREGW   bpl6ptl       ;fill in later, null line
	ENDC

          CPEND

	movem.l	(sp)+,d0-d2/a0-a2
	rts
	
	LABEL	WIPEI1_SIZEOF

***********************************************************
* ~SetUpWipeInterface1(->SetUpWipe structure)

	IFD	CCODE
_SetUpWipeInterface1	movea.l	4(sp),a0
	ENDC


 ifeq 0
SetUpWipeInterface1	movem.l	d0-d1/a0-a3,-(sp)
	movea.l	a0,a1			;->structure
	movea.l	SUDVE_DBCopLists(a1),a2	;->DBcoplist
	move.w	(a2),d0			;current
	movea.l	DB_Data(a2,d0.w),a2	;->coplist	

	lea	WIPEI1_Spr0pt1(a2),a0
	movea.l	SUDVE_DBSprite0E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite0R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)

	movea.l	SUDVE_DBSprite1R(a1),a3
	move.w	(a3),d1			;current
	movea.l	DB_Data(a3,d1.w),a3	
	move.l	a3,d1
	move.l	#SPRITE1CTRL241,(a3)

	lea	WIPEI1_Spr0pt2I(a2),a0
	CPMOVEVALL	d0
	swap	d0
	CPMOVEVALL	d1
	swap	d1

	lea	WIPEI1_Spr0pt2II(a2),a0
	CPMOVEVALL	d0
	swap	d0
	CPMOVEVALL	d1
	swap	d1

*;----
*;assumes all low/high order bitplane data is each within a 64K block
	movea.l	SUDVE_DBPlanePtrs(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	;**PlanePtrs
	move.l	a3,-(sp)		;save, ->current bitmaps

	movea.l	SUDVE_CompBitMapList(a1),a0
	move.w	Wipe1CBML_TopBM(a0),d0
	add.w	d0,d0
	add.w	d0,d0
	movea.l	0(a3,d0.w),a3	;*PlanePtrs for null line
	move.l	(a3),d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	swap	d0
	lea	WIPEI1_Bpl2pth(a2),a0
	CPMOVEVALW	d0	;bpl2pth

	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0	;bpl2pth
	ENDC

	swap	d0

*;----	
	lea	WIPEI1_Bpl2ptl1I(a2),a0
	CPMOVEVALW	d0	;null plane 0
	
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC

	lea	WIPEI1_Bpl2ptl1II(a2),a0
	CPMOVEVALW	d0	;null plane 0
	
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC

*;---
* Like with the DVE CBML should I check for MiddleBM = -1 = termination, then
* wait forever after top ????? And also check for effect height = 0. ????? 

	movea.l	(sp),a3		;restore **planeprs
	movea.l	SUDVE_CompBitMapList(a1),a0
	move.w	Wipe1CBML_MiddleBM(a0),d0
	add.w	d0,d0
	add.w	d0,d0
	movea.l	0(a3,d0.w),a3	;*PlanePtrs for null line
	move.l	(a3),d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	lea	WIPEI1_Bpl2ptl2I(a2),a0
	CPMOVEVALW	d0	;effect plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	
	lea	WIPEI1_Bpl2ptl2II(a2),a0
	CPMOVEVALW	d0	;effect plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC

*;---	
	movea.l	(sp)+,a3		;restore **planeprs
	movea.l	SUDVE_CompBitMapList(a1),a0
	move.w	Wipe1CBML_BottomBM(a0),d0
	add.w	d0,d0
	add.w	d0,d0
	movea.l	0(a3,d0.w),a3	;*PlanePtrs for null line
	move.l	(a3),d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	lea	WIPEI1_Bpl2ptl3I(a2),a0
	CPMOVEVALW	d0	;null plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC

	lea	WIPEI1_Bpl2ptl3II(a2),a0
	CPMOVEVALW	d0	;null plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC

*;----
	movea.l	SUDVE_CompBitMapList(a1),a3
	cmpi.w	#3,Wipe1CBML_MiddleRows(a3)  ;HACK !!!!!!
	bcs.s	14$			;jump if less than 3 lines vert.
	tst.w	Wipe1CBML_MiddleBM(a3)
	bpl.s	15$			;don't wait forever, effect is present

14$	move.w	#(255<<8)!(127<<1)!1,d0	;wait forever
	lea	WIPEI1_wait1I(a2),a0
	CPWAITVAL	d0
	lea	WIPEI1_wait1II(a2),a0
	CPWAITVAL	d0
	bra	666$

*---
* fields I/III
15$	move.w	Wipe1CBML_TopRows(a3),d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
  ori.w		#(0<<1)!1,d0

;;        btst      #8,d0
;;        bne.s     16$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     18$
;;16$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

18$	cmpi.w	#255,d1
	bhi.s	10$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait1I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	12$
	
10$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait1I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
*---
* fields II/IV
12$	move.w	Wipe1CBML_TopRows(a3),d0
	addq.w	#1,d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
   ori.w	#(0<<1)!1,d0

;;       btst      #8,d0
;;        bne.s     36$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     38$
;;36$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

38$	cmpi.w	#255,d1
	bhi.s	30$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait1II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	32$

	
30$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait1II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

*;----
* fields I/III
32$	move.w	Wipe1CBML_TopRows(a3),d0
	add.w	Wipe1CBML_MiddleRows(a3),d0
	subq.w	#1,d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
  ori.w	#(0<<1)!1,d0
 
;;       btst      #8,d0
;;        bne.s     26$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     28$
;;26$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

28$	cmpi.w	#255,d1
	bhi.s	20$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait2I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	42$
	
20$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait2I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

*;----
* fields II/IV
42$	move.w	Wipe1CBML_TopRows(a3),d0
	add.w	Wipe1CBML_MiddleRows(a3),d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
   ori.w	#(0<<1)!1,d0
 
;;      btst      #8,d0
;;       bne.s     46$                  ;jump if odd line
;;       ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;      bra.s     48$
;;46$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

48$	cmpi.w	#255,d1
	bhi.s	40$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait2II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	666$
	
40$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait2II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

666$	movem.l	(sp)+,d0-d1/a0-a3	
	rts

 endc




 ifeq 1
SetUpWipeInterface1	movem.l	d0-d1/a0-a3,-(sp)
	movea.l	a0,a1			;->structure
	movea.l	SUDVE_DBCopLists(a1),a2	;->DBcoplist
	move.w	(a2),d0			;current
	movea.l	DB_Data(a2,d0.w),a2	;->coplist	

	lea	WIPEI1_Spr0pt1(a2),a0
	movea.l	SUDVE_DBSprite0E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite0R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)

	movea.l	SUDVE_DBSprite1R(a1),a3
	move.w	(a3),d1			;current
	movea.l	DB_Data(a3,d1.w),a3	
	move.l	a3,d1
	move.l	#SPRITE1CTRL241,(a3)

	lea	WIPEI1_Spr0pt2I(a2),a0
	CPMOVEVALL	d0
	swap	d0
	CPMOVEVALL	d1
	swap	d1

	lea	WIPEI1_Spr0pt2II(a2),a0
	CPMOVEVALL	d0
	swap	d0
	CPMOVEVALL	d1
	swap	d1

*;----
*;assumes all low/high order bitplane data is each within a 64K block
	movea.l	SUDVE_DBPlanePtrs(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	;**PlanePtrs
	move.l	a3,-(sp)		;save, ->current bitmaps

	movea.l	SUDVE_CompBitMapList(a1),a0
	move.w	Wipe1CBML_TopBM(a0),d0
	add.w	d0,d0
	add.w	d0,d0
	movea.l	0(a3,d0.w),a3	;*PlanePtrs for null line
	move.l	(a3),d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	swap	d0
	lea	WIPEI1_Bpl2pth(a2),a0
	CPMOVEVALW	d0	;bpl2pth

	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0	;bpl4pth
	ENDC

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0	;bpl4pth
	CPMOVEVALW	d0	;bpl6pth
	ENDC

	swap	d0

*;----	
	lea	WIPEI1_Bpl2ptl1I(a2),a0
	CPMOVEVALW	d0	;null plane 0
	
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0
	CPMOVEVALW	d0
	ENDC

	lea	WIPEI1_Bpl2ptl1II(a2),a0
	CPMOVEVALW	d0	;null plane 0
	
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0
	CPMOVEVALW	d0
	ENDC

*;---
* Like with the DVE CBML should I check for MiddleBM = -1 = termination, then
* wait forever after top ????? And also check for effect height = 0. ????? 

	movea.l	(sp),a3		;restore **planeprs
	movea.l	SUDVE_CompBitMapList(a1),a0
	move.w	Wipe1CBML_MiddleBM(a0),d0
	add.w	d0,d0
	add.w	d0,d0
	movea.l	0(a3,d0.w),a3	;*PlanePtrs for null line
	move.l	(a3),d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	lea	WIPEI1_Bpl2ptl2I(a2),a0
	CPMOVEVALW	d0	;effect plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0
	CPMOVEVALW	d0
	ENDC
	
	lea	WIPEI1_Bpl2ptl2II(a2),a0
	CPMOVEVALW	d0	;effect plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0
	CPMOVEVALW	d0
	ENDC

*;---	
	movea.l	(sp)+,a3		;restore **planeprs
	movea.l	SUDVE_CompBitMapList(a1),a0
	move.w	Wipe1CBML_BottomBM(a0),d0
	add.w	d0,d0
	add.w	d0,d0
	movea.l	0(a3,d0.w),a3	;*PlanePtrs for null line
	move.l	(a3),d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	lea	WIPEI1_Bpl2ptl3I(a2),a0
	CPMOVEVALW	d0	;null plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0
	CPMOVEVALW	d0
	ENDC

	lea	WIPEI1_Bpl2ptl3II(a2),a0
	CPMOVEVALW	d0	;null plane 0
	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	d0
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	d0
	CPMOVEVALW	d0
	ENDC

*;----
	movea.l	SUDVE_CompBitMapList(a1),a3
	cmpi.w	#3,Wipe1CBML_MiddleRows(a3)  ;HACK !!!!!!
	bcs.s	14$			;jump if less than 3 lines vert.
	tst.w	Wipe1CBML_MiddleBM(a3)
	bpl.s	15$			;don't wait forever, effect is present

14$	move.w	#(255<<8)!(127<<1)!1,d0	;wait forever
	lea	WIPEI1_wait1I(a2),a0
	CPWAITVAL	d0
	lea	WIPEI1_wait1II(a2),a0
	CPWAITVAL	d0
	bra	666$

*---
* fields I/III
15$	move.w	Wipe1CBML_TopRows(a3),d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
  ori.w		#(0<<1)!1,d0

;;        btst      #8,d0
;;        bne.s     16$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     18$
;;16$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

18$	cmpi.w	#255,d1
	bhi.s	10$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait1I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	12$
	
10$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait1I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
*---
* fields II/IV
12$	move.w	Wipe1CBML_TopRows(a3),d0
	addq.w	#1,d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
   ori.w	#(0<<1)!1,d0

;;       btst      #8,d0
;;        bne.s     36$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     38$
;;36$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

38$	cmpi.w	#255,d1
	bhi.s	30$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait1II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	32$

	
30$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait1II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

*;----
* fields I/III
32$	move.w	Wipe1CBML_TopRows(a3),d0
	add.w	Wipe1CBML_MiddleRows(a3),d0
	subq.w	#1,d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
  ori.w	#(0<<1)!1,d0
 
;;       btst      #8,d0
;;        bne.s     26$                  ;jump if odd line
;;        ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;        bra.s     28$
;;26$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

28$	cmpi.w	#255,d1
	bhi.s	20$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait2I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	42$
	
20$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait2I(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

*;----
* fields II/IV
42$	move.w	Wipe1CBML_TopRows(a3),d0
	add.w	Wipe1CBML_MiddleRows(a3),d0
	lsr.w	#1,d0

	addi.w	#21,d0			;actual wait line	
	move.w	d0,d1			;save actual wait line
	
	lsl.w     #8,d0
   ori.w	#(0<<1)!1,d0
 
;;      btst      #8,d0
;;       bne.s     46$                  ;jump if odd line
;;       ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;      bra.s     48$
;;46$     ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

48$	cmpi.w	#255,d1
	bhi.s	40$		;jump if top below wait 255

	moveq	#1,d1			;wait 0,0
	lea	WIPEI1_wait2II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0
	bra.s	666$
	
40$	move.w	#(255<<8)!(111<<1)!1,d1	;was wait to 255,15 pre 3.0 !!!
	lea	WIPEI1_wait2II(a2),a0
	CPWAITVAL	d1
	CPWAITVAL	d0

666$

********** THE FOLLOWING WAS ADDED JUST BEFORE 4.0 WAS FINISHED !!!!!!!
* Because the following can get stomped on by Sequencing (hides interface)
* I need to make sure it's OK
	lea	WIPEI1_COLORS(a2),a0

*-------
	IFND	AACHIPS
	CPMOVEVALW	#$006		;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#$009		;color02
	ENDC


*-------
	IFD	AACHIPS

	IFEQ	NUMINTERFACEPLANES-2
	CPMOVEVALW	#$000		;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#$000		;color02
	ENDC

	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	#$000		;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#$000		;color02
	ENDC

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	#VThigh00	;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#VThigh00	;color02
	ENDC

	ENDC	;AACHIPS
*-------

	lea	WIPEI1_BPLCON01(a2),a0

	IFND	AACHIPS
	CPMOVEVALW	#%1011000000000000
	ENDC

*-------
	IFD	AACHIPS
	IFEQ	NUMINTERFACEPLANES-2
	AAbplcon0	3,1,0,0		;depth=3, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-3
	AAbplcon0	5,1,0,0		;depth=5, HiRes, non-HAM, no ERSY
	ENDC
	IFEQ	NUMINTERFACEPLANES-6
	AAbplcon0	7,1,0,0		;depth=7, HiRes, non-HAM, no ERSY
	ENDC
	move.w	#AAvalue,d0
	or.w	TB_BPLCON0orBits(a5),d0
	CPMOVEVALW	d0		;modes & # planes
	ENDC	;AACHIPS
*-------
	lea	WIPEI1_BPLCON02(a2),a0

	IFND	AACHIPS
	CPMOVEVALW	#%1011000000000000
	ENDC

	IFD	AACHIPS
	CPMOVEVALW d0		;modes & 2 planes
	ENDC

	movem.l	(sp)+,d0-d1/a0-a3	
	rts
 endc


***********************************************************
* ~SetUpWipeCopList1(->SetUpWipe structure)
* 
* Hacks out Interface.  Still does 2 planes, when we could be
* doing 1 plane, but it's not a problem.  I just didn't want
* to go to all the work to make a completely new copperlist,
* so we're using the WipeInterface1 coplist.

* Set color 0 to that of color 1
* Set color 2 to that of color 3
* Set depth always to 2 planes

SetUpWipeCopList1:
	movem.l	d0/a0-a2,-(sp)
	bsr	SetUpWipeInterface1	;act like its going to show interface

	movea.l	a0,a1			;->structure
	movea.l	SUDVE_DBCopLists(a1),a2	;->DBcoplist
	move.w	(a2),d0			;current
	movea.l	DB_Data(a2,d0.w),a2	;->coplist	

	lea	WIPEI1_COLORS(a2),a0

*-------
	IFND	AACHIPS
	CPMOVEVALW	#$846		;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#$849		;color02
	ENDC


*-------
	IFD	AACHIPS

	IFEQ	NUMINTERFACEPLANES-2
	CPMOVEVALW	#$555		;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#$555		;color02
	ENDC

	IFEQ	NUMINTERFACEPLANES-3
	CPMOVEVALW	#$666		;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#$666		;color02
	ENDC

	IFEQ	NUMINTERFACEPLANES-6
	CPMOVEVALW	#VThigh01	;color00
	addq.w	#4,a0			;skip color01
	CPMOVEVALW	#VThigh01	;color02
	ENDC

	ENDC	;AACHIPS
*-------

	lea	WIPEI1_BPLCON01(a2),a0

	IFND	AACHIPS
	CPMOVEVALW	#%1010000000000000
	ENDC

	IFD	AACHIPS
	AAbplcon0	2,1,0,0		;depth=2, HiRes, non-HAM, no ERSY
	move.w	#AAvalue,d0
	or.w	TB_BPLCON0orBits(a5),d0
	CPMOVEVALW d0		;modes & 2 planes
	ENDC

	lea	WIPEI1_BPLCON02(a2),a0

	IFND	AACHIPS
	CPMOVEVALW	#%1010000000000000
	ENDC

	IFD	AACHIPS
	CPMOVEVALW d0		;modes & 2 planes
	ENDC

	movem.l	(sp)+,d0/a0-a2	
	rts


***********************************************************
* ~InitDVECopList2(->copbuf, ->TB)
*		     a0      a5
	IFD	CCODE
_InitDVECopList2
	move.l	a5,-(sp)
	movem.l	8(sp),a0/a5
	bra.s	InitDVECopList2
	movea.l	(sp)+,a5
	rts
	ENDC

InitDVECopList2:
 	STRUCTURE  DVECopList2,0
 	  movem.l  d0-d2/a0-a1,-(sp)
	  movea.l  a0,a1	       ;save ->copbuff	
 	CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

* Here is the variable header stuff
	LABEL     DVECL2_Spr0pt1
          CPMOVEREGL   spr0pth       ;fill values in later
          CPMOVEREGL   spr1pth

	LABEL	DVECL2_Bpl1pth
          CPMOVEREGW   bpl1pth       ;fill in later
          CPMOVEREGW   bpl2pth       ;fill in later
          CPMOVEREGW   bpl3pth       ;fill in later
          CPMOVEREGW   bpl4pth       ;fill in later

	CPMOVE	0,beamcon0	;make sure beamcon0 is ok, necessary?
	CPMOVE	NEWDENISE,bplcon3 ;fix new Denise right edge problem

	  move.l   a1,d0
	  add.l	   #DVECL2_Body,d0
	  CPMOVERL d0,cop1lc		;->copper list body


	IFD	AACHIPS

	CPMOVE	0,fmode
	CPMOVE	0,bplcon3

          CPMOVE   $514,color00  ;I/G0=1 B/R0=1 G/B2=1 R/R2=1
          CPMOVE   $114,color01  ;I/G0=1 B/R0=1 G/B2=1 R/R2=0
          CPMOVE   $510,color02  ;I/G0=1 B/R0=1 G/B2=0 R/R2=1
          CPMOVE   $110,color03  ;I/G0=1 B/R0=1 G/B2=0 R/R2=0
          CPMOVE   $514,color04  ;I/G0=1 B/R0=0 G/B2=1 R/R2=1
          CPMOVE   $014,color05  ;I/G0=1 B/R0=0 G/B2=1 R/R2=0
          CPMOVE   $510,color06  ;I/G0=1 B/R0=0 G/B2=0 R/R2=1
          CPMOVE   $010,color07  ;I/G0=1 B/R0=0 G/B2=0 R/R2=0
          CPMOVE   $504,color08  ;I/G0=0 B/R0=1 G/B2=1 R/R2=1
          CPMOVE   $104,color09  ;I/G0=0 B/R0=1 G/B2=1 R/R2=0
          CPMOVE   $500,color10  ;I/G0=0 B/R0=1 G/B2=0 R/R2=1
          CPMOVE   $100,color11  ;I/G0=0 B/R0=1 G/B2=0 R/R2=0
          CPMOVE   $404,color12  ;I/G0=0 B/R0=0 G/B2=1 R/R2=1
          CPMOVE   $004,color13  ;I/G0=0 B/R0=0 G/B2=1 R/R2=0
          CPMOVE   $400,color14  ;I/G0=0 B/R0=0 G/B2=0 R/R2=1
          CPMOVE   $000,color15  ;I/G0=0 B/R0=0 G/B2=0 R/R2=0

*;;       CPMOVE   $000,color16	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0 ;transparent
          CPMOVE   $600,color17	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $024,color18	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $624,color19	;I/B1/G0=0 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $101,color20	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $701,color21	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $125,color22	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $725,color23	;I/B1/G0=0 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $012,color24	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $612,color25	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $036,color26	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $636,color27	;I/B1/G0=1 B/B0/R0=0 G/G1/B2=1 R/R1/R2=1
          CPMOVE   $113,color28	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=0
          CPMOVE   $713,color29	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=0 R/R1/R2=1
          CPMOVE   $137,color30	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=0
          CPMOVE   $737,color31	;I/B1/G0=1 B/B0/R0=1 G/G1/B2=1 R/R1/R2=1

	ENDC

	IFND	AACHIPS

*----------------
* I=most sig nibble, B=least sig nibble,  NOTE: The data must be complemented
* G=most sig nibble, R=least sig nibble, of least sig 2 planes
	
;;	IFD	CRAP
          CPMOVE   $889,color00  ;I=1 B=1 G=1 R=1
          CPMOVE   $789,color01  ;I=1 B=1 G=1 R=0
          CPMOVE   $879,color02  ;I=1 B=1 G=0 R=1
          CPMOVE   $779,color03  ;I=1 B=1 G=0 R=0
          CPMOVE   $887,color04  ;I=1 B=0 G=1 R=1
          CPMOVE   $787,color05  ;I=1 B=0 G=1 R=0
          CPMOVE   $877,color06  ;I=1 B=0 G=0 R=1
          CPMOVE   $777,color07  ;I=1 B=0 G=0 R=0
          CPMOVE   $888,color08  ;I=0 B=1 G=1 R=1
          CPMOVE   $788,color09  ;I=0 B=1 G=1 R=0
          CPMOVE   $878,color10  ;I=0 B=1 G=0 R=1
          CPMOVE   $778,color11  ;I=0 B=1 G=0 R=0
          CPMOVE   $886,color12  ;I=0 B=0 G=1 R=1
          CPMOVE   $786,color13  ;I=0 B=0 G=1 R=0
          CPMOVE   $876,color14  ;I=0 B=0 G=0 R=1
          CPMOVE   $776,color15  ;I=0 B=0 G=0 R=0
;;	ENDC

	IFD	CRAP
          CPMOVE   $007,color00  ;I=1 B=1 G=1 R=1
          CPMOVE   $007,color01  ;I=1 B=1 G=1 R=0
          CPMOVE   $007,color02  ;I=1 B=1 G=0 R=1
          CPMOVE   $007,color03  ;I=1 B=1 G=0 R=0
          CPMOVE   $007,color04  ;I=1 B=0 G=1 R=1
          CPMOVE   $007,color05  ;I=1 B=0 G=1 R=0
          CPMOVE   $007,color06  ;I=1 B=0 G=0 R=1
          CPMOVE   $007,color07  ;I=1 B=0 G=0 R=0
          CPMOVE   $000,color08  ;I=0 B=1 G=1 R=1
          CPMOVE   $000,color09  ;I=0 B=1 G=1 R=0
          CPMOVE   $000,color10  ;I=0 B=1 G=0 R=1
          CPMOVE   $000,color11  ;I=0 B=1 G=0 R=0
          CPMOVE   $000,color12  ;I=0 B=0 G=1 R=1
          CPMOVE   $000,color13  ;I=0 B=0 G=1 R=0
          CPMOVE   $000,color14  ;I=0 B=0 G=0 R=1
          CPMOVE   $000,color15  ;I=0 B=0 G=0 R=0
	ENDC

	IFD	CRAP
          CPMOVE   $008,color00  ;I=1 B=1 G=1 R=1
          CPMOVE   $008,color01  ;I=1 B=1 G=1 R=0
          CPMOVE   $008,color02  ;I=1 B=1 G=0 R=1
          CPMOVE   $008,color03  ;I=1 B=1 G=0 R=0
          CPMOVE   $000,color04  ;I=1 B=0 G=1 R=1
          CPMOVE   $000,color05  ;I=1 B=0 G=1 R=0
          CPMOVE   $000,color06  ;I=1 B=0 G=0 R=1
          CPMOVE   $000,color07  ;I=1 B=0 G=0 R=0
          CPMOVE   $008,color08  ;I=0 B=1 G=1 R=1
          CPMOVE   $008,color09  ;I=0 B=1 G=1 R=0
          CPMOVE   $008,color10  ;I=0 B=1 G=0 R=1
          CPMOVE   $008,color11  ;I=0 B=1 G=0 R=0
          CPMOVE   $000,color12  ;I=0 B=0 G=1 R=1
          CPMOVE   $000,color13  ;I=0 B=0 G=1 R=0
          CPMOVE   $000,color14  ;I=0 B=0 G=0 R=1
          CPMOVE   $000,color15  ;I=0 B=0 G=0 R=0
	ENDC

	IFD	CRAP
          CPMOVE   $0f0,color00  ;I=1 B=1 G=1 R=1
          CPMOVE   $0f0,color01  ;I=1 B=1 G=1 R=0
          CPMOVE   $000,color02  ;I=1 B=1 G=0 R=1
          CPMOVE   $000,color03  ;I=1 B=1 G=0 R=0
          CPMOVE   $0f0,color04  ;I=1 B=0 G=1 R=1
          CPMOVE   $0f0,color05  ;I=1 B=0 G=1 R=0
          CPMOVE   $000,color06  ;I=1 B=0 G=0 R=1
          CPMOVE   $000,color07  ;I=1 B=0 G=0 R=0
          CPMOVE   $0f0,color08  ;I=0 B=1 G=1 R=1
          CPMOVE   $0f0,color09  ;I=0 B=1 G=1 R=0
          CPMOVE   $000,color10  ;I=0 B=1 G=0 R=1
          CPMOVE   $000,color11  ;I=0 B=1 G=0 R=0
          CPMOVE   $0f0,color12  ;I=0 B=0 G=1 R=1
          CPMOVE   $0f0,color13  ;I=0 B=0 G=1 R=0
          CPMOVE   $000,color14  ;I=0 B=0 G=0 R=1
          CPMOVE   $000,color15  ;I=0 B=0 G=0 R=0
	ENDC

	IFD	CRAP
          CPMOVE   $f00,color00  ;I=1 B=1 G=1 R=1
          CPMOVE   $000,color01  ;I=1 B=1 G=1 R=0
          CPMOVE   $f00,color02  ;I=1 B=1 G=0 R=1
          CPMOVE   $000,color03  ;I=1 B=1 G=0 R=0
          CPMOVE   $f00,color04  ;I=1 B=0 G=1 R=1
          CPMOVE   $000,color05  ;I=1 B=0 G=1 R=0
          CPMOVE   $f00,color06  ;I=1 B=0 G=0 R=1
          CPMOVE   $000,color07  ;I=1 B=0 G=0 R=0
          CPMOVE   $f00,color08  ;I=0 B=1 G=1 R=1
          CPMOVE   $000,color09  ;I=0 B=1 G=1 R=0
          CPMOVE   $f00,color10  ;I=0 B=1 G=0 R=1
          CPMOVE   $000,color11  ;I=0 B=1 G=0 R=0
          CPMOVE   $f00,color12  ;I=0 B=0 G=1 R=1
          CPMOVE   $000,color13  ;I=0 B=0 G=1 R=0
          CPMOVE   $f00,color14  ;I=0 B=0 G=0 R=1
          CPMOVE   $000,color15  ;I=0 B=0 G=0 R=0
	ENDC

* Low contrast sprite. 
*;;          CPMOVE   $776,color16   I=0 B=0 G=0 R=0 ;transparent
          CPMOVE   $876,color17   ;I=0 B=0 G=0 R=1
          CPMOVE   $786,color18   ;I=0 B=0 G=1 R=0
          CPMOVE   $886,color19   ;I=0 B=0 G=1 R=1
          CPMOVE   $778,color20   ;I=0 B=1 G=0 R=0
          CPMOVE   $878,color21   ;I=0 B=1 G=0 R=1
          CPMOVE   $788,color22   ;I=0 B=1 G=1 R=0
          CPMOVE   $888,color23   ;I=0 B=1 G=1 R=1
          CPMOVE   $777,color24   ;I=1 B=0 G=0 R=0
          CPMOVE   $877,color25   ;I=1 B=0 G=0 R=1
          CPMOVE   $787,color26   ;I=1 B=0 G=1 R=0
          CPMOVE   $887,color27   ;I=1 B=0 G=1 R=1
          CPMOVE   $779,color28   ;I=1 B=1 G=0 R=0
          CPMOVE   $879,color29   ;I=1 B=1 G=0 R=1
          CPMOVE   $789,color30   ;I=1 B=1 G=1 R=0
          CPMOVE   $889,color31   ;I=1 B=1 G=1 R=1

	ENDC

          CPMOVE   ((21<<8)!92),diwstrt
          CPMOVE   (((262<<8)&$ff00)!(458-256)),diwstop
          CPMOVE   ((64>>1)&$fc),ddfstrt
          CPMOVE   ((424>>1)&$fc),ddfstop
          CPMOVE   ((7<<4)!7),bplcon1   ;scroll
          CPMOVE   -96,bpl1mod
          CPMOVE   -96,bpl2mod
          CPMOVE   $24,bplcon2         ;sprite priority over bm

	  CPMOVE   0,copjmp1		;jump to body
*;---------------------------------------------------------
	LABEL	DVECL2_Main
	  CPMOVE   INTF_SETCLR!INTF_COPER,intreq        ;copper interrupt = flag start

	LABEL     DVECL2_Spr0pt2
          CPMOVEREGL   spr0pth       ;fill values in later, freeze/live
          CPMOVEREGL   spr1pth	    ;usually same as Spr1pt1		

*;---------
	LABEL	DVECL2_Body
 	  move.l   a1,d0
	  add.l	   #DVECL2_Main,d0
	  CPMOVERL d0,cop1lc		;->main copper list

	STRUCT     DVECL2_Spr2pt,4*12
	  move.l   TB_EffectsBase+EFB_SpriteData(a5),d0
	  add.l	   #ESD_SpriteNull,d0	

	  move.w   #spr2pth,d1
	  moveq	   #5,d2		;null out sprites 2-7	  	  
10$	  move.w   d1,(a0)+
	  swap	   d0		;msw	
	  move.w   d0,(a0)+

          addq.w   #2,d1
          move.w   d1,(a0)+
          swap     d0		;lsw
	  move.w   d0,(a0)+

          addq.w   #2,d1
	  dbra	   d2,10$
*;---------

	LABEL     DVECL2_Bpl1ptl1
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line

;;* had this up upto 3.1          CPWAIT   21,0

	move.w	#%1100000000000000,d0
	or.w	TB_BPLCON0orBits(a5),d0
	CPMOVERW d0,bplcon0		;modes & 4 planes

	LABEL DVECL2_wait1
	    CPWAITNOPL
*          CPWAIT   255,111      ;make 255,111 or 0,0 or forever
*          CPWAIT   0,0          ;fill in later

	LABEL     DVECL2_Bpl1ptl2
          CPMOVEREGW   bpl1ptl       ;fill in later, effect line
          CPMOVEREGW   bpl2ptl       ;fill in later, effect line
          CPMOVEREGW   bpl3ptl       ;fill in later, effect line
          CPMOVEREGW   bpl4ptl       ;fill in later, effect line

	LABEL DVECL2_wait2
	    CPWAITNOPL
*          CPWAIT   255,111      ;make 255,111 or 0,0 later
*          CPWAIT   0,0          ;fill in later

	LABEL     DVECL2_Bpl1ptl3
          CPMOVEREGW   bpl1ptl       ;fill in later, null line
          CPMOVEREGW   bpl2ptl       ;fill in later, null line
          CPMOVEREGW   bpl3ptl       ;fill in later, null line
          CPMOVEREGW   bpl4ptl       ;fill in later, null line

*;I don't think there's anything to gain by turning off DMA here = 0 planes

            CPEND

	movem.l	(sp)+,d0-d2/a0-a1
	rts

	LABEL	DVECL2_SIZEOF
	
***********************************************************
* ~SetUpDVECopList2(->SetUpDVE structure)

	IFD	CCODE
_SetUpDVECopList2	movea.l	4(sp),a0
	ENDC
	
SetUpDVECopList2	movem.l	d0-d3/a0-a3,-(sp)
	movea.l	a0,a1			;->structure
	movea.l	SUDVE_DBCopLists(a1),a2	;->DBcoplist
	move.w	(a2),d0			;current
	movea.l	DB_Data(a2,d0.w),a2	;->coplist	

	lea	DVECL2_Spr0pt1(a2),a0
	movea.l	SUDVE_DBSprite0E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1E(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

	lea	DVECL2_Spr0pt2(a2),a0
	movea.l	SUDVE_DBSprite0R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE0CTRL241,(a3)
	CPMOVEVALL	d0

	movea.l	SUDVE_DBSprite1R(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	
	move.l	a3,d0
	move.l	#SPRITE1CTRL241,(a3)
	CPMOVEVALL	d0

*;----
	lea	DVECL2_Bpl1pth(a2),a0
	movea.l	SUDVE_DBPlanePtrs(a1),a3
	move.w	(a3),d0			;current
	movea.l	DB_Data(a3,d0.w),a3	;**PlanePtrs
	move.l	a3,-(sp)		;save

	movea.l	(a3),a3			;*PlanePtrs for null line
	move.l	(a3)+,d0		;planeptr plane 0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,d1		;null plane0 lsw
	swap	d0
	CPMOVEVALW	d0	;bpl1pth
	move.l	(a3)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,d2
	swap	d0
	CPMOVEVALW	d0	;bpl2pth
	move.l	(a3)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	move.w	d0,d3
	swap	d0
	CPMOVEVALW	d0	;bpl3pth
	move.l	(a3),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	swap	d0
	CPMOVEVALW	d0	;bpl4pth
	swap	d0		;null plane3 lsw
	
	lea	DVECL2_Bpl1ptl1(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d2	;null plane 1
	CPMOVEVALW	d3	;null plane 2
	CPMOVEVALW	d0	;null plane 3
	
	lea	DVECL2_Bpl1ptl3(a2),a0
	CPMOVEVALW	d1	;null plane 0
	CPMOVEVALW	d2	;null plane 1
	CPMOVEVALW	d3	;null plane 2
	CPMOVEVALW	d0	;null plane 3

	lea	DVECL2_Bpl1ptl2(a2),a0
	movea.l	(sp)+,a3	;restore **planeprs
	movea.l	4(a3),a3	;*Planeptrs for effect planes
	move.l	(a3)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 0
	move.l	(a3)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 1
	move.l	(a3)+,d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 2
	move.l	(a3),d0

	IFND	AACHIPS
	subq.l	#4,d0
	ENDC

	CPMOVEVALW	d0	;effect plane 3
	
*;----
	lea	DVECL2_wait1(a2),a0
	movea.l	SUDVE_CompBitMapList(a1),a3
	tst.b	DVE1CBML_MiddleBM(a3)
	bmi.s	5$			;wait forever, only top given
	tst.b	DVE1CBML_MiddleRows(a3)
	beq.s	5$			;wait forever, effect not present

	moveq	#0,d0
	move.b	DVE1CBML_TopRows(a3),d0
	addi.w	#21,d0			;actual wait line	
	cmpi.w	#255,d0
	bhi.s	10$		;jump if top below wait 255
	CPWAITVAL	#1	;wait 0,0
	bra.s	12$

5$	CPWAITVAL	#((255<<8)!(127<<1)!1)   ;wait forever
	bra.s		666$

	
10$	CPWAITVAL	#((255<<8)!(15<<1)!1)   ;wait to 255,15

12$       lsl.w     #8,d0
			 ori.w	#(0<<1)!1,d0

;;          btst      #8,d0
;;          bne.s     16$                  ;jump if odd line
;;          ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;          bra.s     18$
;;16$       ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

18$       CPWAITVAL d0		         ;wait to top of effect
	
*;----
	lea	DVECL2_wait2(a2),a0
	moveq	#0,d0	
	move.b	DVE1CBML_TopRows(a3),d0
	add.b	DVE1CBML_MiddleRows(a3),d0

	addi.w	#21,d0			;actual wait line	
	cmpi.w	#255,d0
	bhi.s	20$		;jump if top below wait 255
	CPWAITVAL	#1	;wait 0,0
	bra.s	22$	
20$	CPWAITVAL	#((255<<8)!(15<<1)!1)   ;wait to 255,111
        andi.w    #$ff,d0

22$       lsl.w     #8,d0
			 ori.w	#(0<<1)!1,d0

;;          btst      #8,d0
;;         bne.s     26$                  ;jump if odd line
;;          ori.w     #(12<<1)!1,d0        ;must be between 0 and 12
;;          bra.s     28$
;;26$       ori.w     #((140<<1)&$ff)!1,d0 ;must be between 111 and 140

28$       CPWAITVAL d0		         ;wait to top of effect
	

666$	movem.l	(sp)+,d0-d3/a0-a3	
	rts

***************************************************

	STRUCTURE	CopperBuffs,0
*CopperListData
	  STRUCT	CB_DVECopList1A,DVECL1_SIZEOF	
	  STRUCT	CB_DVECopList1B,DVECL1_SIZEOF	

	  STRUCT	CB_DVECopList2A,DVECL2_SIZEOF	
	  STRUCT	CB_DVECopList2B,DVECL2_SIZEOF	

	  STRUCT	CB_DVEInterface1A,DVEI1_SIZEOF
	  STRUCT	CB_DVEInterface1B,DVEI1_SIZEOF

	  STRUCT	CB_WipeInterface1A,WIPEI1_SIZEOF
	  STRUCT	CB_WipeInterface1B,WIPEI1_SIZEOF


	LABEL	CB_SIZEOF


*******************************************************
* ~MemoryMapCopLists(->TB)
*		     a5

	IFD	CCODE
_MemoryMapCopLists	move.l	a5,-(sp)
			movea.l	8(sp),a5
			bra.s	MemoryMapCopLists
			movea.l	(sp)+,a5
			rts
	ENDC

MemoryMapCopLists movem.l	a0-a1,-(sp)

	GET.l	TB_CHIPMem,a0
	adda.l	TB_CHIPMemSIZE(a5),a0	;->Top of memory + 1
	suba.l	#TB_CHIPMEMBLOCKSIZE*2,a0 ;below frameload buffer

	lea	-(ECD_SIZEOF+CB_SIZEOF)(a0),a0

	lea	CB_DVECopList1A(a0),a1
	move.l	a1,TB_EffectsBase+EFB_DVE1CopLists+DB_DataA(a5)
		
	lea	CB_DVECopList1B(a0),a1
	move.l	a1,TB_EffectsBase+EFB_DVE1CopLists+DB_DataB(a5)
		
	lea	CB_DVECopList2A(a0),a1
	move.l	a1,TB_EffectsBase+EFB_DVE2CopLists+DB_DataA(a5)
		
	lea	CB_DVECopList2B(a0),a1
	move.l	a1,TB_EffectsBase+EFB_DVE2CopLists+DB_DataB(a5)

	lea	CB_DVEInterface1A(a0),a1
	move.l	a1,TB_EffectsBase+EFB_DVEI1CopLists+DB_DataA(a5)
		
	lea	CB_DVEInterface1B(a0),a1
	move.l	a1,TB_EffectsBase+EFB_DVEI1CopLists+DB_DataB(a5)
		
	lea	CB_WipeInterface1A(a0),a1
	move.l	a1,TB_EffectsBase+EFB_WipeI1CopLists+DB_DataA(a5)
		
	lea	CB_WipeInterface1B(a0),a1
	move.l	a1,TB_EffectsBase+EFB_WipeI1CopLists+DB_DataB(a5)
		
	movem.l	(sp)+,a0-a1
	rts

*********************************************************
* ~MemoryMapPlanes(->TB)
*		     a5

	IFND	AACHIPS
PlaneOffset	set	4
	ENDC
	
	IFD	AACHIPS
PlaneOffset	set	0
	ENDC

MemoryMapPlanes movem.l	d0-d2/a0-a1,-(sp)
	GET.l	TB_CHIPMem,d0
	add.l	TB_CHIPMemSIZE(a5),d0	;->Top of memory + 1
	sub.l	#((TB_CHIPMEMBLOCKSIZE*2)+ECD_SIZEOF+CB_SIZEOF+BMBYTESPERROW+PlaneOffset),d0
	andi.l	#~7,d0		 ;Double Long Word Align to lower address
	move.l	#BMBYTESPERROW,d1

	movea.l	d0,a0	;possible address for 1st plane ptr
	move.l	d1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneLA(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneLA(a5)
	sub.l	d1,d0
	
	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane
	
	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneLB(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneLB(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneL2A(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneL2A(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneL2B(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneL2B(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneHA(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneHA(a5)
	sub.l	d1,d0
	
	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane
	
	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneHB(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneHB(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneH2A(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneH2A(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	d1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0PlaneH2B(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1PlaneH2B(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	#BMBYTESPERROW<<1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0Wipe1A(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1Wipe1A(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM2Wipe1A(a5)
	sub.l	d1,d0

	IFND	AACHIPS
	subq.l	#PlaneOffset,d0
	ENDC

	movea.l	d0,a0
	move.l	#BMBYTESPERROW<<1,d0
	bsr	FindNextPlane

	IFND	AACHIPS
	addq.l	#PlaneOffset,d0
	ENDC

	move.l	d0,TB_EffectsBase+EFB_BM0Wipe1B(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM1Wipe1B(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_BM2Wipe1B(a5)

	move.l	#READPLANESIZE,d1
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_ReadPlane0A(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_ReadPlane1A(a5)

* The following 4 scanlines are only used during Toaster startup.
* They are used by ReadScatter in the AutoHue routines.
	move.l	#BMBYTESPERROW,d1
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_ReadPlane0B(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_ReadPlane1B(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_ReadPlane0C(a5)
	sub.l	d1,d0
	move.l	d0,TB_EffectsBase+EFB_ReadPlane1C(a5)
	
	subq.l	#2,d0	;allow for cleared word under sprite
	move.l	d0,TB_EffectsBase+EFB_CHIPDataMem(a5)

	movem.l	(sp)+,d0-d2/a0-a1
	rts

*----------------------------------------
* a0 = current copper plane pointer
* d0 = Chunk size for a plane that is all within a 64K memory boundry
* returns d0 = base to use for copper pointer
FindNextPlane
	movem.l	d1/a0,-(sp)
	exg	d0,a0	;d0 = upper cop planeptr, a0 = size
	move.l	d0,d1	;d1 = upper cop planeptr
	sub.l	a0,d1	;d1 = lower ptr
	swap	d1
	swap	d0
	cmp.w	d1,d0
	beq.s	10$	;jump if within 64K block
	
	move.w	#$fff8,d0	;top of next lowest 64K block	
				;double line word aligned
	swap	d0
	move.w	d1,d0

10$	swap	d0	;upper cop ptr to use

	movem.l	(sp)+,d1/a0
	rts

***************************************************************
* ~AttachSprite0(->CopList, ->SpriteTable, ->Sprite0)
*                   a0         a1           a2
* ->CopList usually = TB_CurrentCopList
* ->SpriteTable usually = TB_CurrentSpriteTable = TB_CurrentSpr0Tbl

AttachSprite0:
	movem.l	d0-d1/a1-a2,-(sp)
	move.l	a2,d0

	lea	  _custom,a2
	CALLTL	AllInterruptsOff
5$	move.b	vhposr(a2),d1
	cmpi.b	#3,d1	;needs to be about at least line 3
	bcs.s	5$	;jump if too near field start

10$	move.w	(a1)+,d1
	beq.s	100$
	move.w	d0,6(a0,d1.w)
	swap	d0
	move.w	d0,2(a0,d1.w)	
	swap	d0
	bra.s	10$	

100$	CALLTL	AllInterruptsOn
	movem.l	(sp)+,d0-d1/a1-a2
	rts

***************************************************************
* ~AttachSprite1(->CopList, ->SpriteTable, ->Sprite1)
*                   a0         a1           a2
* ->CopList usually = TB_CurrentCopList
* ->SpriteTable usually = TB_CurrentSpriteTable = TB_CurrentSpr0Tbl

AttachSprite1:
	movem.l	d0-d1/a1-a2,-(sp)
	move.l	a2,d0

	lea	  _custom,a2
	CALLTL	AllInterruptsOff
5$	move.b	vhposr(a2),d1
	cmpi.b	#3,d1	;needs to be about at least line 3
	bcs.s	5$	;jump if too near field start

10$	move.w	(a1)+,d1
	beq.s	100$
	move.w	d0,14(a0,d1.w)
	swap	d0
	move.w	d0,10(a0,d1.w)	
	swap	d0
	bra.s	10$	

100$	CALLTL	AllInterruptsOn
	movem.l	(sp)+,d0-d1/a1-a2
	rts

***************************************************************
* ~AttachSprites(->CopList, ->SpriteTable, ->Sprite0, ->Sprite1)
*                   a0         a1             a2	 a3
* ->CopList usually = TB_CurrentCopList
* ->SpriteTable usually = TB_CurrentSpriteTable = TB_CurrentSpr0Tbl

AttachSprites:
	movem.l	d0-d2/a1-a2,-(sp)
	move.l	a2,d0
	move.l	a3,d1

	lea	  _custom,a2
	CALLTL	AllInterruptsOff
5$	move.b	vhposr(a2),d2
	cmpi.b	#3,d2	;needs to be about at least line 3
	bcs.s	5$	;jump if too near field start

10$	move.w	(a1)+,d2
	beq.s	100$
	move.w	d0,6(a0,d2.w)
	move.w	d1,14(a0,d2.w)
	swap	d0
	swap	d1
	move.w	d0,2(a0,d2.w)	
	move.w	d1,10(a0,d2.w)	
	swap	d0
	swap	d1
	bra.s	10$	

100$	CALLTL	AllInterruptsOn
	movem.l	(sp)+,d0-d2/a1-a2
	rts

***************************************************************
* hardware color = ~Soft2HardColor(software color)
* "Software" colors have this nibble format: 0  0 RH RL GH GL BH BL
* "Hardware" colors have this nibble format: 0 RH GH BH  0 RL GL BL
* In both formats bit 31 is the genlock transparency bit.
* NOTE: This routine could use some optimization!! 

Soft2HardColor:
	movem.l	d1-d2,-(sp)

	move.l	d0,d1	;BL ok
	bpl.s	10$
	bset.l	#27,d0		;genlock transparent bit

10$	lsr.l	#4,d0	;BH ok

	move.w	d0,d2
	andi.w	#$0f0,d2
	andi.w	#$00f,d1
	or.w	d2,d1	;GL ok
	
	move.w	d0,d2
	lsr.w	#4,d2
	andi.w	#$f00,d2
	or.w	d2,d1	;RL ok

	move.l	d0,d2
	lsl.w	#4,d2
	lsr.l	#8,d2
	andi.w	#$8ff0,d2
	andi.w	#$00f,d0
	or.w	d2,d0	;RH & GH ok
	
	swap	d0
	move.w	d1,d0

	movem.l	(sp)+,d1-d2
	rts

**************************************************************

	ALLDUMPS

**************************************************************
	SECTION	,DATA

CompRSLPalFlag	dc.w	0

	IFD	DEBUGDSW
DoSafeCount	dc.l	0
dswdebug	dc.b	0
		ds.b	3
	ENDC	;DEBUGDSW

**************************************************************
* AVE things XREFed above

	XREF	TwoFI_ISPR,TwoFI_IISPR

* These spr0 tables are used by the FreezeThaw routine via TB_CurrentSpr0Tbl

AVEspr0Tbl	dc.w	4	;entry sprites
		dc.w	AVESPR	;repeat sprites
		dc.w	0

AVEIspr0Tbl	dc.w	4	 ;entry sprites
		dc.w	AVEISPR1 ;repeat sprites	
		dc.w	AVEISPR2
		dc.w	0

DVEspr0Tbl	dc.w	DVECL1_Spr0pt1 ;entry
		dc.w	DVECL1_Spr0pt2 ;repeat
		dc.w	0

DVE2spr0Tbl	dc.w	DVECL2_Spr0pt1
		dc.w	DVECL2_Spr0pt2
		dc.w	0

DVEIspr0Tbl	dc.w	DVEI1_Spr0pt1
		dc.w	DVEI1_Spr0pt2I
		dc.w	DVEI1_Spr0pt2II
		dc.w	0

WipeIspr0Tbl	dc.w	WIPEI1_Spr0pt1
		dc.w	WIPEI1_Spr0pt2I
		dc.w	WIPEI1_Spr0pt2II
		dc.w	0

SBMsprTbl	dc.w	4	
		dc.w	SBMSPR
		dc.w	SBMSPRb
		dc.w	0

TwoFIspr0Tbl	dc.w	4	
		dc.w	TwoFI_ISPR
		dc.w	TwoFI_IISPR
		dc.w	0

********************************************************************
* FourFieldTBL structure
WipeIFourFieldTBL dc.l	WIPEI1_LATCH
		  dc.l	WIPEI1_IBody
		  dc.l	WIPEI1_IIBody
		  dc.l	WIPEI1_IBody
		  dc.l	WIPEI1_IIBody

DVEIFourFieldTBL  dc.l	DVEI1_LATCH
		  dc.l	DVEI1_IBody
		  dc.l	DVEI1_IIBody
		  dc.l	DVEI1_IBody
		  dc.l	DVEI1_IIBody

 XREF AVE_LATCH,AVE_BODY
 XREF AVEI_LATCH
;; XREF AVEI_IBODY,AVEI_IIBODY
 XREF TwoFI_LATCH,TwoFI_IBODY,TwoFI_IIBODY
 XREF SBM_LATCH,SBM_IBODY,SBM_IIBODY

AVEFourFieldTBL   dc.l	AVE_LATCH
		  dc.l	AVE_BODY
		  dc.l	AVE_BODY
		  dc.l	AVE_BODY
		  dc.l	AVE_BODY

AVEIFourFieldTBL  dc.l	AVEI_LATCH
		  dc.l	AVEI_IBODY
		  dc.l	AVEI_IIBODY
		  dc.l	AVEI_IBODY
		  dc.l	AVEI_IIBODY

TwoFI4FieldTBL    dc.l	TwoFI_LATCH
		  dc.l	TwoFI_IBODY
		  dc.l	TwoFI_IIBODY
		  dc.l	TwoFI_IBODY
		  dc.l	TwoFI_IIBODY

SBM4FieldTBL      dc.l	SBM_LATCH
		  dc.l	SBM_IBODY
		  dc.l	SBM_IIBODY
		  dc.l	SBM_IBODY
		  dc.l	SBM_IIBODY

	END
