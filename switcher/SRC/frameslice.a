********************************************************************
* frameslice.a
*
* Copyright C1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved. 
*
* $Id: frameslice.a,v 2.67 1997/04/02 16:06:10 Holt Exp $
*
* $Log: frameslice.a,v $
*Revision 2.67  1997/04/02  16:06:10  Holt
*fixed null named framestore save problem
*
*Revision 2.66  1996/02/06  16:23:02  Holt
*Add more lines to the init memory at bottom of screen.
*.,
*,
*
*Revision 2.65  1996/02/01  17:31:01  Holt
*Clearing top and bottom of buffer on 400 line frame load.
*
*Revision 2.64  1995/12/13  17:48:08  Holt
*fixed reallydosave so it deletes the partial file if an error occours
*
*Revision 2.63  1995/11/13  12:18:22  Holt
*working on making freeze/unfreeze more logical
*
*Revision 2.62  1995/08/03  18:06:35  Holt
*made ham-anim croutons work.
*
*Revision 2.61  1995/06/14  09:44:15  Holt
*had to add 8 to vt_setup to get proper offset to main row setup.
*
*Revision 2.60  1995/06/09  16:04:42  Holt
*fixed problem with fsname string overwriteing address pointer
*
*Revision 2.59  1995/02/28  23:50:00  Holt
*added ReallyProcessSaveButton.
*needs error handling.
*
*Revision 2.58  1995/02/26  16:28:33  Holt
*turned off debug.
*
*Revision 2.57  1995/02/24  18:50:14  Holt
*checked in so pat can work on it.
*
*Revision 2.56  1995/02/16  20:50:31  Kell
*Can load Frames with AlphaUp, or kill Alpha if necessary for display write space, or load bank.  Framewriting now writes 6 sets of data lines instead of 5.  Saving frames or grabbing icons from bank now can KillAlphaKey.
*
*Revision 2.55  1995/01/24  11:55:04  Kell
*Commented out some debugs.
*
*Revision 2.54  1994/12/23  03:29:46  Kell
*New default TAGs for the hardcoded crouton.
*
*Revision 2.53  1994/08/08  19:01:10  Holt
*fixed problem with memory allocation and embeded icons.
*
*Revision 2.52  94/08/05  16:55:26  Holt
*added new iconsaving, apending to end of file and remoded PIconSave.
*
*Revision 2.51  94/07/27  19:24:46  Kell
**** empty log message ***
*
*Revision 2.50  1994/07/26  15:56:42  Holt
**** empty log message ***
*
*Revision 2.49  94/07/26  15:46:04  Holt
*fixed singlelinedecode to work in any field.
*
*Revision 2.48  94/07/19  16:42:30  Holt
* corrected problem with icon decoding.            
*
*Revision 2.47  94/07/18  15:46:03  Holt
*Added test for MKPiconrgb
*
*Revision 2.46  94/07/17  17:13:59  Holt
*added support for icon only graber - GrabIcon
*
*Revision 2.45  94/07/16  00:26:12  Holt
*Changed call to Pconsave to account for CrUD data prameters.
*
*Revision 2.44  94/07/14  00:57:43  Holt
**** empty log message ***
*
*Revision 2.43  94/05/27  15:13:38  Holt
*fixed some IsRMBup calls that were not using ToasterBase.
*
*Revision 2.42  94/05/24  22:34:57  Kell
**** empty log message ***
*
*Revision 2.41  94/05/09  21:04:01  Holt
*added icon genaration to field saves.
*
*Revision 2.40  94/05/05  17:48:34  Holt
*added icon saving to framesave
*
*Revision 2.39  94/04/25  14:27:42  Kell
**** empty log message ***
*
*Revision 2.38  94/02/07  15:54:40  Kell
*Various changes to support the new 4.0 croutons & projects.
*
*Revision 2.37  93/12/07  02:15:07  Turcotte
**** empty log message ***
*
*Revision 2.36  93/11/06  08:42:23  Kell
*Fixed to work with EF_EffectsLogic, EF_EffectsTable, EF_TimeVariables and EF_VariableResults no longer being embedded within EFXBase.
*
*Revision 2.35  93/10/29  03:38:33  Kell
*Framegrabbing Abort now calls TB function instead of looking at hardware.
*
*Revision 2.34  93/10/23  05:40:04  Kell
*Now calls CaliReadScanLine instead of doing extra TestReadScanLines.
*
*Revision 2.34  93/09/29  18:06:08  Kell
**** empty log message ***
*
*Revision 2.33  93/06/09  18:53:28  Turcotte
*Fixed problem with number of args not being checked.
*
*Revision 2.32  93/06/09  18:12:48  Turcotte
**** empty log message ***
*
*Revision 2.31  93/06/09  14:13:11  Turcotte
*Added 1 field save.
*
*Revision 2.30  93/06/07  19:02:13  Turcotte
**** empty log message ***
*
*Revision 2.29  93/06/06  22:18:35  Turcotte
**** empty log message ***
*
*Revision 2.28  93/06/06  17:31:00  Turcotte
**** empty log message ***
*
*Revision 2.27  93/06/06  01:50:14  Turcotte
**** empty log message ***
*
*Revision 2.26  93/06/04  21:45:45  Turcotte
**** empty log message ***
*
*Revision 2.25  93/06/02  06:01:04  Turcotte
**** empty log message ***
*
*Revision 2.24  93/05/31  18:38:08  Turcotte
**** empty log message ***
*
*Revision 2.23  93/05/31  11:08:31  Turcotte
**** empty log message ***
*
*Revision 2.22  93/05/24  22:26:22  Turcotte
**** empty log message ***
*
*Revision 2.21  93/05/20  18:04:20  Turcotte
**** empty log message ***
*
*Revision 2.20  93/05/20  04:42:25  Turcotte
**** empty log message ***
*
*Revision 2.19  93/05/14  11:01:19  Turcotte
**** empty log message ***
*
*Revision 2.18  93/05/13  17:19:51  Turcotte
**** empty log message ***
*
*Revision 2.17  93/05/12  23:00:46  Turcotte
**** empty log message ***
*
*Revision 2.16  93/05/12  22:42:27  Kell
*makeserver
*
*Revision 2.15  93/05/12  22:16:47  Turcotte
**** empty log message ***
*
*Revision 2.13  93/05/12  21:28:03  Turcotte
**** empty log message ***
*
*Revision 2.12  93/05/12  16:09:44  Kell
*Fixed postview anims to 30 frames/sec
*
*Revision 2.10  93/05/12  13:51:16  Turcotte
**** empty log message ***
*
*Revision 2.9  93/05/12  09:04:11  Kell
*Added Postview crouton.  Fixed some things in the Preview crouton.
*
*Revision 2.8  93/05/05  00:16:49  Turcotte
**** empty log message ***
*
*Revision 2.7  93/04/18  07:11:13  Kell
**** empty log message ***
*
*Revision 2.6  93/04/17  21:10:15  Turcotte
**** empty log message ***
*
*Revision 2.5  93/04/03  11:14:42  Kell
*Surrounded wait to line 21 with AllInterrupts off before coplist is installed.
*
*Revision 2.4  93/03/25  02:07:30  Turcotte
**** empty log message ***
*
*Revision 2.3  93/02/14  19:34:59  Kell
**** empty log message ***
*
*Revision 2.2  93/02/14  17:59:59  Turcotte
*AA DLWORD for bitmap fix.
*
*Revision 2.1  93/02/13  05:33:42  Kell
*On AA Machines frame loading will always do zipper writing now.
*We need a parameter for this, instead of looking at the BM width.
*
*Revision 2.0  92/05/18  21:35:18  Turcotte
**** empty log message ***
*
*********************************************************************
********************************************************************
* FrameSlice.a - ProcessSaveButton, ProcessLoadButton
*
* HISTORY	NAME		DESCRIPTION
* -------	-----------	-------------------------------------
* 11-20-89	Junior		Created this file
* 11-29-89	Speier		Removed "ProcessGrabButton" from this
*						source module - removed FG state
*						processing code since these routines
*						are now hosted by the NumPad FG system
* 1989-1990	SKell		General Mass reorganization, and messing around.
* 3-6-90	Junior		Eliminated references to "toefonts:", calls LockFS(),
*						Fixed bugs in error handling
* 3-7-90	Junior		Added file comment handling
* 4-26-90	Speier		Removed DisplayMessageAndWait() calls and
*				replaced them with an equivalent routine that
*				also keeps the ToasterBase disk system
*				updated
* 5-1-90	Speier		Fixes because of change to
*				DoSwitcherRequester().
* 5-8-90	Speier		Added support to saving FrameStores, now
*				warns the user of overwrites and will format
*				bad floppies if so requested by the user.
* 7/30/90	Speier		Fixed free memory checking on RAM: device on
*				frame saving. Revised misleading
*				documentation.
* 8/11/90	Ken		changed grabing to use 680xx compatible code
* 8/26/90	Ken		Added dezipper code.
* 9/26/90	Speier		Fixed save FrameStore after formatting
*				floppy bug.
* 10/12/90	Speier		Small bug fixes/code cleanup. Another
*				general reorganization of the code and
*				documentation in an attempt to make it
*				coherent.
* 11/16/90	Speier		Added temp fix for snow to color Matte
*				problem
* 11-23-90	Junior	Changed FrameLoad(),FrameSave() so they do not
*					assume switcher is running
* 01/30/91	Speier		Added the capability to abort FrameStore
*				saving in the routines DoOldGrab() and
*				DoNewGrab() by holding down the right mouse
*				button.
* 04/16/91	Speier		In responce to Tech Support - removed the
*				test messages accidently left in.
*********************************************************************
	include "assembler.i"
	include "exec/types.i"
	include	"exec/memory.i"
	include	"exec/execbase.i"
	include "graphics/gfx.i"
	include "graphics/text.i"
	include "libraries/dos.i"
	include	"hardware/custom.i"
	INCLUDE "rexx/rxslib.i"		;includes modified storage.i

	include "lib/dos_lib.i"
	include "lib/graphics_lib.i"
	include "lib/exec_lib.i"

	include "smallmacros.i"
	include	"frameio.i"
	include "instinct.i"
	include	"custom.i"
	include "elh.i"
	include "vthand.i"
	include "vtdebug.i"

;	include "Commonrgb.i"
	include	"serialdebug.i"
	include "Commonrgbprivate.i"
	include "FrameLoad.i"

	include	"eflib.i"
	include	"croutons.i"
	include "AnimFXtable.i"
	INCLUDE	"lib/intuition_lib.i"


;;SERDEBUG EQU 1
	ALLDUMPS


;;NOCALI	SET	1
;;NEGCOLORS	SET	1

* size of string arrays in switcher's table
COMMENT_SIZE	equ	14

	xref	IFFComment
	XREF	_ToasterBase

nozip1	equ	729
nozip2	equ	731
nozipdest equ	735

oldnozip1	equ	182+189
oldnozip2	equ	182+189+189+189
oldnozipdest	equ	183+189+189+189

shiftlastback	equ	3
*shiftlastback	equ	2			;for old toasters

CHECK_ABORT	MACRO
;;	btst.b	#6,$BFE001	;old lmb abort (killed)

;;	btst.b	#10-8,CHIPBASE+potinp
	CALLTL	IsRMBup

	IFC	'\0','W'
	beq	\1
	MEXIT
	ENDC
	beq.\0	\1
	ENDM

	section	,code




******* ToasterLibrary/ReallyProcessSaveButton *********************************
*
*   NAME   
*	ReallyProcessSaveButton -- Handle user frame save stuff.
*
*   SYNOPSIS
*	Error = ReallyProcessSaveButton(NumberOfFileds,Filepathname)
*	d0                              d0             a0	   
*   FUNCTION
*
*   INPUTS
*	NumberOfFileds	0 - ask user
*			1 - field
*	                2 - frame
*	                3 - 4 field
*   RESULT
*	0 Things were cool, 1 there was an error.
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	
*****************************************************************************
ReallyProcessSaveButton:
	XDEF	ReallyProcessSaveButton
	SAVE	d0-d6/a0-a6

	move.l	a0,a4
	move.l	d0,d4
	DUMPREG	<ReallyProcessSaveButton>	
	CALLTL	KillAlphaKey
	XCALL	NoTransFreeze		; assure Switcher in a good state
	DUMPMSG	<ReallyProcessSaveButton>
	DUMPMEM	<ReallyprocesssaveB,framename>,(A0),#64
	cmp.b	#3,d4
	beq	.frame
	moveq	#1,d1
	bsr	FieldSave
	bra 	.end
.frame
	bsr	FrameSave

.end	
	move.l	d0,d6			; save return code ptr to text
;	DUMPREG	<after frame is saved look for error?>

	CALLTL	ReDoDisplay		; fix CHIP memory
	XCALL	InstallAVEI		; install interface copper list
	XCALL	InitDVEFastMem		; fix FAST memory
	move.l	d6,(sp)			;return error
	tst.l	d6
	beq	.noerror
.ExitFail:
*
;	lea	TextNotEnoughRoom1(a3),a0
;	DUMPREG	<comp. error msg addresses,d6,a0>
;	cmp.l	d6,a0
;	bne	.notdrivefull

;	DUMPMSG	<deleting file>
	move.l	a4,d1
	move.l	TB_DOSBase(a5),a6

	XSYS	DeleteFile

.notdrivefull
 ifeq 1			; when error req comesup, it's behind editor boom! don't go there
	CLEAR	d0
	move.l	d0,FrameSliceError1(a3)		; clear error status
	move.l	d0,FrameSliceError2(a3)

*
	lea.l	TextDeviceError1(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextDeviceError2(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea.l	TextDeleteError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea.l	TextNotEnoughRoom1(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextNotEnoughRoom2(a3),a0
	move.l	a0,FrameSliceError2(a3)
*
	move.l	FrameSliceError1(a3),a0	; display error message
	move.l	FrameSliceError2(a3),a1
	CALL	DisplayMessageAndWait
 endc
.noerror
	REST	d0-d6/a0-a6
	rts


*******************************************************************
*
* BOOL ProcessSaveButton(struct ToasterBase *);
* (32)                             (32)
*  D0                               a5
*
* Summary:
*	handles save button on switcher - highest level call. And the one
*	that should be used whenever possible since it keeps the Switcher
*	internals updated as well as performing its primary function.
*
*	returns see NewProcessSaveButton
*
********************************************************************`
 XLABEL ProcessSaveButton
	moveq.l	#3,d0		;4 field save
	bsr.s	NewProcessSaveButton
	rts



******* ToasterLibrary/NewProcessSaveButton *********************************
*
*   NAME   
*	NewProcessSaveButton -- Handle user frame save stuff.
*
*   SYNOPSIS
*	NewProcessSaveButton(NumberOfFileds)
*	                           d0
*   FUNCTION
*
*   INPUTS
*	NumberOfFileds	0 - ask user
*			1 - field
*	                2 - frame
*	                3 - 4 field
*   RESULT
*	1 Things were cool, 0 there was an error.
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*	ProcessSaveButton
*****************************************************************************
NewProcessSaveButton:
	XDEF	NewProcessSaveButton
	DUMPMSG	<NewProcessSaveButton>
	SAVE	d0-d4/a0-a3/a6
	move.l	d0,d4			;number of fields to save

	moveq.l	#FALSE,d0		;setup return code
	move.l	d0,(sp)

	move.l	TB_DOSBase(a5),a6
	lea.l	LocalData,a3

	CLEAR	d0
	move.l	d0,FrameSliceError1(a3)	; clear error status
	move.l	d0,FrameSliceError2(a3)
	move.l	d0,DirectoryLock(a3)

	GET.l	TB_FCString,a0		; save USER's project name for
	lea	SaveCommentArea(a3),a1	; for possible later retrys
	CALL	StringCopy

	move.l	TB_ARexxResult(a5),d0	; is this an arexx command
	beq	.askuser
	move.l	d0,a0

;;	DUMPREG	<WASAREXX>

	move.b	rm_Action+3(a0),d0
	cmp.b	#4,d0
	blt.s	.forcemode

	move.l	rm_Args+(4*4)(a0),d0	;arg 4
	beq.s	.forcemode
	move.l	d0,a0
	XJSR	AsciiToBinary
	lea	ARToRel,a0		;request lookup table
	add.l	d0,d0
	add.l	d0,d0
	move.l	0(a0,d0.w),d4		;number of fields to save
	bra.s	111$

.forcemode
	DUMPREG	<NOARG>
	moveq.l	#3,d4
	bra.s	111$

.askuser
	tst.l	d4			;do we ask user howmany frames
	bne.s	111$

	moveq.l	#3,d4			;number of fields to save

	xref	SaveModeFG1

	lea	SaveModeFG1,a0		;if save mode is set to
	tst.w	FG_HiLiteMask(a0)	;single field freeze do it.
	beq.s	111$
	moveq.l	#1,d4


 ifeq 1

	lea	SaveCommentArea(a3),a0	;put name in requester
	move.l	a3,-(sp)
	moveq.l	#0,d0
	moveq.l	#0,d1
	lea	SaveTypeRequest,a3
;	move.l	(a3)+,d2		;opt text
	moveq.l	#0,d2
	move.l	(a3)+,d3		;opt text
	move.l	(a3)+,a1		;message
;	move.l	(a3)+,a1		;message 2
	move.l	(a3)+,a2		;oktext
	move.l	(a3)+,a3		;cancel text
	tst.b	(a0)
	bne.s	1$
	exg.l	a0,a1
1$
	XCALL	NewSwitcherRequester
	move.l	(sp)+,a3
	lea	RqToRel,a0		;request lookup table
	addq.l	#1,d0
	add.l	d0,d0
	add.l	d0,d0
	move.l	0(a0,d0.w),d4		;number of fields to save	
	bpl.s	111$
	bra	.end

 endc

111$

	DUMPREG	<D4_HASMODE>

* make sure that we don't overwrite an existing framestore without permisso.
.RetryFS:
*					; check string table to see if a
	GET.w	TB_NumPadPri,d0		; framestore with the specified
	mulu	#COMMENT_SIZE,d0	; framestore number exists
	GET.l	TB_FSStrings,a0
	add.l	d0,a0
	cmp.b	#-1,(a0)+
	beq.s	.NoOverWrite		; if no framestore exists - skip on

	tst.l	TB_ARexxResult(a5)	; if from arexx overwrite it
	bne.s	.NoOverWrite

	move.l	a3,d3		; else ask user if he wants an overwrite

	CLEAR	d0				; diskchanges return FALSE
	move.l	#DISKINSERTED+DISKREMOVED,d1
	move.l	a0,a1				;old file comment
	lea	OverWriteMsg(a3),a0
;	move.l	d0,a1
	lea	YesMsg(a3),a2
	lea	NoMsg(a3),a3
	XCALL	DoSwitcherRequester
	move.l	d3,a3
	ble	.ExitFail		; user didn't allow overwrite - out

.NoOverWrite:

* change to the directory where frames are stored
	moveq.l	#0,d0	; Mode
	CALLTL	LockFS
	move.l	d0,DirectoryLock(a3)
	bne	.GotLock

* if no directory on that device, try to create one
	move.l	TB_LastGlobalError(a5),d0
	cmp.l	#ERROR_OBJECT_NOT_FOUND,d0
	bne.s	.NotBadDir

* try to CreateDir
.CreateDir:
	move.l	TB_FSDev(a5),a0
	tst.b	(a0)+
	bne.s	.GoOn

	lea.l	TextDeviceError1(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextDeviceError2(a3),a0
	move.l	a0,FrameSliceError2(a3)
	bra		.ExitFail

.GoOn:
	lea.l	FrameComment(a3),a1	; use as temp storage area
	bsr		StringCopy
	lea.l	TextFrameStore(a3),a0 ; append "framestore"
	lea.l	FrameComment(a3),a1	; use as temp storage area
	bsr		StringAppend

	lea.l	FrameComment(a3),a0	; use as temp storage area
	move.l	a0,d1
	XSYS	CreateDir
	move.l	d0,DirectoryLock(a3)
	beq	.DeviceBad
	move.l	d0,d1			; make created dir the current dir
	CALLROM	CurrentDir
	bra	.GotLock

* check for bad disk, if it is bad and is a floppy, ask user if OK to format.
.NotBadDir:
	cmp.l	#ERROR_NOT_A_DOS_DISK,d0
	bne	.DeviceBad

	move.l	a3,d3

	GET.l	TB_FSDev,a0		; is it on a floppy device?
	cmp.b	#4,(a0)+
	bne.s	.NotAFloppy
	cmp.b	#'D',(a0)+
	bne.s	.NotAFloppy
	cmp.b	#'F',(a0)+
	bne.s	.NotAFloppy
	move.b	(a0),d2
	sub.b	#'0',d2
	cmp.b	#4,d2
	bcc.s	.NotAFloppy

*					; at this point we have a floppy...

	lea	BadDiskMsg(a3),a0	; get messages to show -
	lea	FormatMsg(a3),a1
	lea	YesMsg(a3),a2
	lea	NoMsg(a3),a3
	move.l	#DISKINSERTED+DISKREMOVED,d0	; allow disk changes to
	CLEAR	d1				; return a TRUE result
	XCALL	DoSwitcherRequester
	move.l	d3,a3
	ble.s	.DeviceBad		; if USER wants out - jump on

	lea	FSDiskName(a3),a0	; else format the floppy disk...
	moveq	#-1,d1
	CLEAR	d0
	move.b	d2,d0
	XCALL	FloppyDiskFormat
	bmi.s	.DeviceBad		; if an error occurs - jump out

	lea	SaveCommentArea(a3),a0	; restore proper file comment on
	GET.l	TB_FCStringSec,a1	; display
	CALL	StringCopy
	pea	.CreateDir(pc)		; and when ready - retry the save
	JUMPTL	UpdateDisplay

.NotAFloppy:
	CLEAR	d0
	move.l	#DISKINSERTED+DISKREMOVED,d1
	lea	BadDiskMsg(a3),a0	; there is no hope of recovery -
	move.l	d0,a1
	move.l	d0,a2
	lea	CancelMsg(a3),a3	; but tell the USER anyway
	XCALL	DoSwitcherRequester
	move.l	d3,a3
	bra	.ExitFail		; exit....

.DeviceBad
	move.l	a3,d3

	move.l	#DISKINSERTED+DISKREMOVED,d0	; allow disk changes to
	CLEAR	d1				; return a TRUE result
	lea	SaveFSMsg(a3),a0	; get messages to show -
	move.l	d1,a1
	lea	RetryMsg(a3),a2
	lea	CancelMsg(a3),a3
	XCALL	DoSwitcherRequester
	move.l	d3,a3
	ble	.ExitFail		; if no retry - exit....

	lea	SaveCommentArea(a3),a0	; else restore proper file comment on
	GET.l	TB_FCStringSec,a1	; display
	CALL	StringCopy
	pea	.RetryFS(pc)		; and when ready - retry the save
	JUMPTL	UpdateDisplay

.GotLock

* get the keypad numeric gadget, and create the filename
	moveq.l	#0,d0
	move.w	TB_NumPadPri(a5),d0	; range 0-999
	move.w	d0,d3
	lea.l	FrameNumber(a3),a0
	XJSR	CreateFrameName

* delete the old file with this number, if it exists
	lea.l	FrameComment(a3),a1	; filename
	clr.b	(a1)	; default is no comment
	move.l	TB_FSStrings(a5),a2
	mulu.w	#COMMENT_SIZE,d3
	add.l	d3,a2
	cmp.b	#$ff,(a2)	; flag for no file
	beq.s	.NoOldFile	; if no OldFile - skip on
	lea	1(a2),a0
	bsr	StringCopy

* if get a Lock on the old file, delete it
	lea.l	FrameName(a3),a0
	move.l	a0,d1
	XSYS	Lock
	move.l	d0,d1
	beq.s	.NoOldFile
	XSYS	UnLock
	lea.l	FrameName(a3),a0
	move.l	a0,d1
	XSYS	DeleteFile
	tst.l	d0
	bne.s	.OldFileGone

* if error while deleting old version of file, do not continue
	lea.l	TextDeleteError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	bra		.ExitFail
.OldFileGone
	move.w	#$FF00,(a2)		; clear entry in string table
	GET.l	TB_FCStringSec,a0	; and file comment to refect it
	clr.b	(a0)

.NoOldFile:

* now that (potential) old file gone, check to see if enough room on device
* to save this frame. Check for RAM: device because it is a special case
* device on which Info() does not work... (RAM: has no fixed size, it's
* dynamic)

	GET.l	TB_FSDev,a0		; ram disk?
	cmp.b	#4,(a0)+
	bne.s	.NotRamDisk
	cmp.b	#'R',(a0)+
	bne.s	.NotRamDisk
	cmp.b	#'A',(a0)+
	bne.s	.NotRamDisk
	cmp.b	#'M',(a0)+
	bne.s	.NotRamDisk

	GET.l	TB_SYSBase,a6		; the ram disk is specified -
	CLEAR	d1			; see if we have enough memory
	CALLROM	AvailMem		; to save a frame there
	GET.l	TB_DOSBase,a6
	cmp.l	#FORM_SIZE+4,d0
	bhs.s	.EnoughRoom		; jump if enough room
	bra.s	.NotEnoughRoom		; else denote short of room error

.NotRamDisk:
	move.l	DirectoryLock(a3),d1 ; if we got this far, it's valid
	move.l	TB_FileBuff(a5),d2
	XSYS	Info
	move.l	d2,a0
	move.l	id_NumBlocks(a0),d0
	sub.l	id_NumBlocksUsed(a0),d0
	move.l	id_BytesPerBlock(a0),d1
	bsr	BigMultiply
	tst.l	d1
	bne.s	.EnoughRoom	; if >4 gig, enough room ;-)
	cmp.l	#FORM_SIZE+4,d0
	bhs.s	.EnoughRoom

.NotEnoughRoom:
	lea.l	TextNotEnoughRoom1(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextNotEnoughRoom2(a3),a0
	move.l	a0,FrameSliceError2(a3)
	bra	.ExitFail

.EnoughRoom
	move.l	TB_FCString(a5),a0	; make new FrameStore filename
	lea	FrameComment(a3),a1
	bsr	StringCopy

* lots of stuff that used to be in FrameSave()
* I think the switcher will already be frozen here??
	CALLTL	KillAlphaKey
	XCALL	NoTransFreeze		; assure Switcher in a good state
	lea	FrameName(a3),a0	; save and write out the new FS

	lea	SaveDispatch(a3),a1
	subq.l	#1,d4
	add.l	d4,d4
	add.l	d4,d4
	move.l	0(a1,d4),a1
	jsr	(a1)
;	CALL.s	FrameSave

	move.l	d0,d2			; save BOOL return code
	CALLTL	ReDoDisplay		; fix CHIP memory
	XCALL	InstallAVEI		; install interface copper list
	XCALL	InitDVEFastMem		; fix FAST memory
	lea	FrameName+3(a3),a0	; assure framename text constants
	move.b	#'.',(a0)+		; are preserved
	move.b	#'F',(a0)+
	move.b	#'S',(a0)+
	move.b	#'.',(a0)
	tst.l	d2
	beq.s	.FSOK
	bsr		HandleError	; print error message
	bra.s	.Exit			; and exit
.FSOK
	moveq.l	#TRUE,d0		; return all ok
	move.l	d0,(sp)

	lea	FrameComment(a3),a0	; update Switcher internals
	GET.l	TB_FCStringSec,a1	; appropriately on success
	CALL	StringCopy
	CALL	StringLength
	GET.w	TB_NumPadPri,d1
	mulu	#COMMENT_SIZE,d1
	GET.l	TB_FSStrings,a1
	add.l	d1,a1
	move.b	d0,(a1)+
	CALL	StringCopy
	bra.s	.Exit

.ExitFail:
	move.l	FrameSliceError1(a3),a0	; display error message
	move.l	FrameSliceError2(a3),a1
	CALL	DisplayMessageAndWait

.Exit:
	move.l	DirectoryLock(a3),d1	; unlock the directory lock
	beq.s	.end
	CALLROM	UnLock

.end	REST	d0-d4/a0-a3/a6
	rts


	STRUCTURE	MRSAVE,0
	LONG		MRSAVE_PLANE1
	LONG		MRSAVE_PLANE2
	LONG		MRSAVE_PLANE3
	LONG		MRSAVE_PLANE4

	LABEL		MRSAVE_SIZEOF



******* ToasterLibrary/MRSave ***********************************************
*
*   NAME   
*	MRSave(FileName)
*	          A0
*	        
*
*   SYNOPSIS
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
MRFrameSave
	movem.l	d0-d1/a0-a1,-(sp)
	sub.l	#MRSAVE_SIZEOF,sp

	move.l	sp,a0
	moveq.l	#4,d0
	XJSR	AllocateMRBuffers
	move.l	d0,d0
	beq.s	.errorexit

	movem.l	(sp),a0-a3
	XJSR	Get4Still
.errorexit
	move.l	sp,a0
	moveq.l	#4,d0
	XJSR	FreeMRBuffers

	add.l	#MRSAVE_SIZEOF,sp
	movem.l	(sp)+,d0-d1/a0-a1
	rts




******* ToasterLibrary/FieldSave ********************************************
*
*   NAME   
*	FieldSave -- Save a field as a Framestore
*
*   SYNOPSIS
*	FieldSave(FileName,fieldnumber)
*		  a0	   d1
*
*	* LONG[] = FrameSave(char*)
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
FieldSave:
	XDEF	FieldSave
	DUMPMSG	<FieldSave>
	moveq.l	#0,d0				;errorcode
	movem.l	d0-d4/a0-a4/a6,-(sp)
	move.l	d1,d3				;test keep field number safe
	move.l	a0,FSIcon			;keep frame namestring addr safe
	DUMPMEM	<FSICONNAME>,(A0),#64
	CALLTL	SoftSpriteAudioOff

	lea.l	LocalData,a3

	lea	PrivatePicture,a0
	moveq.l	#0,d0				;type of memory
	CALLTL	AllocPlanes

	move.l	d0,d0
	bne.s	.gotpicture

	lea	NoMemError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code
	bra 	.exitQuick

.gotpicture
	DUMPMSG	<no problem got picture memory>
	lea	TB_VTSetUp+8(a5),a1		;what bank
	moveq.l	#1,d0
	ELHTEST_OBR	a1
	bne	1$
	lea	VTSU_RG+SURG_EH0R(a1),a1
	DUMPREG	<VTSU_RG+SURG_EH0R>
	DUMPMEM	<VTSU_RG+SURG_EH0R>,(A1),#16	
	moveq.l	#0,d0
	DUMPMSG	<clearing buffer numb>
1$
*	moveq.l	#0,d1				;grab field #0 could be{0..3}
	move.l	d3,d1				;grab field #0 could be{0..3}
	CALLTL	GrabRGBField
	CALLTL	RestoreBorderColor
	move.l	d0,d0
	beq.s	3$

	lea	notcalerror(a3),a0		; cpu is not calibrated
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)
	bra	.exitQuick
3$	
*
* place icon save here.
	move.l	a0,-(sp)			push picture struct addr on stack
	DUMPMSG	<before StartSavePIcon>
	XJSR	StartSavePIcon
	DUMPMSG	<after StartSavePIcon>
	move.l	d0,Icon_save_buffer
	move.l	d0,a2
	DUMPMSG	<before Icon_CopyRGB>
	XJSR	Icon_CopyRGB
	DUMPMSG	<after Icon_CopyRGB>
	DUMPMSG	<before Icon_save_buffer>
	tst.l	Icon_save_buffer
	beq	101$
	DUMPMSG	<after Icon_save_buffer>
	move.l	Icon_save_buffer,a0		address of icon struct
*	XJSR	StopSavePIconRGB		end icon save
	DUMPMSG	<before SaveIconRGB>
	bsr	SaveIconRGB
	DUMPMSG	<after SaveIconRGB>
101$
	move.l	(sp)+,a0			pop picture stuct addr.
*		
	move.l	#FILEF_COMPOSITE,D0		;flags
	move.l	a0,a1				;picture
	move.l	5*4(sp),a0
	CALLTL	SaveRGBPicture
	move.l	d0,d0
	beq	.exitQuick


	DUMPMSG	<EEERRROOORRR!!!>	
	lea	TextSaveError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	lea	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code

	move.l	TB_DOSBase(a5),a6
;	lea.l	FrameName(a3),a0
	move.l	5*4(sp),a0
	move.l	a0,d1
	XSYS	DeleteFile

.exitQuick
	lea	PrivatePicture,a0
	CALLTL	FreePlanes

	CALLTL	SoftSpriteAudioOn
	movem.l	(sp)+,d0-d4/a0-a4/a6
	rts




 ifeq 1
******* ToasterLibrary/FieldSave ********************************************
*
*   NAME   
*	FieldSave -- Save a field as a Framestore
*
*   SYNOPSIS
*	FieldSave(FileName,fieldnumber)
*		  a0	   d1
*
*	* LONG[] = FrameSave(char*)
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
FieldSave:
	XDEF	FieldSave
	moveq.l	#0,d0				;errorcode
	movem.l	d0-d4/a0-a4/a6,-(sp)
	move.l	d1,d3				;test keep field number safe
	move.l	a0,FSIcon			;keep frame namestring addr safe
	CALLTL	SoftSpriteAudioOff

	lea.l	LocalData,a3

	lea	PrivatePicture,a0
	moveq.l	#0,d0				;type of memory
	CALLTL	AllocPlanes

	move.l	d0,d0
	bne.s	.gotpicture

	lea	NoMemError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code
	bra 	.exitQuick

.gotpicture

	lea	TB_VTSetUp(a5),a1		;what bank
	moveq.l	#1,d0
	ELHTEST_OBR	a1
	beq.s	1$
	moveq.l	#0,d0
	DUMPMSG	<clearing d0 for other buffer grab.>	
1$
*	moveq.l	#0,d1				;grab field #0 could be{0..3}
	move.l	d3,d1				;grab field #0 could be{0..3}
	CALLTL	GrabRGBField
	CALLTL	RestoreBorderColor
	move.l	d0,d0
	beq.s	3$

	lea	notcalerror(a3),a0		; cpu is not calibrated
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)
	bra	.exitQuick
3$	
*
* place icon save here.
	move.l	a0,-(sp)			push picture struct addr on stack
	XJSR	StartSavePIcon
	move.l	d0,Icon_save_buffer
	move.l	d0,a2
	XJSR	Icon_CopyRGB
	tst.l	Icon_save_buffer
	beq	101$
	move.l	Icon_save_buffer,a0		address of icon struct
*	XJSR	StopSavePIconRGB		end icon save 
	bsr	SaveIconRGB
101$
	move.l	(sp)+,a0			pop picture stuct addr.
*		
	move.l	#FILEF_COMPOSITE,D0		;flags
	move.l	a0,a1				;picture
	move.l	5*4(sp),a0
	CALLTL	SaveRGBPicture
	move.l	d0,d0
	beq	.exitQuick


 ifeq 1
** testing
	movem.l	d0-d7/a0-a6,-(sp)
	lea	PrivatePicture,a1
	lea	TestName,a0
	lea	TestName,a2
	moveq	#11,d0
;;	DUMPREG	<MKPIcon>
	CALLTL	MKPIcon
	movem.l	(sp)+,d0-d7/a0-a6
	move.l	d0,d0
	bra	.exitQuick
** end testing
 endc
 ifeq 1
** testing
	movem.l	d0-d7/a0-a6,-(sp)
;;	DUMPREG	<1>
	lea	PrivatePicture,a1
;;	DUMPREG	<2>
	lea	TestName2,a0
	lea	TestName2,a2
	moveq	#11,d0
	CALLTL	MKPIconRGB
;;	DUMPREG	<3>
	movem.l	(sp)+,d0-d7/a0-a6
	bra	.exitQuick
** end testing
 endc
 

	lea	TextSaveError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	lea	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code

	move.l	TB_DOSBase(a5),a6
;	lea.l	FrameName(a3),a0
	move.l	5*4(sp),a0
	move.l	a0,d1
	XSYS	DeleteFile

.exitQuick
	lea	PrivatePicture,a0
	CALLTL	FreePlanes

	CALLTL	SoftSpriteAudioOn
	movem.l	(sp)+,d0-d4/a0-a4/a6
	rts
 endc



******* ToasterLibrary/FrameSave ********************************************
*
*   NAME   
*	FrameSave -- Saves toaster digital buffer to dos device.
*
*   SYNOPSIS
*	Error = Framesave(FileName)
*	                     a0
*
*	* LONG[] = FrameSave(char*,LONG)
*
*   FUNCTION
*	This function will write the frame to the provide filename.
*	The caller must assure the toaster is in frozen mode.
*
*   INPUTS
*	FileName   - NULL terminated string.
*
*   RESULT
*	Error      - Pointer to an array[2] of pointers to error strings,
*	             or 0 if ok.
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
FrameSave:
	xdef	FrameSave

setupsave	equ	10			;storage space for tb elh stuff
	moveq.l	#0,d0				;clear error code
	movem.l	d0-d4/a0-a4/a6,-(sp)
	move.l	a0,FSIcon			;keep frame namestring addr safe
	
	CALLTL	SoftSpriteAudioOff

	move.l	4,a6
	XSYS	Forbid

	move.l	TB_DOSBase(a5),a6		;bug fix june 30 91

	lea	TB_VTSetUp+8(a5),a0		;what bank
	moveq.l	#1,d4
	ELHTEST_OBR	a0
	bne	1$				
	moveq.l	#0,d4
	DUMPMSG	<clearing buffer for other grab>
	lea	VTSU_RG+SURG_EH0R(a0),a0
	DUMPREG	<VTSU_RG+SURG_EH0R>	
	DUMPMEM	<VTSU_RG+SURG_EH0R>,(A0),#64
1$
;+++++

	DEA.l	TB_VTSetUp,a0			;Put Black on main
	moveq.l	#0,d0
	ELHTEST_NOSNOW	a0
	beq.s	365$
	moveq.l	#-1,d0
365$	move.w	d0,-(sp)			;snow

	ELHGET_MA	a0,d0
	move.w		d0,-(sp)		;mat a
	ELHGET_MB	a0,d0
	move.w		d0,-(sp)		;mat b

	ELHGET_AM	A0,D0
	move.w		d0,-(sp)		;A mux
	ELHGET_BM	A0,D0
	move.w		d0,-(sp)		;B mux

	ELHPUT_MA_I	a0,0
	ELHPUT_MB_I	a0,0
	ELHPUT_AM_I	A0,VTI_AM_ENCODER
	ELHPUT_BM_I	A0,VTI_BM_ENCODER
	ELHSET_NOSNOW	A0

	LEA	MainBlankList(pc),a0
	CALLTL	SendELHList2Toaster		; Addendum 11/16/90:
	CALLTL	SendELHList2Toaster		; temp fix for Matte
	CALLTL	SendELHList2Toaster
	CALLTL	SendELHList2Toaster
	CALLTL	SendELHList2Toaster
	CALLTL	SendELHList2Toaster
;+++++

	lea.l	LocalData,a3
	move.l	d0,FrameSliceError1(a3)	; clear error status
	move.l	d0,FrameSliceError2(a3)


	XCALL	InstallAVE		; install the proper copper list

	CALLTL	InitReadScanLineBMs
	move.l	#CalibrationLine,d0		;line number
	moveq.l	#0,d1				;bank #
	move.l	TB_CHIPMem(a5),a0

	IFD	NOCALI
	bra	.DoneCali
	ENDC

* the following test is done by CaliReadScanLine
;;	CALLTL	TestReadScanLine
;;	tst.l	d0
;;	bne.s	.DoneCali

	moveq	#0,d0		;don't necessarily force whole calibration
	CALLTL	CaliReadScanLine
	CALLTL	RestoreBorderColor
	tst.l	d0
	bne.s	.DoneCali

	lea	notcalerror(a3),a0		; cpu is not calibrated
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,setupsave(sp)				;error code
	bra	.nomemexit

.DoneCali
	move.l	(5*4)+setupsave(sp),a0			;file name
	move.l	#BUFFER_WIDTH,D0
	move.l	#FILEF_COMPOSITE,d1		;This is a framestore.
;	move.l	#FILEF_COMPOSITE!FILEF_COMPRESSED,d1		; test only
	moveq.l	#0,d2				;no alpha planes
	CALLTL	StartSaveRGBPicture
	move.l	d0,d0				;save data struct
	bne.s	.gotsavedata

	lea	NoMemError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,setupsave(sp)		;error code
	bra	.nomemexit

.gotsavedata
	move.l	d0,a4
	tst.l	SaveData_Error(a4)
	beq.s	.createdfile

	lea	TextSaveError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	lea	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,setupsave(sp)		;error code
	bra	.exitsave

.createdfile
*
** OPEN ICON SAVE BUFFERS
	XJSR	StartSavePIcon
	move.l	d0,Icon_save_buffer

;+++++++++++++++++++++++
	btst.b	#GRAB68000_OK_BIT,TB_Flags(a5)
	beq.s	.TryNewGrab			; ...if not a 68000

	bsr	OldGrab
	move.l	d0,setupsave(sp)	;error code
	beq	.exitsave
	lea	NoMemError(a3),a0
	move.l	d0,a1
	cmp.l	(a1),a0
	bne	.exitsave
	clr.l	setupsave(sp)		;error code
					;if no memory try the new frame grab
.TryNewGrab

;+++++++++++++++++++++++

	move.w	#BUFFER_TOTAL_HEIGHT-1,d3
.lineloop

 	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
    	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1
	move.l	d4,d0				;bank # to save (0/1)
;	move.l	d2,d1
	move.l	#BUFFER_TOTAL_HEIGHT,d1		;480 top line is skiped 
	sub.w	d3,d1
	CALLTL	ReadScanLine

;;	btst.b	#10-8,CHIPBASE+potinp
	CALLTL	IsRMBup

	bne.s	.noabort

	lea	TextAbortSave(a3),a0		;user abort message
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,setupsave(sp)		;error code
	bra	.exitsave

.noabort
	move.l	SaveData_LinesWidth(a4),d1			pixels wide
	lsr.l	#4,d1						con to words wide
	lea	SaveData_SVR+SVR_PLANEPOINTERS(a4),a1		output plane buff
	btst	#0,d3
	beq	666$
	btst	#1,d3
	beq	666$				every 4 line. 
	move.l	Icon_save_buffer,a2
 	moveq	#0,d0
	XJSR	Icon_CopySL
666$
	moveq.l	#0,d0						0 offset
	CALLTL	Bytes2Planes

	move.l	a1,a0				;plane array
	move.l	SaveData_LinesWidth(a4),d0	;size in words
	lsr.l	#3,d0				;con to size in bytes
	move.l	SaveData_FileHandle(a4),d1	;file handle
	move.l	SaveData_Flags(a4),d2		;flags
	CALLTL	WritePlanesBW
	bne.s	.wrerr

    	movea.l	TB_EffectsBase+EFB_BuffB(a5),a0
	move.l	SaveData_LinesWidth(a4),d1
	lsr.l	#4,d1
	lea	SaveData_SVR+SVR_PLANEPOINTERS(a4),a1
;	moveq	#4,d0				2nd plane	
;	move.l	Icon_save_buffer,a2
;	XJSR	Icon_CopySL
	moveq.l	#0,d0				no offset
	CALLTL	Bytes2Planes

	move.l	a1,a0				;plane array
	move.l	SaveData_LinesWidth(a4),d0
	lsr.l	#3,d0				;size in bytes
	move.l	SaveData_FileHandle(a4),d1	;file handle
	move.l	SaveData_Flags(a4),d2		;flags
	CALLTL	WritePlanesBW
	beq.s	.gobump

.wrerr
	lea	TextSaveError(a3),a0		; generic save error text
	move.l	a0,FrameSliceError1(a3)
	lea	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,setupsave(sp)		;error code
	bra.s	.exitsave

.gobump
	move.l	a4,a0
	CALLTL	BumpLineCount
;	addq.l	#1,d2				;current scan line

	dbf	d3,.lineloop

.exitsave
	move.l	a4,a0				;save data struct
	CALLTL	StopSaveRGBPicture
	
*	tst.l	Icon_save_buffer
*	beq	.nomemexit
*	move.l	Icon_save_buffer,a0		address of icon struct
*	XJSR	StopSavePIcon			end icon save 

.nomemexit

	tst.l	setupsave(sp)			;delete file if there is an
	beq.s	.okexit				;error

	move.l	TB_DOSBase(a5),a6
	lea.l	FrameName(a3),a0
	move.l	a0,d1
	XSYS	DeleteFile
	bra	.notokexit

.okexit

	bsr	SaveIcon

.notokexit

;+++
	DEA.l	TB_VTSetUp,a0			;Restore Main
	move.w	(sp)+,d0
	ELHPUT_BM_R	A0,D0
	move.w	(sp)+,d0
	ELHPUT_AM_R	A0,D0
	move.w	(sp)+,d0
	ELHPUT_MB_R	A0,D0
	move.w	(sp)+,d0
	ELHPUT_MA_R	A0,D0
* not needed	ELHSET_NOSNOW	A0
	move.w	(sp)+,d0
	bne.s	374$
	ELHCLEAR_NOSNOW	A0
374$	LEA	MainBlankList(pc),a0		;set headers to toaster
	CALLTL	SendELHList2Toaster
;+++

	move.l	4,a6				;^(
	XSYS	Permit
	CALLTL	SoftSpriteAudioOn
	
	movem.l	(sp)+,d0-d4/a0-a4/a6
	rts


******* ToasterLibrary/GrabIcon ********************************************
*
*   NAME   
*	GrabIcon -- Grabs a field and makes an icon from it
*
*   SYNOPSIS
*	GrabIcon(FileName,Data,Size)
*		  a0	  a1   d1
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
GrabIcon:
	XDEF	GrabIcon
	moveq.l	#0,d0				;errorcode
	movem.l	d0-d6/a0-a4/a6,-(sp)
	move.l	a0,FSIcon			;keep frame namestring addr safe
	move.l	A1,D5				;keep extra data address
	move.L	D1,D6				;keep extra data size	




;	XCALL	InstallAVEI		; install the proper copper list
;	XCALL	ReDoDisplay
	CALLTL	KillAlphaKey
	XCALL	NoTransFreeze		; assure Switcher in a good state
	CALLTL	SoftSpriteAudioOff

	lea.l	LocalData,a3

	XJSR	StartSavePIcon
	move.l	d0,Icon_save_buffer
	beq	.exitQuick
	move.l	d0,a0

	lea	TB_VTSetUp(a5),a1		;what bank
	moveq.l	#1,d0
	ELHTEST_OBR	a1
	beq.s	1$
	moveq.l	#0,d0
1$
	moveq.l	#0,d1
	
	XJSR	SingleLineDecode_Icon
*	CALLTL	SingleLineDecode_Icon
	CALLTL	RestoreBorderColor
	move.l	d0,d0
	beq.s	3$

	lea	notcalerror(a3),a0		; cpu is not calibrated
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)
*	XJSR	StopSavePIconRGB		end icon save 
	bra	.exitQuick
3$	
	move.l	Icon_save_buffer,a0		address of icon struct
	move.l	FSIcon,a1			;Copy the framestore name,number,ect
	move.l	d5,a2				;extra data
	move.l	d6,d0				;size of extra data	
	XJSR	StopSaveRGBPIcon644		end icon save 
	
*	move.l	FSIcon,a1			;Copy the framestore name,number,ect
*	move.l	d5,a2				;extra data
*	move.l	d6,d0				;size of extra data	
*	XJSR	PCON_Save			;go save the icon

.exitQuick
	CALLTL	SoftSpriteAudioOn

	CALLTL	ReDoDisplay		; fix CHIP memory
	XCALL	InstallAVEI		; install interface copper list
	XCALL	InitDVEFastMem		; fix FAST memory

	movem.l	(sp)+,d0-d6/a0-a4/a6
	rts



******* SaveIcon *********************************
*
*   NAME   
*	SaveIcon -- 
*
*   SYNOPSIS
*	SaveIcon(IconBuffer)
*	                           
*   FUNCTION
*	SaveIcon
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
SaveIcon:
	movem.l	d0-d4/a0-a4/a6,-(sp)
	move.l	FSIcon,a1			;Copy the framestore name,number,ect
	lea	IconName,a2

401$	move.b	(a1)+,(a2)+
	bne	401$	
	lea	-1(a2),a2
	move.b	#'.',(a2)+
	move.b	#'I',(a2)+
	move.b	#0,(a2)

	move.l	#IconName,d1			;pass the icon name
	moveq	#0,d2				;save only default CrUD
	sub.l	a0,a0				;no CrUD data passed.

*	XJSR	PCON_Save			;go save the icon


	move.l	Icon_save_buffer,a0		address of icon struct
	lea	IconName,a1
	moveq	#0,d0
 	sub.l	a2,a2
	XJSR	StopSavePIcon644		;PICON(A0),FILENAME(A1),DATA(A2),DATASIZE(D0) 	
*
	move.l	FSIcon,d1
	move.l	#IconName,d0
	MOVE.L	D1,A0
;;	DUMPMEM	<#IconName>,(A0),#64

	MOVE.L	D0,A0
;;	DUMPMEM	<#FSIcon>,(A0),#64
	
;	XJSR	AppendI
*	
	movem.l	(sp)+,d0-d4/a0-a4/a6
	rts	



******* SaveIconRGB *********************************
*
*   NAME   
*	SaveIconRGB -- 
*
*   SYNOPSIS
*	SaveIconRGB(IconBuffer)
*	                           
*   FUNCTION
*	SaveIconRGB
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
SaveIconRGB:
	movem.l	d0-d4/a0-a4/a6,-(sp)
	move.l	FSIcon,a1			;Copy the framestore name,number,ect
	lea	IconName,a2

401$	move.b	(a1)+,(a2)+
	bne	401$	
	lea	-1(a2),a2
	move.b	#'.',(a2)+
	move.b	#'I',(a2)+
	move.b	#0,(a2)

	move.l	#IconName,d1			;pass the icon name
	moveq	#0,d2				;save only default CrUD
	sub.l	a0,a0				;no CrUD data passed.

*	XJSR	PCON_Save			;go save the icon


	move.l	Icon_save_buffer,a0		address of icon struct
	lea	IconName,a1
	moveq	#0,d0
 	sub.l	a2,a2
	DUMPMSG	<before StopSaveRGBPIcon644>
	XJSR	StopSaveRGBPIcon644		;PICON(A0),FILENAME(A1),DATA(A2),DATASIZE(D0) 	
	DUMPMSG	<afterStopSaveRGBPIcon644>
*
	

	move.l	FSIcon,d1
	move.l	#IconName,d0
;;	DUMPREG	<d1-FSIcon, d0-IconName>
;;	MOVE.L	D1,A0
;;	DUMPMEM	<#IconName>,(A0),#64

;;	MOVE.L	D0,A0
;;	DUMPMEM	<#FSIcon>,(A0),#64
;;	XJSR	AppendI
*
	movem.l	(sp)+,d0-d4/a0-a4/a6
	rts	




******* /OldGrab ************************************************************
*
*   NAME   
*	OldGrab(savedata,bank)
*	           a4     d4
*   SYNOPSIS
*	This is to be called from inside  frame save only
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
*
midplanewidth	equ	756

FieldBufferSize	equ	241*midplanewidth


OldGrab
	moveq.l	#0,d0				;clear error code
	movem.l	d0-d3/a0-a3,-(sp)

	moveq.l	#4-1,d2
	lea	FieldBuffers(a3),a2
	move.l	(4).w,a6
.getbuffers					;allocate four filed size buffers
	moveq.l	#0,d1				;any memory will do
	move.l	#FieldBufferSize,d0
	XSYS	AllocMem
	move.l	d0,(a2)+
	dbeq	d2,.getbuffers
	bne.s	.GetFields

	lea	NoMemError(a3),a0		;say there is no memory for grab
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code
	bra	.freebuffers

.GetFields
						;read four fileds into
	moveq.l	#4-1,d2				;buffers
	lea	FieldBuffers(a3),a2
.fieldloop
	move.l	d4,d0			;bank
	move.l	TB_CHIPMem(a5),a0
	moveq.l	#3,d1
	sub.b	d2,d1	; field
	CALLTL	GrabField
	tst.l	d0
	beq.s	.badgrab

;;	btst.b	#10-8,CHIPBASE+potinp
	CALLTL	IsRMBup

	bne.s	.noabort
.doabort
	lea	TextAbortSave(a3),a0		;user abort message
	move.l	a0,FrameSliceError1(a3)
	moveq.l	#0,d0
	move.l	d0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code
	bra	.freebuffers
.noabort
	move.l	TB_CHIPMem(a5),a0
	move.l	(a2)+,a1
	bsr	shiftraw
	dbf	d2,.fieldloop
	bra.s	.GotField

.badgrab
	lea.l	TextToasterError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code
	bra.s	.freebuffers
.GotField

	move.l	#240-1,d2
	moveq.l	#0,d3
.writelines

;;	btst.b	#10-8,CHIPBASE+potinp
	CALLTL	IsRMBup

	beq.s	.doabort

	move.l	a4,a0
	move.l	FieldBuffers+0(a3),d0
	move.l	FieldBuffers+8(a3),d1
	add.l	d3,d0
	add.l	d3,d1
	XJSR	AddCompLine
	move.l	d0,(sp)
	bne.s	.err

	add.l	#midplanewidth,d3		;bump counter

	move.l	FieldBuffers+4(a3),d0
	move.l	FieldBuffers+12(a3),d1
	move.l	a4,a0
	add.l	d3,d0
	add.l	d3,d1
	XJSR	AddCompLine
	move.l	d0,(sp)
	dbne	d2,.writelines
	beq.s	.freebuffers
.err
	lea.l	TextSaveError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,(sp)				;error code
	
.freebuffers

	moveq.l	#4,d2
	lea	FieldBuffers(a3),a2
	move.l	(4).w,a6
	bra.s	1$
.freebuffersloop
	clr.l	-4(a2)				;clear pointer
	move.l	d0,a1				;memory
	move.l	#FieldBufferSize,d0
	XSYS	FreeMem
1$	move.l	(a2)+,d0
	dbeq	d2,.freebuffersloop

	movem.l	(sp)+,d0-d3/a0-a3

	rts

**------------------------------------------------------------------------
**	shiftraw(source,dest)
**		   a0    a1
**------------------------------------------------------------------------
shiftraw
	move.l	#240-1,d1
	addq.w	#1,a0			;fix for something strange
1$	move.l	#(midplanewidth/4)-1,d0
2$	move.b	(a0)+,(a1)+
	move.b	(189*1)-1(a0),(a1)+
	move.b	(189*2)-1(a0),(a1)+
	move.b	(189*3)-1(a0),(a1)+
	dbf	d0,2$
	lea	(189*3)(a0),a0			;skip to next line
	dbf	d1,1$
	rts


	ifeq 1


*****************************************************************************
*
* ErrorMessages FrameSave( FileName, ToasterBase );
* (32)              (32)       (32)
*  D0                A0         A5
*
* This function causes the digital bank to be dumped into the specified
* filename in the current directory.
* Caller must display error messages, if any.
* ErrorMessages is a pointer to an array of two pointers to ascii strings,
* or NULL if successful
*
* Trashes D1,A0,A1.
*
*****************************************************************************

	IFNE	_CCODE

 XLABEL	_FrameSave
	move.l	4(sp),a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FrameSave
	REST1	a5
	rts

	ENDC

 XLABEL	FrameSave
	SAVE	d2/d3/a2-a4/a6		; work registers

	move.l	a0,a2			; save filename pointer
	lea.l	LocalData,a3

	CLEAR	d0
	move.l	d0,FrameSliceError1(a3)	; clear error status
	move.l	d0,FrameSliceError2(a3)

 IFD asdfg
	move.l	a2,a0			; write filename out to a special
	lea	FrameName(a3),a1	; filename container
	bsr	StringCopy

	lea	IFFComment,a1		; assume IFF comment as empty
	clr.b	(a1)

	move.l	a2,a0			; get filename string length
	bsr	StringLength

	subq.w	#7,d0			; long enough to have file comment?
	bls.s	.NoComment

	CLEAR	d2			; assume nothing fudged

	cmp.w	#12,d0			; comment a size we can handle?
	bls.s	.DoComment

	move.b	19(a2),d2		; save char we're cutting
	clr.b	19(a2)			; clip the filename momentarily

.DoComment:
	lea	7(a2),a0		; write out filename comment into
*	lea	IFFComment,a1		; IFF header
	bsr	StringCopy

	tst.w	d2			; fudging need to be done?
	beq.s	.NoComment		; ...if not

	move.b	d2,19(a2)		; else mend the filename string
 ENDC

.NoComment:
	move.l	TB_DOSBase(a5),a6
	move.l	a2,a0			; open the file and write IFF header
	XCALL	StartFrameWrite
	move.l	d0,d3			; (save the filehandle)
	bne.s	.GoodStart

	lea.l	TextSaveError(a3),a0	; generic save error text
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)

	bra	.ExitQ

.GoodStart:
*	XCALL	NoTransFreeze	; (done by caller, if needed)
	XCALL	InstallAVE		; install the proper copper list
	XCALL	SoftSpriteAudioOff	; SoftSprite system ENTIRELY off...

	GET.l	TB_SYSBase,a6
;;	move.w	AttnFlags(a6),d1
;;	btst.b	#AFB_68010,AttnFlags+1(a6)
;;	bne.s	.TryNewGrab			; ...if not a 68000

	btst.b	#GRAB68000_OK_BIT,TB_Flags(a5)
	beq.s	.TryNewGrab			; ...if not a 68000

	move.l	d3,d0
	bsr	DoOldGrab			; try to do old grab
	move.l	FrameSliceError1(a3),d2
	lea.l	TextToasterError(a3),a0
	cmp.w	d2,a0
	bne.s	.Exit

.TryNewGrab:
	lea	ConversionPlane0+(4*4*8)(a3),a4
	lea	PlaneTab(a3),a2
	moveq.l	#4-1,d2				; number of planes to grab

.OuterLoop:
	move.l	#BUFFER_WIDTH_OLD*BUFFER_HEIGHT,d0
	moveq.l	#0,d1
	CALLROM	AllocMem
	move.l	d0,a1

	moveq.l	#8-1,d1

.InnerLoop:
	move.l	a1,-(a4)				; msb first in memory
	lea	(BUFFER_WIDTH_OLD/8)*BUFFER_HEIGHT(a1),a1
	dbf	d1,.InnerLoop

	move.l	d0,(a2)+
	dbeq	d2,.OuterLoop

	bne.s	.GotTheMemory

	lea	NoMemError(a3),a0		; denote no memory error
	move.l	a0,FrameSliceError1(a3)
	bra.s	.FreeUpMemory

.GotTheMemory:
	lea	TB_VTSetUp(a5),a0		; check to see what bank to
	DUMPMEM	<TB_VTSetUp(a5)>,(A0),#16
	moveq.l	#1,d0				; save
	ELHTEST_OBR	a0
	beq.s	.GotTheBank
	moveq.l	#0,d0

.GotTheBank:
	move.l	d0,BankToSave(a3)
	move.l	d3,d0
	bsr	DoNewGrab			; do the new grab routine

.FreeUpMemory:
	lea	PlaneTab(a3),a2
	moveq.l	#4-1,d2				; number of planes to grab

.FreeLoop:
	move.l	(a2)+,d0
	move.l	d0,a1
	beq.s	.NotAPlane

	move.l	#BUFFER_WIDTH_OLD*BUFFER_HEIGHT,d0
	CALLROM	FreeMem

	clr.l	-4(a2)

.NotAPlane:
	dbf	d2,.FreeLoop

.Exit:
	XCALL	SoftSpriteAudioOn	; SoftSprite system back online
*	CALLTL	ReDoDisplay		; (done by caller, if needed)
*	XCALL	InstallAVEI		; (done by caller, if needed)
*	XCALL	InitDVEFastMem	; (done by caller, if needed)

.ExitQ:
*	lea	FrameName+3(a3),a0	; (done by caller, if needed)
*	move.b	#'.',(a0)+
*	move.b	#'F',(a0)+
*	move.b	#'S',(a0)+
*	move.b	#'.',(a0)

	moveq.l	#NULL,d0		; success return
	tst.l	FrameSliceError1(a3)
	beq.s	.RealExit
	lea.l	FrameSliceError1(a3),a0
	move.l	a0,d0
.RealExit
	REST	d2/d3/a2-a4/a6
	rts

*****************************************************************************
*
* void DoOldGrab( FileHandle, LocalData, ToasterBase )
*                    (32)        (32)       (32)
*                     D0          A3         A5
*
* To be called internally ONLY.
*
* Trashes D0,D1,A0,A1.
*
*****************************************************************************

DoOldGrab:
	SAVE	d2-d7/a2/a6		; save work registers
	move.l	d0,d5			; save filehandle
	GET.l	TB_DOSBase,a6		; get DOS base
	lea	-bm_SIZEOF(sp),sp	; get a bitmap struct

****************************************************
* get field buffer (weird-scrambled) for GrabField()
	move.l	TB_CHIPMem(a5),d3

* get the field buffer (bitmap) for WriteNextField()
	move.l	TB_FASTMem(a5),d4	; note: will destroy EFXFastMemory

* build the bitmap structure for Grabbed2Planes()
	move.w	#BUFFER_WIDTH_OLD/8,bm_BytesPerRow(sp)
	move.w	#BUFFER_HEIGHT,bm_Rows(sp)
	clr.b	bm_Flags(sp)
	move.b	#BUFFER_FIELD_DEPTH,bm_Depth(sp)
	lea.l	bm_Planes(sp),a0
	moveq.l	#BUFFER_FIELD_DEPTH-1,d0
	move.l	d4,a1
10$
	move.l	a1,(a0)+
	lea.l	(BUFFER_WIDTH_OLD/8)*BUFFER_HEIGHT(a1),a1
	dbra	d0,10$

*************************************

* for each field I-IV,
	moveq.l	#4-1,d2	


20$
	CHECK_ABORT	.DoAbortStuff

	lea	TB_VTSetUp(a5),a0
	moveq.l	#1,d0	; bank
	ELHTEST_OBR	a0
	beq.s	22$
	moveq.l	#0,d0	;bank

* download into Amiga memory with GrabField()
* get the field buffer (weird-scrambled) for GrabField(),
22$	
	move.l	d3,a0	; chip buffer

	moveq.l	#3,d1
	sub.b	d2,d1	; field
	CALLTL	GrabField
	tst.l	d0
	bne.s	.GotField
	lea.l	TextToasterError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	bra		.ExitDelete
.GotField

* convert into bitplane format with Grabbed2Planes()
	moveq.l	#0,d6				; offset into planes
	move.w	#BUFFER_HEIGHT-1,d7	; -1 for dbra
	move.l	d3,a2
	addq.w	#1,a2	;ignore 1st quads
25$
	CHECK_ABORT	.DoAbortStuff
	move.l	a2,a0				; ptr into weird-scrambled buffer

	moveq.l	#0,d1				;remove zipper
	moveq.l	#0,d0
	move.b	oldnozip1(a0),d0
	move.b	oldnozip2(a0),d1
	add.w	d0,d1
	lsr.w	#1,d1
	move.b	d1,oldnozipdest(a0)

	lea.l	bm_Planes(sp),a1	; planes array
	move.l	d6,d0				; offset into planes
	moveq.l	#BUFFER_WIDTH_OLD/16,d1
	CALLTL	Grabbed2Planes
	add.w	#BUFFER_WIDTH_OLD/8,d6	; point at next dest line
	lea.l	756(a2),a2			; point at next source line
	dbra	d7,25$

* save to disk with WriteNextField()
	CHECK_ABORT.s	.DoAbortStuff
	move.l	d5,a0	; file handle
	move.l	sp,a1	; bitmap structure
	lea.l	FrameName(a3),a2
	XJSR	WriteNextField
	tst.l	d0
	bne.s	.FieldWritten
.SaveError
	lea.l	TextSaveError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)
	bra.s	.ExitFail

.FieldWritten
	dbf	d2,20$

	move.l	d5,a0			; file handle
	XJSR	EndFrameWrite

	lea	bm_SIZEOF(sp),sp	; clean off the stack
	REST	d2-d7/a2/a6		; restore work registers
	rts

.ExitDelete:
	move.l	d5,d1			; close and delete the file
	XSYS	Close
	lea.l	FrameName(a3),a0
	move.l	a0,d1
	XSYS	DeleteFile

.ExitFail:
	lea	bm_SIZEOF(sp),sp	; clean off the stack
	REST	d2-d7/a2/a6		; restore work registers
	rts

.DoAbortStuff:
	lea.l	TextAbortSave(a3),a0
	move.l	a0,FrameSliceError1(a3)
	bra.s	.ExitDelete

*****************************************************************************
*
* void DoNewGrab( FileHandle, LocalData, ToasterBase )
*                    (32)        (32)       (32)
*                     D0          A3         A5
*
* To be called internally ONLY.
*
* Trashes D0,D1,A0,A1.
*
*****************************************************************************

DoNewGrab:
	SAVE	d2-d6/a2/a6
	move.l	d0,d5				; save filehandle
	GET.l	TB_DOSBase,a6			; get DOS base
	moveq	#-1,d6				; denote ABORT flag active

	CALLTL	InitReadScanLineBMs
	move.l	#CalibrationLine,d0		;line number
	moveq.l	#0,d1				;bank #
	move.l	TB_CHIPMem(a5),a0

	IFD	NOCALI
	bra	295$
	ENDC

* the following test is done by CaliReadScanLine
;;	CALLTL	TestReadScanLine
;;	tst.l	d0
;;	bne.s	295$

	moveq	#0,d0		;don't necessarily force whole calibration
	CALLTL	CaliReadScanLine
	CALLTL	RestoreBorderColor
	tst.l	d0
	bne.s	295$

	lea.l	notcalerror(a3),a0
	move.l	a0,FrameSliceError1(a3)
	clr.l	FrameSliceError2(a3)
	bra		.ExitDelete
295$


	DEA.l	TB_VTSetUp,a0			;Put Black on main
	moveq.l	#0,d0
	ELHTEST_NOSNOW	a0
	beq.s	365$
	moveq.l	#-1,d0
365$	move.w	d0,-(sp)			;snow

	ELHGET_MA	a0,d0
	move.w		d0,-(sp)		;mat a
	ELHGET_MB	a0,d0
	move.w		d0,-(sp)		;mat b

	ELHGET_AM	A0,D0
	move.w		d0,-(sp)		;A mux
	ELHGET_BM	A0,D0
	move.w		d0,-(sp)		;B mux

	ELHPUT_MA_I	a0,0
	ELHPUT_MB_I	a0,0
	ELHPUT_AM_I	A0,VTI_AM_ENCODER
	ELHPUT_BM_I	A0,VTI_BM_ENCODER
	ELHSET_NOSNOW	A0

	LEA	MainBlankList(pc),a0
	CALLTL	SendELHList2Toaster		; Addendum 11/16/90:
	CALLTL	SendELHList2Toaster		; temp fix for Matte
	CALLTL	SendELHList2Toaster
	CALLTL	SendELHList2Toaster
	CALLTL	SendELHList2Toaster
	CALLTL	SendELHList2Toaster


	moveq.l	#0,d2
	moveq.l	#0,d4				;conversion offset
367$						;read lines into buffer
	CHECK_ABORT	.StartAbort
 	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
    	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1
	move.l	BankToSave(a3),d0		;bank
	move.l	d2,d1
	CALLTL	ReadScanLine

	lea	ConversionPlane1(a3),a1
 	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
	moveq.l	#0,d1
	moveq.l	#0,d0
	move.b	nozip1(a0),d0
	move.b	nozip2(a0),d1
	add.w	d0,d1
	lsr.w	#1,d1
	move.b	d1,nozipdest(a0)
	moveq.l	#BUFFER_WIDTH_OLD/16,d1
	move.l	d4,d0					;offset
	CALLTL	Bytes2Planes

	lea	ConversionPlane3(a3),a1
 	movea.l	TB_EffectsBase+EFB_BuffB(a5),a0
	moveq.l	#0,d1
	moveq.l	#0,d0
	move.b	nozip1(a0),d0
	move.b	nozip2(a0),d1
	add.w	d0,d1
	lsr.w	#1,d1
	move.b	d1,nozipdest(a0)
	moveq.l	#BUFFER_WIDTH_OLD/16,d1
	move.l	d4,d0					;offset
	CALLTL	Bytes2Planes
	addq.w	#1,d2

 	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
    	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1
	move.l	BankToSave(a3),d0		;bank # to save
	move.l	d2,d1
	CALLTL	ReadScanLine

	lea	ConversionPlane0(a3),a1
 	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
	moveq.l	#0,d1
	moveq.l	#0,d0
	move.b	nozip1(a0),d0
	move.b	nozip2(a0),d1
	add.w	d0,d1
	lsr.w	#1,d1
	move.b	d1,nozipdest(a0)
	moveq.l	#BUFFER_WIDTH_OLD/16,d1
	move.l	d4,d0					;offset
	CALLTL	Bytes2Planes

	lea	ConversionPlane2(a3),a1
 	movea.l	TB_EffectsBase+EFB_BuffB(a5),a0
	moveq.l	#0,d1
	moveq.l	#0,d0
	move.b	nozip1(a0),d0
	move.b	nozip2(a0),d1
	add.w	d0,d1
	lsr.w	#1,d1
	move.b	d1,nozipdest(a0)
	moveq.l	#BUFFER_WIDTH_OLD/16,d1
	move.l	d4,d0					;offset
	CALLTL	Bytes2Planes

	add.l	#BUFFER_WIDTH_OLD/8,d4
	addq.w	#1,d2
	cmp.w	#BUFFER_TOTAL_HEIGHT,d2		;height to read
	blt	367$

	CLEAR	d6				; denote no ABORT pending

.StartAbort:
	DEA.l	TB_VTSetUp,a0			;Restore Main
	move.w	(sp)+,d0
	ELHPUT_BM_R	A0,D0
	move.w	(sp)+,d0
	ELHPUT_AM_R	A0,D0
	move.w	(sp)+,d0
	ELHPUT_MB_R	A0,D0
	move.w	(sp)+,d0
	ELHPUT_MA_R	A0,D0
* not needed	ELHSET_NOSNOW	A0
	move.w	(sp)+,d0
	bne.s	374$
	ELHCLEAR_NOSNOW	A0
374$	LEA	MainBlankList(pc),a0		;set headers to toaster
	CALLTL	SendELHList2Toaster

	tst.l	d6			; ABORT pending?
	bne.s	.DoAbortStuff		; yup - do it

	lea	PlaneTab+(4*4)(a3),a2
	moveq.l	#4-1,d4
263$
	CHECK_ABORT.s	.DoAbortStuff
	move.l	d5,d1
	move.l	-(a2),d2
	move.l	#BUFFER_WIDTH_OLD*BUFFER_HEIGHT,d3
	CALLROM	Write
	cmp.l	d0,d3				;was write ok
	dbne	d4,263$
	beq.s	385$				;yes it was

	lea.l	TextSaveError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotSaved(a3),a0
	move.l	a0,FrameSliceError2(a3)

.ExitDelete:
	move.l	d5,d1			; close and delete the file
	XSYS	Close
	lea.l	FrameName(a3),a0
	move.l	a0,d1
	XSYS	DeleteFile

	REST	d2-d6/a2/a6
	rts

385$
	move.l	d5,a0			; file handle
	XJSR	EndFrameWrite

	REST	d2-d6/a2/a6
	rts

.DoAbortStuff:
	lea.l	TextAbortSave(a3),a0
	move.l	a0,FrameSliceError1(a3)
	bra.s	.ExitDelete



	endc		;old frame grab


*******************************************************************
*
* BOOL ProcessLoadButton(struct ToasterBase *);
* (32)                             (32)
*  D0                               a5
*
* Summary:
*	handles frame load button on switcher
*	Loads to OBR bank. Assumes not during a LINP=clear effect transition.
*
* Trashes D1,A0,A1.
*
********************************************************************`
 XLABEL ProcessLoadButton
	SAVE	d2/a3/a6

	GET.l	TB_DOSBase,a6
	lea.l	LocalData,a3

	CLEAR	d0			; clear error status
	clr.l	FrameSliceError1(a3)
	clr.l	FrameSliceError2(a3)

* change to the directory where frames are stored
	moveq.l	#0,d0	; Mode
	XCALL	LockFS
	move.l	d0,DirectoryLock(a3)
	bne.s	.GotLock
	lea.l	TextFrameNotFound(a3),a0
	move.l	a0,FrameSliceError1(a3)
	bra	.ExitFail
.GotLock

* get the keypad numeric gadget, and create the filename
	moveq.l	#0,d0
	move.w	TB_NumPadPri(a5),d0	; range 0-999
	move.w	d0,d2
	lea.l	FrameNumber(a3),a0
	XJSR	CreateFrameName

* now see if there is a file on the selected device
	mulu.w	#COMMENT_SIZE,d2
	move.l	TB_FSStrings(a5),a0
	add.l	d2,a0
	cmp.b	#$ff,(a0)	; no file flag
	bne.s	.GotFile
	lea.l	TextFrameNotFound(a3),a0
	move.l	a0,FrameSliceError1(a3)
	bra		.ExitFail

.GotFile
	addq.l	#1,a0
	lea.l	FrameComment(a3),a1	; filename
	bsr		StringCopy


	lea.l	FrameName(a3),a0	; get the filename string
	bsr	CheckFileType
	bne.s	111$


	IFND	AACHIPS

	lea.l	TextNotAA(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextNotAA2(a3),a0
	move.l	a0,FrameSliceError2(a3)

	bra	.ExitFail

	ENDC


;;	DUMPREG	<WASANIM>
	swap.w	d1
	cmp.w	#400,d1
	blt.s	.smallpreview

	lea	FrameName(a3),a0	;test of compressed anims
	move.l	a0,AnimFileTable

	lea	PostviewCrouton,a0
	GET.l	TB_EfxFG,d0
	cmp.l	d0,a0
	bne.s	.goSelect
					;if already selected select
	lea	PreviewCrouton,a0	;some one else first.
	bsr	SelectPreviewCrouton
	lea	PostviewCrouton,a0
.goSelect
	bsr	SelectPreviewCrouton
	bra.s	.Exit

.smallpreview
	lea	PreviewCrouton,a0
	bsr	SelectPreviewCrouton
	lea	FrameName(a3),a0	;test of compressed anims
	bsr	LoadAnimation

	bra.s	.Exit
111$


* lots of stuff used to be in FrameLoad()
	lea.l	FrameName(a3),a0	; get the filename string

;	CALL	FrameLoad		; load the frame


	jsr	FrameLoad ;(will install AVE if no key, else installs AVEI with key only)
	move.l	d0,d2			; save the BOOL result

	lea	TB_VTSetUp(a5),a0		;determine bank to load to
	moveq.l	#0,d0
	ELHTEST_OBR	a0
	beq.s	470$
	move.l	#1,d0				;currentbank
470$	CALLTL	WriteLineZero


	CALLTL	ReDoDisplay		; rebuild the display
	CALLTL	InstallAVEI		; and put up the interface
	tst.l	d2
	bne.s	.ShowError
	moveq	#TRUE,d2		; denote save
	bra.s	.Exit
.ShowError
	moveq	#FALSE,d2		; denote no save
	bsr.s	HandleError		; display any error messages
	bra.s	.Exit			; continue on

.ExitFail:
	move.l	FrameSliceError1(a3),a0	; display error message
	move.l	FrameSliceError2(a3),a1
	CALL	DisplayMessageAndWait
	moveq	#FALSE,d2		; denote no save

.Exit:
	move.l	DirectoryLock(a3),d1	; unlock the directory lock
	beq.s	.NoDirLock
	CALLROM	UnLock

.NoDirLock:
	move.l	d2,d0
	REST	d2/a3/a6
	rts

******************************************************************
* displays error messages, if any
HandleError
	move.l	FrameSliceError1(a3),d0
	beq.s	.Exit
	move.l	d0,a0
	move.l	FrameSliceError2(a3),a1
	CALL	DisplayMessageAndWait
.Exit
	rts



******* ToasterLibrary/FrameLoad ********************************************
*
*   NAME   
*	FrameLoadNew -- loads a framestore.
*   SYNOPSIS
*	error = FrameLoadNew(filename)
*	                        a0
*   FUNCTION
*	This function is included for compatibility with the 1.0
*	switcher.  It does not allow you to keep up a user interface while
*	loading a framestore.
*
*   INPUTS
*	filename    - Null terminated filename.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
FrameLoad:
	XDEF	FrameLoad
	movem.l	d1/a4/a0,-(sp)
	GET.w	TB_InterfaceDepth,d0
	move.l	d0,-(sp)		;stash original depth

	lea	-frml_SIZEOF(sp),sp
	move.l	a0,frml_filename(sp)
	move.l	sp,a0			;Frameload Structure

* assume no Key up
	moveq.l	#0,d1
	move.l	d1,frml_Palette(a0)
	move.l	d1,frml_CustomBMTop(a0)
	move.l	d1,frml_AMBM(a0)
	move.l	d1,frml_AlphaFill(a0)

* leave any current Key up during Load if there's room

	GET.l	TB_CurrentAlphaBM,frml_CustomBM(a0)
	beq.s	50$

	GET.w	TB_CurrentAlphaTop,d0
	add.w	#1,d0			;actual line (count't half line)
	lsr.w	#1,d0			;Field Top (not Frame)

	cmpi.w	#8,d0
	bcc.s	48$			;jump if can leave key up
	clr.l	frml_CustomBM(a0)
	CALLTL	KillAlphaKey
	bra.s	50$

48$	move.w	d0,frml_CustomBMTop+2(a0)
	GET.l	TB_CurrentAlphaPaletteKeyOnly,frml_Palette(a0)

	clr.w	TB_InterfaceDepth(a5)	;no interface
	CALLTL	InstallAVEI		;Key only to reduce flashing
	bra.s	55$
	
50$	CALLTL	InstallAVE
55$	bsr.s	FrameLoadNew
	lea	frml_SIZEOF(sp),sp

	PUT.w	2(sp),TB_InterfaceDepth
	addq.w	#4,sp
	movem.l	(sp)+,d1/a4/a0
	rts

******* ToasterLibrary/FrameLoadNew ********************************************
*
*   NAME   
*	FrameLoadNew -- loads a framestore.
*   SYNOPSIS
*	error = FrameLoadNew(frameload)
*	                         a0
*	APTR = frameload(APTR)
*
*   FUNCTION
*
*   INPUTS
*	frameload - a frameload struct (see frameload.i)
*
*   RESULT
*	error = 0 if ok else * char[2] error string
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
FrameLoadNew:
	XDEF	FrameLoadNew
	DUMPMSG	<FrameLoadNew>
writesize	equ	58		;largest 58

	moveq.l	#0,d0
	movem.l	d0-d7/a0-a4/a6,-(sp)

	move.l	a0,a4

;	move.l	frml_AlphaFill(a4),a2		;test only
;	DUMPMEM	<DEST_BITMAP>,0(A2),#40		;test only

	move.l	a1,a2
	lea	-PI_SIZEOF(sp),sp
	move.l	sp,a1
	move.l	frml_filename(a4),a0
	CALLTL	QueryFile
	tst.l	d0
	beq.s	.gotfile

	bsr	FrameLoadOld
	move.l	d0,PI_SIZEOF(sp)
	bra	300$
.gotfile
	btst.b	#0,PI_COMPOSITEFLAG(sp)		;bit 0 means composite data
	bne.s	.goloadcomp

	lea.l	LocalData,a3		; address local data
	lea.l	TextFrameCorrupt(a3),a0
	move.l	a0,FrameSliceError1(a3)
	clr.l	FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,PI_SIZEOF(sp)

	bra	.nomem

.goloadcomp
;	CALLTL	InstallAVE

	move.l	sp,a1				;picture info structure
	bsr	StartLoadComposite
	bne.s	.gotmem

	lea.l	LocalData,a3		; address local data
	lea	TextLoadMEM1(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea	TextLoadMEM2(a3),a0
	move.l	a0,FrameSliceError2(a3)
	lea	FrameSliceError1(a3),a0
	move.l	a0,PI_SIZEOF(sp)

	bra	.nomem
.gotmem

;+++++++++++++++++++++++++++
	CALLTL	SoftSpriteBPLCON0Off

* since the Interface Planes are destroyed, we will use this new coplist.
;	CALLTL	InstallAVE

	XJSR	makefrzpanelfreeze	;NEED TO UPDATE FREEZE PANEL.
	DUMPMSG	<checking for freeze in frameslice.a>
* SetUp toaster for uploading
	lea	TB_VTSetUp(a5),a0


	ELHTEST_ABSE	a0
	beq.s	15$		;jump if already frozen
	
	move.l	#VIDEOTYPE_FREEZE4,d0
	CALLTL	FreezeThawDVE
	XJSR	CookFreezeThaw	;be careful to have valid buttons
15$	


;	ELHSET_LINP	a0	;ok
	ELHCLEAR_USERON	a0	;ok
	ELHSET_SA	a0	
;	ELHSET_LINR	a0	;ok
;	ELHCLEAR_AFR	a0	;ok
;	ELHSET_BRIDGE	a0
;	WAIT4LMB
	CALLTL	SendELH2Toaster
;	WAIT4LMB

;+++++++++++++++++++++++++++



	move.l	PI_BMHEADER(sp),a0
	moveq.l	#0,d3
	move.b	bmh_NumberPlanes(a0),d3		;number of planes

	cmp.b	#16,d3
	ble.s	.noaplanes
	moveq.l	#16,d3
.noaplanes
	move.w	bmh_Width(a0),d0
	add.w	#15,d0				;round up to next word
	lsr.w	#3,d0
	and.w	#-2,d0				;clear lsb
	mulu.w	d0,d3				;size of memory required


	move.l	PI_BMHEADER(sp),a3		;get height of file
	move.w	bmh_Height(a3),d4		;from bitmap header
	cmp.w	#BUFFER_TOTAL_HEIGHT,d4
	blt.s	100$
	move.w	#BUFFER_TOTAL_HEIGHT,d4		;#480, length must not be longer
100$						;than picture sturcuture

	move.l	#writesize,d7			;#58
	move.l	frml_CustomBM(a4),d2
	beq.s	200$				;no key to keep up
	move.l	d2,a1
	moveq.l	#0,d2
	move.w	bm_Rows(a1),d2
	lsr.w	#2,d2				;groups of 4 lines
	sub.w	d2,d7				;smaller if bitmap


***!!!! NOTE! CHANGE THIS TO 5 IF YOU ARE HAVING PROBLEMS
	moveq.l	#6,d7	;*****!!!!!! HARD CODED!!!  It was 5 for Version 3.5

200$
 ifeq 1
	lea	TB_VTSetUp(a5),a0		;determine bank to load to
	moveq.l	#0,d0
	ELHTEST_OBR	a0
	beq.s	470$
	move.l	#1,d0				;currentbank
470$	CALLTL	WriteLineZero
 endc

	move.l	TB_CHIPMem(a5),a1		;buffer pointer
	moveq.l	#0,d2				;alpha destination

	moveq.l	#1,d6				;destination line
	add.w	bmh_Y(a3),d6

	DUMPREG	<a3 bmhd>

;	move.l	PI_READBUFFER(sp),a0		;where data comes from
	move.l	d7,d5
	
 ifeq 0
	DUMPMEM	<bmb_Y.w>,bmh_Y(A3),#16
	tst.w	bmh_Y(A3)
	beq 	501$
	bsr	KeyPageLoad
	move.w	#0,bmh_Y(a3)
501$
 endc

	move.b	#1,d0
	bra.s	500$				;adj for dbeq 
*****************************************************************************
**	This is where one line is read from the file into chip memory
*****************************************************************************
400$
	move.l	d3,d0
	move.l	sp,a0				;picture info

	bsr	UnPackLine
	bpl.s	.goodread
	CALLROM	IoErr
	move.l	d0,PI_SIZEOF(sp)		;put error code on stack
	bra	.errorabort

.goodread
	move.l	frml_AlphaFill(a4),d1		;do we discard alpha
	beq.s	.skipalpha
	tst.l	PI_AlphaDepth(a0)		;is there alpha to load
	beq.s	.skipalpha
	lea	PI_ALPHA(a0),a0
	move.l	d2,d0				;offset
	bsr	UnPackAlpha
	addq.l	#1,d2

.skipalpha
	add.l	d3,a0				;source
;	add.l	d3,a1				;destination
	subq.l	#1,d5
500$	dbeq	d4,400$



 ifeq 1
;	DUMPMEM	<bmb_Y.w>,bmh_Y(A3),#16
	tst.w	bmh_Y(A3)
	beq 	341$
	bsr	Dumppagelines
	move.w	#0,bmh_Y(a3)
341$
 endc

	;write lines to toaster here
	DUMPREG	<a3 bmhd>


	movem.l	d0-d5/a0/a2,-(sp)			;allocate mem for bm
	lea	-bm_SIZEOF(sp),sp

	move.b	#4,bm_Depth(sp)
	move.b	#0,bm_Flags(sp)
	move.l	d3,d0
	lsr.w	#4,d0					;find size of plane
	add.w	#7,d0
	and.w	#~7,d0

	move.w	d0,bm_BytesPerRow(sp)


	move.l	d7,d0				;upto 5 hardcoded lines
	sub.l	d5,d0				;skip lines not read yet
	lsl.w	#2,d0				;*4 (hi, lo, hicomp, locomp)
	move.w	d0,bm_Rows(sp)			;typically =20
	
	lsr.l	#4,d3
	add.l	#7,d3
	and.l	#~7,d3

	move.l	TB_CHIPMem(a5),a0		;buffer pointer

	move.l	a0,bm_Planes+12(sp)
	add.l	d3,a0
	move.l	a0,bm_Planes+8(sp)
	add.l	d3,a0
	move.l	a0,bm_Planes+4(sp)
	add.l	d3,a0
	move.l	a0,bm_Planes(sp)

	sub.l	a1,a1				;no interface bm
	sub.l	a2,a2				;palette
	move.l	d6,d0				;start line
	moveq.l	#0,d1				;interfacetop


	lea	TB_VTSetUp(a5),a0		;determine bank to load to
	moveq.l	#0,d4
	ELHTEST_OBR	a0
	beq.s	472$
	move.l	#1,d4				;currentbank
472$
	move.l	sp,a0				;data bitmap
	mulu.w	#3,d3				;dataBMModulo
	move.l	frml_CustomBM(a4),a1		;custom bitmap
	move.l	frml_Palette(a4),a2		;palette
	move.l	frml_CustomBMTop(a4),d1		;custom bm top
	move.l	frml_AMBM(a4),d2		;fader in non safe
	move.l	d3,d0				;modulo
	move.l	d6,d3				;startline

* NOTE!!!! D5 is cleared for AA Chip Machines. This will force zipper writing
* to always occur on an AA machine, even if there is garbage in the bitmap
* beyond the 732nd pixel. The bitmap needs to be 768 pixels wide for AA
* machines. And the bitmap needs to be DOUBLE LONG WORD ALIGNED!!
* If we want to allow non-zipper type writing on AA machines, then D5
* needs to be a parameter to this routine.

	moveq	#0,d5

	CALLTL	DoSafeWrite

	CALLTL	Wait4Top			;finish write before
						;you mess up bp data
	lea	bm_SIZEOF(sp),sp

	movem.l	(sp)+,d0-d5/a0/a2

	move.l	d7,d0
	add.l	d0,d6


	move.l	TB_CHIPMem(a5),a1		;buffer pointer
	move.l	d7,d5


	tst.w	d4
	dbmi	d4,400$				;Other db may have done all
						;lines

.donealllines
.errorabort
	move.l	sp,a1				;picture info
	bsr	StopLoadComposite

;+++++++++++++++++++++++++++
	lea	TB_VTSetUp(a5),a0
;	ELHSET_AFR	a0
;	ELHCLEAR_BRIDGE	a0

	tst.w	TB_UserOn(a5)
	beq.s	30$	
	ELHSET_USERON	a0
30$	
	CALLTL	SendELH2Toaster

* Stays in Frozen, Linear mode
	CALLTL	SoftSpriteBPLCON0On
;+++++++++++++++++++++++++++

.nomem

300$
	move.l	sp,a0
	CALLTL	CloseQuery
	lea	PI_SIZEOF(sp),sp


	movem.l	(sp)+,d0-d7/a0-a4/a6

	rts

 ifeq 1
Dumppagelines:
	movem.l	d0-d5/a0-a6,-(sp)
	move.l	TB_CHIPMem(a5),a1		;buffer pointer
	DUMPMEM	<Bitmaplines>,(A1),#4000	
	movem.l	(sp)+,d0-d5/a0-a6
	rts
 endc


*
*  Called when a frame is not being load in the top line.
*
*
KeyPageLoad:
	movem.l	d0-d7/a0-a6,-(sp)

	DUMPREG	<KeyPageLoad>

	move.l	TB_CHIPMem(a5),a0		;buffer pointer

	move.w	#150,d0
707$
* 0 at 6*16
	move.w	#(6*8)-1,d1
710$
	move.w	#0,(a0)+	
	dbra	d1,710$	
* ff at 6*16
	move.w	#(6*8)-1,d1
711$
	move.w	#$ffff,(a0)+	
	dbra	d1,711$	

* 0  at 18*16
	move.w	#(18*8)-1,d1
712$
	move.w	#0,(a0)+	
	dbra	d1,712$	

* ff at 18*16
	move.w	#(18*8)-1,d1
713$
	move.w	#$ffff,(a0)+	
	dbra	d1,713$	

	dbra	d0,707$

	moveq	#1,d6					;startline
	moveq	#6,d5
	bsr	SendBkBnd

	move.l	#439,d6					;startline
	moveq	#6,d5	
	bsr	SendBkBnd

	movem.l	(sp)+,d0-d7/a0-a6
	rts	


SendBkBnd:
**
* send it to the toaster.
** 
	DUMPMSG	<Sending top band to Toaster>


800$	
	movem.l	d0-d5/a0/a2,-(sp)			;allocate mem for bm
	lea	-bm_SIZEOF(sp),sp

	move.b	#4,bm_Depth(sp)
	move.b	#0,bm_Flags(sp)
	move.l	d3,d0
	lsr.w	#4,d0					;find size of plane
	add.w	#7,d0
	and.w	#~7,d0

	move.w	d0,bm_BytesPerRow(sp)


	move.l	d7,d0				;upto 5 hardcoded lines
	sub.l	d5,d0				;skip lines not read yet
	lsl.w	#2,d0				;*4 (hi, lo, hicomp, locomp)
	move.w	d0,bm_Rows(sp)			;typically =20
	
	lsr.l	#4,d3
	add.l	#7,d3
	and.l	#~7,d3

	move.l	TB_CHIPMem(a5),a0		;buffer pointer

	move.l	a0,bm_Planes+12(sp)
	add.l	d3,a0
	move.l	a0,bm_Planes+8(sp)
	add.l	d3,a0
	move.l	a0,bm_Planes+4(sp)
	add.l	d3,a0
	move.l	a0,bm_Planes(sp)

	sub.l	a1,a1				;no interface bm
	sub.l	a2,a2				;palette
	move.l	d6,d0				;start line
	moveq.l	#0,d1				;interfacetop


	lea	TB_VTSetUp(a5),a0		;determine bank to load to
	moveq.l	#0,d4
	ELHTEST_OBR	a0
	beq.s	472$
	move.l	#1,d4				;currentbank
472$
	move.l	sp,a0				;data bitmap
	mulu.w	#3,d3				;dataBMModulo
	move.l	frml_CustomBM(a4),a1		;custom bitmap
	move.l	frml_Palette(a4),a2		;palette
	move.l	frml_CustomBMTop(a4),d1		;custom bm top
	move.l	frml_AMBM(a4),d2		;fader in non safe
	move.l	d3,d0				;modulo
	move.l	d6,d3				;startline

* NOTE!!!! D5 is cleared for AA Chip Machines. This will force zipper writing
* to always occur on an AA machine, even if there is garbage in the bitmap
* beyond the 732nd pixel. The bitmap needs to be 768 pixels wide for AA
* machines. And the bitmap needs to be DOUBLE LONG WORD ALIGNED!!
* If we want to allow non-zipper type writing on AA machines, then D5
* needs to be a parameter to this routine.

	moveq	#0,d5

	CALLTL	DoSafeWrite

	CALLTL	Wait4Top			;finish write before
						;you mess up bp data
	lea	bm_SIZEOF(sp),sp

	movem.l	(sp)+,d0-d5/a0/a2

	move.l	d7,d0
	add.l	d0,d6


	move.l	TB_CHIPMem(a5),a1		;buffer pointer
	move.l	d7,d5

	rts
	












******i ToasterBase/UnPackLine **********************************************
*
*   NAME   
*	UnPackLine -- Unpacks a compressed line of framestore data
*
*   SYNOPSIS
*	UnPackLine(pictureinfo,dest,size)
*	             a0         a1   d0
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*	A1 dest pointer is bumped
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*	Still too slow.  fix read data.
*   SEE ALSO
*
*****************************************************************************
UnPackLine:
	movem.l	d0-d6/a0/a2-a4/a6,-(sp)

	lsr.w	#4,d0				;size of each plane
	move.l	d0,d5				;size required
	move.l	d0,d4
	add.w	#7,d4
	and.w	#~7,d4

	sub.w	d5,d4				;modulo

	moveq.l	#16-1,d6			;plane counter


	move.l	a1,a2				;dest
	move.l	a0,a1				;picture info
	move.l	TB_DOSBase(a5),a6		;dosbase
	move.l	PI_BMHEADER(a1),a3
	move.b	bmh_Compression(a3),d1
	cmp.b	#1,d1
	beq.s	.brun1

111$
	move.l	d5,d3		;size to read
	XJSR	ReadDataNorm
	bmi.s	.errexit
	add.w	d4,a2
	dbf	d6,111$

	bra.s	.corner
.brun1
112$
	move.l	d5,d3
	XJSR	ReadData
	bmi.s	.errexit
	add.w	d4,a2
	dbf	d6,112$

.corner


	move.l	a2,a4


	move.l	PI_PLANEBUFFER(a1),a2
	add.l	(sp),a2				;put in composite place

	move.l	PI_PLANEBUFFERSIZE(a1),d3	;size of alpha to unpack
	sub.l	(sp),d3
;	subq.l	#1,d3				;for dbf in ReadData
	bgt.s	.go2
	moveq.l	#0,d0
	bra.s	.errexit
.go2
	move.l	PI_BMHEADER(a1),a3
	move.b	bmh_Compression(a3),d1
	cmp.b	#1,d1
	beq.s	.brun2
	XJSR	ReadDataNorm
	bra.s	.corner2
.brun2
	XJSR	ReadData
.corner2
.errexit

	move.l	a4,a1

	movem.l	(sp)+,d0-d6/a0/a2-a4/a6
	rts

******i ToasterBase/UnPackAlpha *********************************************
*
*   NAME   
*	UnPackAlpha -- Unpacks alpha planes
*
*   SYNOPSIS
*	length=UnPackAlpha(offset,sourceplanes,destbm)
*	                     d0        a0        d1
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
	XDEF	UnPackAlpha
UnPackAlpha:
	movem.l	d0-d2/a0-a4,-(sp)

	move.l	d1,a1

	mulu.w	bm_BytesPerRow(a1),d0
	move.l	d0,(sp)				;offset

	lea	bm_Planes(a1),a2
	moveq.l	#0,d1
	move.b	bm_Depth(a1),d1

;;	DUMPUDEC.b	<AlphaDepth=>,d1,<\>

	moveq.l	#0,d0
	move.w	bm_BytesPerRow(a1),d0


	bra.s	.endloop
.loop
	move.l	(a2)+,a3
	add.l	(sp),a3			;add offset. dest
	move.l	(a0)+,a4		;            source

	move.w	d0,d2
	bra.s	.endcop

.copy
	move.b	(a4)+,(a3)+
.endcop
	dbf	d2,.copy
.endloop
	dbf	d1,.loop

	movem.l	(sp)+,d0-d2/a0-a4

	rts

******* ToasterLibrary/StartLoadComposite ***************************************
*
*   NAME   
*	StartLoadComposite -- Allocates buffer memory for loading framestore.
*
*   SYNOPSIS
*	StartLoadComposite(pictureinfo)
*	Z                        a1
*
*   FUNCTION
*	This routine allocates the memory required to read a framestore.
*
*   INPUTS
*	picutureinfo   - pointer to a picture info.
*   RESULT
*	returns *Z if sucessfull Z if failed
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
StartLoadComposite:
	movem.l	d0-d2/a0-a4/a6,-(sp)
	CALLTL	StartLoadRGBPicture
	movem.l	(sp)+,d0-d2/a0-a4/a6
	rts

******* ToasterLibrary/StopLoadComposite ************************************
*
*   NAME   
*	StopLoadComposite -- Frees memory allocated by StartLoadComposite.
*
*   SYNOPSIS
*	StopLoadComposite(pictureinfo)
*                             a1
*
*   FUNCTION
*	Frees all memory allocated by StartLoadComposite.
*
*   INPUTS
*	Save pictureinfo structure you passed to StartLoadComposite.
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
StopLoadComposite:
	movem.l	d0-d1/a0-a1/a4/a6,-(sp)
	CALLTL	StopLoadRGBPicture
	movem.l	(sp)+,d0-d1/a0-a1/a4/a6
	rts


*****************************************************************************
*
* ErrorMessages FrameLoad( FileName, ToasterBase );
* (32)              (32)       (32)
*  D0                A0         A5
*
* This function causes the digital bank to be loaded from the specified
* filename in the current directory.
* Caller must display error messages FrameSliceError1/2.
* ErrorMessages is a pointer to an array of two pointers to ascii strings,
* or NULL if successful
*
* Trashes D1,A0,A1.
*
*****************************************************************************

	IFNE	_CCODE

 XLABEL	_FrameLoadOld
	move.l	4(sp),a0
	SAVE1	a5
	lea	_ToasterBase,a5
	CALL.s	FrameLoad
	REST1	a5
	rts

	ENDC

 XLABEL	FrameLoadOld
	SAVE	d2-d7/a2/a3/a6
	lea	-bm_SIZEOF(sp),sp

	GET.l	TB_DOSBase,a6		; get DOS base
	lea.l	LocalData,a3		; address local data

	CLEAR	d0			; clear error status
	clr.l	FrameSliceError1(a3)
	clr.l	FrameSliceError2(a3)

	XJSR	StartFrameRead		; open specified framestore file
	move.l	d0,d6
	bne.s	.GotStarted
	lea.l	TextFrameCorrupt(a3),a0
	move.l	a0,FrameSliceError1(a3)
	bra		.ExitQ

.GotStarted:

* get field buffer (weird-scrambled) for GrabField()
	move.l	TB_CHIPMem(a5),d0

* build the bitmap structure for Grabbed2Planes()
	move.w	#BUFFER_WIDTH_OLD/8,bm_BytesPerRow(sp)
	move.w	#BUFFER_HEIGHT_OLD,bm_Rows(sp)
	clr.b	bm_Flags(sp)
	move.b	#BUFFER_FIELD_DEPTH,bm_Depth(sp)
	lea.l	bm_Planes(sp),a0
	moveq.l	#BUFFER_FIELD_DEPTH-1,d1

	lea	4*BUFFER_FIELD_DEPTH(a0),a0		;point to last plane
10$:
	move.l	d0,-(a0)
	add.l	#(BUFFER_WIDTH_OLD/8)*BUFFER_HEIGHT_OLD,d0
	dbra	d1,10$

*************************************
	CALLTL	SoftSpriteBPLCON0Off

* since the Interface Planes are destroyed, we will use this new coplist.
	CALLTL	InstallAVE

* SetUp toaster for uploading
	lea	TB_VTSetUp(a5),a0

	ELHTEST_ABSE	a0
	beq.s	15$		;jump if already frozen
	
	move.l	#VIDEOTYPE_FREEZE4,d0
	CALLTL	FreezeThawDVE
	XJSR	CookFreezeThaw	;be careful to have valid buttons

15$	
	ELHSET_LINP	a0
	ELHCLEAR_USERON	a0
	ELHSET_SA	a0	
	ELHSET_LINR	a0
	ELHCLEAR_AFR	a0
	ELHSET_BRIDGE	a0	;?
;;	ELHCLEAR_LUT	a0 ;???
	CALLTL	SendELH2Toaster

*************************************
* Initialize FieldWrite Structure
	movea.l	TB_EffectsBase+EFB_SpriteData(a5),a1
	lea	ESD_Sprite1Linear(a1),a2
	move.l	a2,TB_EffectsBase+EFB_FieldWrite+FW_Sprite1(a5)
	
	move.l	TB_CurrentCopList(a5),TB_EffectsBase+EFB_FieldWrite+FW_AfterCopList(a5)

	move.w	#BUFFER_WIDTH_OLD,TB_EffectsBase+EFB_FieldWrite+FW_PixelsWide(a5)

*************************************
* for each field I-IV,
	moveq	#0,d7	;field counter
	moveq	#4-1,d3	;4 fields
20$	
	moveq	#2-1,d5	;2 nibbles/field

* load from disk with ReadNextField()
25$	
	move.l	d6,a0	; file handle
	move.l	sp,a1	; bitmap structure
	move.l	d5,d0
	XJSR	ReadNextField
	tst.l	d0
	bne.s	.GotField
	lea.l	TextLoadError(a3),a0
	move.l	a0,FrameSliceError1(a3)
	lea.l	TextFrameNotLoaded(a3),a0
	move.l	a0,FrameSliceError2(a3)
	bra		.Exit

.GotField
	tst	d5
	beq.s	.nodezip
	move.l	sp,a0
	bsr	ShiftToDeZip

*************************************
* upload nibbles to toaster
.nodezip lea	TB_EffectsBase+EFB_VTSprites0(a5),a0
	GETCURRENT a0
	move.l	a0,TB_EffectsBase+EFB_FieldWrite+FW_Sprite0(a5)
	
	move.w	#$f000,d0	;red
	swap	d0

	IFD	NEGCOLORS
	move.w	d7,d2
	add.w	#2,d2
	andi.w	#%11,d2
	move.w	d2,d0
	ENDC

	IFND	NEGCOLORS
	move.w	d7,d0
	ENDC

	ror.w	#2,d0		;field

	or.w	d5,d0		;nibble

	ori.w	#%10,d0		;cerb high
	ror.w	#2,d0		;green = nibble, and field		
	
	moveq	#1,d1
	move.l	#239,d2
	CALLTL	FillSprite

	and.w	#~$8000,d0
	move.l	#0,d1
	moveq	#1,d2
	CALLTL	FillSprite	;only do 240 lines!

	move.l	#240,d1
	CALLTL	FillSprite

	lea	TB_EffectsBase+EFB_FieldWriteCopLists(a5),a1
	GETCURRENT a1
	move.l	a1,TB_EffectsBase+EFB_FieldWrite+FW_CopList(a5)

	move.w	d5,d0
	lsl.w	#4,d0
	lea	bm_Planes(sp,d0.w),a0
	move.l	a0,TB_EffectsBase+EFB_FieldWrite+FW_Planes(a5)

	lea	TB_EffectsBase+EFB_FieldWrite(a5),a0
	CALLTL	SetUpFieldWrite
			
;;	moveq	#1,d1 ;for debug
27$	
	lea	  _custom,a0

	CALLTL	AllInterruptsOff
26$	move.b	vhposr(a0),d0	
	cmpi.b	#21,d0		;needs to be about at least line 21 ( COPINITDONE ??? )
	bcs.s	26$		;jump if to near field start (or end?)

	move.l    a1,cop1lc(a0)	;TB never knows about it!
	CALLTL	AllInterruptsOn

* Dont allow ToastBase to ever know about this coplist
;;	CALLTL	InstallFieldIorIII	;send data to toaster DONT USE
	CALLTL	Wait4Top

;;	btst.b	#6,$bfe001 ;for debug
;;	bne.s	27$
;;28$	btst.b	#6,$bfe001
;;	beq.s	28$

;;	dbra	d1,27$
*************************************
	lea	TB_EffectsBase+EFB_VTSprites0(a5),a0
	FLIPCURRENT a0	
	lea	TB_EffectsBase+EFB_FieldWriteCopLists(a5),a0
	FLIPCURRENT a0

	dbra	d5,25$
	
	addq	#1,d7
	dbra	d3,20$

 ifeq 0
	movem.l	d0-d7,-(sp)
	lea	TB_VTSetUp(a5),a0	;Fix half Line of Video
	moveq.l	#0,d0
	ELHTEST_OBR	a0
	beq.s	472$
	move.l	#1,d0			;currentbank
472$	CALLTL	WriteLineZero


	move.l	d0,d7			;bank
	moveq.l	#$47,d0			;data 1
	moveq.l	#$47,d1			;data 2
	moveq.l	#$47,d2			;data 3
	moveq.l	#100,d3			;data 1 width
	moveq.l	#100,d4			;data 2 width
	move.l	#480,d5			;line
	moveq.l	#1,d6			;height
	move.l	TB_CHIPMem(a5),a0
	CALLTL	WriteGrayPulse
	moveq.l	#1,d5			;line
	CALLTL	WriteGrayPulse


	movem.l	(sp)+,d0-d7
 endc

.Exit:
	move.l	d6,a0		; file handle
	XJSR	EndFrameRead

	CALLTL	Wait4Top	;!!!!!! Kill this later, probably not needed

	lea	TB_VTSetUp(a5),a0
	ELHSET_AFR	a0
	ELHCLEAR_BRIDGE	a0	;?
;;	ELHNOT_OBR	a0		; Not really necessary?, for flipping banks

	tst.w	TB_UserOn(a5)
	beq.s	30$	
	ELHSET_USERON	a0
30$	
	CALLTL	SendELH2Toaster

* Stays in Frozen, Linear mode
;;;;	CALLTL	ReDoDisplay	; done by caller, if needed
;;;;	CALLTL	InstallAVEI
	CALLTL	SoftSpriteBPLCON0On

.ExitQ:
	moveq.l	#NULL,d0		; success return
	tst.l	FrameSliceError1(a3)
	beq.s	.RealExit
	lea.l	FrameSliceError1(a3),a0
	move.l	a0,d0
.RealExit
	lea.l	bm_SIZEOF(sp),sp
	REST	d2-d7/a2/a3/a6
	rts

**-------------------------------------------------------------------
**	ShiftToDeZip(bitmap)
**			a0
**
**
**	Shifts Pixel 735 to pixel 732 useing blitter
**-------------------------------------------------------------------
ShiftToDeZip
	movem.l	d0-d4/a0-a3/a6,-(sp)

	move.l	TB_GFXBase(a5),a6

	moveq.l	#0,d2
	move.b	bm_Depth(a0),d2
	lea	bm_Planes(a0),a3

	move.w	bm_BytesPerRow(a0),d3
	mulu.w	bm_Rows(a0),d3
	subq.l	#2,d3				;offset to start blit

	moveq.l	#0,d4				;calcutate size of blit
	move.w	bm_Rows(a0),d4
	lsl.l	#6,d4
	or.w	#1,d4				;size of blit

	CALLROM	OwnBlitter
;	CALLROM	WaitBlit

	lea	_custom,a1			;custom chips
	bsr.s	waitblit
;; test	only CALLTL	Wait4Top


	moveq.l	#0,d0
	move.l	#(BUFFER_WIDTH_OLD/8)-2,d0
	move.w	d0,bltamod(a1)		;setup destination modulus
	move.w	d0,bltbmod(a1)		;setup source modulus
	move.w	d0,bltdmod(a1)		;setup source modulus

	moveq.l	#-1,d0
	move.w	d0,bltafwm(a1)		;first word mask
	move.w	d0,bltalwm(a1)		;last word mask
	move.w	#2,bltcon1(a1)		;Desc Mode Blit

	bra.s	.countplanes
.shiftloop
	move.l	(a3)+,d0
	beq.s	.doneallplanes
	add.l	d3,d0
	move.l	d0,bltdpt(a1)	; raster destination
	move.l	d0,bltapt(a1)	; source for shifted data
	move.l	d0,bltbpt(a1)	; source for non shifted data
	move.w	#$0de4!(shiftlastback<<12),bltcon0(a1)	;setup bltcon0
	move.w	#1<<shiftlastback,bltcdat(a1)		;mask bit
	move.w	d4,bltsize(a1)			;start blitter
;	XSYS	WaitBlit
	bsr.s	waitblit
; test only	CALLTL	Wait4Top

	move.l	d0,bltdpt(a1)	; raster destination
	move.l	d0,bltapt(a1)	; source for shifted data
	move.l	d0,bltbpt(a1)	; source for non shifted data
	move.w	#$0de4!((shiftlastback-1)<<12),bltcon0(a1)	;setup bltcon0
	move.w	#1<<(shiftlastback-1),bltcdat(a1)		;mask bit
	move.w	d4,bltsize(a1)			;start blitter
;	XSYS	WaitBlit
	bsr.s	waitblit
; test only	CALLTL	Wait4Top


.countplanes
	dbf	d2,.shiftloop

.doneallplanes

	CALLROM	DisownBlitter

	movem.l	(sp)+,d0-d4/a0-a3/a6
	rts

waitblit
	btst.b	#6,dmaconr(a1)
	btst.b	#6,dmaconr(a1)

100$	btst.b	#6,dmaconr(a1)
	bne.s	100$

	btst.b	#6,dmaconr(a1)
	btst.b	#6,dmaconr(a1)
	rts

*******************************************************************
* VOID StringCopy(char *From, *To)
*                        a0    a1
* Summary
*	copys a null-terminated string to a new location (incl. null)
*
* Upon Exit:
*	all registers preserved
********************************************************************`
 XLABEL	StringCopy
	movem.l	a0-a1,-(sp)
.NextChar
	move.b	(a0)+,(a1)+
	bne.s	.NextChar
	movem.l	(sp)+,a0-a1
	rts

*******************************************************************
* WORD StringLength(char *string)
*  d0                    a0
*
* Summary
*	returns length of null-terminated string
*
* Upon Exit:
*	d0 contains length / all others preserved
********************************************************************`
 XLABEL	StringLength
	move.l	a0,-(sp)
	moveq.l	#0,d0
1$
	tst.b	(a0)+
	beq.s	2$
	addq.l	#1,d0
	bra.s	1$
2$
	move.l	(sp)+,a0
	rts

*******************************************************************
* VOID StringAppend(char *From, *To)
*                        a0    a1
* Summary
*	appends a null-terminated string onto another string
*
* Upon Exit:
*	all registers preserved
********************************************************************`
 XLABEL	StringAppend
	movem.l	d0/a0-a1,-(sp)
	exg.l	a0,a1
	bsr.s	StringLength
	add.l	d0,a0
.NextChar
	move.b	(a1)+,(a0)+
	bne.s	.NextChar
	movem.l	(sp)+,d0/a0-a1
	rts

*******************************************************************
* LONG BigMultiply(LONG Number1, Number2)
*  d0,d1                   d0       d1
*
* Summary
*	multiplies two signed 32-bit numbers,
*	result in d0 (low 32 bits) and d1 (high 32 bits)
*	FROM:The 68000:principles and programming, Leo Scanlon, p.116
*
* Upon Exit:
*	all registers preserved
********************************************************************`
BigMultiply
	movem.l	d2-d7,-(sp)
	move.l	d1,d2	; to match book's paramters
	move.l	d0,d1

	move.l	d1,d6
	move.l	d2,d7

	move.l	d1,d3
	move.l	d1,d4
	swap	d4
	move.l	d2,d5
	swap	d5
	mulu	d2,d1
	mulu	d4,d2
	mulu	d5,d3
	mulu	d5,d4
	swap	d1
	add.w	d2,d1
	moveq.l	#0,d5
	addx.l	d5,d4
	add.w	d3,d1
	addx.l	d5,d4
	swap	d1

	clr.w	d2
	swap	d2
	clr.w	d3
	swap	d3
	add.l	d3,d2

	add.l	d4,d2

	tst.l	d7
	bpl.s	.Chkd6
	sub.l	d6,d2

.Chkd6
	tst.l	d6
	bpl.s	.Done
	sub.l	d7,d2

.Done
	move.l	d1,d0	; change book's parameters to mine
	move.l	d2,d1
	movem.l	(sp)+,d2-d7	
	rts




CheckFileType:			; 0- animation
	moveq.l	#-1,d0

	movem.l	d0-d5/a0-a1/a6,-(sp)

	clr.b	SetLoop+4+3

	move.l	a0,d1
	move.l	#MODE_OLDFILE,d2
	move.l	TB_DOSBase(a5),a6
	XSYS	Open
	move.l	d0,d5
	beq.s	.abort

	bsr	ReadFormSize
	bne.s	.errorclose

	cmp.l	#'FORM',D0
	bne.s	.errorclose			;not an iff file
	cmp.l	#'ANIM',D2
	bne.s	.errorclose			;not an anim file

	move.l	d5,d1				;handle
	move.l	#$20,d2
	move.l	#OFFSET_BEGINNING,d3
	XSYS	Seek
	move.l	d5,d0				;handle
	bsr	ReadFormSize
	bne.s	.errorclose
	move.l	d0,4(sp)			;size of file

	move.l	d5,d1				;handle
	move.l	#$34,d2
	move.l	#OFFSET_BEGINNING,d3
	XSYS	Seek
	move.l	d5,d0				;handle
	bsr	ReadFormSize
	bne.s	.errorclose
	cmp.l	#'NWTK',D0
	bne.s	.nont

	move.l	d5,d0				;handle
	bsr	ReadFormSize
	bne.s	.errorclose

	lea	SetLoop+4+3,a0
	tst.l	d0
	sne	(a0)
.nont

	clr.l	(sp)				;Yes it is an anim file

.errorclose
	move.l	d5,d1
	XSYS	Close
.abort

	movem.l	(sp)+,d0-d5/a0-a1/a6
	move.l	d0,d0				;set z flag
	rts



ReadFormSize
	movem.l	d0-d3/a0-a1,-(sp)
	move.l	d0,d1		;file handle
	move.l	sp,d2		;buffer
	moveq.l	#12,d3		;length
	XSYS	Read
	cmp.l	d0,d3
100$	movem.l	(sp)+,d0-d3/a0-a1
	rts


*****************************************************************************
LoadAnimation:

	movem.l	d0-d1/a0-a1/a6,-(sp)
	CALLTL	DisplayWaitSprite
	tst.l	CurrentAnim
	beq.s	.NoneLoaded
	bsr	UnLoadAnimation
.NoneLoaded
	move.l	TB_DOSBase(a5),a6
	CALLTL	LoadAnim
	move.l	d0,CurrentAnim
	beq.s	.fail
	move.l	d0,a0
	XJSR	GetRamAnimFrameCount
	move.w	d0,TB_FCountSec(a5)
	lea	PreviewCrouton,a0

***!!!**** WARNING!!!! WE NO LONGER ACCESS MOST OF THE FGS_ FIELDS
* DIRECTLY.  SO THIS MAY NEED TO BE FIXED.  I DIDN'T FIX IT BECAUSE
* I COULDN'T UNDERSTAND HOW TB_FCountSec COULD WORK HERE FOR ANIMS???
* SKELL 1-13-94
;;	move.w	d0,FGS_MedFCount(a0)

	move.w	d0,TB_NumFramesMedium(a5)

;;	CALLTL	UpdateDisplay
.fail
	CALLTL	DisplayNormalSprite
	movem.l	(sp)+,d0-d1/a0-a1/a6
	rts

*****************************************************************************
UnLoadAnimation
	movem.l	d0-d1/a0-a1,-(sp)
	move.l	CurrentAnim,d0
	beq.s	.exit
	move.l	d0,a0
	CALLTL	FreeAnim
	clr.l	CurrentAnim
.exit
	movem.l	(sp)+,d0-d1/a0-a1
	rts


*****************************************************************************
SelectPreviewCrouton
	movem.l	d0-d7/a0-a6,-(sp)

	cmp.l	TB_EfxFG(a5),a0
	beq.s	.Exit			; We are selected so just exit
	move.l	FG_Function(a0),d0	; function code
	beq.s	.Exit			; this can never happen
	move.l	a5,-(sp)
	move.l	a0,-(sp)
	move.l	#FGC_SELECTQ,-(sp)
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
.Exit
	movem.l	(sp)+,d0-d7/a0-a6
	rts

*****************************************************************************
DoPlay
	movem.l	d0-d1/a0-a1,-(sp)
	move.l	CurrentAnim,d0
	move.l	d0,a0
	beq.s	.exit
	moveq.l	#0,d1
	CALLTL	PlayAnim
.exit
	movem.l	(sp)+,d0-d1/a0-a1
	rts

*****************************************************************************
DoTPlay
	movem.l	d0-d1/a0-a1,-(sp)
	move.l	CurrentAnim,d0
	move.l	d0,a0
	beq.s	.exit
	moveq.l	#1,d1
	CALLTL	PlayAnim
.exit
	movem.l	(sp)+,d0-d1/a0-a1
	rts

*****************************************************************************
*
* Preview Anim Crouton
*
* Dummy crouton function handler code.
*
*
*****************************************************************************

* NOTE: This code will never get FGC_LOAD or FGC_UNLOAD commands!
PostviewCode:
	MOVEM.L	4(sp),D0/A3/A5		; D0.L = Gadget Select, A3.L = FG.
	GET.l	TB_EFXbase,a4		; A4.L = Address of Effects Base.
 	JUMPTL	AnimFXHandler


************!!!!!!*********** THIS IS BROKEN!!!!!!
*------------------
ToasterTable:
	dc.l	AFXT_Interlaced
	dc.l	TRUE

	dc.l	AFXT_AnimFiles
	dc.l	AnimFileTable

	dc.l	AFXT_KeyMode
	dc.l	AFXT_Key_Overlay70ns	;PixelSw

	dc.l	AFXT_ButtonELHlogic		
	dc.l	AFXT_Logic_EncoderAlpha

	dc.l	AFXT_Color0Transparent
	dc.l	TRUE

	dc.l	AFXT_FieldSync
	dc.l	TRUE

	dc.l	AFXT_AbortIfSlow
	dc.l	TRUE
SetLoop
	dc.l	AFXT_LoopAnims
	dc.l	FALSE	;TRUE

	ENDOFLIST		;end of tag list

AnimFileTable:
	dc.l	0	;This needs to be filled in with a pointer to a filename

	CNOP	0,4


****************************************************************************
*
*
* HamPreview Crouton test code.
*
*
****************************************************************************
	xdef	HamPreTestselect
HamPreTestselect:
	movem.l	d0-d3/a0-a3,-(sp)

	move.l	CurrentAnim,d0
	beq.s	6$
	move.l	d0,a0
	CALLTL	FreeAnim
	clr.l	CurrentAnim	

6$
	move.l	TB_DOSBase(a5),a6
*	lea	testanimpre,a0
	move.l	FGS_FileName(a3),a0
	CALLTL	LoadAnim
	move.l	d0,CurrentAnim
	movem.l	(sp)+,d0-d3/a0-a3
	rts
			


	xdef	HamPreTest
HamPreTest:		
	movem.l	d0-d3/a0-a3,-(sp)

	tst.l	CurrentAnim
	beq.s	6$
	
	move.l	CurrentAnim,d0
	move.l	d0,a0
	moveq.l	#0,d1
	CALLTL	PlayAnim

	CALLTL	ReDoDisplay
	CALLTL	InstallAVEI
*	
 IFEQ 1
	move.l	CurrentAnim,d0
	beq.s	.exit
	move.l	d0,a0
	CALLTL	FreeAnim
	clr.l	CurrentAnim
 ENDC
.exit	
6$
	movem.l	(sp)+,d0-d3/a0-a3
	rts



testanimpre dc.b	'dos1:testanim',0



*****************************************************************************
*
* Preview Anim Crouton
*
* Dummy crouton function handler code.
*
*
*****************************************************************************

PreviewCode:
	movem.l	4(sp),d0/a3/a5
	GET.l	TB_EFXbase,a4

* NOTE: This code will never get FGC_LOAD or FGC_UNLOAD commands!

	lea	_LVOHandleSwitcher1TBar(a4),a1
	lea	.EffectData(pc),a2


	cmpi.w	#FGC_REMOVE,d0
	beq.s	.dounload
	cmpi.w	#FGC_UNLOAD,d0
	bne.s	.donormal	
.dounload
	bsr	UnLoadAnimation
	bra.s	7$
.donormal

	tst.l	CurrentAnim
	beq.s	6$
	
	cmpi.w	#FGC_AUTO,d0
	bne.s	5$
	bsr	DoPlay
	CALLTL	ReDoDisplay
	CALLTL	InstallAVEI
	rts
5$	


	cmpi.w	#FGC_TBAR,d0
	bne.s	7$

	bsr	DoTPlay
	CALLTL	ReDoDisplay
	CALLTL	InstallAVEI	
	rts

6$
	cmpi.w	#FGC_TBAR,d0
	beq.s	10$
7$	cmpi.w	#FGC_AUTO,d0
	bne.s	25$
	lea	_LVOHandleSwitcher1Auto(a4),a1

10$	lea	TB_VTSetUp(a5),a0
	ELHPUT_CDS_I	a0,VTI_CDS_CD

*------------------
* d0=command, a0->handler function, a1->data, a3->FG, a4->EFXlib, a5->TB

*! OLD as of 11-5-93
*25$	movea.l	EF_TSEab(a4),a0
25$	movea.l	EF_EffectsLogic(a4),a0
	movea.l	TEL_TSEab(a0),a0


	jmp	_LVOProcessEffect(a4)

* SwitcherEffects structure
.EffectData:
	dc.l	.Variables-.EffectData	;always points to Time Variables
	dc.l	SEF_DOELH1		;modes

.Variables:
;------------------------------------------
;00 = end of table
;01 = ignore
;02 = constant		WORDvalue  
 
;all 03,04,05 parameters are binary reals (LONGS)
;03 = linear		initDistance, speed, minDistance, maxDistance
; mind <= sp*t+id <= maxd
 
;04 = accelerated	initVelocity, accel, minSpeed, maxSpeed, initDistance
; (minsp <= ac*t+iv <= maxsp)*t + id
 
;05 = harmonic		initFreq, deltaFreq, minFreq, maxFreq, initPhase, 
;                      iAmp, deltaAmp, minAmp, maxAmp
; (minam <= da*t+ia <= maxam)*t * SIN[(minfr <= df*t+if <= maxfr)*t + ip]+os


;----------------------------
;ELHDATA
	dc.w ET_TELH1

;CD
	dc.w TVT_LINEAR
	dc.l 0,255<<16,$00000000,MAXLIMIT
	
;LKA
	dc.w TVT_CONST
	dc.w IGNORE	;flag use VTSetUps value

;LKB
	dc.w TVT_CONST
	dc.w IGNORE	;flag use VTSetUps value

	dc.w TVT_END
	dc.w ET_RUN

	cnop	0,4

CurrentAnim	dc.l	0

*-----------------------------------------------------
	XDEF	PreviewCrouton
PreviewCrouton:
	DC.l	0			; gg_NextGadget
	DC.w	0			; gg_LeftEdge
	DC.w	0			; gg_TopEdge
	DC.w	0			; gg_Width
	DC.w	0			; gg_Height
	DCB.b	gg_SIZEOF-gg_Flags,0	; clear rest of Gadget structure
	DC.w	0			; FG_ModeType
	DC.w	0			; FG_WWidth
	DC.w	0			; FG_Height
	DC.w	0			; FG_Modulus
	DC.l	0			; FG_Offset
	DC.l	0			; FG_Data
	DC.w	0			; FG_EntrySize
	DC.w	0			; FG_PTRIndex
	DC.l	0			; FG_PTRTable
	DC.l	PreviewCode		; FG_Function
	DC.b	0			; FG_LoadFlag
	DC.b	-1			; FG_DispFlag
	DC.b	-1			; FG_MouseFlag
	DC.b	0			; FG_HiLiteVal
	DC.w	0			; FG_IndexID
	DC.w	0			; FG_HiLiteMask
	DC.w	0			; FG_BorderCon
	DC.w	0			; FG_TopSize
	DC.w	0			; FG_BotSize
	DC.w	0			; FG_LeftWSize
	DC.w	0			; FG_RightWSize
	DC.w	0			; FG_LeftMask
	DC.w	0			; FG_RightMask
	DC.w	0			; FG_Extra1

	dcb.b	PreviewCrouton+FG_SIZ-*,0

	dc.l	0		;FGS_FileName
	dc.l	0		;FGS_ObjectType
	dc.l	0		;FGS_ObjectVersion
	DC.l	0		;FGS_EntryLibrary
	DC.l	0		;FGS_EntryRoutine
	dc.l	PreviewCroutonTagLists-PreviewCrouton 	 ;FGS_TagLists
	DC.l	0		;FGS_LocalData

	dcb.b	PreviewCrouton+FGS_SIZ-*,0

PreviewCroutonTagLists:	
	TAG_START

;;	TAG_CroutonType	0
;;	TAG_TimeLine	0
;;	TAG_IndexID	0	   	

	TAG_FCountMode	0	   

	TAG_VariableFCount	0   	
	TAG_SlowFCount	   	0
	TAG_MedFCount	   	100
	TAG_FastFCount		0

	TAG_VariableFCount68000	0
	TAG_SlowFCount68000    	0
	TAG_MedFCount68000     	100
	TAG_FastFCount68000    	0

	TAG_NumFields		0

;;	TAG_StartTime		0
	TAG_MatteColor		0	   
;;	TAG_CustomMatteColor	0   

* Generated fields after FGC_LOAD or FGC_FCOUNT
	TAG_NumFields		0	;read only
	TAG_NumFramesSlow	0	;read only
	TAG_NumFramesMedium	0	;read only
	TAG_NumFramesFast	0	;read only
	TAG_NumFramesVariable	0	;read only

	TAG_END		;end of tag list

*----------------------------------------------
* NOTE!!! It seems wasteful to have two croutons for playing back animations.
* These two could be combined into one since only their code is different!!!!!

	XDEF	PostviewCrouton
PostviewCrouton:
	DC.l	0			; gg_NextGadget
	DC.w	0			; gg_LeftEdge
	DC.w	0			; gg_TopEdge
	DC.w	0			; gg_Width
	DC.w	0			; gg_Height
	DCB.b	gg_SIZEOF-gg_Flags,0	; clear rest of Gadget structure
	DC.w	0			; FG_ModeType
	DC.w	0			; FG_WWidth
	DC.w	0			; FG_Height
	DC.w	0			; FG_Modulus
	DC.l	0			; FG_Offset
	DC.l	0			; FG_Data
	DC.w	0			; FG_EntrySize
	DC.w	0			; FG_PTRIndex
	DC.l	0			; FG_PTRTable
	DC.l	PostviewCode		; FG_Function
	DC.b	0			; FG_LoadFlag
	DC.b	-1			; FG_DispFlag
	DC.b	-1			; FG_MouseFlag
	DC.b	0			; FG_HiLiteVal
	DC.w	0			; FG_IndexID
	DC.w	0			; FG_HiLiteMask
	DC.w	0			; FG_BorderCon
	DC.w	0			; FG_TopSize
	DC.w	0			; FG_BotSize
	DC.w	0			; FG_LeftWSize
	DC.w	0			; FG_RightWSize
	DC.w	0			; FG_LeftMask
	DC.w	0			; FG_RightMask
	DC.w	0			; FG_Extra1

	dcb.b	PostviewCrouton+FG_SIZ-*,0

	dc.l	0		;FGS_FileName
	dc.l	0		;FGS_ObjectType
	dc.l	0		;FGS_ObjectVersion
	DC.l	0		;FGS_EntryLibrary
	DC.l	0		;FGS_EntryRoutine
	dc.l	PostviewCroutonTagLists-PostviewCrouton 	 ;FGS_TagLists
	DC.l	0		;FGS_LocalData

	dcb.b	PostviewCrouton+FGS_SIZ-*,0

PostviewCroutonTagLists:	
	TAG_START

;;	TAG_CroutonType	0
;;	TAG_TimeLine	0
;;	TAG_IndexID	0	   	

	TAG_FCountMode	0	   

	TAG_VariableFCount	0   	
	TAG_SlowFCount	   	2
	TAG_MedFCount	   	2
	TAG_FastFCount		2

	TAG_VariableFCount68000	0
	TAG_SlowFCount68000    	2
	TAG_MedFCount68000     	2
	TAG_FastFCount68000    	2

	TAG_NumFields		0

;;	TAG_StartTime		0
	TAG_MatteColor		0	   
;;	TAG_CustomMatteColor	0   

* Generated fields after FGC_LOAD or FGC_FCOUNT
	TAG_NumFields		0	;read only
	TAG_NumFramesSlow	0	;read only
	TAG_NumFramesMedium	0	;read only
	TAG_NumFramesFast	0	;read only
	TAG_NumFramesVariable	0	;read only

	TAG_END		;end of tag list

*+*******
*+
*+ void DisplayMessageAndWait( Message1, Message2 );
*+                              A0        A1
*+
*+ Summary:
*+	This routine emulates the old DisplayMessageAndWait() routine that
*+	was removed from ToasterBase. Also insures that the ToasterBase
*+	floppy disk system is kept updated.
*+
*+ Upon Exit:
*+	All registers are preserved.
*+
*+*******

DisplayMessageAndWait:
	SAVE	d0/d1/a0-a3

	CLEAR	d0				; positive IDCMP
	CLEAR	d1				; negative IDCMP
	move.l	d0,a2				; no positive text
	lea	.ContinueString(pc),a3		; negative text
	XCALL	DoSwitcherRequester

	REST	d0/d1/a0-a3
	rts

.ContinueString:
	DC.b	'CONTINUE',0

	CNOP	0,4

*********************************************************************`
	section	,data
	cnop	0,4

MainBlankList	dc.b	EH3,EH2,EHEND

	cnop	0,4

LocalData
	DATASYM	DirectoryLock,LocalData
	dc.l	0
	DATASYM	FrameSliceError1,LocalData
	dc.l	0
	DATASYM	FrameSliceError2,LocalData
	dc.l	0
	DATASYM	PlaneTab,LocalData		;Pointers to buffers
	ds.l	4				;of allocated memory

	DATASYM	ConversionPlane0,LocalData	;for planes2bytes
	ds.l	8
	DATASYM	ConversionPlane1,LocalData
	ds.l	8
	DATASYM	ConversionPlane2,LocalData
	ds.l	8
	DATASYM	ConversionPlane3,LocalData
	ds.l	8

	DATASYM	BankToSave,LocalData
	dc.l	0

	DATASYM	SaveDispatch,LocalData
	dc.l	FieldSave,MRFrameSave,FrameSave

	DATASYM	FieldBuffers,LocalData
	dc.l	0,0,0,0
	dc.l	0			;end of table marker

Icon_save_buffer				
	dc.l	0			;PIcon ptr	

PrivatePicture
	dc.w	CommonBufferWidth,CommonBufferHeight
	dc.b	0,3
	dc.w	0		;pad
	dc.l	0,0,0
	ds.b	bm_SIZEOF


* file names are "000.FS.File_Comment"
	DATASYM	FrameName,LocalData
	DATASYM	FrameNumber,LocalData
	dc.b	"000."
	dc.b	"FS."
	DATASYM	FrameComment,LocalData
	dcb.b	MAX_COMMENT_STRING,0

	DS.b	30					; fudge factor

	DATASYM	TextFrameStore,LocalData
	dc.b	"FrameStore",0


	DATASYM	TextNotAA,LocalData
	dc.b	"Animations can only be played on",0
	DATASYM	TextNotAA2,LocalData
	dc.b	"Amiga 4000 Video Toaster systems",0


	DATASYM	TextFrameNotFound,LocalData
;;	dc.b	"Frame not found.",0
	dc.b	"Graphic not found.",0
	DATASYM	TextFrameCorrupt,LocalData
	dc.b	"Frame not found or is not correct version.",0
	DATASYM	TextLoadError,LocalData
	dc.b	"Error while loading-",0
	DATASYM	TextFrameNotLoaded,LocalData
	dc.b	"Frame not loaded.",0

	DATASYM	TextDeviceError1,LocalData
	dc.b	"Unable to write to selected",0
	DATASYM	TextDeviceError2,LocalData
	dc.b	"device - frame not saved.",0


;;	DATASYM	TextSaveError1,LocalData		;test only
;;	dc.b	"Error1 while saving-",0

;;	DATASYM	TextSaveError2,LocalData		;test only
;;	dc.b	"Error2 while saving-",0

;;	DATASYM	TextSaveError3,LocalData		;test only
;;	dc.b	"Error3 while saving-",0



	DATASYM	TextSaveError,LocalData
	dc.b	"Error while saving-",0
	DATASYM	TextFrameNotSaved,LocalData
	dc.b	"Frame not saved.",0
	DATASYM	TextToasterError,LocalData
	dc.b	"Error while downloading-",0
	DATASYM TextDeleteError,LocalData
	dc.b	"Error while deleting old frame-",0
	DATASYM	TextNotEnoughRoom1,LocalData
	dc.b	"Not enough room on selected",0
	DATASYM	TextNotEnoughRoom2,LocalData
	dc.b	"device to save this frame.",0
	DATASYM	OverWriteMsg,LocalData
	DC.b	'Overwrite existing Framestore',0
	DATASYM	BadDiskMsg,LocalData
	DC.b	'Bad device',0
	DATASYM	FormatMsg,LocalData
	DC.b	'Format the disk and continue?',0
	DATASYM	SaveFSMsg,LocalData
	DC.b	'Could not save the Framestore',0
	DATASYM	YesMsg,LocalData
	DC.b	'YES',0
	DATASYM	NoMsg,LocalData
	DC.b	'NO',0
	DATASYM	RetryMsg,LocalData
	DC.b	'RETRY',0
	DATASYM	CancelMsg,LocalData
	DC.b	'CANCEL',0
	DATASYM	FSDiskName,LocalData
	DC.b	'FrameStore',0
	DATASYM	notcalerror,LocalData
;	DC.b	'Cpu is not Calibrated.',0
	DC.b	'Unable to calibrate for frame grab.',0
	DATASYM	TextAbortSave,LocalData
	DC.b	'Save aborted by user.',0


	DATASYM	TextLoadMEM1,LocalData
	dc.b	"Unable to Load File.",0
	DATASYM	TextLoadMEM2,LocalData
	dc.b	"Out Of Memory.",0


	DATASYM	NoMemError,LocalData
	dc.b	'No Memory For Frame Grab.',0
	DATASYM	SaveCommentArea,LocalData
	DS.b	COMMENT_SIZE


 IFD	JustForFindTab
RAMSTORAGE	DC.B	'RAM:CAL.DAT',0
 ENDC

 
IconName	DC.B	'ram:NoNameFrame',0
		dc.l	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
FSName		dc.l	0
FSIcon		dc.l	0	


RqToRel		dc.l	3,0,1,2,-1	;conversion table from requester
					;buttons to reality
ARToRel		dc.l	1,1,1,1,2,3	;conversion table from arexx to
					;reality +1
 ifeq 1
SaveTypeRequest
; no 2		dc.l	1$
		dc.l	2$
		dc.l	3$
		dc.l	5$
		dc.l	6$

;1$		dc.b	'Two',0
2$		dc.b	'Cancel',0
3$		dc.b	'Number of fields to save?',0
6$		dc.b	' Four ',0
5$		dc.b	'One',0
 endc

	end
* end of frameslice.a
