head	2.52;
access;
symbols;
locks; strict;
comment	@*@;


2.52
date	95.01.24.11.45.05;	author Kell;	state Exp;
branches;
next	2.51;

2.51
date	94.12.15.17.40.13;	author Kell;	state Exp;
branches;
next	2.50;

2.50
date	94.10.28.12.52.00;	author Kell;	state Exp;
branches;
next	2.49;

2.49
date	94.03.18.01.12.01;	author Kell;	state Exp;
branches;
next	2.48;

2.48
date	94.01.08.01.44.08;	author Kell;	state Exp;
branches;
next	2.47;

2.47
date	93.05.24.19.28.25;	author Kell;	state Exp;
branches;
next	2.46;

2.46
date	93.05.24.16.40.36;	author Kell;	state Exp;
branches;
next	2.45;

2.45
date	93.05.12.19.44.21;	author Finch2;	state Exp;
branches;
next	2.44;

2.44
date	93.04.20.14.53.42;	author Finch2;	state Exp;
branches;
next	2.43;

2.43
date	93.04.20.13.12.23;	author Kell;	state Exp;
branches;
next	2.42;

2.42
date	93.04.19.18.37.00;	author Finch;	state Exp;
branches;
next	2.41;

2.41
date	93.04.19.18.27.20;	author Finch;	state Exp;
branches;
next	2.40;

2.40
date	93.04.19.18.13.08;	author Finch;	state Exp;
branches;
next	2.39;

2.39
date	93.04.14.16.41.48;	author Finch2;	state Exp;
branches;
next	2.38;

2.38
date	93.04.14.15.10.24;	author Finch2;	state Exp;
branches;
next	2.37;

2.37
date	93.04.14.13.57.39;	author Finch2;	state Exp;
branches;
next	2.36;

2.36
date	93.04.14.12.55.47;	author Kell;	state Exp;
branches;
next	2.35;

2.35
date	93.04.14.08.33.45;	author Finch;	state Exp;
branches;
next	2.34;

2.34
date	93.04.13.11.59.05;	author Finch2;	state Exp;
branches;
next	2.33;

2.33
date	93.04.12.17.54.23;	author Finch;	state Exp;
branches;
next	2.32;

2.32
date	93.04.12.16.37.30;	author Finch2;	state Exp;
branches;
next	2.31;

2.31
date	93.04.12.16.12.16;	author Finch;	state Exp;
branches;
next	2.30;

2.30
date	93.04.12.15.58.32;	author Finch2;	state Exp;
branches;
next	2.29;

2.29
date	93.04.12.09.07.45;	author Finch2;	state Exp;
branches;
next	2.28;

2.28
date	93.04.05.17.43.06;	author Finch;	state Exp;
branches;
next	2.27;

2.27
date	93.04.05.17.37.35;	author Finch2;	state Exp;
branches;
next	2.26;

2.26
date	93.04.02.18.34.14;	author Finch2;	state Exp;
branches;
next	2.25;

2.25
date	93.04.01.13.58.47;	author Finch2;	state Exp;
branches;
next	2.24;

2.24
date	93.04.01.10.22.17;	author Finch;	state Exp;
branches;
next	2.23;

2.23
date	93.04.01.10.02.09;	author Finch;	state Exp;
branches;
next	2.22;

2.22
date	93.04.01.09.32.02;	author Finch;	state Exp;
branches;
next	2.21;

2.21
date	93.03.31.18.08.16;	author Finch;	state Exp;
branches;
next	2.20;

2.20
date	93.03.31.17.16.47;	author Finch;	state Exp;
branches;
next	2.19;

2.19
date	93.03.30.16.54.39;	author Finch;	state Exp;
branches;
next	2.18;

2.18
date	93.03.29.17.40.55;	author Finch;	state Exp;
branches;
next	2.17;

2.17
date	93.03.29.08.39.10;	author Finch;	state Exp;
branches;
next	2.16;

2.16
date	93.03.26.17.50.52;	author Finch;	state Exp;
branches;
next	2.15;

2.15
date	93.03.26.09.15.12;	author Finch;	state Exp;
branches;
next	2.14;

2.14
date	93.03.25.17.50.00;	author Finch;	state Exp;
branches;
next	2.13;

2.13
date	93.03.25.08.14.56;	author Finch;	state Exp;
branches;
next	2.12;

2.12
date	93.03.24.18.29.12;	author Finch;	state Exp;
branches;
next	2.11;

2.11
date	93.03.23.13.30.04;	author Finch;	state Exp;
branches;
next	2.10;

2.10
date	93.03.22.18.28.48;	author Finch;	state Exp;
branches;
next	2.9;

2.9
date	93.03.22.16.09.47;	author Finch;	state Exp;
branches;
next	2.8;

2.8
date	93.03.19.19.55.39;	author Finch;	state Exp;
branches;
next	2.7;

2.7
date	93.03.17.19.16.15;	author Finch;	state Exp;
branches;
next	2.6;

2.6
date	93.03.16.18.34.36;	author Finch;	state Exp;
branches;
next	2.5;

2.5
date	93.03.16.11.05.02;	author Finch;	state Exp;
branches;
next	2.4;

2.4
date	93.03.16.11.00.14;	author Finch;	state Exp;
branches;
next	2.3;

2.3
date	93.03.12.20.01.37;	author Finch;	state Exp;
branches;
next	2.2;

2.2
date	93.03.11.09.23.26;	author Finch;	state Exp;
branches;
next	2.1;

2.1
date	93.03.04.12.11.33;	author Finch;	state Exp;
branches;
next	2.0;

2.0
date	93.03.03.17.37.09;	author Finch;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.52
log
@Now supports loading ILBMs into FAST memory.  Used by Scrolls/Crawls.
@
text
@	NOLIST
	idnt	Animated
	section	text,code
	Include	"Assembler.i"
	Include	"NewTek.i"
	Include	"Include.i"
	Include "ELH.i"
	Include	"VtHand.i"
	Include	"Instinct.i"
	Include	"Rect.i"
	Include "KeyLogic.i"
	Include	"EfLib.i"
	Include	"Custom.i"
	Include "VTDebug.i"
	Include	"AnimEqu.i"
	Include "AnimatedEffectsEqu.i"
	Include	"AnimWipeMacros.i"
	Include	"IffUncompress.i"

	Include "SerialDebug.i"

;;SERDEBUG	Set	1
	ALLDUMPS

;;DEBUGMEMORY	set	1


*------------------------------------
MEMORYHEXI	MACRO
	IFD	DEBUGMEMORY
	DUMPHEXI.L	<\1>,<\2>,<\3>
	ENDC
	ENDM


	STARTLIST
	PAGE
*************************************************************************
*									*
*	AnimLoad:							*
*									*
*	Loads the Anim data into FastMem and allocates it's needed	*
*	resources.							*
*									*
*	Input:								*
*									*
*	A0.L	= Address of anl Structure.				*
*									*
*	Output:								*
*									*
*	D0.L	= Error Code.						*
*	A0.L	= Address of aec_Base.					*
*									*
*	CC	>= Zero -> Execution Without Error.			*
*	CC	<  Zero -> Failed To Allocate Memory.			*
*									*
*	3.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimLoad

AnimLoad:
	MOVEM.L	D1-D5/A1-A6,-(A7)	; Save Calling State.
	SUBQ.L	#8,A7			; Make Read Buffer On Stack.
	MOVEA.L	A0,A2			; A2.L = anl Structure.
	move.l	a0,d5			; stash -> anl
*
*	Try To Allocate aec Structure.
*
	MOVEQ.L	#aec_Sizeof,D0		; D0.L = Number of Bytes.
	MOVE.L	#MEMF_PUBLIC!MEMF_CLEAR,D1 ; D1.L = Type of Memory.
	MOVEA.L	anl_SYSBase(A2),A6	; A6.L = Address of Sys Base.

	MEMORYHEXI <ALLOC aec >,d0,< >

	JSR	_LVOAllocMem(A6)	; D0.L = Address of Memory.

	MEMORYHEXI <             at >,d0,<\>

	MOVEA.L	D0,A4			; A4.L = Address of aec Base.
	TST.L	D0			; Did We Allocate The Memory?
	BEQ	ANMLDC			; Exit If Failed.
*
*	Allocated aec Memory.
*
	MOVE.L	anl_Flags(A2),aec_Flags(A4)	; Opening Flags.
	MOVE.L	anl_DOSBase(A2),aec_DOSBase(A4)	; DOS Base.
	MOVE.L	anl_SYSBase(A2),aec_SYSBase(A4)	; SYS Base.
	MOVE.L	anl_GFXBase(A2),aec_GFXBase(A4)	; GFX Base.
	MOVE.L	anl_TSTBase(A2),aec_TSTBase(A4)	; TST Base.
	MOVEA.L	anl_AvailableMemory(A2),A3	; A3.L = Addr Available Memory.
*
*	Now Try To Open The File.
*
	MOVE.L	anl_FileName(A2),D1	; D1.L = Address of File Name.
	MOVE.L	#MODE_OLDFILE,D2	; D2.L = Address of File Mode.
	MOVEA.L	aec_DOSBase(A4),A6	; A6.L = Address of Dos Base.
	JSR	_LVOOpen(A6)		; Try To Open The File.
	TST.L	D0			; Did We Open The File?
	BNE.S	ANMLD1			; Jump If All Ok.
	MOVEQ.L	#AEE_OpenFile,D0	; D0.L = Open Error.
	BRA	ANMLDB			; Exit Subroutine.
ANMLD1	MOVEA.L	D0,A2			; A2.L = Address of File Lock.
*
*	Are We In An Overlay Hunk?
*
	MOVE.L	aec_Flags(A4),D4	; D4.L = aec_Flags.
	BTST.L	#aecb_AnimInOverlay,D4	; In an Overlay?
	BEQ.S	ANMLD4			; Jump If Not In an Overlay.
*
*	Find The Overlay.
*
	MOVEA.L	A2,A0			; A0.L = Address of File Lock.
	MOVE.L	#$3F5,D0		; D0.L = Look For Overlay Hunk.
	MOVEA.L	aec_TSTBase(A4),A5	; A5.L = Toast Base.
	CALLTL	FindDebugHunk		; Search For The Overlay Hunk.
	TST.L	D0			; Did We Find The Overlay Hunk?
	BEQ.S	ANMLD3			; Exit If Failed.
	ADDQ.L	#4,D0			; D0.L = Extra Amount To Advance.
	MOVE.L	A2,D1			; D1.L = Value of File Lock.
	MOVE.L	D0,D2			; D2.L = Amount To Skip.
	MOVEQ.L	#OFFSET_CURRENT,D3	; D3.L = Seek Mode.
	JSR	_LVOSeek(A6)		; Go To This Position.
	ADDQ.L	#1,D0			; Did We Have An Error?
	BEQ.S	ANMLD3			; Jump If SEEK Error.
*
*	Find The Code Section We Need.
*
	ANDI.W	#aecm_HunkNumber,D4	; D4.W = Code Hunk Number.
ANMLD2	MOVEA.L	A2,A0			; A0.L = Address of File Lock.
	MOVE.L	#$3E9,D0		; D0.L = Look For Code Hunk.
	CALLTL	FindDebugHunk		; Search For The Hunk.
	TST.L	D0			; Did We Get Anything?
	BEQ.S	ANMLD3			; Exit On Error.
	TST.W	D4			; At The HUNK We Need?
	BEQ.S	ANMLD4			; Jump If At Proper Hunk.
	MOVE.L	A2,D1			; D1.L = Value of File Lock.
	MOVE.L	D0,D2			; D2.L = Amount To Skip.
	MOVEQ.L	#OFFSET_CURRENT,D3	; D3.L = Seek Mode.
	JSR	_LVOSeek(A6)		; Go To This Position.
	ADDQ.L	#1,D0			; Did We Have An Error?
	BEQ.S	ANMLD3			; Jump If SEEK Error.
	DBF	D4,ANMLD2		; Loop Until Done.
*
*	Looked Thru Crouton and Could Not Find An Anim.
*
ANMLD3	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	MOVEQ.L	#AEE_CannotFindOverlay,D0 ; Cannot Find Anim In Overlay.
	BRA	ANMLDB			; Exit Subroutine.
*
*	Read First 8 Bytes.
*
ANMLD4	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
	MOVE.L	A7,D2			; D2.L = Address of Memory Area.
	MOVEQ.L	#8,D3			; D3.L = Number  of Bytes.
	JSR	_LVORead(A6)		; Read Data Off Disk.
	CMP.L	D0,D3			; Read Error?
	BEQ.S	ANMLD5			; Jump If No Error.
	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	MOVEQ.L	#AEE_FileReadError,D0	; D0.L = File Read Error.
	BRA	ANMLDB			; Exit Subroutine.
*
*	Check For Legal Data.
*
ANMLD5	CMPI.L	#'FORM',(A7)		; Did We Get A Form Hunk?
	BEQ.S	ANMLD6			; Not an Iff FORM.
	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	MOVEQ.L	#AEE_WrongFileType,D0	; D0.L = Wrong File Type Error.
	BRA	ANMLDB			; Exit Subroutine.
*
*	Get The Memory To Read Into.
*
ANMLD6	MOVE.L	4(A7),D0		; D0.L = Number of Bytes in Hunk.
	ADDQ.L	#(2-1),D0		; Make Even Number.
	ANDI.W	#~(2-1),D0		; Rounded To Even Number.
	MOVE.L	D0,aec_LoadLength(A4)	; Save Size of Data.
	MOVE.L	#MEMF_PUBLIC,D1		; D1.L = Type of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
	MOVEA.L	aec_TSTBase(A4),A5	; A5.L = Toast Base.
	CALLTL	AllocateBufferMem	; D0.L = Address of Memory Block.
	MOVEA.L	aec_DOSBase(A4),A6	; A6.L = Address of Dos Base.
	MOVE.L	D0,aec_LoadBase(A4)	; Save Pointer To Loaded Data.
	BNE.S	ANMLD7			; Jump If Ok.
	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Not Enough Memory.
	BRA	ANMLDB			; Exit Subroutine.
*
*	Read The Data Out Of The File.
*
ANMLD7	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
	MOVE.L	aec_LoadBase(A4),D2	; D2.L = Address of Memory Area.
	MOVE.L	aec_LoadLength(A4),D3	; D3.L = Number  of Bytes.
	JSR	_LVORead(A6)		; Read Data Off Disk.
	CMP.L	D0,D3			; Read Error?
	BEQ.S	ANMLD8			; Jump If No Error.
	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	MOVEQ.L	#AEE_FileReadError,D0	; D0.L = File Read Error.
	BRA	ANMLDB			; Exit Subroutine.
*
*	Close File, Move From Chip To Fast Memory.
*
ANMLD8	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	MOVE.L	aec_LoadLength(A4),D0	; D0.L = Number of Bytes Loaded Data.
	MOVEA.L	aec_LoadBase(A4),A0	; A0.L = Address of Current Loaded Data.
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of Exec Base.
	BSR	MoveChipToFastMemory	; If Loaded Into Chip, Move To Fast.
	MOVE.L	A0,aec_LoadBase(A4)	; A0.L = Save Address of Loaded Data.
*
*	Check For ILBM.
*
	CMPI.L	#'ILBM',(A0)		; Needs To Be ILBM.
	BEQ.S	ANMLDA			; Jump If Ok.
*
*	Check For ANIM, FORM.
*
	CMPI.L	#'ANIM',(A0)+		; Needs To Be ANIM.
	BNE.S	ANMLD9			; Jump If Not An Anim.
	CMPI.L	#'FORM',(A0)+		; Needs To Be FORM
	BNE.S	ANMLD9			; Jump If Not An Anim.
	ADDQ.L	#4,A0			; Point Past Size.
	CMPI.L	#'ILBM',(A0)		; Needs To Be ILBM.
	BEQ.S	ANMLDA			; Jump If Ok.
ANMLD9	MOVEQ.L	#AEE_WrongFileType,D0	; D0.L = Wrong File Type Error.
	BRA.S	ANMLDB			; Exit Subroutine.
*
*	Build The Structures.
*
ANMLDA	BSR	FindFramePositions	; D0.L = Error Code.
	TST.L	D0			; Check For Error.
	BMI.S	ANMLDB			; Exit On Error.
	BSR	Build_aec_Defaults	; D0.L = Error Code.
	TST.L	D0			; Check For Error.
	BMI.S	ANMLDB			; Exit On Error.
	MOVEA.L	A3,A0			; A0.L = Address of Available Memory.
	BSR	AllocCircularBuffers	; D0.L = Error Code.
	BMI.S	ANMLDB			; Exit If Error.

*------------
* Prevent using up every drop of CHIP or PUBLIC memory
	move.l	d0,-(sp)		; save "good" error code
	movea.l	d5,a2			; restore -> anl

	MOVE.L	anl_CHIPlimit(a2),D0	; D0.L = Number of Bytes.
	MOVE.L	#MEMF_CHIP,D1 		; D1.L = Type of Memory.
	MOVEA.L	anl_SYSBase(A2),A6	; A6.L = Address of Sys Base.
	JSR	_LVOAllocMem(A6)	; D0.L = Address of Memory.
	MOVE.L	D0,-(sp)
	beq.s	10$			; jump if not enough chip

	MOVE.L	anl_PUBLIClimit(a2),D0	; D0.L = Number of Bytes.
	MOVE.L	#MEMF_PUBLIC,D1 	; D1.L = Type of Memory.
	JSR	_LVOAllocMem(A6)	; D0.L = Address of Memory.
	tst.l	D0
	beq.s	20$			; jump if not enough public

	movea.l	d0,a1
	MOVE.L	anl_PUBLIClimit(a2),D0
	JSR	_LVOFreeMem(a6)
	
	movea.l	(sp)+,a1
	MOVE.L	anl_CHIPlimit(a2),D0
	JSR	_LVOFreeMem(a6)

	move.l	(sp)+,d0		; Restore original "good" error code
	bra.s	ANMLDD

* not enough fast
20$ 	movea.l	(sp)+,a1
	MOVE.L	anl_CHIPlimit(a2),D0
	JSR	_LVOFreeMem(a6)
	addq.w	#4,sp
	bra.s	30$

* not enough chip
10$	addq.w	#8,sp
30$	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Error Code.
;;	bra.s	ANMLDB

*------------

*
*	Failed To Build Structures.
*
ANMLDB	BSR	AnimUnload		; Remove Anim From Memory.
	SUBA.L	A4,A4			; A4.L = No aec Structure.
	BRA.S	ANMLDD			; Exit Subroutine.
*
*	Failed To Allocate Memory for aec Structure.
*
ANMLDC	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Error Code.
*
*	Exit Subroutine.
*
ANMLDD	MOVEA.L	A4,A0			; A0.L = Address of aec Structure.
	ADDQ.L	#8,A7			; Return Read Buffer On Stack.
	MOVEM.L	(A7)+,D1-D5/A1-A6	; Return Calling State.
	TST.L	D0			; Set Return Code.
	RTS
	PAGE
*************************************************************************
*									*
*	FindFramePositions:						*
*									*
*	Assign The Pointers To Frame Positions.				*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	D0.L	= Error Code.						*
*									*
*	Current Frame Positions Are Created.				*
*									*
*	5.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FindFramePositions
FindFramePositions:
	MOVEM.L	D1-D4/A0-A2,-(A7)	; Save Calling State.
*
*	Make The First Frame.
*
	CLR.W	aec_TotalFrames(A4)	; Count The Loaded Frames.
	BSR	AllocPackedListStruct	; A0.L = Address of Packed Header.
	BEQ	FNFRPH			; Exit Memory Error.
	MOVE.L	A0,aec_PackedList(A4)	; Save Pointer.
	BEQ	FNFRPH			; Exit Memory Error.
	MOVEA.L	A0,A1			; A1.L = Address of Element In List.
	MOVE.W	aec_TotalFrames(A4),pkl_FrameNumber(A1) ; Current Frame Number.
	ADDQ.W	#1,aec_TotalFrames(A4)	; Increase Frame Count.
	MOVEA.L	aec_LoadBase(A4),A2	; A2.L = Address of IFF Data.
	MOVE.L	aec_LoadLength(A4),D4	; D4.L = Number of Bytes.
*
*	Check For ILBM or ANIM.
*
	CMPI.L	#'ANIM',(A2)		; Is It An Anim?
	BNE.S	FNFRP1			; Jump If Not Anim.
*
*	An Anim Loaded.
*
	SUBI.L	#12,D4			; Less Size of Header.
	BCS	FNFRPG			; Exit If Too Small.
	ADDQ.L	#8,A2			; Move To ILBM Size.
	MOVE.L	(A2)+,D3		; Get ILBM Size.
	BRA.S	FNFRP2			; Slip Else Part.
*
*	An ILBM Loaded.
*
FNFRP1	MOVE.L	D4,D3			; D3.L = ILBM Size.
*
*	Remove That Much Data.
*
FNFRP2	ADDQ.L	#(2-1),D3		; Make Even Number.
	ANDI.W	#~(2-1),D3		; Rounded To Even Number.
	SUB.L	D3,D4			; D4.L = Less Total Size.
	BCS	FNFRPG			; Exit If Too Small.
	ADDQ.L	#4,A2			; A2.L = Move Past ILBM.
	SUBQ.L	#4,D3			; Less What We Read.
	BCS	FNFRPG			; Exit If Too Small.
*
*	Loop And Parse The First Frame.
*
FNFRP3	SUBQ.L	#8,D3			; D3.L = Less Header Size.
	BCS	FNFRPG			; Exit If Too Small.
	MOVE.L	(A2)+,D0		; D0.L = Iff Type.
	MOVE.L	(A2)+,D1		; D1.L = Record Size.
	MOVE.L	D1,D2			; D2.L = Record Size Not Modified.
	ADDQ.L	#(2-1),D1		; Make Even Number.
	ANDI.W	#~(2-1),D1		; Rounded To Even Number.
	SUB.L	D1,D3			; That Much Data There?
	BCS	FNFRPG			; Exit If Too Small.
*
*	Check For BMHD
*
	CMPI.L	#'BMHD',D0		; Is It A Bit Map Header?
	BNE.S	FNFRP4			; Jump If Not Bit Map Header.
	ORI.L	#(1<<pklb_FirstFrame)!(1<<pklb_BMHD)!(1<<pklb_StartFrame),pkl_Flags(A1)
	MOVE.L	A2,pkl_Header(A1)	; Save Pointer to Header.
	BRA.S	FNFRP7			; Skip Else Part.
*
*	Check For BODY
*
FNFRP4	CMPI.L	#'BODY',D0		; Is It A Body Hunk?
	BNE.S	FNFRP5			; Jump If Not Body Hunk.
	BSETA.L	pklb_BODY,pkl_Flags(A1)	; We Have A Body Hunk.
	MOVE.L	D2,pkl_DataSize(A1)	; Save Size of Data.
	MOVE.L	A2,pkl_Data(A1)		; Save Pointer to Data.
	BRA.S	FNFRP7			; Skip Else Part.
*
*	Check For CAMG
*
FNFRP5	CMPI.L	#'CAMG',D0		; Is It A CAMG Hunk?
	BNE.S	FNFRP6			; Jump If Not CAMG Hunk.
	MOVE.L	(A2),pkl_ViewMode(A1)	; Get The View Modes.
	BRA.S	FNFRP7			; Skip Else Part.
*
*	Check For CMAP
*
FNFRP6	CMPI.L	#'CMAP',D0		; Is It A CMAP Hunk?
	BNE.S	FNFRP7			; Jump If Not CMAP Hunk.
	MOVE.L	D2,pkl_ColorTableSize(A1) ; Color Table Size.
	MOVE.L	A2,pkl_ColorTable(A1)	; Pointer to Color Table.
*
*	Advance Thru Record.
*
FNFRP7	ADDA.L	D1,A2			; Move Thru Record.
	TST.L	D3			; Any More Left?
	BNE.S	FNFRP3			; Jump Back If More Left.
*
*	Now Read The DLTA Records.
*
	BRA	FNFRPE			; Check For All Done.
FNFRP8	MOVEA.L	A1,A0			; A0.L = Address of pkl Structure.
	BSR	BuildColorTable		; Make The Color Table.
	BEQ	FNFRPH			; Exit On Memory Error.
	BSR	AllocPackedListStruct	; A0.L = Address of Packed Header.
	BEQ	FNFRPH			; Exit If Failed.
	MOVE.L	A0,pkl_AllocLink(A1)	; Link To Next Allocation.
	MOVE.L	A0,pkl_ForwardLink(A1)	; Link To Next Forward Position.
	MOVE.L	A1,pkl_BackwardLink(A0)	; Link To Next Backward Position.
	MOVE.L	pkl_ColorTableSize(A1),pkl_ColorTableSize(A0)
	MOVE.L	pkl_ColorTable(A1),pkl_ColorTable(A0)
	MOVE.L	pkl_ViewMode(A1),pkl_ViewMode(A0)
	MOVEA.L	A0,A1			; A1.L = Address of Current Element.
	MOVE.W	aec_TotalFrames(A4),pkl_FrameNumber(A1) ; Current Frame Number.
	ADDQ.W	#1,aec_TotalFrames(A4)	; Increase Frame Count.
*
*	Read Thru the FORM size ILBM.
*
	SUBQ.L	#8,D4			; D4.L = Less Size of FORM and size.
	BCS	FNFRPG			; Exit If Too Small.
	CMPI.L	#'FORM',(A2)+		; Need To Word Form.
	BNE	FNFRPF			; Exit If Wrong File Type.
	MOVE.L	(A2)+,D3		; Get Size of Record.
	ADDQ.L	#(2-1),D3		; Make Even Number.
	ANDI.W	#~(2-1),D3		; Rounded To Even Number.
	SUB.L	D3,D4			; D4.L = Less Total Size.
	BCS	FNFRPG			; Exit If Too Small.
	CMPI.L	#'ILBM',(A2)+		; Do We Have An ILBM?
	BNE	FNFRPF			; Exit If Wrong File Type.
	SUBQ.L	#4,D3			; Less What We Read.
	BCS	FNFRPG			; Exit If Too Small.
*
*	Loop And Parse The Delta Frames.
*
FNFRP9	SUBQ.L	#8,D3			; D3.L = Less Header Size.
	BCS	FNFRPG			; Exit If Too Small.
	MOVE.L	(A2)+,D0		; D0.L = Iff Type.
	MOVE.L	(A2)+,D1		; D1.L = Record Size.
	MOVE.L	D1,D2			; D2.L = Record Size Not Modified.
	ADDQ.L	#(2-1),D1		; Make Even Number.
	ANDI.W	#~(2-1),D1		; Rounded To Even Number.
	SUB.L	D1,D3			; That Much Data There?
	BCS.S	FNFRPG			; Exit If Too Small.
*
*	Check For ANHD
*
	CMPI.L	#'ANHD',D0		; Is It A Anim Header?
	BNE.S	FNFRPA			; Jump If Not Anim Header.
	BSETA.L	pklb_ANHD,pkl_Flags(A1)	; We Have An Anim Header.
	MOVE.L	A2,pkl_Header(A1)	; Save Pointer to Header.
	BRA.S	FNFRPD			; Skip Else Part.
*
*	Check For CAMG
*
FNFRPA	CMPI.L	#'CAMG',D0		; Is It A CAMG Hunk?
	BNE.S	FNFRPB			; Jump If Not CAMG Hunk.
	MOVE.L	(A2),pkl_ViewMode(A1)	; Get The View Modes.
	BRA.S	FNFRPD			; Skip Else Part.
*
*	Check For CMAP
*
FNFRPB	CMPI.L	#'CMAP',D0		; Is It A CMAP Hunk?
	BNE.S	FNFRPC			; Jump If Not CMAP Hunk.
	MOVE.L	D2,pkl_ColorTableSize(A1) ; Color Table Size.
	MOVE.L	A2,pkl_ColorTable(A1)	; Pointer to Color Table.
	BRA.S	FNFRPD			; Skip Else Part.
*
*	Check For DLTA
*
FNFRPC	CMPI.L	#'DLTA',D0		; Is It A Dlta Hunk?
	BNE.S	FNFRPD			; Jump If Not Dlta Hunk.
	BSETA.L	pklb_DLTA,pkl_Flags(A1)	; We Have A Dlta Hunk.
	MOVE.L	D2,pkl_DataSize(A1)	; Save Size of Data.
	MOVE.L	A2,pkl_Data(A1)		; Save Pointer to Data.
*
*	Advance Thru Record.
*
FNFRPD	ADDA.L	D1,A2			; Move Thru Record.
	TST.L	D3			; Any More Left?
	BNE	FNFRP9			; Jump Back If More Left.
*
*	All Done With Anim?
*
FNFRPE	TST.L	D4			; Any Data Left?
	BNE	FNFRP8			; Jump If More Data Left.
	MOVEA.L	A1,A0			; A0.L = Address of pkl Structure.
	BSR	BuildColorTable		; Make The Color Table.
	BEQ.S	FNFRPH			; Exit On Memory Error.
*
*	Exit No Error.
*
	MOVEQ.L	#AEE_NoError,D0		; D0.L = No Error.
	BRA.S	FNFRPI			; Exit Subroutine.
*
*	Wrong File Type.
*
FNFRPF	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
	CLR.L	aec_PackedList(A4)	; NULL Pointer To List.
	BSR	FreePackedList		; Give The Memory In The List Back.
	MOVEQ.L	#AEE_WrongFileType,D0	; D0.L = Return Code.
	BRA.S	FNFRPI			; Exit Subroutine.
*
*	Data Too Small.
*
FNFRPG	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
	CLR.L	aec_PackedList(A4)	; NULL Pointer To List.
	BSR	FreePackedList		; Give The Memory In The List Back.
	MOVEQ.L	#AEE_ChunkSizeTooSmall,D0 ; D0.L = Return Code.
	BRA.S	FNFRPI			; Exit Subroutine.
*
*	Memory Error.
*
FNFRPH	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
	CLR.L	aec_PackedList(A4)	; NULL Pointer To List.
	BSR	FreePackedList		; Give The Memory In The List Back.
	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Return Code.
*
*	Exit Subroutine.
*
FNFRPI	MOVEM.L	(A7)+,D1-D4/A0-A2	; Return Calling State.
	TST.L	D0			; Set Flags.
	RTS
	PAGE
*************************************************************************
*									*
*	Build_aec_Defaults:						*
*									*
*	Makes The Default Constants for the Loaded Data.		*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	The aec Structure has it's defaults Set.			*
*									*
*	15.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	Build_aec_Defaults
Build_aec_Defaults:
	MOVEM.L	D1-D2/A0-A2,-(A7)	; Save Calling State.
*
*	Get Pointer To Bit Map Structure.
*
	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Address of Packed List Header.
	MOVE.L	A0,D0			; Check For NULL Pointer.
	BEQ	BLDEFG			; Jump If Nothing Loaded.
	MOVEA.L	pkl_AllocLink(A0),A1	; A1.L = Address of 2nd In Packed List.
	BTSTA.L	pklb_BMHD,pkl_Flags(A0)	; Did We Get A Bit Map Header?
	BEQ	BLDEFG			; Jump If No Loaded.
*
*	Set Up Some Defaults.
*
	MOVE.W	aec_TotalFrames(A4),aec_FrameCount(A4) ; Number of Frames.
	MOVE.L	pkl_ColorTableSize(A0),D0 ; D0.L = Total Size Of Color Table.
	ADDQ.L	#3-1,D0			; Make Number of Colors.
	DIVU.W	#3,D0			; D0.W = Number of Colors.
	ANDI.L	#$FFFF,D0		; Remove Remainder.
	MOVE.W	D0,aec_NumberOfColors(A4) ; Save Number of Colors.
*
*	Make The First Frame Sizes.
*
	MOVEA.L	pkl_Header(A0),A0	; A0.L = Address of Bit Map Header.
	MOVE.L	A0,D0			; Check For NULL Pointer.
	BEQ	BLDEFG			; Jump If Nothing Loaded.
	MOVE.L	aec_ViewModes(A4),pkl_ViewMode(A0) ; Default View Modes.
	MOVE.W	bmh_w(A0),D0		; Make Width Of Screen.
	ADDI.W	#(1<<3)-1,D0		; Go Mod Max Size.
	LSR.W	#3,D0			; D0.W = Number of Bytes Width.
	MOVE.W	D0,aec_Width(A4)	; Save Width In Bytes.
	MOVE.W	bmh_h(A0),D1		; D1.W = Height In Lines.
	MOVE.W	D1,aec_Height(A4)	; Save Height In Lines.
	MULU.W	D1,D0			; D0.L = Number of Bytes in Plane.
	ADDQ.L	#6,D0			; Round Up To Double Word Alligned.
	MOVE.L	D0,aec_PlaneSize(A4)	; Save Plane Size.
	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.B	bmh_nPlanes(A0),D0	; Number of Bit Planes.
	MOVE.W	D0,aec_Depth(A4)	; Save Number of Bit Planes.
*
*	Check For Only One Frame.
*
	MOVE.W	#1,aec_NumberOfBuffers(A4) ; Assume 1 Buffer.
	MOVE.L	A1,D0			; Check For NULL Pointer.
	BNE.S	BLDEF1			; More Than One Loaded.
*
*	Only One Frame Loaded.
*
	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Address of Packed List Header.
	BSETA.L	pklb_LastNormal,pkl_Flags(A0) ; Flag Last Normal Flag.
	MOVE.L	A0,pkl_ForwardLink(A0)	; Forward  Link.
	MOVE.L	A0,pkl_BackwardLink(A0)	; Backward Link.
	BRA	BLDEFD			; Exit Subroutine.
*
*	Check For Number of Buffers.
*
BLDEF1	BTSTA.L	pklb_ANHD,pkl_Flags(A1)	; Did We Get An Anim Header?
	BEQ	BLDEFF			; Jump If No Loaded.
	MOVEA.L	pkl_Header(A1),A0	; A0.L = Address of Anim Header.
	MOVE.L	A0,D0			; Check For NULL Pointer.
	BEQ	BLDEFF			; Jump If Nothing Loaded.
	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.B	anh_interleave(A0),D0	; D0.L = Number of Buffers.
	BNE.S	BLDEF2			; Jump If Ok.
	MOVEQ.L	#2,D0			; Else Set To 2 Buffers.
BLDEF2	MOVE.W	D0,aec_NumberOfBuffers(A4) ; Save Number Of Buffers.
*
*	Mark, Starting At Second Buffer to Nth Buffer, The Copy Flag.
*
	SUBQ.L	#1,D0			; One Less Buffer.
	BRA.S	BLDEF4			; Start Looping.
BLDEF3	ORI.L	#(1<<pklb_MakeFromPrev)!(1<<pklb_StartFrame),pkl_Flags(A1)
	MOVEA.L	pkl_AllocLink(A1),A1	; A1.L = Address of Next In Packed List.
	MOVE.L	A1,D1			; Check For NULL Pointer.
BLDEF4	DBEQ	D0,BLDEF3		; Loop For Number of Buffers - 1.
*
*	We Need To Mark Last Normal and Last Loop.
*
	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Address of Packed List Header.
	MOVEQ.L	#0,D0			; Load Number of Buffers.
	MOVE.W	aec_NumberOfBuffers(A4),D0  ; D0.L = Number of Buffers.
	BTSTA.L	aecb_LoopAnim,aec_Flags(A4) ; Loop Mode Anim?
	BNE.S	BLDEF7			; Jump If Loop Anim.
*
*	Set Non-Loop Mode Pointers.
*
	ORI.L	#(1<<pklb_FirstNormal)!(1<<pklb_NormalFrame),pkl_Flags(A1)
	BRA.S	BLDEF6			; Look For End Of List.
BLDEF5	MOVEA.L	D2,A1			; A1.L = Next Position In List.
	BSETA.L	pklb_NormalFrame,pkl_Flags(A1) ; Mark As Normal.
BLDEF6	MOVE.L	pkl_AllocLink(A1),D2	; D2.L = Address of Next In Packed List.
	BNE.S	BLDEF5			; Loop Back.
	BSETA.L	pklb_LastNormal,pkl_Flags(A1) ; Flag Last Normal Flag.
	MOVE.L	A0,pkl_ForwardLink(A1)	; Forward  Link.
	MOVE.L	A1,pkl_BackwardLink(A0)	; Backward Link.
	BRA.S	BLDEFD			; Exit Subroutine.
*
*	Set Loop Mode Pointers.
*
BLDEF7	MOVEQ.L	#0,D1			; Clear High Bits.
	MOVE.W	aec_TotalFrames(A4),D1	; D1.L = Total Number of Frame.
	SUB.L	D0,D1			; D1.L = Frame Count.
	MOVE.W	D1,aec_FrameCount(A4)	; Save Number of Normal Frames.
	SUB.L	D0,D1			; D1.L = Frames From Nth frame to Last Norma.
	SUBQ.L	#1,D1			; D1.L = Less One.
*
*	Go To Last Normal.
*
	MOVEA.L	A1,A2			; A2.L = Address of Nth Frame.
	BSETA.L	pklb_FirstNormal,pkl_Flags(A2) ; Flag First Normal Flag.
	BRA.S	BLDEF9			; Loop For N Frames.
BLDEF8	BSETA.L	pklb_NormalFrame,pkl_Flags(A1) ; We Have A Normal Frame.
	MOVEA.L	pkl_AllocLink(A1),A1	; A1.L = Address of Next In Packed List.
	MOVE.L	A1,D2			; Check For NULL Pointer.
	BEQ.S	BLDEFE			; Exit If Not Enough Frames.
BLDEF9	DBF	D1,BLDEF8		; Go To Nth Buffer.
	ORI.L	#(1<<pklb_NormalFrame)!(1<<pklb_LastNormal),pkl_Flags(A1) ; Normal & Last
	MOVE.L	A1,pkl_BackwardLink(A0)	; Should Never Happen!!!!!
*
*	Go To Last Loop.
*
	MOVE.L	pkl_AllocLink(A1),D2	; Go To First Loop Frame.
	BEQ.S	BLDEFC			; Jump If All Done.
	MOVEA.L	D2,A1			; A1.L = Next Position In List.
	ORI.L	#(1<<pklb_FirstLoop)!(1<<pklb_LoopFrame),pkl_Flags(A1) ; First & Loop.
	BRA.S	BLDEFB			; Look For End Of List.
BLDEFA	MOVEA.L	D2,A1			; A1.L = Next Position In List.
	BSETA.L	pklb_LoopFrame,pkl_Flags(A1) ; This Is a Loop Frame.
BLDEFB	MOVE.L	pkl_AllocLink(A1),D2	; D2.L = Address of Next In Packed List.
	BNE.S	BLDEFA			; Loop Back.
BLDEFC	BSETA.L	pklb_LastLoop,pkl_Flags(A1)  ; Flag Last Normal Flag.
	MOVE.L	A1,pkl_BackwardLink(A2)	; Point To Last Loop.
	MOVE.L	A2,pkl_ForwardLink(A1)	; Reset Loop Position.
*
*	Exit No Error.
*
BLDEFD	MOVEQ.L	#AEE_NoError,D0		; D0.L = No Error.
	BRA.S	BLDEFH			; Exit Subroutine.
*
*	Not Enough Frames For Loop Mode.
*
BLDEFE	MOVEQ.L	#AEE_ToFewFrames,D0	; D0.L = Too Few Frames.
	BRA.S	BLDEFH			; Exit Subroutine.
*
*	Only One Frame.
*
BLDEFF	MOVEQ.L	#AEE_OnlyOneFrameLoaded,D0 ; Only One Frame Loaded.
	BRA.S	BLDEFH			; Exit Subroutine.
*
*	Error Not Loaded.
*
BLDEFG	MOVEQ.L	#AEE_BMHeaderNotLoaded,D0 ; Bit Map Header Not Loaded.
*
*	Exit Subroutine.
*
BLDEFH	MOVEM.L	(A7)+,D1-D2/A0-A2	; Return Calling State.
	TST.L	D0
	RTS
	PAGE
*************************************************************************
*									*
*	BuildColorTable:						*
*									*
*	Makes the IFF Style Color Table Into A Toaster Color Table.	*
*									*
*	Input:								*
*									*
*	A0.L	= Address of pkl structure to Make Color Table Into.	*
*									*
*	Output:								*
*									*
*	CC	== Zero -> Failed To Make Color Table.			*
*	CC	!= Zero -> Color  Table Was Made.			*
*									*
*	16.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	BuildColorTable
BuildColorTable:
	MOVEM.L	D0-D2/A0-A2/A6,-(A7)	; Save Calling State.
	MOVEA.L	A0,A2			; A2.L = Address of pkl.
*
*	Is There A Color Table Already There?
*
	CLR.W	pkl_NumberOfColors(A2)	; Initial Number Of Colors.
	TST.L	pkl_LoadableColors(A2)	; Color Table There?
	BNE	BUCOT7			; Jump If Color Table There.
	MOVE.L	pkl_ColorTableSize(A2),D0 ; Is There One To Make?
	BEQ	BUCOT6			; Jump If Nothing To Do.
	ADDQ.L	#2,D0			; Round Up.
	DIVU.W	#3,D0			; D0.L = Number of Colors.
	ANDI.L	#$FFFF,D0		; Remove Remainder.
	MOVE.L	D0,D2			; D2.L = Number of Colors.
	MOVE.W	D0,pkl_NumberOfColors(A2) ; Save Number of Colors.
	ADD.L	D0,D0			; D0.L = Word Sized Table
	BTSTA.L	aecb_8BitColors,aec_Flags(A4) ; Do We Have An AA Chip Set?
	BEQ.S	BUCOT1			; Jump If Not AA Chips.
	ADD.L	D0,D0			; D0.L = Long Sized Table.
BUCOT1	MOVE.L	D0,pkl_LoadableCLength(A2) ; Save Size of Data.
	MOVE.L	#MEMF_PUBLIC,D1		; D1.L = Type of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.


	MEMORYHEXI <ALLOC colortable >,d0,< >

	JSR	_LVOAllocMem(A6)	; Try To Get Memory.

	MEMORYHEXI <             at >,d0,<\>

	MOVE.L	D0,pkl_LoadableColors(A2) ; Save Pointer To Allocated Memory.
	BEQ.S	BUCOT7			; Exit If Failed.
*
*	Loop And Make Color Table.
*
	MOVEA.L	pkl_ColorTable(A2),A0	; A0.L = Address of Source.
	MOVEA.L	D0,A1			; A1.L = Address of Destination.
	BTSTA.L	aecb_8BitColors,aec_Flags(A4) ; Do We Have An AA Chip Set?
	BNE.S	BUCTO5			; Jump If AA Chip Set.
*
*	Pre AA Chip Set.
*
	BRA.S	BUCTO3			; Start Looping.
BUCOT2	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.B	(A0)+,D0		; Get Red.
	LSL.W	#4,D0			; Move Up.
	MOVE.B	(A0)+,D0		; Get Green.
	ANDI.B	#$F0,D0			; Leave Only Green.
	MOVE.B	(A0)+,D1		; Get Blue.
	LSR.B	#4,D1			; Move Down.
	OR.B	D1,D0			; D0.W = 0RGB.
	MOVE.W	D0,(A1)+		; Save Result.
BUCTO3	DBF	D2,BUCOT2		; Loop Until Done.
	BRA.S	BUCOT6			; Exit Subroutine.
*
*	AA Chip Set.
*
BUCOT4	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.B	(A0)+,D0		; Get Red.
	SWAP.W	D0			; Put In High Position.
	MOVE.B	(A0)+,D0		; Get Green.
	LSL.W	#8,D0			; Put In High Posiition.
	MOVE.B	(A0)+,D0		; Get Blue.
	BSR	SoftToHardColor		; Convert To New Format.
	MOVE.L	D0,(A1)+		; Save Result.
BUCTO5	DBF	D2,BUCOT4		; Loop Until Done.
*
*	Exit Without Error.
*
BUCOT6	MOVEQ.L	#-1,D0			; Set CC != Zero.
*
*	Exit Subroutine.
*
BUCOT7	MOVEM.L	(A7)+,D0-D2/A0-A2/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	FreeColorTable:							*
*									*
*	Frees the Toaster Color Table.					*
*									*
*	Input:								*
*									*
*	A0.L	= Address of pkl Structure to Free Color Table.		*
*									*
*	Output:								*
*									*
*	Color Table Is Freed.						*
*									*
*	16.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FreeColorTable
FreeColorTable:
	MOVEM.L	D0-D1/A0-A1/A6,-(A7)	; Save Calling State.
*
*	If Color Table There, Deallocate It.
*
	MOVE.L	pkl_LoadableColors(A0),D1 ; Color Table There?
	BEQ	FRCOT1			; Jump If Color Table Not There.
	MOVE.L	pkl_LoadableCLength(A0),D0 ; Get Size of Data.
	BEQ	FRCOT1			; Jump If Color Table Not There.
	MOVEA.L	D1,A1			; A1.L = Address of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; Address of Exec Base.


	MEMORYHEXI <FREE colortable >,d0,< >
	MEMORYHEXI <             at >,a1,<\>


	JSR	_LVOFreeMem(A6)		; Give Back the Memory.
*
*	Exit Subroutine.
*
FRCOT1	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	SoftToHardColor:						*
*									*
*	Converts From The Software Format 8 Bit Color to the Hardware	*
*	Format 4 Bit Colors.						*
*									*
*	Input:								*
*									*
*	D0.L	= LlRrGgBb Software Color Value.			*
*									*
*	Output:								*
*									*
*	D0.L	= LRGBlrgb Hardware Color Value.			*
*									*
*	11.Feb.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	SoftToHardColor
SoftToHardColor:
	MOVEM.L	D1-D3,-(A7)	; Save Calling State.
*
*	Make Blue.
*
	MOVE.W	D0,D1		; D1.W = Result Low.
	ANDI.W	#$000F,D1	; D1.W = 000b.
	LSR.L	#4,D0		; D0.L = 0LlRrGbB.
	MOVE.W	D0,D2		; D2.W = Result High.
	ANDI.W	#$000F,D2	; D2.W = 000B.
*
*	Make Green.
*
	MOVE.W	D0,D3		; D3.W = rGgB.
	ANDI.W	#$00F0,D3	; D3.W = 00g0.
	OR.W	D3,D1		; D1.W = 00gb.
	LSR.L	#4,D0		; D0.L = 00LlRrGg.
	MOVE.W	D0,D3		; D3.W = RrGg.
	ANDI.W	#$00F0,D3	; D3.W = 00G0.
	OR.W	D3,D2		; D2.W = 00GB.
*
*	Make Red.
*
	MOVE.W	D0,D3		; D3.W = RrGg.
	ANDI.W	#$0F00,D3	; D3.W = 0r00.
	OR.W	D3,D1		; D1.W = 0rgb.
	LSR.L	#4,D0		; D0.L = 000LlRrG.
	MOVE.W	D0,D3		; D3.W = lRrG.
	ANDI.W	#$0F00,D3	; D3.W = 0R00.
	OR.W	D3,D2		; D2.W = 0RGB.
*
*	Make Genlock.
*
	ANDI.W	#$F000,D0	; D0.L = 000Ll000.
	OR.W	D0,D1		; D1.W = lrgb.
	CLR.W	D0		; D0.L = 000L0000.
	LSR.L	#4,D0		; D0.L = 0000L000.
	OR.W	D2,D0		; D0.L = 0000LRGB.
*
*	Combine Result.
*
	SWAP.W	D0		; D0.L = LRGB0000.
	MOVE.W	D1,D0		; D0.L = LRGBlrgb.
*
*	Exit Subroutine.
*
	MOVEM.L	(A7)+,D1-D3	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AnimUnload:							*
*									*
*	Frees any allocated Fast & Chip memory and all other resources	*
*	which were allocated by AnimLoad.  This is caled when an Anim	*
*	effect is de-selected.						*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Anim Data Is Unloaded.						*
*									*
*	3.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimUnload
AnimUnload:
	MOVEM.L	D0-D1/A0-A1/A6,-(A7)	; Save Calling State.
*
*	See If Data Was Loaded?
*
	MOVE.L	A4,D0			; Anything To Free?
	BEQ	ANMUL9			; Exit If NULL.
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of Exec Base.
*
*	Free The List Of Circular Buffers.
*
	MOVE.L	aec_CircularList(A4),A0	; A0.L = Pointer To First Element.
	CLR.L	aec_CircularList(A4)	; NULL Pointer To List.
	MOVE.L	A0,D0			; Anything to Free?
	BEQ.S	ANMUL1			; Jump If Nothing To Free.

	BSR	FreesCircularBuffers	; Free The List.
*
*	Free The List Of Headers.
*
ANMUL1	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
	CLR.L	aec_PackedList(A4)	; NULL Pointer To List.
	MOVE.L	A0,D0			; Anything to Free?
	BEQ.S	ANMUL2			; Jump If Nothing To Free.

	BSR	FreePackedList		; Give The Memory In The List Back.
*
*	Free The Large Memory Area.
*
ANMUL2	MOVEA.L	aec_LoadBase(A4),A1	; A1.L = Address of Memory.
	MOVE.L	A1,D0			; Anything to Free?
	BEQ	ANMUL7			; Jump If Nothing To Free.
	MOVE.L	aec_LoadLength(A4),D0	; D0.L = Amount  of Memory.
	BEQ	ANMUL7			; Jump If No Data To Free.

	MEMORYHEXI <FREE LoadBase >,d0,< >
	MEMORYHEXI <           at >,a1,<\>

	JSR	_LVOFreeMem(A6)		; Give Back the Memory.
ANMUL7	CLR.L	aec_LoadLength(A4)	; Clear Length.
	CLR.L	aec_LoadBase(A4)	; Clear Base Address.
*
*	Give Back aec Structure.
*
ANMUL8	MOVEQ.L	#aec_Sizeof,D0		; D0.L = Amount  of Memory.
	MOVEA.L	A4,A1			; A1.L = Address of Memory.


	MEMORYHEXI <FREE aec >,d0,< >
	MEMORYHEXI <      at >,a1,<\>

	JSR	_LVOFreeMem(A6)		; Give Back The Memory.
*
*	Exit Subroutine.
*
ANMUL9	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AllocPackedListStruct:						*
*									*
*	Allocates a Packed List Struct.					*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	A0.L	= Address of Packed List Header.			*
*									*
*	CC	== Zero -> Failed To Allocate Memory.			*
*	CC	!= Zero -> Execution Without Error.			*
*									*
*	11.March.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AllocPackedListStruct
AllocPackedListStruct:
	MOVEM.L	D0-D1/A1/A6,-(A7)	; Save Calling State.
*
*	Try To Allocate Memory.
*
	MOVEQ.L	#pkl_Sizeof,D0		; D0.L = Number of Bytes to Allocate.
	MOVE.L	#MEMF_PUBLIC!MEMF_CLEAR,D1 ; D1.L = Type of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.


	MEMORYHEXI <ALLOC pkl >,d0,< >

	JSR	_LVOAllocMem(A6)	; D0.L = Address of Memory.

	MEMORYHEXI <             at >,d0,<\>

	MOVEA.L	D0,A0			; A0.L = Address of Memory.
	TST.L	D0			; D0.L = Value of Return Code.
*
*	Exit Subroutine.
*
	MOVEM.L	(A7)+,D0-D1/A1/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	FreePackedListStruct:						*
*									*
*	Frees a Packed List Struct.					*
*									*
*	Input:								*
*									*
*	A0.L	= Address of Packed List Header to be Freed.		*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Packed List Struct Header is Freed.				*
*									*
*	11.March.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FreePackedListStruct
FreePackedListStruct:
	MOVEM.L	D0-D1/A0-A1/A6,-(A7)	; Save Calling State.
*
*	If It Exists, Give It Back.
*
	MOVE.L	A0,D0			; NULL Pointer?
	BEQ	FRPLS1			; Exit If NULL Pointer.
	BSR	FreeColorTable		; Give Back The Color Table.
	MOVEQ.L	#pkl_Sizeof,D0		; D0.L = Number  of Bytes to Free.
	MOVEA.L	A0,A1			; A1.L = Address of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; Address of Exec Base.

	MEMORYHEXI <FREE pkl >,d0,< >
	MEMORYHEXI <      at >,a1,<\>

	JSR	_LVOFreeMem(A6)		; Give Back the Memory.
*
*	Exit Subroutine.
*
FRPLS1	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	FreePackedList:							*
*									*
*	Frees a Packed List.						*
*									*
*	Input:								*
*									*
*	A0.L	= Address of Packed List to be Freed.			*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Packed List is Freed.						*
*									*
*	11.March.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FreePackedList
FreePackedList:
	MOVEM.L	D0/A0,-(A7)		; Save Calling State.
*
*	If It Exists, Give It Back.
*
	MOVE.L	A0,D0			; NULL Pointer?
	BEQ.S	FRPLI2			; Exit If NULL Pointer.
FRPLI1	MOVEA.L	D0,A0			; A0.L = Value Of This Element.
	MOVE.L	pkl_AllocLink(A0),D0	; D0.L = Next Element In List.
	BSR	FreePackedListStruct	; Give It Back.
	TST.L	D0			; Anything Else In List?
	BNE.S	FRPLI1			; Loop Until Done.
*
*	Exit Subroutine.
*
FRPLI2	MOVEM.L	(A7)+,D0/A0		; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AllocCircularBuffers:						*
*									*
*	Allocate The Circular Buffer List For The Display.		*
*									*
*	Input:								*
*									*
*	A0.L	= Address of Available Memory.				*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	D0.L	= Error Code.						*
*									*
*	16.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AllocCircularBuffers
AllocCircularBuffers:
	MOVEM.L	D1-D6/A0-A2,-(A7)	; Save Calling State.
	MOVEA.L	A0,A2			; A2.L = Available Memory List.
*
*	First Allocate The List of Headers.
*
	TST.L	aec_CircularList(A4)	; Already Allocated?
	BNE	ALCIB9			; Jump If List Already Allocated.
	MOVEQ.L	#0,D2			; Make Number of Buffers.
	MOVE.W	aec_NumberOfBuffers(A4),D2 ; D2.L = Number of Buffers.
	BNE.S	ALCIB1			; Jump If Not Zero.
	MOVEQ.L	#2,D2			; D2.L = Number of Buffers.
*
*	Make The Head Of The List.
*
ALCIB1
	DUMPUDEC.l	<aec_NumberOfBuffers>,d2,<\>

	MOVEA.L	A2,A0			; A0.L = Available Memory.
	BSR.S	AllocateCirBuffer	; A0.L = Address of Structure.
	BEQ.S	ALCIB8			; Not Enough Memory.
	MOVE.L	A0,aec_CircularList(A4)	; Pointer To First Element.
	SUBQ.L	#1,D2			; One Less Buffer.
*
*	Make The Nth In List.
*
	BRA.S	ALCIB3			; Start Looping.
ALCIB2	MOVEA.L	A2,A0			; A0.L = Available Memory.
	BSR.S	AllocateCirBuffer	; A0.L = Address of Structure.
	BEQ.S	ALCIB8			; Not Enough Memory.
	MOVE.L	A0,acl_AllocationLink(A1) ; Save Pointer To Next Line List.
	MOVE.L	A0,acl_ForwardLink(A1)	; Save Point To Forward  Position.
	MOVE.L	A1,acl_BackwardLink(A0)	; Save Point To Backward Position.
ALCIB3	MOVEA.L	A0,A1			; A1.L = Address of End of List.
	DBF	D2,ALCIB2		; Loop Until Done.
	MOVEA.L	aec_CircularList(A4),A0	; A0.L = Address Start Of List.
	MOVE.L	A0,acl_ForwardLink(A1)	; End Of List Points At Start.
	MOVE.L	A1,acl_BackwardLink(A0)	; Start Of List Points At End.
*
*	Execution Without Error.
*
	MOVEQ.L	#AEE_NoError,D0		; D0.L = No Error Occured.
	BRA.S	ALCIBA			; Exit Subroutine.
*
*	Not Enough Memory.
*
ALCIB8	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Not Enough Memory.
	BRA.S	ALCIBA			; Exit Subroutine.
*
*	List Already Allocated.
*
ALCIB9	MOVEQ.L	#AEE_CircularListAlreadyAlloc,D0 ; D0.L = Error Code.
*
*	Exit Subroutine.
*
ALCIBA	TST.L	D0			; Set Return Code.
	MOVEM.L	(A7)+,D1-D6/A0-A2	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AllocateCirBuffer:						*
*									*
*	Allocate A Single Buffer In Circular Buffer List.		*
*									*
*	Input:								*
*									*
*	A0.L	= Address of Available Memory.				*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	A0.L	= Address of acl Header.				*
*									*
*	CC	== Zero -> Failed To Allocate Memory.			*
*	CC	!= Zero -> Execution Without Error.			*
*									*
*	16.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AllocateCirBuffer
AllocateCirBuffer:
	MOVEM.L	D0-D3/A1-A3/A5-A6,-(A7)	; Save Calling State.
	MOVE.L	A0,D3			; D3.L = Address of Available Memory.
*
*	Make The Header.
*
	MOVE.L	#acl_Sizeof,D0		; D0.L = Size of The Structure.
	MOVE.L	#MEMF_PUBLIC!MEMF_CLEAR,D1 ; D1.L = Type of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
	MOVE.L	A1,-(A7)		; Save Available Memory.

	MEMORYHEXI <ALLOC acl >,d0,< >

	JSR	_LVOAllocMem(A6)	; Try To Get Memory.

	MEMORYHEXI <             at >,d0,<\>

	MOVEA.L	(A7)+,A1		; Return Available Memory.
	MOVEA.L	D0,A0			; A0.L = Address of Header.
	TST.L	D0			; Set Return Code.
	BEQ	ALCRBB			; Exit On Error.
	MOVEA.L	A0,A2			; A2.L = Address of acl Header.
*
*	Fill Out Structure.
*
	MOVE.W	aec_NumberOfColors(A4),acl_NumberOfColors(A2)
	MOVE.W	aec_Width(A4),acl_Width(A2)	; Save Width.
	MOVE.W	aec_Height(A4),acl_Height(A2)	; Save Height.
	MOVEQ.L	#0,D2			; Clear High Bits.
	MOVE.W	aec_Depth(A4),D2	; D2.L = Number of Planes.
	MOVE.B	D2,acl_Depth(A2)	; Save Depth.
*
*	Allocate The Bit Planes, Using avcm_PriFree.
*
	LEA.L	acl_Planes(A2),A3	; A3.L = Address of Plane Table.
	MOVEA.L	D3,A1			; A1.L = Address of Available Memory.
	BRA.S	ALCRB2			; Start Looping.
ALCRB1	MOVEQ.L	#avmc_PriFree,D0	; D0.L = Memory Priority.
	BSR	AllocateToasterMemory	; A0.L = Address of Memory.
	BEQ.S	ALCRB3			; Exit If Failed.
	MOVE.L	A0,D0			; D0.L = Memory Address.
	BSR	RoundToDoubleLongWord	; D0.L = Double Word Alligned.
	MOVE.L	D0,(A3)+		; Save Plane Pointer.
ALCRB2	DBF	D2,ALCRB1		; Loop Until Done.
	BRA	ALCRB9			; Exit Subroutine.
*
*	Allocate The Bit Planes, Using AllocMem.
*
ALCRB3	LEA.L	acl_AllocatedPlanes(A2),A5 ; A5.L = Address of Allocations.
ALCRB4	MOVE.L	aec_PlaneSize(A4),D0	; D0.L = Amount of Memory.

	MOVE.L	#MEMF_CHIP,D1		; D1.L = Type of Memory.
	BTSTA.L	aecb_CirBuffsInFAST,aec_Flags(A4) ; Are we forcing the Circular buffers into FAST?
	beq.s	ALCRB4b
	MOVE.l	#MEMF_FAST,D1		; D1.L = Type of Memory.

ALCRB4b	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
	MOVE.L	A1,-(A7)		; Save Available Memory.

	MEMORYHEXI <ALLOC CHIP or Fast Circular Buffer plane >,d0,< >

	JSR	_LVOAllocMem(A6)	; Try To Get Memory.

	MEMORYHEXI <             at >,d0,<\>

	MOVEA.L	(A7)+,A1		; Return Available Memory.
	MOVE.L	D0,(A5)+		; Save Allocation Plane Pointer.
	BEQ.S	ALCRB5			; Exit If Failed, NULL Pointer.
	BSR.S	RoundToDoubleLongWord	; D0.L = Double Word Alligned.
	MOVE.L	D0,(A3)+		; Save Plane Pointer.
	DBF	D2,ALCRB4		; Loop Until Done.
	BRA.S	ALCRB9			; Exit Subroutine.
*
*	Allocate The Bit Planes, Using avcm_PriPublic.
*
ALCRB5	MOVEA.L	D3,A1			; A1.L = Address of Available Memory.
ALCRB6	MOVEQ.L	#avmc_PriPublic,D0	; D0.L = Memory Priority.
	BSR.S	AllocateToasterMemory	; A0.L = Address of Memory.
	BEQ.S	ALCRB7			; Exit If Failed.
	MOVE.L	A0,D0			; D0.L = Memory Address.
	BSR.S	RoundToDoubleLongWord	; D0.L = Double Word Alligned.
	MOVE.L	D0,(A3)+		; Save Plane Pointer.
	DBF	D2,ALCRB6		; Loop Until Done.
	BRA.S	ALCRB9			; Exit Subroutine.
*
*	Allocate The Bit Planes, Using avcm_PriPrivate.
*
ALCRB7	MOVEA.L	D3,A1			; A1.L = Address of Available Memory.
ALCRB8	MOVEQ.L	#avmc_PriPrivate,D0	; D0.L = Memory Priority.
	BSR.S	AllocateToasterMemory	; A0.L = Address of Memory.
	BEQ.S	ALCRBA			; Exit If Failed.
	MOVE.L	A0,D0			; D0.L = Memory Address.
	BSR.S	RoundToDoubleLongWord	; D0.L = Double Word Alligned.
	MOVE.L	D0,(A3)+		; Save Plane Pointer.
	DBF	D2,ALCRB8		; Loop Until Done.
*
*	Return No Error.
*
ALCRB9	MOVEQ.L	#-1,D0			; Set CC != Zero.
	MOVEA.L	A2,A0			; A0.L = Address of acl Header.
	BRA.S	ALCRBB			; Exit Subroutine.
*
*	Not Enough Memory.
*
ALCRBA	BSR	FreeCirBuffer		; Get Back Single Buffer.
	MOVEQ.L	#0,D0			; Set CC == Zero.
	MOVEA.L	D0,A0			; Set It To NULL.
*
*	Exit Subroutine.
*
ALCRBB	MOVEM.L	(A7)+,D0-D3/A1-A3/A5-A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	RoundToDoubleLongWord:						*
*									*
*	Rounds a Pointer To Double Word Alligned Value.			*
*									*
*	Input:								*
*									*
*	D0.L	= Value To Double Word Allign.				*
*									*
*	Output:								*
*									*
*	D0.L =	Double Word Alligned Value.				*
*									*
*	20.April 1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	RoundToDoubleLongWord
RoundToDoubleLongWord:
*
*	Round To Nearest Double Word.
*
	ADDQ.L	#((1<<3)-1),D0		; Increment Past Starting.
	ANDI.W	#~((1<<3)-1),D0		; Remove Extra Bits.
*
*	Exit Subroutine.
*
	RTS
	PAGE
*************************************************************************
*									*
*	AllocateToasterMemory:						*
*									*
*	Input:								*
*									*
*	D0.L	= Memory Priority.					*
*	A1.L	= Address of Available Memory.				*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	A0.L	= Address of Bit Plane.					*
*	A1.L	= Address of Updated Available Memory.			*
*									*
*	CC	== Zero -> Failed To Allocate Memory.			*
*	CC	!= Zero -> Execution Without Error.			*
*									*
*	17.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AllocateToasterMemory
AllocateToasterMemory:
	MOVE.L	D1,-(A7)		; Save Calling State.
*
*	Move To Next Link In List.
*
	SUBA.L	A0,A0			; A0.L = Initilize To NULL.
	BRA.S	ALTOM2			; Check Node For NULL.
ALTOM1	MOVEA.L	avm_NextNode(A1),A1	; A1.L = Go To Next In List.
*
*	Check To See If We Can Fit Here.
*
ALTOM2	MOVE.L	A1,D1			; At End Of List?
	BEQ	ALTOM3			; Jump If Allocate From Free Mem.
	MOVE.L	avm_Size(A1),D1		; Make Amount To Use.
	SUB.L	avm_NumberOfBytesUsed(A1),D1  ; D1.L = Amount Left.
	CMP.L	aec_PlaneSize(A4),D1	; Enough For Us?
	BCS.S	ALTOM1			; Jump If Not Enough There.
	CMP.W	avm_MemoryPri(A1),D0	; Can I Use This Memory?
	BNE.S	ALTOM1			; Jump If We Cannout Use It.
	MOVE.W	avm_MemoryType(A1),D1	; Check For correct Memory type.

	BTSTA.L	aecb_CirBuffsInFAST,aec_Flags(A4) ; Are we forcing the Circular buffers into FAST?
	beq.s	ALTOM2b			; Jump if not forcing FAST
	ANDI.W	#MEMF_FAST,D1		; Is It Fast Memory?
	BEQ.S	ALTOM1			; Jump If Not Fast Memory.
	BRA.S	ALTOM2c

ALTOM2b	ANDI.W	#MEMF_CHIP,D1		; Is It Chip Memory?
	BEQ.S	ALTOM1			; Jump If Not Chip Memory.
*
*	We Can Use This Memory.
*
	
ALTOM2c	MOVEA.L	avm_Memory(A1),A0	; Make Address of Current Page.
	ADDA.L	avm_NumberOfBytesUsed(A1),A0 ; A0.L = Address of Memory.
	MOVE.L	aec_PlaneSize(A4),D1	; D1.L = Amount of Memory.

	MEMORYHEXI <ALLOC ToasterMem >,d1,< >
	MEMORYHEXI <             at >,a0,<\>

	ADD.L	D1,avm_NumberOfBytesUsed(A1) ; Amount We Used Up.
	MOVEQ.L	#-1,D1			; Set CC != Zero.
*
*	Exit Subroutine.
*
ALTOM3	MOVEM.L	(A7)+,D1		; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	FreesCircularBuffers:						*
*									*
*	Frees The Circular Buffer List For The Display.			*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Circular List Is Freed.						*
*									*
*	16.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FreesCircularBuffers
FreesCircularBuffers:
	MOVEM.L	D0/A0,-(A7)		; Save Calling State.
*
*	If It Exists, Give It Back.
*
	MOVE.L	A0,D0			; NULL Pointer?
	BEQ.S	FRCLI2			; Exit If NULL Pointer.
FRCLI1	MOVEA.L	D0,A0			; A0.L = Value Of This Element.
	MOVE.L	acl_AllocationLink(A0),D0 ; D0.L = Next Element In List.

	BSR.S	FreeCirBuffer		; Give It Back.
	TST.L	D0			; Anything Else In List?
	BNE.S	FRCLI1			; Loop Until Done.
*
*	Exit Subroutine.
*
FRCLI2	MOVEM.L	(A7)+,D0/A0		; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	FreeCirBuffer:							*
*									*
*	Frees The Circular Buffer List For The Display.			*
*									*
*	Input:								*
*									*
*	A0.L	= Address of acl Structure.				*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	A Single Circular Buffer Item Is Freed.				*
*									*
*	16.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FreeCirBuffer
FreeCirBuffer:
	MOVEM.L	D0-D2/A0-A3/A6,-(A7)	; Save Calling State.
	MOVEA.L	aec_SYSBase(A4),A6	; Address of Exec Base.
*
*	If It Exists, Give It Back.
*
	MOVE.L	A0,D0			; NULL Pointer?
	BEQ	FRCIB2			; Exit If NULL Pointer.
	MOVEA.L	A0,A2			; A2.L = Address of acl Structure.
	LEA.L	acl_AllocatedPlanes(A2),A3  ; A3.L = Address of Bit Plane Table.
	MOVEQ.L	#MaximumNumberOfPlanes-1,D2 ; D2.L = Number of Planes.
*
*	If Any Of The Bit Planes Were Allocated, Free Them.
*
FRCIB1	MOVE.L	(A3)+,D0		; NULL Pointer?
	BEQ	FRCIB1b			; Jump If NULL.
	MOVEA.L	D0,A1			; A1.L = Address of Memory.
	MOVE.L	aec_PlaneSize(A4),D0	; D0.L = Number of Bytes.

	MEMORYHEXI <FREE CirBuff >,d0,< >
	MEMORYHEXI <          at >,a1,<\>

	JSR	_LVOFreeMem(A6)		; Give Back The Memory.
	DBF	D2,FRCIB1		; Loop For Number of Planes.
*
*	Free The Header Structure.
*
FRCIB1b	MOVE.L	#acl_Sizeof,D0		; D0.L = Number  of Bytes to Free.
	MOVEA.L	A2,A1			; A1.L = Address of Memory.


	MEMORYHEXI <FREE acl >,d0,< >
	MEMORYHEXI <      at >,a1,<\>

	JSR	_LVOFreeMem(A6)		; Give Back the Memory.
*
*	Exit Subroutine.
*
FRCIB2	MOVEM.L	(A7)+,D0-D2/A0-A3/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	CreateNextFrame:						*
*									*
*	Creates the Nth Frame In The List.				*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*	A6.L	= Address of GFX Base.					*
*									*
*	Output:								*
*									*
*	Anim Data is Unpacked Into Circular List.			*
*									*
*	25.March 1993 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	CreateNextFrame
CreateNextFrame:
	MOVEM.L	D0-D6/A0-A2,-(A7)	; Save Calling State.
*
*	On a BODY or DLTA.
*
	MOVEA.L	aec_UnPackedList(A4),A2	; A2.L = Address of pkl Position.
	MOVE.L	pkl_Flags(A2),D6	; D6.L = Value of Flags.
	BTST.L	#pklb_BODY,D6		; On A BODY Or DLTA?
	BEQ.S	CRNXF1			; Jump If Not BODY.
*
*	Do a BODY Frame.
*
	MOVEA.L	pkl_Data(A2),A0		; A0.L = Address of The Start of Body.
	MOVE.L	pkl_DataSize(A2),D0	; D0.L = Number of Bytes in Frame.
	MOVEA.L	pkl_Header(A2),A1	; A1.L = Address of Bit Map Header.
	MOVEQ.L	#0,D1			; Clear High Bits.
	MOVE.W	aec_Width(A4),D1	; D1.L = Width in Bytes.
	MOVEQ.L	#0,D2			; Clear High Bits.
	MOVE.W	aec_Height(A4),D2	; D2.L = Height of data in scan lines
	MOVEQ.L	#0,D3			; Clear High Bits.
	MOVE.W	aec_Depth(A4),D3	; D3.L = Number of BitPlanes.
	MOVEQ.L	#0,D4			; Clear High Bits.
	MOVE.B	bmh_compression(A1),D4	; D4.L = Compression method
	MOVEQ.L	#0,D5			; Clear High Bits.
	MOVE.B	bmh_masking(A1),D5	; D5.L = Masking.
	MOVEA.L	aec_CurrentFrame(A4),A1	; A1.L = Address of Current In List.
	ADDA.W	#acl_Planes,A1		; A1.L = Address of Bit Planes.
	BSR	REPACK			; Copy First Frame to Active Display.
	BRA.S	CRNXF3			; Skip Else Part.
*
*	On a DLTA?
*
CRNXF1	BTST.L	#pklb_DLTA,D6		; On A DLTA?
	BEQ.S	CRNXF3			; Jump If Not DLTA.
	BTST.L	#pklb_MakeFromPrev,D6	; Make From Previous?
	BEQ.S	CRNXF2			; Jump If Not Make From Previous.
*
*	Copy Previous Plane Data.
*
	MOVEA.L	aec_CurrentFrame(A4),A1	; A1.L = Make Address of Destination.
	MOVEA.L	acl_BackwardLink(A1),A0	; A0.L = Make Address of Source.
	ADDA.W	#acl_Planes,A1		; A1.L = Address of Destin Planes.
	ADDA.W	#acl_Planes,A0		; A0.L = Address of Source Planes.
	MOVEQ.L	#0,D0			; Make Number of Planes.
	MOVE.W	aec_Depth(A4),D0	; D0.L = Number of Planes.
	MOVE.L	aec_PlaneSize(A4),D1	; D1.L = Number of Bytes In Bit Plane.
	SUBQ.L	#6,D1			; Less Double Long Word Size Adjustment.
	BSR	CopyBitPlanesChipMemory	; Copy The Bits Planes.
*
*	Decompress The Anim Deltas.
*
CRNXF2	MOVEA.L	pkl_Header(A2),A1	; A1.L = Address of Anim Header.
	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.W	aec_Depth(A4),D0	; D0.L = Number of Bit Planes.
	MOVEQ.L	#0,D1			; Clear High Bits.
	MOVE.B	anh_operation(A1),D1	; D1.L = Compression Method.
	MOVEQ.L	#0,D2			; Clear High Bits.
	MOVE.W	aec_Width(A4),D2	; D2.L = Width of Anim in Bytes.
	MOVE.L	anh_bits(A1),D3		; D3.L = Value of Anim Bits.
	MOVEA.L	pkl_Data(A2),A0		; A0.L = Address of Deltas.
	MOVEA.L	aec_CurrentFrame(A4),A1	; A1.L = Address of Current In List.
	ADDA.W	#acl_Planes,A1		; A1.L = Address of Bit Planes.
	BSR	UpDatePic		; Copy The Deltas.
*
*	Attach The Rest Of The Data.
*
CRNXF3	MOVEA.L	aec_CurrentFrame(A4),A1	; A1.L = Address of Current In List.
	MOVE.L	pkl_LoadableColors(A2),acl_ColorTable(A1)	; Color Table.
	MOVE.W	pkl_NumberOfColors(A2),acl_NumberOfColors(A1)	; # of Colors.
	MOVE.L	pkl_ViewMode(A2),acl_ViewModes(A1)		; ViewModes.
	MOVE.W	pkl_FrameNumber(A2),acl_FrameNumber(A1)		; Frame #.
*
*	Exit Subroutine.
*
	MOVEM.L	(A7)+,D0-D6/A0-A2	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AnimSetupForward:						*
*									*
*	Generates the data for the N-buffers, starting at the first	*
*	frame.								*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	The N-buffered data is created.					*
*									*
*	3.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimSetupForward
AnimSetupForward:
	MOVEM.L	D0-D1/A0-A1/A6,-(A7)	; Save Calling State.
	MOVE.L	A4,D0			; NULL Pointer?
	BEQ.S	ANSTF3			; Exit If NULL.
	CLR.B	AnimAbortFlag		; Set Flag To No Abort.
*
*	Intiliize Ourselfs To First Frame.
*
	MOVE.L	aec_PackedList(A4),aec_UnPackedList(A4) ; Source Packed Data.
	BEQ.S	ANSTF3			; Exit If NULL Pointer.
	MOVE.L	aec_CircularList(A4),D0	; Circular List Pointer.
	BEQ.S	ANSTF3			; Exit If NULL Pointer.
	MOVE.L	D0,aec_CurrentFrame(A4) ; Frame To Play Into.
	MOVEA.L	D0,A0			; Initilizes the Current/Next Logic.
	MOVE.L	acl_BackwardLink(A0),aec_DisplayFrame(A4) ; Frame To Look At.
*
*	Initilize The Anim Player.
*
	MOVEA.L	aec_GFXBase(A4),A6	; A6.L = Address of Graphics Base.
	BSR	OpenChipMemoryMove	; Open The Memory Move Routine.
	MOVEQ.L	#0,D1			; Make Width Of Anim.
	MOVE.W	aec_Width(A4),D1	; D1.L = Width Of Anim.
	BSR	InitAnim		; Initilize The Animation Mode.
*
*	Loop For Number of Buffer and Create Initial Frames.
*
	MOVE.W	aec_NumberOfBuffers(A4),D1 ; D1.W = Loop Counter.
	BRA.S	ANSTF2			; Start Looping.
ANSTF1	BSR	CreateNextFrame		; Build Next Frame.
*
*	Move Thru The Buffered Frames.
*
	MOVEA.L	aec_CurrentFrame(A4),A0	; A0.L = acl Present Link.
	MOVE.L	acl_ForwardLink(A0),aec_CurrentFrame(A4) ; New Head Of List.
	MOVEA.L	aec_UnPackedList(A4),A0	; A0.L = pkl Present Link.
	MOVE.L	pkl_ForwardLink(A0),aec_UnPackedList(A4) ; New Head Of List.
ANSTF2	DBF	D1,ANSTF1		; Loop Until Done.
*
*	Close Initilization Process.
*
	BSETA.L	aecb_BufferFull,aec_Flags(A4) ; The Buffer Is Full.
	BSR	CloseChipMemoryMove	; Close Memory Move Routine.
*
*	Exit Subroutine.
*
ANSTF3	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AnimatedInterruptOn:						*
*									*
*	Turns On The Animated Interrupt.				*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Animated Interrupt is Enabled.					*
*									*
*	26.March 1993 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimatedInterruptOn
AnimatedInterruptOn:
	MOVEM.L	A0-A2/A6/D0-D1,-(A7)	; Save Calling State.
*
*	Is The Interrupt Already On?
*
	BTSTA.L	aecb_CopperOn,aec_Flags(A4) ; Is The Interrupt Already On?
	BNE	ANMIO2			    ; Exit If Already On.
	ORI.L	#(1<<aecb_CopperOn)!(1<<aecb_DisableInt),aec_Flags(A4) ; On, but Stoped.
*
*	Initilize Old Structure.
*
	MOVEQ.L	#(IS_SIZE)/2-1,D0	; D0.L = Loop Counter.
	MOVEQ.L	#0,D1			; D1.L = Value To Clear With.
	LEA.L	aec_CopperInter(A4),A1	; A1.L = Address of Structure.
	MOVEA.L	A1,A0			; A0.L = Address of Structure.
ANMIO1	MOVE.W	D1,(A0)+		; Clear Value.
	DBF	D0,ANMIO1		; Loop Until Done.
*
*	Put in Constant Values.
*
	MOVE.B	#NT_INTERRUPT,LN_TYPE(A1) ; Type.
	CLR.B	LN_PRI(A1)		; Priority.
	LEA.L	AnimServerName(PC),A0	; A0.L = Name Of Node.
	MOVE.L	A0,LN_NAME(A1)		; Save Pointer To Name.
	MOVE.L	A4,IS_DATA(A1)		; Save Pointer To Data.
	LEA.L	AnimatedHandler(PC),A0	; A0.L = Address of Handler.
	MOVE.L	A0,IS_CODE(A1)		; Save Pointer To Handler.
*
*	Add Interrupt To System.
*
	CALLTL	DisableInterrupts

	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.

* Stash what Exec is using for a Software interrupt handler.
* SetIntVector can return 0, even if there is a handler, because
* it doesn't need a IS_ structure (no node!), just a code pointer.
	lea	StashOldSoftInt(pc),a0
	lea	IVSOFTINT(a6),a2
	move.w	#IV_SIZE-1,d0
10$	move.b	(a2)+,(a0)+
	dbra	d0,10$

	MOVEQ.L	#INTB_SOFTINT,D0		; D0.L = Int Number.
	JSR	_LVOSetIntVector(A6)	; Establish The Interrupt.
	PUT.L	d0,TB_SoftIntHandler	;stash old SoftInt handler

* At this point, I'm assuming normal AVE or AVEI is up!!!!!!
* If color versions of AVEC were installed, we're in trouble!!!
	PUT.w	#INTF_SETCLR!INTF_SOFTINT,TB_CopListIntreq
	btst.b	#AVEI_BIT,TB_Flags(a5)
	beq.s	20$	
	CALLTL	InstallAVEI		;install SOFTINT version of AVEI
	bra.s	30$

20$	btst.b	#AVE_BIT,TB_Flags3(a5)
	beq.s	30$	
	CALLTL	InstallAVE		;install SOFTINT version of AVE

30$	move.w	#INTF_SETCLR!INTF_SOFTINT,_custom+intena ;enable soft interrupts

	CALLTL	EnableInterrupts

*
*	Exit Subroutine.
*
ANMIO2	MOVEM.L	(A7)+,A0-A2/A6/D0-D1	; Return Calling State.
	RTS

StashOldSoftInt	dcb.b	IV_SIZE,0

*
*	Name of Our Server.
*
AnimServerName:
	DC.B	'AnimatedEffectSoftInterrupt',0
	CNOP	0,4

	PAGE
*************************************************************************
*									*
*	AnimatedInterruptOff:						*
*									*
*	Turns Off The Animated Interrupt.				*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Animated Interrupt is Disabled.					*
*									*
*	26.March 1993 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimatedInterruptOff
AnimatedInterruptOff:
	MOVEM.L	A0-A2/A6/D0-D1,-(A7)	; Save Calling State.
*
*	Is The Interrupt Already Off?
*
	BTSTA.L	aecb_CopperOn,aec_Flags(A4) ; Is The Interrupt Already Off?
	BEQ	ANMIF1			    ; Exit If Already Off.
	BCLRA.L	aecb_CopperOn,aec_Flags(A4) ; We Are Going To Turn It Off Now.
*
*	Remove Interrupt To System.
*
	MOVEQ.L	#(IS_SIZE)/2-1,D0	; D0.L = Loop Counter.
	MOVEQ.L	#0,D1			; D1.L = Value To Clear With.
	LEA.L	aec_CopperInter(A4),A1	; A1.L = Address of Structure.
	MOVEA.L	A1,A0			; A0.L = Address of Structure.
ANMIO1b	MOVE.W	D1,(A0)+		; Clear Value.
	DBF	D0,ANMIO1b		; Loop Until Done.
*
*	Put in Constant Values.
*
**+	MOVE.B	#NT_INTERRUPT,LN_TYPE(A1) ; Type.
**+	CLR.B	LN_PRI(A1)		; Priority.
**+	LEA.L	AnimNullServerName(PC),A0	; A0.L = Name Of Node.
**+	MOVE.L	A0,LN_NAME(A1)		; Save Pointer To Name.
**+	MOVE.L	A4,IS_DATA(A1)		; Save Pointer To Data.
**+	GET.L	TB_NullSoftIntHandler,A0	; A0.L = Address of Handler.
**+	MOVE.L	A0,IS_CODE(A1)			; Save Pointer To Handler.
*
*	Add Interrupt To System.
*
	CALLTL	DisableInterrupts

	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
	GET.L	TB_SoftIntHandler,d0
	bne.s	5$

* If there wasn't a full blown handler (with a node), then restore
* exec to it's previous state, which may contain a code pointer only.
	lea	StashOldSoftInt(pc),a0
	lea	IVSOFTINT(a6),a2
	move.w	#IV_SIZE-1,d0
10$	move.b	(a0)+,(a2)+
	dbra	d0,10$
	bra.s	40$

5$	movea.l	d0,a1
	MOVEQ.L	#INTB_SOFTINT,D0	; D0.L = Int Number.
	JSR	_LVOSetIntVector(A6)	; Establish The Interrupt.

40$	move.w	#INTF_SOFTINT,_custom+intena ;disable soft interrupts

* Software interrupts will be re-anabled in ServeAVE_AVEI.
* Also, they will install a proper normal INTF_COPER AVE or AVEI first.

	CALLTL	EnableInterrupts

*
*	Exit Subrutine.
*
ANMIF1	MOVEM.L	(A7)+,A0-A2/A6/D0-D1	; Return Calling State.
	RTS

**+ AnimNullServerName:
**+ 	DC.B	'NullSoftwareInterrupt',0
**+ 	CNOP	0,4

	PAGE
*************************************************************************
*									*
*	AnimatedHandler:						*
*									*
*	Handles the Interrupt to Advance The Anim.			*
*									*
*	Input:								*
*									*
*	A1.L	    = Address of Anim Base.				*
*	D0-D1/A1/A5 = Scratch.						*
*									*
*	Output:								*
*									*
*	The Interrupt is Handled.					*
*									*
*	CC	== Zero -> Interrupt Not Processed.			*
*	CC	!= Zero -> Interrupt Processed.				*
*									*
*	D0-D1/A0-A1/A5	= Scratch.					*
*									*
*	27.April 1992 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimatedHandler
AnimatedHandler:
	move.l	a0,-(sp)

	MOVEA.L	A1,A0			; A0.L = aec Base Address.
*
*	Are We Allowed To Take This One?
*
	BTSTA.L	aecb_DisableInt,aec_Flags(A0) ; Is the Interrupt Disabled?
	BNE.S	AINHN6			; Exit If Disabled.
	BSETA.L	aecb_InteruptOccured,aec_Flags(A0) ; Interrupt Occured.
*
*	Can We Show Another Frame?
*
AINHN1	MOVE.L	aec_CurrentFrame(A0),D1	; D1.L = acl Address of Present Decompress.
	BEQ.S	AINHN3			; Exit If Null List.
	MOVE.L	aec_DisplayFrame(A0),D0	; D0.L = acl Address of Present Displayed.
	BEQ.S	AINHN3			; Exit If Null List.
	MOVEA.L	D0,A1			; A1.L = acl Address of Display Frame.
	MOVEA.L	acl_ForwardLink(A1),A1	; Pointer to Next Display Position.
	BTSTA.L	aecb_BufferFull,aec_Flags(A0) ; Is The Buffer Full?
	BNE.S	AINHN2			; Jump If Buffer Is Full.
	CMPA.L	D1,A1			; Is It The Current One?
	BEQ.S	AINHN3			; Exit If Current Is Head of List.
*
*	Send Ready Command.
*
AINHN2	MOVEQ.L	#fxhc_Ready,D0		; D0.L = Ready Command.
	MOVEA.L	aec_FXHandler(A0),A1	; A1.L = Address of FX Handler.
	JSR	(A1)			; Execute The Command.
	MOVE.L	D0,D1			; Check For Ready Command.
	ANDI.L	#fxhc_Ready,D1		; Did It Display The Buffer?
	BEQ.S	AINHN4			; Jump If Not Displayed.
*
*	Move To Next Position In List.
*
	MOVEA.L	aec_DisplayFrame(A0),A1	; A1.L = acl Present Link.
	MOVE.L	acl_ForwardLink(A1),aec_DisplayFrame(A0) ; New Head Of List.
	BCLRA.L	aecb_BufferFull,aec_Flags(A0) ; The Buffer Is NOT Full.
*
*	Was The Stop Command Issued?
*
	ANDI.L	#fxhc_Stop!fxhc_Abort,D0 ; Stop or Abort Command?
	BEQ.S	AINHN1			; Jump If Not Stop Command.
	BRA.S	AINHN5			; Got Stop Command, Exit.
*
*	Send Not Ready Command.
*
AINHN3	MOVEQ.L	#fxhc_NotReady,D0	; D0.L = Not Ready Command.
	MOVEA.L	aec_FXHandler(A0),A1	; A1.L = Address of FX Handler.
	JSR	(A1)			; Execute The Command.
*
*	Was The Stop or Abort Command Issued?
*
AINHN4	ANDI.L	#fxhc_Stop!fxhc_Abort,D0 ; Stop or Abort Command?
	BEQ.S	AINHN6			 ; Jump If Not Stop Command.

* Stop or abort
AINHN5	BSETA.L	aecb_GotStopCommand,aec_Flags(A0) ; Send Stop Command.
	MOVE.B	#1,AnimAbortFlag	; Assume Stop
	ANDI.L	#fxhc_Abort,D0
	beq.s	AINHN6
	MOVE.B	#-1,AnimAbortFlag	; Set Flag To Abort.
*
*	Exit Subroutine.
*
AINHN6	move.l	(sp)+,a0

	move.w	#INTF_SOFTINT,intreq(a0)
	RTS

	PAGE
*************************************************************************
*									*
*	TimeToAdvance:							*
*									*
*	Checks To See If It Is Ok To Advance The Decompressor.		*
*									*
*	Input:								*
*									*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	Waits Till Display It Is Ok To Write In Next Buffer.		*
*									*
*	CC	== Zero -> Stop Command Received.			*
*	CC	!= Zero -> Time To Advance.				*
*									*
*	29.March 1993 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	TimeToAdvance
TimeToAdvance:
	MOVE.L	D0,-(A7)		; Save Calling State.
*
*	Check To See If We Are Overrunning List.
*
TMTAD1	BTSTA.L	aecb_BufferFull,aec_Flags(A4) ; Is The Buffer Already Full?
	BNE.S	TMTAD2			; Jump If Buffer Full.
	MOVE.L	aec_CurrentFrame(A4),D0	; D0.L = acl List To Unpack Into.
	CMP.L	aec_DisplayFrame(A4),D0	; Unpack Into == On is Display?
	BNE	TMTAD4			; Jump If Unpack Into != On Display.
	BSETA.L	aecb_BufferFull,aec_Flags(A4) ; Flag The Buffer Is Full.
*
*	Wait For An Interrupt to Occure.
*
TMTAD2	BCLRA.L	aecb_InteruptOccured,aec_Flags(A4) ; Interrupt Occured Flag.
TMTAD3	BTSTA.L	aecb_InteruptOccured,aec_Flags(A4) ; Interrupt Occured?
	BEQ	TMTAD3			; Burn Off a Frame.
	BTSTA.L	aecb_GotStopCommand,aec_Flags(A4)  ; Got Stop Command?
	BEQ	TMTAD1			; Jump If Stop Command Not Received.
*
*	We Received A Stop Command.
*
	MOVEQ.L	#0,D0			; D0.L = Stop Command Received.
	BRA.S	TMTAD5			; Exit, We Got Stop Command.
*
*	Execution Without Error.
*
TMTAD4	MOVEQ.L	#-1,D0			; D0.L = Time To Advance.
*
*	Exit Subroutine.
*
TMTAD5	MOVEM.L	(A7)+,D0		; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AnimPlayForward:						*
*									*
*	This enables the Copper Interrupt handler.  As the Interrupt	*
*	handler installs copperlists, the player code will be running,	*
*	decompressing future frames.					*
*									*
*	Input:								*
*									*
*	A0.L	= Address of FX handler.				*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	The N-buffered Anim Data Is Played Forward.			*
*									*
*	3.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimPlayForward
AnimPlayForward:
	MOVEM.L	D0-D1/A0-A1/A6,-(A7)	; Save Calling State.
*
*	Check Calling Parameters For NULL.
*
	MOVE.L	A4,D0			; Check For NULL Pointer.
	BEQ.S	ANPLF4			; Exit If NULL
	MOVE.L	A0,D0			; Check For NULL Pointer.
	BEQ.S	ANPLF4			; Exit If NULL
	MOVE.L	A0,aec_FXHandler(A4)	; Save FX Base Address.
*
*	Make Sure Loaded And Ready To Go.
*
	TST.L	aec_UnPackedList(A4)	; Source Packed Data.
	BEQ.S	ANPLF4			; Exit If NULL Pointer.
	TST.L	aec_DisplayFrame(A4)	; Frame To Look At.
	BEQ.S	ANPLF4			; Exit If NULL Pointer.
	TST.L	aec_CurrentFrame(A4)	; Frame To Play Into.
	BEQ.S	ANPLF4			; Exit If NULL Pointer.
*
*	Enable the Interrupts.
*
	MOVEA.L	aec_GFXBase(A4),A6	; A6.L = Address of Graphics Base.
	BSR	OpenChipMemoryMove	; Open The Memory Move Routine.
	BCLRA.L	aecb_GotStopCommand,aec_Flags(A4) ; Clear Stop Command.
	BSR	AnimatedInterruptOn	; Enable The Interrupt.
	BCLRA.L	aecb_DisableInt,aec_Flags(A4) ; Allow Anim To Run.
*
*	Ok To Advance Now?
*
	BRA.S	ANPLF2			; Start Looping.
ANPLF1	BSR	TimeToAdvance		; Wait Till Advance Time.
	BEQ.S	ANPLF3			; Exit If Stop Command.
	BSR	CreateNextFrame		; Build Next Frame.
*
*	Move Thru The Buffered Frames.
*
	MOVEA.L	aec_CurrentFrame(A4),A0	; A0.L = acl Present Link.
	MOVE.L	acl_ForwardLink(A0),aec_CurrentFrame(A4) ; New Head Of List.
	MOVEA.L	aec_UnPackedList(A4),A0	; A0.L = pkl Present Link.
	MOVE.L	pkl_ForwardLink(A0),aec_UnPackedList(A4) ; New Head Of List.
	MOVE.W	#INTF_SETCLR!INTF_SOFTINT,(_custom+intreq) ; Generate Copper Int.
*
*	Play Till End Of Anim.
*
ANPLF2	BCLRA.L	aecb_GotStopCommand,aec_Flags(A4) ; Check Stop Command.
	BEQ.S	ANPLF1			; Keep Going It Not Stop.
*
*	Disable Interupts.
*
ANPLF3	BSETA.L	aecb_DisableInt,aec_Flags(A4) ; Stop Anim From Running.
	BSR	AnimatedInterruptOff	; Disable The Interrupt.
	BSR	CloseChipMemoryMove	; Close Memory Move Routine.
	CLR.B	AnimAbortFlag		; No Abort, Software Compatability.
*
*	Exit Subroutine.
*
ANPLF4	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	AnimPlayReverse:						*
*									*
*	This enables the Copper Interrupt handler.  As the Interrupt	*
*	handler installs copperlists, the player code will be running,	*
*	decompressing future frames.					*
*									*
*	Input:								*
*									*
*	A0.L	= Address of FX handler.				*
*	A4.L	= Address of aec Base.					*
*									*
*	Output:								*
*									*
*	The N-buffered Anim Data Is Played in Reverse.			*
*									*
*	3.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	AnimPlayReverse
AnimPlayReverse:
	MOVEM.L	D0-D7/A0-A6,-(A7)	; Save Calling State.
*
*	Exit Subroutine.
*
	MOVEM.L	(A7)+,D0-D7/A0-A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	MoveChipToFastMemory:						*
*									*
*	Tries to move Animation Data From Chip Memory to Fast Memory.	*
*									*
*	Input:								*
*									*
*	D0.L	= Number  of Bytes In Memory Block.			*
*	A0.L	= Address of Current  Memory Block.			*
*	A6.L	= Address of Exec Base.					*
*									*
*	Output:								*
*									*
*	A0.L	= Address of New Memory Block.				*
*									*
*	If Possable, Animation Data is Moved From Chip to Fast Memory.	*
*									*
*	29.Jan.1992, Jamie L. Finch					*
*									*
*************************************************************************
*
	XDEF	MoveChipToFastMemory
MoveChipToFastMemory:
	MOVEM.L	D0-D2/A1-A3,-(A7)	; Save Calling State.
	MOVEA.L	A0,A2			; A2.L = Address of Memory Block.
	MOVE.L	D0,D2			; D2.L = Size of Memory Block.
*
*	If Something is Loaded, and In Chip Memory,
*	Try to put it into Fast Memory.
*
	MOVE.L	A0,D0			; D0.L = Address of Pic Base.
	BEQ	MVTFM3			; Exit If Nothing Loaded.
	BSR	IsItChipMemory		; Is This Address in Chip Memory?
	BNE	MVTFM3			; Exit If Not Chip Memory.
*
*	Try to Allocate The Memory in Fast Memory.
*
	MOVE.L	D2,D0			; D0.L = Number of Bytes to Allocate.
	MOVEQ.L	#MEMF_FAST,D1		; D1.L = Type of Memory.

	MEMORYHEXI <ALLOC LoadBase >,d0,< >

	JSR	_LVOAllocMem(A6)	; D0.L = Address of Memory Block.

	MEMORYHEXI <             at >,d0,<\>

	TST.L	D0			; Did We Get The Memory?
	BEQ	MVTFM3			; Exit If Allocation Failed.
*
*	Copy The Memory Area.
*
	MOVEA.L	A2,A3			; A3.L = Memory To Be Freed.
	MOVEA.L	A3,A0			; A3.L = Source Memory.
	MOVEA.L	D0,A2			; A2.L = Now We Point to New Data.
	MOVEA.L	D0,A1			; A1.L = Pointer to New Data Area.
	MOVE.L	D2,D0			; D0.L = Number of Bytes.
	MOVE.L	D0,D1			; D1.L = Number of Bytes.
	LSR.L	#2,D0			; D0.L = Number of Long Words.
	BSR	MoveLongs		; Move Over The Data.
	ANDI.W	#$3,D1			; D1.W = Number of Bytes To Move.
	LSL.L	#2,D0			; D0.L = Address Offset for Sources.
	ADDA.L	D0,A0			; Increment Source.
	ADDA.L	D0,A1			; Increment Destination.
	BRA.S	MVTFM2			; Copy The Bytes.
MVTFM1	MOVE.B	(A0)+,(A1)+		; Move The Byte.
MVTFM2	DBF	D1,MVTFM1		; Loop Until Done.
*
*	Free the Old Memory.
*
	MOVEA.L	A3,A1			; A1.L = Address of Memory Block.
	MOVE.L	D2,D0			; D0.L = Number  of Bytes.

;;	MEMORYHEXI <FREE tempchip >,d0,< >
;;	MEMORYHEXI <           at >,a1,<\>

	JSR	_LVOFreeMem(A6)		; Give Back The Memory.
*
*	Exit Subroutine.
*
MVTFM3	MOVEA.L	A2,A0			; A0.L = Block Of Memory.
	MOVEM.L	(A7)+,D0-D2/A1-A3	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	MoveLongs:							*
*									*
*	Moves a Memory Area Using Long Word Move Instructions.		*
*									*
*	Input:								*
*									*
*	D0.L	= Number  of Long Words To Move.			*
*	A0.L	= Address of Source      Memory Area To Move From.	*
*	A1.L	= Address of Destination Memory Area To Move To.	*
*									*
*	Output:								*
*									*
*	Memory Area Is Moved in Decending Order.			*
*									*
*	19.Mar.1990 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	MoveLongs
MoveLongs:
	MOVEM.L D0-D2/A0-A1,-(A7)	; Save Calling State.
*
*	Loop and Move the Memory Area.
*
	MOVE.W	D0,D2			; Lets Send Out 32 At A Time.
	LSR.L	#5,D0			; D0.L = Adjusted Outer Loop Counter.
	MOVE.L	D0,D1			; D1.L = Make 2 Meg Loop Counter.
	SWAP.W	D1			; D1.L = 2 Meg Loop Counter.
	ANDI.W	#(1<<5)-1,D2		; D2.L = Jump Index.
	ADD.W	D2,D2			; Times 2 For Size of Opcode.
	NEG.W	D2			; Go Into Reverse.
	JMP	MOVEL2(PC,D2.W)		; Start Looping.
MOVEL1	MOVE.L	(A0)+,(A1)+		; Store The Values.
	MOVE.L	(A0)+,(A1)+		;  1
	MOVE.L	(A0)+,(A1)+		;  2
	MOVE.L	(A0)+,(A1)+		;  3
	MOVE.L	(A0)+,(A1)+		;  4
	MOVE.L	(A0)+,(A1)+		;  5
	MOVE.L	(A0)+,(A1)+		;  6
	MOVE.L	(A0)+,(A1)+		;  7
	MOVE.L	(A0)+,(A1)+		;  8
	MOVE.L	(A0)+,(A1)+		;  9
	MOVE.L	(A0)+,(A1)+		; 10
	MOVE.L	(A0)+,(A1)+		; 11
	MOVE.L	(A0)+,(A1)+		; 12
	MOVE.L	(A0)+,(A1)+		; 13
	MOVE.L	(A0)+,(A1)+		; 14
	MOVE.L	(A0)+,(A1)+		; 15
	MOVE.L	(A0)+,(A1)+		; 16
	MOVE.L	(A0)+,(A1)+		; 17
	MOVE.L	(A0)+,(A1)+		; 18
	MOVE.L	(A0)+,(A1)+		; 19
	MOVE.L	(A0)+,(A1)+		; 20
	MOVE.L	(A0)+,(A1)+		; 21
	MOVE.L	(A0)+,(A1)+		; 22
	MOVE.L	(A0)+,(A1)+		; 23
	MOVE.L	(A0)+,(A1)+		; 24
	MOVE.L	(A0)+,(A1)+		; 25
	MOVE.L	(A0)+,(A1)+		; 26
	MOVE.L	(A0)+,(A1)+		; 27
	MOVE.L	(A0)+,(A1)+		; 28
	MOVE.L	(A0)+,(A1)+		; 29
	MOVE.L	(A0)+,(A1)+		; 30
	MOVE.L	(A0)+,(A1)+		; 31
MOVEL2	DBF	D0,MOVEL1		; Loop Until Done.
	DBF	D1,MOVEL1		; 2 Meg Loop.
*
*	Exit Subroutine.
*
	MOVEM.L	(A7)+,D0-D2/A0-A1	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	IsItChipMemory:							*
*									*
*	Checks To See If A Memory Address Is In Chip Memory.		*
*									*
*	Input:								*
*									*
*	A0.L	= Address of Check.					*
*	A6.L	= Address of Exec Base.					*
*									*
*	Output:								*
*									*
*	CC	== Zero -> A0.L Address Is In Chip Memory.		*
*	CC	!= Zero -> A0.L Address Is Not In Chip Memory.		*
*									*
*	30.Jan.1992 Jamie L. Finch.					*
*									*
*************************************************************************
*
	XDEF	IsItChipMemory
IsItChipMemory:
	MOVEM.L	D0-D2/A0-A1,-(A7)	; Save Calling State.
*
*	See If Address Is In Chip Memory List.
*
	MOVE.L	A0,D2			; D2.L = Save Address to Check.
	JSR	_LVOForbid(A6)		; Keep Other Tasks From Running.
*
*	Loop And Check Upper and Lower Ranges.
*
	LEA.L	MemList(A6),A0		; A0.L = Memory Header.
	MOVEA.L	A0,A1			; A1.L = Head of List.
	ADDQ.L	#4,A1			; A1.L = Make Ending Position.
ISCHM1	MOVEA.L	(A0),A0			; Are Ther Any More Nodex.
	CMPA.L	A0,A1			; At End Of List?
	BEQ.S	ISCHM2			; Jump If Not Found.
	MOVE.W	MH_ATTRIBUTES(A0),D0	; Get Flags.
	ANDI.W	#MEMF_CHIP,D0		; Is It Chip Memory?
	BEQ.S	ISCHM1			; Jump If No Chip Memory.
	CMP.L	MH_LOWER(A0),D2		; Within Lower Range?
	BCS.S	ISCHM1			; Jump If We Are Less Than It.
	CMP.L	MH_UPPER(A0),D2		; Within Upper Range.
	BCC.S	ISCHM1			; Jump If We Are Greater That It.
*
*	Found Within Range.
*
	JSR	_LVOPermit(A6)		; Allow Other Tasks To Run.
	MOVEQ.L	#0,D0			; Flag Found.
	BRA.S	ISCHM3			; Exit Subroutine.
*
*	Found Not Within Range.
*
ISCHM2	JSR	_LVOPermit(A6)		; Allow Other Tasks To Run.
	MOVEQ.L	#-1,D0			; Flag Not Found.
*
*	Exit Subroutine.
*
ISCHM3	MOVEM.L	(A7)+,D0-D2/A0-A1	; Return Calling State.
	RTS

*************************************************************************
*									*
*	LoadAnimHeader:							*
*									*
*	Loads the first Anim header into the supplied buffer.		*
*									*
*	Input:								*
*									*
*	A0.L	= Address of anh Structure (see AnimEQU.i)				*
*	A1.L	= Pointer to file name					*
*	A5.L	= ToastBase						*
*	D0.L	= Hunk# (0=not in overlay)				*
*									*
*	Output:								*
*									*
*	D0.L	= Error Code.						*
*									*
*	7.Jan.1994 SKell						*
*									*
*************************************************************************
*
	XDEF	LoadAnimHeader

tempbuff  set	(5*4)
a0ptr	  set	(4*4+tempbuff)		;SEE BELOW

LoadAnimHeader:
	movem.l	d1-d4/a0-a2/a6,-(sp)	;SEE ABOVE
	lea	-tempbuff(sp),sp

	move.l	d0,d4			; stash hunk#

	GET.l	TB_DOSBase,a6	
	MOVE.L	a1,D1			; D1.L = Address of File Name.
	MOVE.L	#MODE_OLDFILE,D2
	JSR	_LVOOpen(A6)		; Try To Open The File.
	TST.L	D0			; Did We Open The File?
	BNE.S	10$			; Jump If All Ok.
	MOVEQ.L	#AEE_OpenFile,D0	; D0.L = Open Error.
	BRA	666$			; Exit Subroutine.
10$	MOVEA.L	D0,A2			; A2.L = Address of File Lock.

	tst.w	d4			; Are We In An Overlay Hunk?
	BEQ.S	100$			; Jump If Not In an Overlay.

* Find The Overlay.
	MOVEA.L	A2,A0			; A0.L = Address of File Lock.
	MOVE.L	#$3F5,D0		; D0.L = Look For Overlay Hunk.
	CALLTL	FindDebugHunk		; Search For The Overlay Hunk.
	TST.L	D0			; Did We Find The Overlay Hunk?
	BEQ.S	777$			; Exit If Failed.
	ADDQ.L	#4,D0			; D0.L = Extra Amount To Advance.
	MOVE.L	A2,D1			; D1.L = Value of File Lock.
	MOVE.L	D0,D2			; D2.L = Amount To Skip.
	MOVEQ.L	#OFFSET_CURRENT,D3	; D3.L = Seek Mode.
	JSR	_LVOSeek(A6)		; Go To This Position.
	ADDQ.L	#1,D0			; Did We Have An Error?
	BEQ.S	777$			; Jump If SEEK Error.

* Find The Code Section We Need.
	subq.w	#1,d4
20$	MOVEA.L	A2,A0			; A0.L = Address of File Lock.
	MOVE.L	#$3E9,D0		; D0.L = Look For Code Hunk.
	CALLTL	FindDebugHunk		; Search For The Hunk.
	TST.L	D0			; Did We Get Anything?
	BEQ.S	777$			; Exit On Error.

	TST.W	D4			; At The HUNK We Need?
	BEQ.S	100$			; Jump If At Proper Hunk

	MOVE.L	A2,D1			; D1.L = Value of File Lock.
	MOVE.L	D0,D2			; D2.L = Amount To Skip.
	MOVEQ.L	#OFFSET_CURRENT,D3	; D3.L = Seek Mode.
	JSR	_LVOSeek(A6)		; Go To This Position.
	ADDQ.L	#1,D0			; Did We Have An Error?
	BEQ.S	777$			; Jump If SEEK Error.
	DBF	D4,20$			; Loop Until Done.

* Fall thru for overlay error

* Looked Thru Crouton and Could Not Find An Anim.
777$	MOVEQ.L	#AEE_CannotFindOverlay,D2 ; Cannot Find Anim In Overlay.
	BRA	555$			; Exit Subroutine.

888$	MOVEQ.L	#AEE_FileReadError,D2	; D0.L = File Read Error.
	BRA	555$			; Exit Subroutine.

999$	MOVEQ.L	#AEE_WrongFileType,D2	; D0.L = Wrong File Type Error.
	BRA	555$			; Exit Subroutine.

*------------------------
* At correct file position to look at first FORM ILBM
100$ ;Read First 8 Bytes.
	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
	MOVE.L	sp,D2			; D2.L = Address of Memory Area.
	moveq.l	#tempbuff,d3			; # bytes to read
	JSR	_LVORead(A6)		; Read Data Off Disk.
	CMP.L	D0,D3			; Read Error?
	BNE.S	888$			; Jump If No Error.

* Check For Legal Data.
110$	CMPI.L	#'FORM',(sp)		; Did We Get A Form Hunk?
	bne	999$			; Not an Iff FORM.

	CMPI.L	#'ANIM',2*4(sp)		; Did We Get A ANIM Hunk?
	bne	999$			; Not an Iff ANIM.

	CMPI.L	#'FORM',3*4(sp)		; Did We Get A Form Hunk?
	bne	999$			; Not an Iff FORM.

* Seek to first Delta FORM ILBM
	MOVE.L	A2,D1			; D1.L = Value of File Lock.
	MOVE.L	4*4(sp),D2		; D2.L = Amount To Skip.
	MOVEQ.L	#OFFSET_CURRENT,D3	; D3.L = Seek Mode.
	JSR	_LVOSeek(A6)		; Go To This Position.
	ADDQ.L	#1,D0			; Did We Have An Error?
	BEQ.S	888$			; Jump If SEEK Error.
	
	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
	MOVE.L	sp,D2			; D2.L = Address of Memory Area.
	moveq.l	#tempbuff,d3			; # bytes to read
	JSR	_LVORead(A6)		; Read Data Off Disk.
	CMP.L	D0,D3			; Read Error?
	BNE.S	888$			; Jump If No Error.

* Check For Legal Data.
	CMPI.L	#'FORM',(sp)		; Did We Get A Form Hunk?
	bne	999$			; Not an Iff FORM.

	CMPI.L	#'ILBM',2*4(sp)		; Did We Get A ILBM Hunk?
	bne	999$			; Not an Iff ILBM.

	CMPI.L	#'ANHD',3*4(sp)		; Did We Get A ANHD Hunk?
	bne	999$			; Not an Iff ANHD.
	
* see AnimEQU.i
	moveq.l	#anh_SIZEOF,d3		; # bytes to read
	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
	MOVE.L	a0ptr(sp),D2		; D2.L = Address of Memory Area.
	JSR	_LVORead(A6)		; Read Data Off Disk.
	CMP.L	D0,D3			; Read Error?
	BNE	888$			; Jump If No Error.

	MOVEQ.L	#0,D2			; No error
555$	MOVE.L	A2,D1			; D1.L = Address of File Lock.
	JSR	_LVOClose(A6)		; Close The File.
	move.l	D2,d0

666$	lea	tempbuff(sp),sp
	movem.l	(sp)+,d1-d4/a0-a2/a6	;SEE ABOVE
	rts


	END
@


2.51
log
@No longer installs a NullSoftIntHandler at end of ANIMs.
But instead restores Exec properly.
@
text
@d27 2
d1164 1
a1164 1
	BNE.S	ALCIB9			; Jump If List Already Allocated.
d1172 4
a1175 1
ALCIB1	MOVEA.L	A2,A0			; A0.L = Available Memory.
d1289 1
d1291 5
a1295 1
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
d1298 1
a1298 1
	MEMORYHEXI <ALLOC CHIPplane >,d0,< >
d1417 1
a1417 1
	BEQ.S	ALTOM3			; Jump If Allocate From Free Mem.
d1424 9
a1432 2
	MOVE.W	avm_MemoryType(A1),D1	; Check For Chip Memory.
	ANDI.W	#MEMF_CHIP,D1		; Is It Chip Memory?
d1437 2
a1438 1
	MOVEA.L	avm_Memory(A1),A0	; Make Address of Current Page.
d1441 4
@


2.50
log
@Replaced Copper Server stuff with Software Interrupt handler stuff.
Rename the names of our Interrupt handlers.
@
text
@d1715 1
a1715 1
	MOVEM.L	A0-A1/A6/D0-D1,-(A7)	; Save Calling State.
d1720 1
a1720 1
	BNE.S	ANMIO2			    ; Exit If Already On.
d1747 10
d1759 9
d1769 3
a1771 2
	move.w	#INTF_SOFTINT,_custom+intreq		;clear it out
	move.w	#INTF_SETCLR!INTF_SOFTINT,_custom+intena ;enable soft interrupts
d1773 2
d1780 1
a1780 1
ANMIO2	MOVEM.L	(A7)+,A0-A1/A6/D0-D1	; Return Calling State.
d1783 2
d1813 1
a1813 1
	MOVEM.L	A0-A1/A6/D0-D1,-(A7)	; Save Calling State.
d1832 7
a1838 7
	MOVE.B	#NT_INTERRUPT,LN_TYPE(A1) ; Type.
	CLR.B	LN_PRI(A1)		; Priority.
	LEA.L	AnimNullServerName(PC),A0	; A0.L = Name Of Node.
	MOVE.L	A0,LN_NAME(A1)		; Save Pointer To Name.
	MOVE.L	A4,IS_DATA(A1)		; Save Pointer To Data.
	GET.L	TB_NullSoftIntHandler,A0	; A0.L = Address of Handler.
	MOVE.L	A0,IS_CODE(A1)			; Save Pointer To Handler.
d1844 12
a1855 2
	move.w	#INTF_SOFTINT,_custom+intena ;disable soft interrupts
	move.w	#INTF_SOFTINT,_custom+intreq ;clear it out
d1857 2
a1858 2
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
	MOVEQ.L	#INTB_SOFTINT,D0		; D0.L = Int Number.
d1861 1
a1861 1
40$	CALLTL	EnableInterrupts
d1863 5
d1871 1
a1871 1
ANMIF1	MOVEM.L	(A7)+,A0-A1/A6/D0-D1	; Return Calling State.
d1874 3
a1876 3
AnimNullServerName:
	DC.B	'NullSoftwareInterrupt',0
	CNOP	0,4
@


2.49
log
@*** empty log message ***
@
text
@d1744 2
d1747 8
a1754 2
	MOVEQ.L	#INTB_COPER,D0		; D0.L = Int Number.
	JSR	_LVOAddIntServer(A6)	; Establish The Interrupt.
d1760 1
d1765 3
a1767 1
	DC.B	'AnimatedEffectCopperInterrupt',0
d1794 1
a1794 1
	BEQ.S	ANMIF1			    ; Exit If Already Off.
d1799 24
d1824 5
a1828 3
	MOVEQ.L	#INTB_COPER,D0		; D0.L = Int Number.
	LEA.L	aec_CopperInter(A4),A1	; A1.L = Address of Structure.
	JSR	_LVORemIntServer(A6)	; Remove The Interrupt.
d1834 5
d1866 2
d1930 3
a1932 1
AINHN6	MOVEQ.L	#0,D0			; Flag, Keep Going Down List.
d1934 1
d1967 1
a1967 1
	BNE.S	TMTAD4			; Jump If Unpack Into != On Display.
d1974 1
a1974 1
	BEQ.S	TMTAD3			; Burn Off a Frame.
d1976 1
a1976 1
	BEQ.S	TMTAD1			; Jump If Stop Command Not Received.
d2055 1
a2055 1
	MOVE.W	#INTF_SETCLR!INTF_COPER,(_custom+intreq) ; Generate Copper Int.
@


2.48
log
@New LoadAnimHeader function added, to do as you would expect.
@
text
@@


2.47
log
@Added fxhc_Abort command vs just the old fxhc_Stop.
@
text
@d2275 154
@


2.46
log
@Now won't use upto all CHIP or PUBLIC memory, or leak any either
@
text
@d1862 1
a1862 1
	ANDI.L	#fxhc_Stop,D0		; Stop Command?
d1872 1
a1872 1
*	Was The Stop Command Issued?
d1874 4
a1877 2
AINHN4	ANDI.L	#fxhc_Stop,D0		; Stop Command?
	BEQ.S	AINHN6			; Jump If Not Stop Command.
d1879 3
@


2.45
log
@*** empty log message ***
@
text
@d19 15
d60 1
d62 1
a62 1
	MOVEM.L	D1-D4/A1-A6,-(A7)	; Save Calling State.
d65 1
d72 3
d76 3
d189 1
a189 1
	BRA.S	ANMLDB			; Exit Subroutine.
d202 1
a202 1
	BRA.S	ANMLDB			; Exit Subroutine.
d233 1
a233 1
ANMLDA	BSR.S	FindFramePositions	; D0.L = Error Code.
d241 45
a285 1
	BPL.S	ANMLDD			; Exit If No Error.
d301 1
a301 1
	MOVEM.L	(A7)+,D1-D4/A1-A6	; Return Calling State.
d749 1
a749 1
	BNE.S	BUCOT7			; Jump If Color Table There.
d751 1
a751 1
	BEQ.S	BUCOT6			; Jump If Nothing To Do.
d764 4
d769 3
d805 1
a805 1
	BSR.S	SoftToHardColor		; Convert To New Format.
d843 1
a843 1
	BEQ.S	FRCOT1			; Jump If Color Table Not There.
d845 1
a845 1
	BEQ.S	FRCOT1			; Jump If Color Table Not There.
d848 6
d957 1
a957 1
	BEQ.S	ANMUL9			; Exit If NULL.
d966 1
d975 2
a976 1
	BSR.S	FreePackedList		; Give The Memory In The List Back.
d982 1
a982 1
	BEQ.S	ANMUL7			; Jump If Nothing To Free.
d984 5
a988 1
	BEQ.S	ANMUL7			; Jump If No Data To Free.
d997 5
d1039 4
d1044 3
d1081 1
a1081 1
	BEQ.S	FRPLS1			; Exit If NULL Pointer.
d1086 4
d1126 1
a1126 1
	BSR.S	FreePackedListStruct	; Give It Back.
d1244 3
d1248 3
d1275 1
a1275 1
	BSR.S	RoundToDoubleLongWord	; D0.L = Double Word Alligned.
d1278 1
a1278 1
	BRA.S	ALCRB9			; Exit Subroutine.
d1287 3
d1291 3
d1333 1
a1333 1
ALCRBA	BSR.S	FreeCirBuffer		; Get Back Single Buffer.
d1459 1
d1496 1
a1496 1
	BEQ.S	FRCIB2			; Exit If NULL Pointer.
d1504 1
a1504 1
	BEQ.S	FRCIB2			; Jump If NULL.
d1507 4
d1516 1
a1516 1
	MOVE.L	#acl_Sizeof,D0		; D0.L = Number  of Bytes to Free.
d1518 5
d2084 1
a2084 1
	BEQ.S	MVTFM3			; Exit If Nothing Loaded.
d2086 1
a2086 1
	BNE.S	MVTFM3			; Exit If Not Chip Memory.
d2092 3
d2096 3
d2100 1
a2100 1
	BEQ.S	MVTFM3			; Exit If Allocation Failed.
d2111 1
a2111 1
	BSR.S	MoveLongs		; Move Over The Data.
d2124 4
@


2.44
log
@*** empty log message ***
@
text
@d1527 1
d1753 1
d1891 1
@


2.43
log
@*** empty log message ***
@
text
@d1133 2
a1134 2
	MOVEM.L	D0-D4/A1-A3/A5-A6,-(A7)	; Save Calling State.
	MOVE.L	A0,D4			; D4.L = Address of Available Memory.
d1146 1
a1146 1
	BEQ	ALCRBA			; Exit On Error.
a1159 1
	MOVEQ.L	#1,D3			; D3.L = Sys Allocation Bit Pick.
d1161 1
a1161 2
	LEA.L	acl_AllocatedPlanes(A2),A5 ; A5.L = Address of Allocations.
	MOVEA.L	D4,A1			; A1.L = Address of Available Memory.
d1166 3
a1168 4
	MOVE.L	A0,(A5)+		; Save Allocation Plane Pointer.
	BSR.S	RoundToDoubleLongWord	; A0.L = Double Word Alligned.
	MOVE.L	A0,(A3)+		; Save Plane Pointer.
	ADD.W	D3,D3			; Shift Mask Up.
d1170 1
a1170 1
	BRA.S	ALCRB8			; Exit Subroutine.
d1174 2
a1175 1
ALCRB3	MOVE.L	aec_PlaneSize(A4),D0	; D0.L = Amount of Memory.
d1181 6
a1186 10
	TST.L	D0			; NULL Pointer?
	BEQ.S	ALCRB4			; Exit If Failed.
	MOVEA.L	D0,A0			; A0.L = Address of Memory.
	MOVE.L	A0,(A5)+		; Save Allocation Plane Pointer.
	BSR.S	RoundToDoubleLongWord	; A0.L = Double Word Alligned.
	MOVE.L	A0,(A3)+		; Save Plane Pointer.
	OR.W	D3,acl_Flags(A2)	; Make Allocation Pick.
	ADD.W	D3,D3			; Shift Mask Up.
	DBF	D2,ALCRB3		; Loop Until Done.
	BRA.S	ALCRB8			; Exit Subroutine.
d1190 2
a1191 2
ALCRB4	MOVEA.L	D4,A1			; A1.L = Address of Available Memory.
ALCRB5	MOVEQ.L	#avmc_PriPublic,D0	; D0.L = Memory Priority.
d1193 6
a1198 6
	BEQ.S	ALCRB6			; Exit If Failed.
	MOVE.L	A0,(A5)+		; Save Allocation Plane Pointer.
	BSR.S	RoundToDoubleLongWord	; A0.L = Double Word Alligned.
	MOVE.L	A0,(A3)+		; Save Plane Pointer.
	DBF	D2,ALCRB5		; Loop Until Done.
	BRA.S	ALCRB8			; Exit Subroutine.
d1202 2
a1203 2
ALCRB6	MOVEA.L	D4,A1			; A1.L = Address of Available Memory.
ALCRB7	MOVEQ.L	#avmc_PriPrivate,D0	; D0.L = Memory Priority.
d1205 5
a1209 5
	BEQ.S	ALCRB9			; Exit If Failed.
	MOVE.L	A0,(A5)+		; Save Allocation Plane Pointer.
	BSR.S	RoundToDoubleLongWord	; A0.L = Double Word Alligned.
	MOVE.L	A0,(A3)+		; Save Plane Pointer.
	DBF	D2,ALCRB7		; Loop Until Done.
d1213 1
a1213 1
ALCRB8	MOVEQ.L	#-1,D0			; Set CC != Zero.
d1215 1
a1215 1
	BRA.S	ALCRBA			; Exit Subroutine.
d1219 1
a1219 1
ALCRB9	BSR.S	FreeCirBuffer		; Get Back Single Buffer.
d1225 1
a1225 1
ALCRBA	MOVEM.L	(A7)+,D0-D4/A1-A3/A5-A6	; Return Calling State.
d1232 12
a1243 1
*	A0.L = Double Word Alligned.					*
a1247 1
	MOVE.L	D0,-(A7)		; Save Calling State.
d1251 2
a1252 4
	MOVE.L	A0,D0			; D0.L = Address to Round To.
	ADDQ.L	#(8-1),D0		; Increment Past Starting.
	ANDI.W	#~(8-1),D0		; Remove Extra Bits.
	MOVEA.L	D0,A0			; A0.L = Address Double Word Alligned.
a1255 1
	MOVE.L	(A7)+,D0		; Return Calling State.
d1381 1
a1381 1
	BEQ.S	FRCIB5			; Exit If NULL Pointer.
d1383 2
a1384 4
	LEA.L	acl_AllocatedPlanes(A2),A3 ; A3.L = Address of Bit Plane Table.
	MOVE.W	acl_Flags(A2),D2	; D1.W = Allocation Pick Flags.
	MOVEQ.L	#0,D3			; Clear High Bits.
	MOVE.B	acl_Depth(A2),D3	; D3.L = Number of Planes.
d1388 2
a1389 5
	BRA.S	FRCIB3			; Start Looping.
FRCIB1	LSR.W	#1,D2			; Was This One Allocated?
	BCC.S	FRCIB2			; Jump If Not Allocated.
	MOVE.L	(A3),D0			; NULL Pointer?
	BEQ.S	FRCIB4			; Jump If NULL.
d1393 1
a1393 2
FRCIB2	ADDQ.L	#4,A3			; Move To Next Position.
FRCIB3	DBF	D3,FRCIB1		; Loop For Number of Planes.
d1397 1
a1397 1
FRCIB4	MOVE.L	#acl_Sizeof,D0		; D0.L = Number  of Bytes to Free.
d1403 1
a1403 1
FRCIB5	MOVEM.L	(A7)+,D0-D2/A0-A3/A6	; Return Calling State.
@


2.42
log
@*** empty log message ***
@
text
@@


2.41
log
@*** empty log message ***
@
text
@d1185 1
@


2.40
log
@*** empty log message ***
@
text
@d1138 1
a1138 1
	MOVEQ.L	#acl_Sizeof,D0		; D0.L = Size of The Structure.
d1401 1
a1401 1
FRCIB4	MOVEQ.L	#acl_Sizeof,D0		; D0.L = Number  of Bytes to Free.
@


2.39
log
@*** empty log message ***
@
text
@d529 1
d1133 1
a1133 1
	MOVEM.L	D0-D4/A1-A3/A6,-(A7)	; Save Calling State.
d1162 1
d1166 1
a1166 1
	BSR.S	AllocateToasterMemory	; A0.L = Address of Memory.
d1168 2
d1185 3
a1187 1
	MOVE.L	D0,(A3)+		; Save Plane Pointer.
d1199 2
d1211 2
d1230 24
a1253 1
ALCRBA	MOVEM.L	(A7)+,D0-D4/A1-A3/A6	; Return Calling State.
d1381 1
a1381 1
	LEA.L	acl_Planes(A2),A3	; A3.L = Address of Bit Plane Table.
d1476 1
@


2.38
log
@*** empty log message ***
@
text
@a18 3
;;;;	Include	"Work:Wipes/binc/Debug.i"
;;;;SERIALDEBUG EQU -1
;;;;	DisplaySerial
d1565 1
a1565 1
	BNE	ANMIO2			    ; Exit If Already On.
d1634 1
a1634 1
	MOVEQ.L	#INTB_INTEN,D0		; D0.L = Int Number.
@


2.37
log
@*** empty log message ***
@
text
@d19 3
a21 3
	Include	"Work:Wipes/binc/Debug.i"
SERIALDEBUG EQU -1
	DisplaySerial
a48 3

	DumpMes <AnimLoad>

a873 3

	DumpMes <AnimUnload>

a1496 3

	DumpMes <AnimSetForward>

a1562 3

	DumpMes <OnEnt>

d1568 1
a1568 1
	BNE.S	ANMIO2			    ; Exit If Already On.
a1593 3

	DumpHex.L <On>,A1

a1625 3

	DumpMes <OffEnt>

a1638 3

	DumpHex.L <Off>,A1

a1639 3

	DumpMes <After>

a1643 3

	DumpMes <ret>

a1671 3

	EmitChar.B #'i'

a1809 3

	DumpMes <PlayForward>

@


2.36
log
@*** empty log message ***
@
text
@d19 3
d49 3
d877 3
d1503 3
d1572 3
d1585 1
a1585 1
	MOVEQ.L	#IS_SIZE/2-1,D0		; D0.L = Loop Counter.
d1606 3
d1641 3
d1657 3
d1661 3
d1668 3
d1699 3
d1840 3
@


2.35
log
@*** empty log message ***
@
text
@@


2.34
log
@*** empty log message ***
@
text
@d1990 2
a1991 1
MoveLongs: MOVEM.L D0-D1/A0-A1,-(A7)	; Save Calling State.
d1995 1
a1995 2
	MOVE.W	D0,D1			; Lets Send Out 32 At A Time.
	ANDI.W	#$1F,D1			; D1.L = Jump Index.
d1997 6
a2002 3
	ADD.W	D1,D1			; Times 2 For Size of Opcode.
	NEG.W	D1			; Go Into Reverse.
	JMP	MOVEL2(PC,D1.W)		; Start Looping.
d2036 1
d2040 1
a2040 1
	MOVEM.L	(A7)+,D0-D1/A0-A1	; Return Calling State.
@


2.33
log
@*** empty log message ***
@
text
@@


2.32
log
@*** empty log message ***
@
text
@a4 1
	Include "RAM:Conditional.i"
@


2.31
log
@*** empty log message ***
@
text
@d1672 1
a1672 1
*	Has Enough Time Passed?
d1674 2
a1676 2
	BTSTA.L	aecb_DisableInt,aec_Flags(A0) ; Is the Interrupt Disabled?
	BNE.S	AINHN3			; Exit If Disabled.
@


2.30
log
@*** empty log message ***
@
text
@@


2.29
log
@*** empty log message ***
@
text
@a19 3
;;;;	Include	":Wipes/binc/Debug.i"
;;;;SERIALDEBUG EQU -1
;;;;	DisplaySerial
d159 2
a160 1
	JSR	_LVOAllocMem(A6)	; Try To Get Memory.
d182 1
a182 1
*	Check For ILBM, ANIM / FORM.
d186 5
a190 1
	MOVEA.L	aec_LoadBase(A4),A0	; A0.L = Address of Loaded Data.
a233 1
	TST.L	D0			; Set Return Code.
d236 1
d350 1
a350 1
	BNE	FNFRP3			; Jump Back If More Left.
d474 1
d503 1
a503 1
	BEQ	BLDEFF			; Jump If Nothing Loaded.
d506 1
a506 1
	BEQ	BLDEFF			; Jump If No Loaded.
d521 1
a521 1
	BEQ	BLDEFF			; Jump If Nothing Loaded.
d535 14
d551 2
a552 5
	CLR.W	aec_NumberOfBuffers(A4)	; Assume No Buffers.
	MOVE.L	A1,D0			; Check For NULL Pointer.
	BEQ	BLDEFE			; Jump If Nothing Loaded.
	BTSTA.L	pklb_ANHD,pkl_Flags(A1)	; Did We Get An Anim Header?
	BEQ	BLDEFE			; Jump If No Loaded.
d555 1
a555 1
	BEQ	BLDEFE			; Jump If Nothing Loaded.
d558 1
a558 1
	BNE.S	BLDEF1			; Jump If Ok.
d560 1
a560 1
BLDEF1	MOVE.W	D0,aec_NumberOfBuffers(A4) ; Save Number Of Buffers.
d565 2
a566 2
	BRA.S	BLDEF3			; Start Looping.
BLDEF2	ORI.L	#(1<<pklb_MakeFromPrev)!(1<<pklb_StartFrame),pkl_Flags(A1)
d569 1
a569 1
BLDEF3	DBEQ	D0,BLDEF2		; Loop For Number of Buffers - 1.
d577 1
a577 1
	BNE.S	BLDEF6			; Jump If Loop Anim.
d582 2
a583 2
	BRA.S	BLDEF5			; Look For End Of List.
BLDEF4	MOVEA.L	D2,A1			; A1.L = Next Position In List.
d585 2
a586 2
BLDEF5	MOVE.L	pkl_AllocLink(A1),D2	; D2.L = Address of Next In Packed List.
	BNE.S	BLDEF4			; Loop Back.
d590 1
a590 1
	BRA.S	BLDEFC			; Exit Subroutine.
d594 1
a594 1
BLDEF6	MOVEQ.L	#0,D1			; Clear High Bits.
d605 2
a606 2
	BRA.S	BLDEF8			; Loop For N Frames.
BLDEF7	BSETA.L	pklb_NormalFrame,pkl_Flags(A1) ; We Have A Normal Frame.
d609 2
a610 2
	BEQ.S	BLDEFD			; Exit If Not Enough Frames.
BLDEF8	DBF	D1,BLDEF7		; Go To Nth Buffer.
d617 1
a617 1
	BEQ.S	BLDEFB			; Jump If All Done.
d620 2
a621 2
	BRA.S	BLDEFA			; Look For End Of List.
BLDEF9	MOVEA.L	D2,A1			; A1.L = Next Position In List.
d623 3
a625 3
BLDEFA	MOVE.L	pkl_AllocLink(A1),D2	; D2.L = Address of Next In Packed List.
	BNE.S	BLDEF9			; Loop Back.
BLDEFB	BSETA.L	pklb_LastLoop,pkl_Flags(A1)  ; Flag Last Normal Flag.
d631 2
a632 2
BLDEFC	MOVEQ.L	#AEE_NoError,D0		; D0.L = No Error.
	BRA.S	BLDEFG			; Exit Subroutine.
d636 2
a637 2
BLDEFD	MOVEQ.L	#AEE_ToFewFrames,D0	; D0.L = Too Few Frames.
	BRA.S	BLDEFG			; Exit Subroutine.
d641 2
a642 2
BLDEFE	MOVEQ.L	#AEE_OnlyOneFrameLoaded,D0 ; Only One Frame Loaded.
	BRA.S	BLDEFG			; Exit Subroutine.
d646 1
a646 1
BLDEFF	MOVEQ.L	#AEE_BMHeaderNotLoaded,D0 ; Bit Map Header Not Loaded.
d650 2
a651 1
BLDEFG	MOVEM.L	(A7)+,D1-D2/A0-A2	; Return Calling State.
a1412 1

d1580 2
a1581 2
	MOVE.B	#NT_INTERRUPT,LN_TYPE(A1) ; Save Type.
	MOVE.B	#0,LN_PRI(A1)		; Save Priority.
d1894 205
@


2.28
log
@*** empty log message ***
@
text
@d1552 1
a1552 1
	BNE.S	ANMIO2			  ; Exit If Already On.
d1615 1
a1615 1
	BEQ.S	ANMIF1			  ; Exit If Already Off.
d1672 1
a1672 1
	BCLRA.L	aecb_BufferFull,aec_Flags(A0) ; Is The Buffer Full?
d1690 1
a1690 1
	BCLRA.L	aecb_BufferFull,aec_Flags(A0) ; The Buffer Is Full.
@


2.27
log
@*** empty log message ***
@
text
@d1150 1
a1150 1
	BSR	AllocateToasterMemory	; A0.L = Address of Memory.
d1155 1
a1155 1
	BRA	ALCRB8			; Exit Subroutine.
@


2.26
log
@*** empty log message ***
@
text
@d71 1
a71 1
	MOVEA.L	anl_AvailableMemory(A2),A3	; A3.L = Addr Available Memory
d184 1
a184 1
*	Check For ANIM, FORM.
d189 8
d202 1
a202 1
	CMPI.L	#'ILBM',(A0)+		; Needs To Be ILBM.
d215 1
d273 8
d285 9
a293 1
	ADDQ.L	#(2-1),D3		; Make Even Number.
d303 1
a303 1
FNFRP1	SUBQ.L	#8,D3			; D3.L = Less Header Size.
d316 1
a316 1
	BNE.S	FNFRP2			; Jump If Not Bit Map Header.
d319 1
a319 1
	BRA.S	FNFRP6			; Skip Else Part.
d323 2
a324 2
FNFRP2	CMPI.L	#'BODY',D0		; Is It A Body Hunk?
	BNE.S	FNFRP3			; Jump If Not Body Hunk.
d328 1
a328 1
	BRA.S	FNFRP6			; Skip Else Part.
d332 2
a333 2
FNFRP3	CMPI.L	#'CAMG',D0		; Is It A CAMG Hunk?
	BNE.S	FNFRP4			; Jump If Not CAMG Hunk.
d335 1
a335 1
	BRA.S	FNFRP6			; Skip Else Part.
d339 2
a340 2
FNFRP4	CMPI.L	#'CMAP',D0		; Is It A CMAP Hunk?
	BNE.S	FNFRP6			; Jump If Not CMAP Hunk.
d346 1
a346 1
FNFRP6	ADDA.L	D1,A2			; Move Thru Record.
d348 1
a348 1
	BNE	FNFRP1			; Jump Back If More Left.
d353 1
a353 1
FNFRP7	MOVEA.L	A1,A0			; A0.L = Address of pkl Structure.
d386 1
a386 1
FNFRP8	SUBQ.L	#8,D3			; D3.L = Less Header Size.
d431 1
a431 1
	BNE	FNFRP8			; Jump Back If More Left.
d436 1
a436 1
	BNE	FNFRP7			; Jump If More Data Left.
d1026 1
a1026 1
*	A1.L	= Address of Available Memory.				*
d1039 2
a1040 2
	MOVEM.L	D1-D6/A0-A3,-(A7)	; Save Calling State.
	MOVEA.L	A1,A3			; A3.L = Available Memory List.
d1053 2
a1054 1
ALCIB1	BSR.S	AllocateCirBuffer	; A0.L = Address of Structure.
d1062 2
a1063 1
ALCIB2	BSR.S	AllocateCirBuffer	; A0.L = Address of Structure.
d1091 1
a1091 1
	MOVEM.L	(A7)+,D1-D6/A0-A3	; Return Calling State.
d1102 1
a1102 1
*	A1.L	= Address of Available Memory.				*
d1119 1
a1119 1
	MOVE.L	A1,D4			; D4.L = Address of Available Memory.
d1147 1
d1150 1
a1150 1
	BSR.S	AllocateToasterMemory	; A0.L = Address of Memory.
d1155 1
a1155 1
	BRA.S	ALCRB8			; Exit Subroutine.
d1746 1
a1746 1
	BNE.S	TMTAD5			; Jump If Unpack Into != On Display.
d1755 1
a1755 20



*********************Method Generate Interrupt******************
	BNE.S	TMTAD4			; Jump If Stop Command.
*
*	Generate Our Own Interrupt.
*
	MOVE.W	#INTF_SETCLR!INTF_COPER,(_custom+intreq) ; Generate Copper Int.
	BRA.S	TMTAD1			; Check To See If Ready.
****************************************************************



**********************Old Method********************************
;;;	BEQ.S	TMTAD1			; Jump If Stop Command Not Received.
****************************************************************



d1759 2
a1760 2
TMTAD4	MOVEQ.L	#0,D0			; D0.L = Stop Command Received.
	BRA.S	TMTAD6			; Exit, We Got Stop Command.
d1764 1
a1764 1
TMTAD5	MOVEQ.L	#-1,D0			; D0.L = Time To Advance.
d1768 1
a1768 1
TMTAD6	MOVEM.L	(A7)+,D0		; Return Calling State.
a1833 1
;;;;	BSETA.L	aecb_BufferFull,aec_Flags(A4) ; Flag The Buffer Is Full.
@


2.25
log
@*** empty log message ***
@
text
@d1710 1
a1710 1
	MOVEM.L	D0/A0,-(A7)		; Save Calling State.
d1716 3
a1718 3
	MOVEA.L	aec_CurrentFrame(A4),A0	; A0.L = acl List To Unpack Into.
	CMPA.L	aec_DisplayFrame(A4),A0	; Unpack Into == On is Display?
	BNE.S	TMTAD4			; Jump If Unpack Into != On Display.
d1720 3
d1727 25
a1751 3
	BEQ.S	TMTAD1			; Jump If No Stop Command.
	MOVEQ.L	#0,D0			; D0.L = Stop Command Received.
	BRA.S	TMTAD5			; Exit, We Got Stop Command.
d1755 1
a1755 1
TMTAD4	MOVEQ.L	#-1,D0			; D0.L = Time To Advance.
d1759 1
a1759 1
TMTAD5	MOVEM.L	(A7)+,D0/A0		; Return Calling State.
d1790 1
a1790 1
	BEQ.S	ANPLF9			; Exit If NULL
d1792 1
a1792 1
	BEQ.S	ANPLF9			; Exit If NULL
d1798 1
a1798 1
	BEQ.S	ANPLF9			; Exit If NULL Pointer.
d1800 1
a1800 1
	BEQ.S	ANPLF9			; Exit If NULL Pointer.
d1802 1
a1802 1
	BEQ.S	ANPLF9			; Exit If NULL Pointer.
d1816 1
a1816 1
	BEQ.S	ANPLF6			; Exit If Stop Command.
d1825 2
a1826 1
	MOVE.W	#INTF_SETCLR!INTF_COPER,_custom+intena ; Generate Copper Int.
d1835 1
a1835 1
ANPLF6	BSETA.L	aecb_DisableInt,aec_Flags(A4) ; Stop Anim From Running.
d1841 1
a1841 1
ANPLF9	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
@


2.24
log
@*** empty log message ***
@
text
@d20 1
a20 1
;;;;	Include	"JLFinch:Wipes/binc/Debug.i"
a34 1
*	A5.L	= Address of Toaster Base.				*
d56 1
a56 1
	MOVE.L	#aec_Sizeof,D0		; D0.L = Number of Bytes.
d95 1
d301 1
d355 1
a355 1
	BNE.S	FNFRPF			; Exit If Wrong File Type.
d399 1
d869 1
a869 1
ANMUL8	MOVE.L	#aec_Sizeof,D0		; D0.L = Amount  of Memory.
d1370 1
d1701 2
a1702 2
*	No Carry -> Not Ok To Advance, All Done, or Stop Command.	*
*	Carry	 -> Ok To Advance Thru File.				*
d1710 1
a1710 3
	MOVEM.L	D0-D1/A0-A1,-(A7)	; Save Calling State.
*
*	Played Up To Frame To Stop At.
a1711 8
	MOVEA.L	aec_UnPackedList(A4),A1	; A1.L = pkl Head of Display.
	MOVE.W	pkl_FrameNumber(A1),D1	; D1.W = Frame Number.
TMTAD1	MOVEA.L	aec_DisplayFrame(A4),A1	; A1.L = acl Head of Display.
	MOVEA.L	aec_CurrentFrame(A4),A0	; A0.L = acl Head of Unpack.
	MOVE.W	acl_FrameNumber(A0),D0	; D0.W = Frame We Have Decompressed To.
	CMP.W	D1,D0			; Are We Their?
	BCC.S	TMTAD7			; Jump If We Are That Far.
*
d1714 1
a1714 1
	BTSTA.L	aecb_BufferFull,aec_Flags(A4) ; Is The Buffer Already Full?
d1716 3
a1718 2
	CMPA.L	A0,A1			; Head Of List == Display?
	BNE.S	TMTAD4			; Jump If Head != Display.
d1723 1
a1723 1
	BTSTA.L	aecb_GotStopCommand,aec_Flags(A4) ; Got Stop Command?
d1725 2
a1726 12
	MOVEQ.L	#0,D0			; Return Carry Clear.
	BRA.S	TMTAD7			; We Got Stop Command.
*
*	Sometimes One Back Gets Run Over.
*
TMTAD4
;	CMPA.L	acl_BackwardLink(A0),A1	; The List Is Really Full Now.
;	BNE.S	TMTAD6			; Jump If List Not Full.
;	BSETA.L	aecb_BufferFull,aec_Flags(A4) ; Flag The Buffer Is Full.
;	BCLRA.L	aecb_InteruptOccured,aec_Flags(A4) ; Interrupt Occured Flag.
;TMTAD5	BTSTA.L	aecb_InteruptOccured,aec_Flags(A4) ; Interrupt Occured?
;	BEQ.S	TMTAD5			; Burn Off a Frame.
d1730 1
a1730 2
TMTAD6	MOVEQ.L	#0,D0			; Return Carry Set.
	SUBQ.W	#1,D0
d1734 1
a1734 1
TMTAD7	MOVEM.L	(A7)+,D0-D1/A0-A1	; Return Calling State.
a1748 1
*	A5.L	= Address of Toaster Base.				*
d1760 4
a1763 1
	MOVEM.L	D0-D7/A0-A6,-(A7)	; Save Calling State.
d1790 2
a1791 2
ANPLF1	BSR	TimeToAdvance
	BCC.S	ANPLF6			; Jump If Error.
a1792 1
	MOVE.W	#INTF_SETCLR!INTF_COPER,_custom+intena ; Generate Copper Int.
d1800 1
a1804 2
;;;;	MOVEA.L	aec_UnPackedList(A4),A0	; A0.L = pkl Present Link.
;;;;	BTSTA.L	pklb_LastNormal,pkl_Flags(A0)
d1815 1
a1815 1
ANPLF9	MOVEM.L	(A7)+,D0-D7/A0-A6	; Return Calling State.
a1829 1
*	A5.L	= Address of Toaster Base.				*
@


2.23
log
@*** empty log message ***
@
text
@@


2.22
log
@*** empty log message ***
@
text
@d1631 1
a1631 1
	BNE.S	AINHN4			; Exit If Disabled.
d1636 1
a1636 1
	BEQ.S	AINHN4			; Exit If Null List.
d1638 1
a1638 1
	BEQ.S	AINHN4			; Exit If Null List.
d1644 1
a1644 1
	BEQ.S	AINHN4			; Exit If Current Is Head of List.
d1653 1
a1653 1
	BEQ.S	AINHN3			; Jump If Not Displayed.
d1663 1
a1663 1
AINHN3	ANDI.L	#fxhc_Stop,D0		; Stop Command?
a1664 1
	BSETA.L	aecb_GotStopCommand,aec_Flags(A0) ; Send Stop Command.
a1665 1

d1669 1
a1669 1
AINHN4	MOVEQ.L	#fxhc_NotReady,D0	; D0.L = Not Ready Command.
d1675 3
a1677 3
	ANDI.L	#fxhc_Stop,D0		; Stop Command?
	BEQ.S	AINHN5			; Jump If Not Stop Command.
	BSETA.L	aecb_GotStopCommand,aec_Flags(A0) ; Send Stop Command.
d1681 1
a1681 1
AINHN5	MOVEQ.L	#0,D0			; Flag, Keep Going Down List.
@


2.21
log
@*** empty log message ***
@
text
@d14 1
a1479 1

a1481 1

a1483 1

d1625 1
a1625 2
	MOVEM.L	A2-A4,-(A7)		; Save Calling State.
	MOVEA.L	A1,A4			; A4.L = aec Base Address.
d1629 3
a1631 3
	BSETA.L	aecb_InteruptOccured,aec_Flags(A4) ; Interrupt Occured.
	BTSTA.L	aecb_DisableInt,aec_Flags(A4) ; Is the Interrupt Disabled?
	BNE.S	AINHN2			; Exit If Disabled.
d1635 10
a1644 10
	MOVE.L	aec_CurrentFrame(A4),D1	; D1.L = acl Address of Present Decompress.
	BEQ.S	AINHN2			; Exit If Null List.
	MOVE.L	aec_DisplayFrame(A4),D0	; D0.L = acl Address of Present Displayed.
	BEQ.S	AINHN2			; Exit If Null List.
	MOVEA.L	D0,A0			; A0.L = acl Address of Display Frame.
	MOVEA.L	acl_ForwardLink(A0),A0	; Pointer to Next Display Position.
	BCLRA.L	aecb_BufferFull,aec_Flags(A4) ; Is The Buffer Full?
	BNE.S	AINHN1			; Jump If Buffer Is Full.
	CMPA.L	D1,A0			; Is It The Current One?
	BEQ.S	AINHN2			; Exit If Current Is Head of List.
d1648 2
a1649 3
AINHN1	MOVEQ.L	#fxhc_Ready,D0		; D0.L = Ready Command.
	MOVEA.L	A4,A0			; A0.L = Address of aec Base.
	MOVEA.L	aec_FXHandler(A4),A1	; A1.L = Address of FX Handler.
d1657 11
a1667 4
	MOVEA.L	aec_DisplayFrame(A4),A0	; A0.L = acl Present Link.
	MOVE.L	acl_ForwardLink(A0),aec_DisplayFrame(A4) ; New Head Of List.
	BCLRA.L	aecb_BufferFull,aec_Flags(A4) ; The Buffer Is Full.
	BRA.S	AINHN3			; Check For Stop Command.
d1671 2
a1672 3
AINHN2	MOVEQ.L	#fxhc_NotReady,D0	; D0.L = Not Ready Command.
	MOVEA.L	A4,A0			; A0.L = Address of aec Base.
	MOVEA.L	aec_FXHandler(A4),A1	; A1.L = Address of FX Handler.
d1677 3
a1679 3
AINHN3	ANDI.L	#fxhc_Stop,D0		; Stop Command?
	BEQ.S	AINHN4			; Jump If Not Stop Command.
	BSETA.L	aecb_GotStopCommand,aec_Flags(A4) ; Send Stop Command.
d1683 1
a1683 2
AINHN4	MOVEQ.L	#0,D0			; Flag, Keep Going Down List.
	MOVEM.L	(A7)+,A2-A4		; Return Calling State.
d1798 2
d1810 1
d1830 1
@


2.20
log
@*** empty log message ***
@
text
@d1634 1
a1634 1
	BNE.S	AINHN6			; Exit If Disabled.
d1639 1
a1639 1
	BEQ.S	AINHN6			; Exit If Null List.
d1641 1
a1641 1
	BEQ.S	AINHN6			; Exit If Null List.
d1645 1
a1645 1
	BNE.S	AINHN3			; Jump If Buffer Is Full.
d1647 1
a1647 2
	BEQ.S	AINHN6			; Exit If Current Is Head of List.
AINHN3
d1649 1
a1649 1
*	Send Command.
d1651 2
a1652 2
	MOVEQ.L	#fxhc_Ready,D0		; D0.L = Ready Command.
	MOVEA.L	A5,A0			; A0.L = Address of aec Base.
d1655 3
d1664 1
d1666 13
d1681 2
a1682 1
AINHN6	MOVEM.L	(A7)+,A2-A4		; Return Calling State.
d1699 1
a1699 1
*	No Carry -> Not Ok To Advance, All Done.			*
d1730 4
a1733 1
	BRA.S	TMTAD1			; Check Full Condition.
d1794 4
a1797 1

d1800 3
a1802 2


a1805 1

a1811 1

d1817 8
a1824 7
ANPLF2	MOVEA.L	aec_UnPackedList(A4),A0	; A0.L = pkl Present Link.
	BTSTA.L	pklb_LastNormal,pkl_Flags(A0)
	BEQ.S	ANPLF1			; Loop Until Done.

ANPLF6

	BSETA.L	aecb_DisableInt,aec_Flags(A4) ; Stop Anim From Running.
@


2.19
log
@*** empty log message ***
@
text
@d70 1
a1634 1
	ADDQ.L	#1,aec_SpeedCount(A4)	; One More Clock Tick.
a1649 20
*	Save Previous Values.
*
	LEA.L	aec_FXStruct(A4),A0	; A0.L = Address of FX Structure.
	MOVE.L	fxh_NextBitMap(A0),fxh_PreviousBitMap(A0)
	MOVE.L	fxh_NextColorTable(A0),fxh_PreviousColorTable(A0)
	MOVE.L	fxh_NextFrameNumber(A0),fxh_PreviousFrameNumber(A0)
	MOVE.L	fxh_NextInstallTime(A0),fxh_PreviousInstallTime(A0)
*
*	Set Next/Previous BitMap, Color Table, Frame Number.
*
	MOVEA.L	aec_DisplayFrame(A4),A1	; A1.L = acl Current Head Of List.
	MOVEA.L	acl_ForwardLink(A1),A1	; A1.L = acl New Head Of List.
	LEA.L	acl_BitMap(A1),A2	; A2.L = acl Next Bit Map.
	MOVE.L	A2,fxh_NextBitMap(A0)	; Save Next Bit Map.
	MOVE.L	acl_ColorTable(A1),fxh_NextColorTable(A0)
	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.W	acl_FrameNumber(A1),D0	; D0.L = Frame Number.
	MOVE.L	D0,fxh_NextFrameNumber(A0) ; Save Frame Number.
	MOVE.L	aec_SpeedCount(A4),fxh_NextInstallTime(A0)
*
d1652 2
a1653 1
	LEA.L	aec_FXStruct(A4),A0	; A0.L = Address of FX Struct.
d1801 1
@


2.18
log
@*** empty log message ***
@
text
@d19 3
a21 3
;;;	Include	"JLFinch:Wipes/binc/Debug.i"
;;;SERIALDEBUG EQU -1
;;;	DisplaySerial
d1020 1
a1020 1
	MOVEQ.L	#1,D2			; D2.L = Number of Buffers.
a1457 1
	MOVE.L	D0,aec_DisplayFrame(A4) ; Frame To Look At.
d1459 2
d1636 14
d1660 3
a1662 2
	MOVEA.L	aec_DisplayFrame(A4),A1	; A1.L = Frame To Display.
	LEA.L	acl_BitMap(A1),A2	; A2.L = Next Bit Map.
d1667 1
a1667 1
	MOVE.L	D0,fxh_NextFrameNumber(A1) ; Save Frame Number.
@


2.17
log
@*** empty log message ***
@
text
@d19 3
a21 3
;;;;	Include	"JLFinch:Wipes/binc/Debug.i"
;;;;SERIALDEBUG EQU -1
;;;;	DisplaySerial
d1477 4
a1480 2
	MOVEA.L	aec_CircularList(A4),A0	; A0.L = acl Present Link.
	MOVE.L	acl_ForwardLink(A0),aec_CircularList(A4) ; New Head Of List.
d1483 1
d1630 1
d1663 1
a1663 1
	MOVE.L	acl_ForwardLink(A0),aec_CircularList(A4) ; New Head Of List.
d1673 67
a1777 1

d1783 4
a1786 1
ANPLF1	BSR	CreateNextFrame		; Build Next Frame.
d1790 3
a1792 2
	MOVEA.L	aec_CircularList(A4),A0	; A0.L = acl Present Link.
	MOVE.L	acl_ForwardLink(A0),aec_CircularList(A4) ; New Head Of List.
d1802 1
@


2.16
log
@*** empty log message ***
@
text
@d865 1
a865 1
ANMUL8	MOVEQ.L	#aec_Sizeof,D0		; D0.L = Amount  of Memory.
@


2.15
log
@*** empty log message ***
@
text
@d34 1
d56 1
a56 1
	MOVEQ.L	#aec_Sizeof,D0		; D0.L = Number of Bytes.
d1495 174
d1692 38
d1733 1
a1733 1
	MOVEM.L	(A7)+,D0-D7/A0-A6	; Return Calling State.
@


2.14
log
@*** empty log message ***
@
text
@d33 1
a33 7
*	D0.L	= aec_Flags.						*
*		  I.E. MOVE.L #(1<<aecb_AnimInOverlay)+2,D0 ; 3rd Anim.	*
*	A0.L	= Address of File Name.					*
*	A1.L	= Address of Available Memory.				*
*	A2.L	= Address of DOS Base.					*
*	A3.L	= Address of SYS Base.					*
*	A5.L	= Address of Toaster Base.				*
d51 1
a54 1
	MOVEM.L	D0/A0-A1,-(A7)		; Save Calling State.
d57 1
a57 1
	MOVEA.L	A3,A6			; A6.L = Address of Sys Base.
d60 1
a60 2
	MOVEM.L	(A7)+,D0/A0-A1		; Return Calling State.
	MOVE.L	A4,D1			; Did We Allocate The Memory?
d65 5
a69 4
	MOVE.L	D0,aec_Flags(A4)	; Opening Flags.
	MOVE.L	A2,aec_DOSBase(A4)	; DOS Base.
	MOVE.L	A3,aec_SYSBase(A4)	; SYS Base.
	MOVEA.L	A1,A3			; A3.L = Address of Available Memory.
d73 1
a73 1
	MOVE.L	A0,D1			; D1.L = Address of File Name.
d1462 1
a1462 1
	MOVEA.L	TB_GFXBase(A5),A6	; A6.L = Address of Graphics Base.
@


2.13
log
@*** empty log message ***
@
text
@a502 2
	ADDI.L	#(1<<3)-1,D0		; Go Mod Max Size.
	LSR.L	#3,D0			; D0.L = Double Long Word Alligned.
d641 1
d650 1
d1338 96
d1453 39
a1491 1
	MOVEM.L	D0-D7/A0-A6,-(A7)	; Save Calling State.
d1495 1
a1495 1
	MOVEM.L	(A7)+,D0-D7/A0-A6	; Return Calling State.
@


2.12
log
@*** empty log message ***
@
text
@@


2.11
log
@*** empty log message ***
@
text
@d34 1
d55 1
a55 1
	MOVEM.L	D1-D3/A1-A6,-(A7)	; Save Calling State.
d68 1
a68 1
	BEQ	ANMLDA			; Exit If Failed.
d86 1
a86 1
	BRA	ANMLD9			; Exit Subroutine.
d89 1
a89 1
*	Are We In A Debug Hunk.
d91 6
a96 4
	MOVE.L	aec_Flags(A4),D3	; D3.L = aec_Flags.
	BTST.L	#aecb_AnimInDebugHunk,D3 ;In a Debug Hunk?
	BEQ.S	ANMLD2			; Jump If Not In Debug Hunk.

d100 15
a114 7
	TST.L	D0
	BEQ.S	ANMLDY

	ANDI.W	#aecm_HunkNumber,D3	; D3.W = Debug Hunk Number.

ANMLDR	MOVEA.L	A2,A0			; A0.L = Address of File Lock.
	MOVE.L	#$3F3,D0		; D0.L = Look For Overlay Hunk.
a115 3

;;;;	DumpHex.L <Hunk>,D0

d117 17
a133 5
	DBEQ	D3,ANMLDR		; Loop Until Done.
	BNE.S	ANMLDX			; Jump If Ok.
ANMLDY	MOVEQ.L	#AEE_CannotFindDebugHunk,D0 ; Cannot Find Debug Hunk.
	BRA	ANMLD9			; Exit Subroutine.
ANMLDX
d137 1
a137 1
ANMLD2	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
d142 1
a142 1
	BEQ.S	ANMLD3			; Jump If No Error.
d146 1
a146 1
	BRA	ANMLD9			; Exit Subroutine.
d150 2
a151 10
ANMLD3

;;;;	MOVE.L	(A7),D0
;;;;	DumpHex.L <0-3>,D0
;;;;	MOVE.L	4(A7),D0
;;;;	DumpHex.L <4-7>,D0


	CMPI.L	#'FORM',(A7)		; Did We Get A Form Hunk?
	BEQ.S	ANMLD4			; Not an Iff FORM.
d155 1
a155 1
	BRA	ANMLD9			; Exit Subroutine.
d159 3
a161 3
ANMLD4	MOVE.L	4(A7),D0		; D0.L = Number of Bytes in Hunk.
	ADDQ.L	#1,D0			; Make Even Number.
	ANDI.W	#$FFFE,D0		; Rounded To Even Number.
d168 1
a168 1
	BNE.S	ANMLD5			; Jump If Ok.
d172 1
a172 1
	BRA	ANMLD9			; Exit Subroutine.
d176 1
a176 1
ANMLD5	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
d181 1
a181 1
	BEQ.S	ANMLD6			; Jump If No Error.
a183 4
	MOVE.L	aec_LoadLength(A4),D0	; D0.L = Amount  of Memory.
	MOVEA.L	aec_LoadBase(A4),A1	; A1.L = Address of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; Address of Exec Base.
	JSR	_LVOFreeMem(A6)		; Give Back the Memory.
d185 1
a185 1
	BRA.S	ANMLD9			; Exit Subroutine.
d189 1
a189 1
ANMLD6	MOVE.L	A2,D1			; D1.L = Address of File Lock.
d193 1
a193 1
	BNE.S	ANMLD7			; Jump If Not An Anim.
d195 1
a195 1
	BNE.S	ANMLD7			; Jump If Not An Anim.
d198 3
a200 3
	BEQ.S	ANMLD8			; Jump If Ok.
ANMLD7	MOVEQ.L	#AEE_WrongFileType,D0	; D0.L = Wrong File Type Error.
	BRA.S	ANMLD9			; Exit Subroutine.
d204 1
a204 1
ANMLD8	BSR.S	FindFramePositions	; D0.L = Error Code.
d206 1
a206 1
	BMI.S	ANMLD9			; Exit On Error.
d209 1
a209 1
	BMI.S	ANMLD9			; Exit On Error.
d211 1
a211 1
	BPL.S	ANMLDB			; Exit If No Error.
d215 1
a215 1
ANMLD9	BSR	AnimUnload		; Remove Anim From Memory.
d217 1
a217 1
	BRA.S	ANMLDB			; Exit Subroutine.
d221 1
a221 1
ANMLDA	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Error Code.
d225 1
a225 1
ANMLDB	MOVEA.L	A4,A0			; A0.L = Address of aec Structure.
d228 1
a228 1
	MOVEM.L	(A7)+,D1-D3/A1-A6	; Return Calling State.
a262 1

a264 1

d271 2
a272 2
	ADDQ.L	#1,D3			; Make Even Number.
	ANDI.W	#$FFFE,D3		; Rounded To Even Number.
d286 2
a287 2
	ADDQ.L	#1,D1			; Make Even Number.
	ANDI.W	#$FFFE,D1		; Rounded To Even Number.
a334 1

a341 1

d352 2
a353 2
	ADDQ.L	#1,D3			; Make Even Number.
	ANDI.W	#$FFFE,D3		; Rounded To Even Number.
d357 1
a357 1
	BNE	FNFRPF			; Exit If Wrong File Type.
d368 2
a369 2
	ADDQ.L	#1,D1			; Make Even Number.
	ANDI.W	#$FFFE,D1		; Rounded To Even Number.
d371 1
a371 1
	BCS	FNFRPG			; Exit If Too Small.
d485 1
a485 1
	ADDQ.L	#2,D0			; Make Number of Colors.
d554 1
a554 1
	BRA	BLDEFC			; Exit Subroutine.
d644 1
a644 1
	BNE	BUCOT7			; Jump If Color Table There.
d646 1
a646 1
	BEQ	BUCOT6			; Jump If Nothing To Do.
d839 1
a839 2
	TST.L	aec_LoadBase(A4)	; Had The Data Been Loaded?
	BEQ.S	ANMUL8			; Exit If Not Loaded.
d844 3
d851 1
a851 1
	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
d853 3
a855 1
	BSR	FreePackedList		; Give The Memory In The List Back.
d859 3
a863 2
	MOVEA.L	aec_LoadBase(A4),A1	; A1.L = Address of Memory.
	MOVEA.L	aec_SYSBase(A4),A6	; Address of Exec Base.
a871 1
	MOVEA.L	aec_SYSBase(A4),A6	; A6.L = Address of System Base.
d1029 1
a1029 1
ALCIB1	BSR	AllocateCirBuffer	; A0.L = Address of Structure.
d1037 1
a1037 1
ALCIB2	BSR	AllocateCirBuffer	; A0.L = Address of Structure.
@


2.10
log
@*** empty log message ***
@
text
@d93 7
d101 1
d103 1
a103 1
	MOVE.L	#$3F3,D0		; D0.L = Hunk Type.
d106 1
a106 1
;;;	DumpHex.L <Hunk>,D0
d111 1
a111 1
	MOVEQ.L	#AEE_CannotFindDebugHunk,D0 ; Cannot Find Debug Hunk.
@


2.9
log
@*** empty log message ***
@
text
@d38 1
d69 1
a69 1
*	Allocate aec Memory.
a223 1
*	A5.L	= Address of Toaster Base.				*
a446 1
*	A5.L	= Address of Toaster Base.				*
a809 1
*	A5.L	= Address of Toaster Base.				*
d871 1
a871 1
*	A5.L	= Address of Toaster Base.				*
d911 1
a911 1
*	A5.L	= Address of Toaster Base.				*
d949 1
a949 1
*	A5.L	= Address of Toaster Base.				*
a987 1
*	A5.L	= Address of Toaster Base.				*
d1039 1
a1039 8
ALCIB8



;;;	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Not Enough Memory.

	MOVEQ.L	#-50,D0
	
a1061 1
*	A5.L	= Address of Toaster Base.				*
a1233 1
*	A5.L	= Address of Toaster Base.				*
a1271 1
*	A5.L	= Address of Toaster Base.				*
a1329 1
*	A5.L	= Address of Toaster Base.				*
d1359 1
a1359 1
*	A4.L	= Address of WP Base.					*
d1390 1
a1390 1
*	A4.L	= Address of WP Base.					*
@


2.8
log
@*** empty log message ***
@
text
@d19 3
a21 3
;;;	Include	"JLFinch:Wipes/binc/Debug.i"
;;;SERIALDEBUG EQU -1
;;;	DisplaySerial
d58 1
a58 1
	MOVEM.L	D0-D1/A0-A1,-(A7)	; Save Calling State.
d64 1
a64 1
	MOVEM.L	(A7)+,D0-D1/A0-A1	; Return Calling State.
d68 1
a68 1
*	Failed To Allocate Memory.
a74 7
*	Is It Already There?
*
	TST.L	aec_LoadBase(A4)	; Is It Already Loaded?
	BEQ.S	ANMLD1			; Jump If Not Already Loaded.
	MOVEQ.L	#AEE_AlreadyLoaded,D0	; D0.L = Already Loaded.
	BRA	ANMLD9			; Exit Subroutine.
*
d77 1
a77 1
ANMLD1	MOVE.L	A0,D1			; D1.L = Address of File Name.
d82 1
a82 1
	BNE.S	ANMLD2			; Jump If All Ok.
d85 20
a104 1
ANMLD2	MOVEA.L	D0,A2			; A2.L = Address of File Lock.
d108 1
a108 1
	MOVE.L	A2,D1			; D1.L = Address of File Pointer.
d121 9
a129 1
ANMLD3	CMPI.L	#'FORM',(A7)		; Did We Get A Form Hunk?
@


2.7
log
@*** empty log message ***
@
text
@d19 3
a21 3
;;;;	Include	"JLFinch:Wipes/binc/Debug.i"
;;;;SERIALDEBUG EQU -1
;;;;	DisplaySerial
d33 1
d36 2
a37 2
*	A4.L	= Address of aec Base.					*
*	A5.L	= Address of Toaster Base.				*
d42 1
d44 3
d53 1
a53 1
	MOVEM.L	D1-D3/A0-A6,-(A7)	; Save Calling State.
d55 18
d80 1
a80 1
	BRA	ANMLDA			; Exit Subroutine.
d86 1
a86 1
	MOVEA.L	TB_DOSBase(A5),A6	; A6.L = Address of Dos Base.
d91 1
a91 1
	BRA	ANMLDA			; Exit Subroutine.
d105 1
a105 1
	BRA	ANMLDA			; Exit Subroutine.
d114 1
a114 1
	BRA	ANMLDA			; Exit Subroutine.
d123 1
a123 1
	MOVEA.L	TB_SYSBase(A5),A6	; A6.L = Address of System Base.
d125 1
a125 1
	MOVEA.L	TB_DOSBase(A5),A6	; A6.L = Address of Dos Base.
d131 1
a131 1
	BRA	ANMLDA			; Exit Subroutine.
d145 1
a145 1
	MOVEA.L	TB_SYSBase(A5),A6	; Address of Exec Base.
d148 1
a148 1
	BRA.S	ANMLDA			; Exit Subroutine.
d163 1
a163 1
	BRA.S	ANMLDA			; Exit Subroutine.
d174 1
a174 1
	BPL.S	ANMLDA			; Exit If No Error.
d179 4
d184 2
d188 2
a189 1
ANMLDA	TST.L	D0			; Set Return Code.
d191 1
a191 1
	MOVEM.L	(A7)+,D1-D3/A0-A6	; Return Calling State.
d227 1
d230 1
d261 1
a261 2
	BSETA.L	pklb_FirstFrame,pkl_Flags(A1) ; We Are On First Frame.
	BSETA.L	pklb_BMHD,pkl_Flags(A1)	; We Have A Bit Map Header.
a291 3
	MOVEA.L	A1,A0			; A0.L = Address of pkl Structure.
	BSR	BuildColorTable		; Make The Color Table.
	BEQ	FNFRPH			; Exit On Memory Error.
d296 4
a299 1
FNFRP7	BSR	AllocPackedListStruct	; A0.L = Address of Packed Header.
d301 1
d309 1
d445 1
a445 1
	BEQ	BLDEF8			; Jump If Nothing Loaded.
d448 1
a448 1
	BEQ.S	BLDEF8			; Jump If No Loaded.
d452 1
a452 1
	MOVE.L	aec_TotalFrames(A4),aec_FrameCount(A4) ; Number of Frames.
d456 1
d463 1
a463 1
	BEQ.S	BLDEF8			; Jump If Nothing Loaded.
d483 1
a483 1
	BEQ.S	BLDEF7			; Jump If Nothing Loaded.
d485 4
a488 4
	BEQ.S	BLDEF7			; Jump If No Loaded.
	MOVEA.L	pkl_Header(A1),A1	; A1.L = Address of Anim Header.
	MOVE.L	A1,D0			; Check For NULL Pointer.
	BEQ.S	BLDEF7			; Jump If Nothing Loaded.
d490 2
a491 2
	MOVE.B	anh_interleave(A1),D0	; D0.L = Number of Buffers.
	BNE.S	BLDEF5			; Jump If Ok.
d493 68
a560 1
BLDEF5	MOVE.W	D0,aec_NumberOfBuffers(A4) ; Save Number Of Buffers.
d564 7
a570 2
	MOVEQ.L	#AEE_NoError,D0		; D0.L = No Error.
	BRA.S	BLDEF9			; Exit Subroutine.
d574 2
a575 2
BLDEF7	MOVEQ.L	#AEE_OnlyOneFrameLoaded,D0 ; Only One Frame Loaded.
	BRA.S	BLDEF9			; Exit Subroutine.
d579 1
a579 1
BLDEF8	MOVEQ.L	#AEE_BMHeaderNotLoaded,D0 ; Bit Map Header Not Loaded.
d583 1
a583 1
BLDEF9	MOVEM.L	(A7)+,D1-D2/A0-A2	; Return Calling State.
d613 1
a613 1
	BNE.S	BUCOT7			; Jump If Color Table There.
d615 1
a615 1
	BEQ.S	BUCOT6			; Jump If Nothing To Do.
d618 1
d621 1
a621 1
	Is_AA_ChipSet			; Do We Have An AA Chip Set?
d626 1
a626 1
	MOVEA.L	TB_SYSBase(A5),A6	; A6.L = Address of System Base.
d635 1
a635 1
	Is_AA_ChipSet			; Do We Have An AA Chip Set?
d699 1
a699 1
	BNE.S	FRCOT1			; Jump If Color Table Not There.
d701 1
a701 1
	BNE.S	FRCOT1			; Jump If Color Table Not There.
d703 1
a703 1
	MOVEA.L	TB_SYSBase(A5),A6	; Address of Exec Base.
d803 1
a803 1
	MOVEM.L	D0/A0-A1/A6,-(A7)	; Save Calling State.
d807 2
d810 1
a810 1
	BEQ.S	ANMUL9			; Exit If Not Loaded.
d826 1
a826 1
	BEQ.S	ANMUL8			; Jump If No Data To Free.
d828 1
a828 1
	MOVEA.L	TB_SYSBase(A5),A6	; Address of Exec Base.
d830 1
a830 1
ANMUL8	CLR.L	aec_LoadLength(A4)	; Clear Length.
d833 1
a833 1
*	Exit Subroutine.
d835 8
a842 1
ANMUL9	MOVEM.L	(A7)+,D0/A0-A1/A6	; Return Calling State.
d874 1
a874 1
	MOVEA.L	TB_SYSBase(A5),A6	; A6.L = Address of System Base.
d914 1
a914 1
	MOVEA.L	TB_SYSBase(A5),A6	; Address of Exec Base.
d1022 8
a1029 1
ALCIB8	MOVEQ.L	#AEE_NotEnoughFreeMemory,D0 ; D0.L = Not Enough Memory.
d1074 1
a1074 1
	MOVEA.L	TB_SYSBase(A5),A6	; A6.L = Address of System Base.
d1109 1
a1109 1
	MOVEA.L	TB_SYSBase(A5),A6	; A6.L = Address of System Base.
d1277 1
a1277 1
	MOVEA.L	TB_SYSBase(A5),A6	; Address of Exec Base.
@


2.6
log
@*** empty log message ***
@
text
@d412 1
a412 1
	BEQ.S	BLDEF8			; Jump If Nothing Loaded.
d432 1
a432 1
	ADDQ.L	#7,D0			; Go Mod 8.
d438 2
d944 2
a945 1
	MOVEM.L	D0-D1/A1/A6,-(A7)	; Save Calling State.
d952 1
d954 1
d957 2
a958 1
	BEQ.S	ALCRB9			; Exit On Error.
d962 54
a1015 6
	MOVE.W	aec_NumberOfColors(A4),acl_NumberOfColors(A0)
	MOVE.W	aec_Width(A4),acl_Width(A0)	; Save Width.
	MOVE.W	aec_Height(A4),acl_Height(A0)	; Save Height.
	MOVEQ.L	#0,D0			; Clear High Bits.
	MOVE.W	aec_Depth(A4),D0	; D0.L = Number of Planes.
	MOVE.B	D0,acl_Depth(A0)	; Save Depth.
d1019 9
a1027 1
	MOVEQ.L	#-1,D0			; Set CC != Zero.
d1031 60
a1090 1
ALCRB9	MOVEM.L	(A7)+,D0-D1/A1/A6	; Return Calling State.
d1139 1
d1153 2
a1154 1
	MOVEM.L	D0-D1/A0-A1/A6,-(A7)	; Save Calling State.
d1159 24
a1182 5
	BEQ.S	FRCIB1			; Exit If NULL Pointer.
	BSR	FreeColorTable		; Give Back The Color Table.
	MOVEQ.L	#acl_Sizeof,D0		; D0.L = Number  of Bytes to Free.
	MOVEA.L	A0,A1			; A1.L = Address of Memory.
	MOVEA.L	TB_SYSBase(A5),A6	; Address of Exec Base.
d1187 1
a1187 1
FRCIB1	MOVEM.L	(A7)+,D0-D1/A0-A1/A6	; Return Calling State.
@


2.5
log
@*** empty log message ***
@
text
@d57 1
a57 1
	BRA	ANMLD9			; Exit Subroutine.
d68 1
a68 1
	BRA	ANMLD9			; Exit Subroutine.
d82 1
a82 1
	BRA	ANMLD9			; Exit Subroutine.
d91 1
a91 1
	BRA	ANMLD9			; Exit Subroutine.
d108 1
a108 1
	BRA	ANMLD9			; Exit Subroutine.
d125 1
a125 1
	BRA.S	ANMLD9			; Exit Subroutine.
d140 4
a143 1
	BRA.S	ANMLD9			; Exit Subroutine.
d148 4
d153 4
d159 1
a159 1
ANMLD9	TST.L	D0			; Set Return Code.
d701 5
d844 206
d1057 1
a1057 1
*	A4.L	= Address of WP Base.					*
@


2.4
log
@*** empty log message ***
@
text
@d19 3
a21 3
	Include	"JLFinch:Wipes/binc/Debug.i"
SERIALDEBUG EQU -1
	DisplaySerial
@


2.3
log
@*** empty log message ***
@
text
@d15 1
d19 3
a21 3
;;;;	Include	"JLFinch:Wipes/binc/Debug.i"
;;;;SERIALDEBUG EQU -1
;;;;	DisplaySerial
d48 1
a48 1
	MOVEM.L	D1-D7/A0-A6,-(A7)	; Save Calling State.
d142 3
d150 1
a150 1
	MOVEM.L	(A7)+,D1-D7/A0-A6	; Return Calling State.
d176 1
a176 1
	MOVEM.L	D1-D6/A0-A6,-(A7)	; Save Calling State.
d180 1
d182 1
a182 1
	BEQ	FNFRPY			; Exit Memory Error.
d184 4
a187 2
	BEQ	FNFRPZ			; Exit If Failed.
	MOVEA.L	A0,A3			; A3.L = Address of Element In List.
d189 3
a191 3
	MOVE.L	aec_LoadLength(A4),D7	; D7.L = Number of Bytes.
	SUBI.L	#12,D7			; Less Size of Header.
	BCS	FNFRPX			; Exit If Too Small.
d193 5
a197 5
	MOVE.L	(A2)+,D6		; Get ILBM Size.
	ADDQ.L	#1,D6			; Make Even Number.
	ANDI.W	#$FFFE,D6		; Rounded To Even Number.
	SUB.L	D6,D7			; D7.L = Less Total Size.
	BCS	FNFRPX			; Exit If Too Small.
d199 2
a200 2
	SUBQ.L	#4,D6			; Less What We Read.
	BCS	FNFRPX			; Exit If Too Small.
d204 2
a205 2
FNFRP1	SUBQ.L	#8,D6			; D6.L = Less Header Size.
	BCS	FNFRPX			; Exit If Too Small.
d211 2
a212 2
	SUB.L	D1,D6			; That Much Data There?
	BCS	FNFRPX			; Exit If Too Small.
d217 4
a220 4
	BNE.S	FNFRP3			; Jump If Not Bit Map Header.
	BSETA.L	pklb_FirstFrame,pkl_Flags(A3) ; We Are On First Frame.
	BCLRA.L	pklb_ANHD,pkl_Flags(A3)	; We Have A Bit Map Header.
	MOVE.L	A2,pkl_Header(A3)	; Save Pointer to Header.
d225 4
a228 4
FNFRP3	CMPI.L	#'BODY',D0		; Is It A Body Hunk?
	BNE.S	FNFRP4			; Jump If Not Body Hunk.
	BCLRA.L	pklb_DLTA,pkl_Flags(A3)	; We Have A Body Hunk.
	MOVE.L	A2,pkl_Data(A3)		; Save Pointer to Data.
d233 3
a235 4
FNFRP4	CMPI.L	#'CAMG',D0		; Is It A CAMG Hunk?
	BNE.S	FNFRP5			; Jump If Not CAMG Hunk.
	MOVE.L	D2,pkl_ColorTableSize(A3) ; Color Table Size.
	MOVE.L	A2,pkl_ColorTable(A3)	; Pointer to Color Table.
d240 1
a240 1
FNFRP5	CMPI.L	#'CMAP',D0		; Is It A CMAP Hunk?
d242 2
a243 1
	MOVE.L	(A2),pkl_ViewMode(A3)	; Get The View Modes.
d248 1
a248 1
	TST.L	D6			; Any More Left?
d250 3
d258 10
a267 8
	BEQ	FNFRPY			; Exit If Failed.
	MOVE.L	A0,pkl_AllocLink(A3)	; Link To Next Allocation.
	MOVE.L	A0,pkl_ForwardLink(A3)	; Link To Next Forward Position.
	MOVE.L	A3,pkl_BackwardLink(A0)	; Link To Next Backward Position.
	MOVE.L	pkl_ColorTableSize(A3),pkl_ColorTableSize(A0)
	MOVE.L	pkl_ColorTable(A3),pkl_ColorTable(A0)
	MOVE.L	pkl_ViewMode(A3),pkl_ViewMode(A0)
	MOVEA.L	A0,A3			; A3.L = Address of Current Element.
d271 2
a272 2
	SUBQ.L	#8,D7			; D7.L = Less Size of FORM and size.
	BCS	FNFRPX			; Exit If Too Small.
d274 6
a279 6
	BNE	FNFRPW			; Exit If Wrong File Type.
	MOVE.L	(A2)+,D6		; Get Size of Record.
	ADDQ.L	#1,D6			; Make Even Number.
	ANDI.W	#$FFFE,D6		; Rounded To Even Number.
	SUB.L	D6,D7			; D7.L = Less Total Size.
	BCS	FNFRPX			; Exit If Too Small.
d281 3
a283 3
	BNE	FNFRPW			; Exit If Wrong File Type.
	SUBQ.L	#4,D6			; Less What We Read.
	BCS	FNFRPX			; Exit If Too Small.
d287 2
a288 2
FNFRP8	SUBQ.L	#8,D6			; D6.L = Less Header Size.
	BCS	FNFRPX			; Exit If Too Small.
d294 2
a295 2
	SUB.L	D1,D6			; That Much Data There?
	BCS	FNFRPX			; Exit If Too Small.
d301 2
a302 2
	BSETA.L	pklb_ANHD,pkl_Flags(A3)	; We Have An Anim Header.
	MOVE.L	A2,pkl_Header(A3)	; Save Pointer to Header.
d309 1
a309 2
	MOVE.L	D2,pkl_ColorTableSize(A3) ; Color Table Size.
	MOVE.L	A2,pkl_ColorTable(A3)	; Pointer to Color Table.
d316 2
a317 1
	MOVE.L	(A2),pkl_ViewMode(A3)	; Get The View Modes.
d324 2
a325 2
	BSETA.L	pklb_DLTA,pkl_Flags(A3)	; We Have A Dlta Hunk.
	MOVE.L	A2,pkl_Data(A3)		; Save Pointer to Data.
d330 1
a330 1
	TST.L	D6			; Any More Left?
d335 1
a335 1
FNFRPE	TST.L	D7			; Any Data Left?
d337 3
d343 2
a344 2
FNFRPV	MOVEQ.L	#AEE_NoError,D0		; D0.L = No Error.
	BRA.S	FNFRPZ			; Exit Subroutine.
d348 1
a348 1
FNFRPW	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
d352 1
a352 1
	BRA.S	FNFRPZ			; Exit Subroutine.
d356 1
a356 1
FNFRPX	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
d360 1
a360 1
	BRA.S	FNFRPZ			; Exit Subroutine.
d364 1
a364 1
FNFRPY	MOVEA.L	aec_PackedList(A4),A0	; A0.L = Head Of List.
d371 1
a371 1
FNFRPZ	MOVEM.L	(A7)+,D1-D6/A0-A6	; Return Calling State.
d376 286
d683 1
a683 1
	MOVEM.L	D0-D6/A0-A6,-(A7)	; Save Calling State.
d690 6
d708 1
a708 1
ANMUL9	MOVEM.L	(A7)+,D0-D6/A0-A6	; Return Calling State.
d777 1
@


2.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
	idnt	"AnimWipe"
a14 1
	Include "AnimWipeEqu.i"
a16 3
	Include	"AnimRam.i"
	Include	"AnimLibrary.i"
	Include	"AnimFileIO.i"
d18 1
a18 1
;;;;	Include	"Work:Wipes/binc/Debug.i"
d90 1
a90 1
	BRA.S	ANMLD9			; Exit Subroutine.
d95 2
d107 1
a107 1
	BRA.S	ANMLD9			; Exit Subroutine.
d131 3
a133 1
	CMPI.L	#'ANIM',(A0)		; Needs To ANIM.
d135 2
a136 1
	CMPI.L	#'FORM',(A0)		; Needs To FORM
d162 2
d172 1
a172 1
	MOVEM.L	D0-D6/A0-A6,-(A7)	; Save Calling State.
d176 2
a177 1
;	BSR	AllocatePacked		; A0.L = Address of Packed Header.
d179 2
a180 1
	BEQ.S	FNFRPZ			; Exit If Failed.
d182 171
a352 1

d354 1
a354 1
*	Exit Subrutine.
d356 1
a356 1
FNFRPZ	MOVEM.L	(A7)+,D0-D6/A0-A6	; Return Calling State.
d402 114
@


2.1
log
@*** empty log message ***
@
text
@d6 1
d20 1
d38 1
a38 1
*	A4.L	= Address of WP Base.					*
d52 88
d143 2
d150 36
d194 1
a194 1
*	A4.L	= Address of WP Base.					*
d207 16
a222 1
	MOVEM.L	D0-D7/A0-A6,-(A7)	; Save Calling State.
d226 1
a226 1
	MOVEM.L	(A7)+,D0-D7/A0-A6	; Return Calling State.
a312 29
	MOVEM.L	D0-D7/A0-A6,-(A7)	; Save Calling State.
*
*	Exit Subroutine.
*
	MOVEM.L	(A7)+,D0-D7/A0-A6	; Return Calling State.
	RTS
	PAGE
*************************************************************************
*									*
*	FXhandler:							*
*									*
*	Anyone using the AnimPlayer will supply FXhandler code.  This	*
*	code is called by the Copper Interrupt handler at 60 or more	*
*	times a second.							*
*									*
*	Input:								*
*									*
*	A0.L	= Address of FX handler.				*
*									*
*	Output:								*
*									*
*	Installs FXhandler.						*
*									*
*	3.Mar.1993 Jamie Lisa Finch.					*
*									*
*************************************************************************
*
	XDEF	FXhandler
FXhandler:
@


2.0
log
@FirstCheckIn
@
text
@@
