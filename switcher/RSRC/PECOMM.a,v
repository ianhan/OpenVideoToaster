head	2.168;
access;
symbols;
locks; strict;
comment	@*@;


2.168
date	97.04.02.16.06.53;	author Holt;	state Exp;
branches;
next	2.167;

2.167
date	97.02.07.00.05.42;	author Holt;	state Exp;
branches;
next	2.166;

2.166
date	96.11.19.11.00.40;	author Holt;	state Exp;
branches;
next	2.165;

2.165
date	96.08.13.16.44.45;	author Holt;	state Exp;
branches;
next	2.164;

2.164
date	96.04.29.10.29.58;	author Holt;	state Exp;
branches;
next	2.163;

2.163
date	96.02.15.11.29.34;	author Holt;	state Exp;
branches;
next	2.162;

2.162
date	96.01.30.12.59.44;	author Holt;	state Exp;
branches;
next	2.161;

2.161
date	96.01.30.12.53.06;	author Holt;	state Exp;
branches;
next	2.160;

2.160
date	96.01.02.17.41.34;	author Holt;	state Exp;
branches;
next	2.159;

2.159
date	95.12.27.15.46.01;	author Holt;	state Exp;
branches;
next	2.158;

2.158
date	95.10.17.15.28.25;	author Flick;	state Exp;
branches;
next	2.157;

2.157
date	95.10.17.12.23.31;	author Flick;	state Exp;
branches;
next	2.156;

2.156
date	95.09.08.18.10.18;	author Flick;	state Exp;
branches;
next	2.155;

2.155
date	95.08.20.00.59.43;	author Flick;	state Exp;
branches;
next	2.154;

2.154
date	95.08.14.12.49.05;	author Flick;	state Exp;
branches;
next	2.153;

2.153
date	95.08.09.12.22.09;	author Holt;	state Exp;
branches;
next	2.152;

2.152
date	95.08.07.15.29.09;	author Flick;	state Exp;
branches;
next	2.151;

2.151
date	95.07.18.13.55.45;	author Flick;	state Exp;
branches;
next	2.150;

2.150
date	95.07.13.15.08.23;	author Flick;	state Exp;
branches;
next	2.149;

2.149
date	95.07.12.12.19.18;	author Flick;	state Exp;
branches;
next	2.148;

2.148
date	95.07.05.15.04.59;	author Flick;	state Exp;
branches;
next	2.147;

2.147
date	95.06.09.16.03.28;	author Holt;	state Exp;
branches;
next	2.146;

2.146
date	95.06.05.12.08.55;	author Flick;	state Exp;
branches;
next	2.145;

2.145
date	95.04.20.11.09.09;	author Flick;	state Exp;
branches;
next	2.144;

2.144
date	95.03.16.12.08.19;	author Holt;	state Exp;
branches;
next	2.143;

2.143
date	95.03.16.11.17.56;	author Holt;	state Exp;
branches;
next	2.142;

2.142
date	95.03.16.09.37.02;	author Flick;	state Exp;
branches;
next	2.141;

2.141
date	95.03.15.18.59.09;	author CACHELIN4000;	state Exp;
branches;
next	2.140;

2.140
date	95.03.15.13.05.12;	author Holt;	state Exp;
branches;
next	2.139;

2.139
date	95.03.14.13.58.39;	author Holt;	state Exp;
branches;
next	2.138;

2.138
date	95.03.07.14.58.50;	author CACHELIN4000;	state Exp;
branches;
next	2.137;

2.137
date	95.03.02.12.35.23;	author pfrench;	state Exp;
branches;
next	2.136;

2.136
date	95.02.26.17.22.51;	author Holt;	state Exp;
branches;
next	2.135;

2.135
date	95.02.24.18.54.44;	author pfrench;	state Exp;
branches;
next	2.134;

2.134
date	95.02.24.18.49.38;	author Holt;	state Exp;
branches;
next	2.133;

2.133
date	95.02.20.17.49.28;	author pfrench;	state Exp;
branches;
next	2.132;

2.132
date	95.02.20.17.27.43;	author pfrench;	state Exp;
branches;
next	2.131;

2.131
date	95.02.18.20.44.42;	author Kell;	state Exp;
branches;
next	2.130;

2.130
date	95.02.17.16.09.54;	author Kell;	state Exp;
branches;
next	2.129;

2.129
date	95.02.16.20.36.26;	author Kell;	state Exp;
branches;
next	2.128;

2.128
date	95.02.13.15.12.21;	author Kell;	state Exp;
branches;
next	2.127;

2.127
date	95.02.12.05.14.27;	author Kell;	state Exp;
branches;
next	2.126;

2.126
date	95.02.11.18.47.37;	author Kell;	state Exp;
branches;
next	2.125;

2.125
date	95.02.11.18.43.57;	author Kell;	state Exp;
branches;
next	2.124;

2.124
date	95.02.10.15.23.11;	author Kell;	state Exp;
branches;
next	2.123;

2.123
date	95.01.31.10.23.50;	author Kell;	state Exp;
branches;
next	2.122;

2.122
date	95.01.25.18.19.23;	author Kell;	state Exp;
branches;
next	2.121;

2.121
date	95.01.25.13.04.17;	author Kell;	state Exp;
branches;
next	2.120;

2.120
date	95.01.24.12.00.05;	author Kell;	state Exp;
branches;
next	2.119;

2.119
date	95.01.23.15.37.43;	author Kell;	state Exp;
branches;
next	2.118;

2.118
date	95.01.04.18.54.10;	author Kell;	state Exp;
branches;
next	2.117;

2.117
date	95.01.04.17.00.41;	author Kell;	state Exp;
branches;
next	2.116;

2.116
date	94.12.31.05.17.31;	author Kell;	state Exp;
branches;
next	2.115;

2.115
date	94.12.31.04.05.42;	author Kell;	state Exp;
branches;
next	2.114;

2.114
date	94.12.30.20.13.00;	author Kell;	state Exp;
branches;
next	2.113;

2.113
date	94.12.30.02.46.08;	author Kell;	state Exp;
branches;
next	2.112;

2.112
date	94.12.29.11.29.26;	author Kell;	state Exp;
branches;
next	2.111;

2.111
date	94.12.29.08.00.40;	author Kell;	state Exp;
branches;
next	2.110;

2.110
date	94.12.28.18.04.10;	author Kell;	state Exp;
branches;
next	2.109;

2.109
date	94.12.23.14.49.26;	author Kell;	state Exp;
branches;
next	2.108;

2.108
date	94.12.23.03.32.53;	author Kell;	state Exp;
branches;
next	2.107;

2.107
date	94.12.17.04.56.29;	author Kell;	state Exp;
branches;
next	2.106;

2.106
date	94.12.09.15.42.01;	author pfrench;	state Exp;
branches;
next	2.105;

2.105
date	94.12.06.23.34.32;	author Kell;	state Exp;
branches;
next	2.104;

2.104
date	94.12.05.19.21.40;	author Kell;	state Exp;
branches;
next	2.103;

2.103
date	94.12.05.19.09.24;	author Kell;	state Exp;
branches;
next	2.102;

2.102
date	94.11.30.22.42.22;	author Kell;	state Exp;
branches;
next	2.101;

2.101
date	94.11.23.16.41.33;	author Kell;	state Exp;
branches;
next	2.100;

2.100
date	94.11.18.08.54.10;	author Kell;	state Exp;
branches;
next	2.99;

2.99
date	94.11.17.15.40.09;	author Kell;	state Exp;
branches;
next	2.98;

2.98
date	94.11.11.10.17.50;	author Kell;	state Exp;
branches;
next	2.97;

2.97
date	94.11.10.02.52.08;	author Kell;	state Exp;
branches;
next	2.96;

2.96
date	94.11.04.08.46.21;	author Kell;	state Exp;
branches;
next	2.95;

2.95
date	94.11.04.03.29.29;	author Kell;	state Exp;
branches;
next	2.94;

2.94
date	94.11.02.19.11.56;	author Kell;	state Exp;
branches;
next	2.93;

2.93
date	94.10.31.17.08.45;	author Kell;	state Exp;
branches;
next	2.92;

2.92
date	94.10.28.14.13.08;	author Kell;	state Exp;
branches;
next	2.91;

2.91
date	94.10.28.12.59.13;	author Kell;	state Exp;
branches;
next	2.90;

2.90
date	94.10.27.14.00.31;	author Kell;	state Exp;
branches;
next	2.89;

2.89
date	94.10.25.13.53.24;	author Kell;	state Exp;
branches;
next	2.88;

2.88
date	94.10.25.07.11.04;	author Kell;	state Exp;
branches;
next	2.87;

2.87
date	94.10.25.07.06.52;	author Kell;	state Exp;
branches;
next	2.86;

2.86
date	94.10.21.23.22.53;	author Kell;	state Exp;
branches;
next	2.85;

2.85
date	94.10.21.17.01.47;	author Kell;	state Exp;
branches;
next	2.84;

2.84
date	94.10.15.01.29.50;	author Kell;	state Exp;
branches;
next	2.83;

2.83
date	94.10.12.00.23.55;	author Kell;	state Exp;
branches;
next	2.82;

2.82
date	94.10.07.23.39.16;	author Kell;	state Exp;
branches;
next	2.81;

2.81
date	94.10.05.05.53.43;	author Kell;	state Exp;
branches;
next	2.80;

2.80
date	94.10.01.12.56.45;	author Kell;	state Exp;
branches;
next	2.79;

2.79
date	94.10.01.01.08.18;	author Kell;	state Exp;
branches;
next	2.78;

2.78
date	94.09.30.21.07.38;	author Kell;	state Exp;
branches;
next	2.77;

2.77
date	94.09.29.15.27.19;	author Kell;	state Exp;
branches;
next	2.76;

2.76
date	94.09.28.22.22.38;	author Kell;	state Exp;
branches;
next	2.75;

2.75
date	94.09.28.22.18.59;	author Kell;	state Exp;
branches;
next	2.74;

2.74
date	94.09.28.22.15.37;	author Kell;	state Exp;
branches;
next	2.73;

2.73
date	94.09.28.19.30.57;	author Kell;	state Exp;
branches;
next	2.72;

2.72
date	94.09.28.18.58.24;	author Kell;	state Exp;
branches;
next	2.71;

2.71
date	94.09.27.09.07.34;	author Kell;	state Exp;
branches;
next	2.70;

2.70
date	94.09.27.08.10.58;	author Kell;	state Exp;
branches;
next	2.69;

2.69
date	94.09.27.04.45.35;	author Kell;	state Exp;
branches;
next	2.68;

2.68
date	94.09.23.08.31.05;	author Kell;	state Exp;
branches;
next	2.67;

2.67
date	94.09.22.05.10.55;	author Kell;	state Exp;
branches;
next	2.66;

2.66
date	94.09.14.02.01.07;	author Kell;	state Exp;
branches;
next	2.65;

2.65
date	94.09.14.01.03.40;	author Kell;	state Exp;
branches;
next	2.64;

2.64
date	94.09.14.00.18.52;	author Kell;	state Exp;
branches;
next	2.63;

2.63
date	94.09.13.19.04.45;	author Kell;	state Exp;
branches;
next	2.62;

2.62
date	94.09.13.05.56.44;	author Kell;	state Exp;
branches;
next	2.61;

2.61
date	94.09.08.19.23.49;	author Kell;	state Exp;
branches;
next	2.60;

2.60
date	94.09.06.21.43.56;	author Kell;	state Exp;
branches;
next	2.59;

2.59
date	94.09.02.08.34.31;	author Kell;	state Exp;
branches;
next	2.58;

2.58
date	94.09.02.03.03.23;	author Kell;	state Exp;
branches;
next	2.57;

2.57
date	94.08.31.22.59.34;	author Kell;	state Exp;
branches;
next	2.56;

2.56
date	94.08.30.19.10.37;	author Kell;	state Exp;
branches;
next	2.55;

2.55
date	94.08.30.10.28.28;	author Kell;	state Exp;
branches;
next	2.54;

2.54
date	94.08.27.06.58.15;	author Kell;	state Exp;
branches;
next	2.53;

2.53
date	94.08.09.03.53.38;	author Kell;	state Exp;
branches;
next	2.52;

2.52
date	94.08.03.19.49.47;	author Kell;	state Exp;
branches;
next	2.51;

2.51
date	94.08.03.06.39.22;	author Kell;	state Exp;
branches;
next	2.50;

2.50
date	94.07.27.19.27.47;	author Kell;	state Exp;
branches;
next	2.49;

2.49
date	94.07.22.20.42.04;	author Kell;	state Exp;
branches;
next	2.48;

2.48
date	94.07.22.19.31.15;	author Kell;	state Exp;
branches;
next	2.47;

2.47
date	94.07.07.02.32.56;	author Kell;	state Exp;
branches;
next	2.46;

2.46
date	94.07.01.12.58.10;	author Kell;	state Exp;
branches;
next	2.45;

2.45
date	94.06.04.03.59.28;	author Kell;	state Exp;
branches;
next	2.44;

2.44
date	94.05.27.17.18.31;	author Kell;	state Exp;
branches;
next	2.43;

2.43
date	94.05.24.22.05.31;	author Kell;	state Exp;
branches;
next	2.42;

2.42
date	94.05.02.17.42.03;	author Kell;	state Exp;
branches;
next	2.41;

2.41
date	94.04.25.14.40.05;	author Kell;	state Exp;
branches;
next	2.40;

2.40
date	94.04.21.17.28.45;	author Kell;	state Exp;
branches;
next	2.39;

2.39
date	94.03.31.13.17.38;	author Kell;	state Exp;
branches;
next	2.38;

2.38
date	94.03.18.17.22.29;	author Kell;	state Exp;
branches;
next	2.37;

2.37
date	94.03.18.09.21.43;	author Kell;	state Exp;
branches;
next	2.36;

2.36
date	94.03.17.09.45.09;	author Kell;	state Exp;
branches;
next	2.35;

2.35
date	94.03.15.23.59.51;	author Kell;	state Exp;
branches;
next	2.34;

2.34
date	94.03.15.23.48.43;	author Kell;	state Exp;
branches;
next	2.33;

2.33
date	94.03.15.19.07.18;	author Kell;	state Exp;
branches;
next	2.32;

2.32
date	94.03.15.16.55.19;	author Kell;	state Exp;
branches;
next	2.31;

2.31
date	94.03.15.16.48.09;	author Kell;	state Exp;
branches;
next	2.30;

2.30
date	94.03.15.16.17.25;	author Kell;	state Exp;
branches;
next	2.29;

2.29
date	94.03.15.14.21.57;	author Kell;	state Exp;
branches;
next	2.28;

2.28
date	94.03.13.08.01.56;	author Kell;	state Exp;
branches;
next	2.27;

2.27
date	94.03.11.15.00.28;	author Kell;	state Exp;
branches;
next	2.26;

2.26
date	94.03.08.07.37.13;	author Kell;	state Exp;
branches;
next	2.25;

2.25
date	94.03.06.16.52.01;	author Kell;	state Exp;
branches;
next	2.24;

2.24
date	94.02.19.09.31.42;	author Kell;	state Exp;
branches;
next	2.23;

2.23
date	94.02.07.15.55.16;	author Kell;	state Exp;
branches;
next	2.22;

2.22
date	94.01.14.13.06.03;	author Kell;	state Exp;
branches;
next	2.21;

2.21
date	94.01.07.17.39.47;	author Kell;	state Exp;
branches;
next	2.20;

2.20
date	94.01.07.17.35.23;	author Turcotte;	state Exp;
branches;
next	2.19;

2.19
date	93.12.28.15.22.53;	author Turcotte;	state Exp;
branches;
next	2.18;

2.18
date	93.12.09.19.26.39;	author Turcotte;	state Exp;
branches;
next	2.17;

2.17
date	93.12.09.02.43.42;	author Turcotte;	state Exp;
branches;
next	2.16;

2.16
date	93.12.07.02.24.31;	author Turcotte;	state Exp;
branches;
next	2.15;

2.15
date	93.12.06.19.27.27;	author Turcotte;	state Exp;
branches;
next	2.14;

2.14
date	93.12.04.00.10.59;	author Turcotte;	state Exp;
branches;
next	2.13;

2.13
date	93.12.04.00.06.04;	author Turcotte;	state Exp;
branches;
next	2.12;

2.12
date	93.12.03.17.10.47;	author Turcotte;	state Exp;
branches;
next	2.11;

2.11
date	93.12.03.16.08.52;	author Turcotte;	state Exp;
branches;
next	2.10;

2.10
date	93.12.01.01.45.22;	author Turcotte;	state Exp;
branches;
next	2.9;

2.9
date	93.11.30.23.04.13;	author Turcotte;	state Exp;
branches;
next	2.8;

2.8
date	93.11.30.18.22.48;	author Turcotte;	state Exp;
branches;
next	2.7;

2.7
date	93.11.30.17.20.00;	author Turcotte;	state Exp;
branches;
next	2.6;

2.6
date	93.11.29.16.22.23;	author Turcotte;	state Exp;
branches;
next	2.5;

2.5
date	93.11.23.16.58.18;	author Turcotte;	state Exp;
branches;
next	2.4;

2.4
date	93.11.19.17.57.01;	author Turcotte;	state Exp;
branches;
next	2.3;

2.3
date	93.11.11.18.24.01;	author Turcotte;	state Exp;
branches;
next	2.2;

2.2
date	93.11.06.04.28.44;	author Kell;	state Exp;
branches;
next	2.1;

2.1
date	93.11.05.19.03.33;	author Turcotte;	state Exp;
branches;
next	2.0;

2.0
date	93.11.05.18.47.57;	author Turcotte;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.168
log
@fixed null named framestore save problem
@
text
@********************************************************************
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
* $Id: pecomm.a,v 2.167 1997/02/07 00:05:42 Holt Exp Holt $
*
* $Log: pecomm.a,v $
*Revision 2.167  1997/02/07  00:05:42  Holt
**** empty log message ***
*
*Revision 2.166  1996/11/19  11:00:40  Holt
**** empty log message ***
*
*Revision 2.165  1996/08/13  16:44:45  Holt
*added support for HQ6 MODE.
*
*Revision 2.164  1996/04/29  10:29:58  Holt
**** empty log message ***
*
*Revision 2.163  1996/02/15  11:29:34  Holt
*added hand_take
*
*Revision 2.162  1996/01/30  12:59:44  Holt
*turned off serdebug
*
*Revision 2.161  1996/01/30  12:53:06  Holt
*fixed vol to not go to 0 durring shuttle.
*
*Revision 2.160  1996/01/02  17:41:34  Holt
*turned off debug
*
*Revision 2.159  1995/12/27  15:46:01  Holt
*tested clock sync
*
*Revision 2.158  1995/10/17  15:28:25  Flick
*Hand_Jump was brain-dead, was setting A/V points based on content LAST TIME,
*then reset A/V content flags for current TAG values!!  Fixes DHD_Jump
*
*Revision 2.157  1995/10/17  12:23:31  Flick
*Hand_ChangeAudio now uses modified StuffCAparams (that supports mono correctly)
*Other clients of this function use the same one, now called StuffCAparams2
*which coerces things to stereo quite annoyingly, but too much depends on this now!
*
*Revision 2.156  1995/09/08  18:10:18  Flick
*Fixed deficiencies in Jog/Shuttle handling to allow scrubbing volume/balance
*
*Revision 2.155  1995/08/20  00:59:43  Flick
*Argh! Sloppy code alert! InitJogShuttle wasn't setting Flyer ReturnTime, so
*we were doing this sync (instead of in parallel with RCB rendering!!!)
*
*Revision 2.154  1995/08/14  12:49:05  Flick
*Disabled debugging
*
*Revision 2.153  1995/08/09  12:22:09  Holt
*turned serdebug flag on.
*
*Revision 2.152  1995/08/07  15:29:09  Flick
*Nothing much, just tested/cleaned up Hand_Jog code a bit
*
*Revision 2.151  1995/07/18  13:55:45  Flick
*PanelOpen,PanelClose now use RT_STOPPED (much safer)
*
*Revision 2.150  1995/07/13  15:08:23  Flick
*Changed hand_tweek to support writing values as USE or SAVE (OOPSKELL)
*
*Revision 2.149  1995/07/12  12:19:18  Flick
*MakeTestClip now sets D2=field# for Flyer_OpenWriteField call
*
*Revision 2.148  1995/07/05  15:04:59  Flick
*Added call to FGC_InterpTagsCommand for duplicating w/ corner symbols
*
*Revision 2.147  1995/06/09  16:03:28  Holt
**** empty log message ***
*
*Revision 2.146  1995/06/05  12:08:55  Flick
*Fixed VID4 bug in ES_SetPrefs
*
*Revision 2.145  1995/04/20  11:09:09  Flick
*Fixed Hand_JOG for clips with > 32K fields, DoMouseXY handles 15 bits only!
*
*Revision 2.144  1995/03/16  12:08:19  Holt
**** empty log message ***
*
*Revision 2.143  1995/03/16  11:17:56  Holt
*fixed 333$ to 666$
*
*Revision 2.142  1995/03/16  09:37:02  Flick
*Cleaned up Hand_RecordAppend
*
*Revision 2.141  1995/03/15  18:59:09  CACHELIN4000
*Add ES_RecordAppend, FLYER_AddFields... just a start
*
*Revision 2.140  1995/03/15  13:05:12  Holt
**** empty log message ***
*
*Revision 2.139  1995/03/14  13:58:39  Holt
**** empty log message ***
*
*Revision 2.138  1995/03/07  14:58:50  CACHELIN4000
*Re-Do HAND_CompressionMode forfast drive mode
*
*Revision 2.137  1995/03/02  12:35:23  pfrench
*Added switcher un-used rawkey handling code
*
*Revision 2.136  1995/02/26  17:22:51  Holt
**** empty log message ***
*
*Revision 2.135  1995/02/24  18:54:44  pfrench
*fixed mangle-o code checking framestore
*
*Revision 2.134  1995/02/24  18:49:38  Holt
*checked in so pat can work on it.
*
*Revision 2.133  1995/02/20  17:49:28  pfrench
*using hardcoded FRAM data type
*
*Revision 2.132  1995/02/20  17:27:43  pfrench
*Now makes sure requested frame save before continuing.
*
*Revision 2.131  1995/02/18  20:44:42  Kell
*New handlers for FoundFile, and Change
*Audio.  New sender for LocateFile.  Made a subroutine for all PutMsgs.
*
*Revision 2.130  1995/02/17  16:09:54  Kell
*Now informs the editor of screen depth (a variable)
*Also, kills keys at end of sequence.
*
*Revision 2.129  1995/02/16  20:36:26  Kell
*Now realtime feedback on palette colors when going between 2/3 monitor modes.  Also, hack panel CancelCGs.
*
*Revision 2.128  1995/02/13  15:12:21  Kell
*Fixed infinite loop bug in GetPrefs
*
*Revision 2.127  1995/02/12  05:14:27  Kell
*Now handles allowing External VID3/4 on the SystemPrefs.
*These will auto-switch to Flyer when required.
*
*Revision 2.126  1995/02/11  18:47:37  Kell
*Now Jogs can handle clips larger than 18 Min.  (no limit)
*
*Revision 2.124  1995/02/10  15:23:11  Kell
*Added AudioControl handler.  Optimized the GetStuctValue calls for GetTable.
*
*Revision 2.123  1995/01/31  10:23:50  Kell
*New  hardcoded data to create a clip to test TBC keying.
*
*Revision 2.122  1995/01/25  18:19:23  Kell
*Now complement sense of AGC flag before sending to TBC
*
*Revision 2.121  1995/01/25  13:04:17  Kell
*TBC hack panel finished.
*
*Revision 2.120  1995/01/24  12:00:05  Kell
*New  handlers for TBCread, TBCwrite, Pause, and Clip Cutting.
*
*Revision 2.119  1995/01/23  15:37:43  Kell
*Hand_Hack changed to have Hack Type has a ES parameter, vs twhk_Type.
*
*Revision 2.118  1995/01/04  18:54:10  Kell
*Re-enabled the code that forces both caf_AUDIOL/R on during jog/shuttle.
*
*Revision 2.117  1995/01/04  17:00:41  Kell
*Don't force both channels on caf_AUDIOL/R if only playing mono.
*
*Revision 2.116  1994/12/31  05:17:31  Kell
*DOHIT debugging
*
*Revision 2.115  1994/12/31  04:05:42  Kell
*Removed Matte color being forced in before sequences.
*
*Revision 2.114  1994/12/30  20:13:00  Kell
*Now forcing all RenderCallBack Frames to Field I.
*
*Revision 2.113  1994/12/30  02:46:08  Kell
*Removed dependency on TB_FlyerVolumes.  Instead using Flyer_VolumeName.
*Removed Hand_FlyerVolume (not needed anymore)
*
*Revision 2.112  1994/12/29  11:29:26  Kell
*New debugs, and now supports QUIT_BIT to signal event loop to Quit switcher.
*
*Revision 2.111  1994/12/29  08:00:40  Kell
*Now don't allow non-Field Is in jogging.  Also, jog max limit upped by 1.
*
*Revision 2.110  1994/12/28  18:04:10  Kell
*Now does a Forbid/permit around sending a message to the Editor.
*Also, once again supports forcing Main to matte black before sequences.
*
*Revision 2.109  1994/12/23  14:49:26  Kell
*New debugs.
*
*Revision 2.108  1994/12/23  03:32:53  Kell
*New debugs.
*
*Revision 2.107  1994/12/17  04:56:29  Kell
*New ES_FlyerVolumes handler.  Now this is received from the Editor, instead of sent to the editor.
*New MakeTestClip code for making an IVectorWithPulse 4 field clip.
*
*Revision 2.106  1994/12/09  15:42:01  pfrench
*Now a little more friendly when waiting for replies
*
*Revision 2.105  1994/12/06  23:34:32  Kell
*Limited Sub-Nyquist to not it's best mode.  Using 3 instead of 2.
*
*Revision 2.104  1994/12/05  19:21:40  Kell
*New values for compression modes.
*
*Revision 2.103  1994/12/05  19:09:24  Kell
*Support for Record compression modes.
*
*Revision 2.102  1994/11/30  22:42:22  Kell
*New SavePrefs handler.
*
*Revision 2.101  1994/11/23  16:41:33  Kell
*New  Hand_NewFieldCount and Hand_UnSavable handlers added.
*
*Revision 2.100  1994/11/18  08:54:10  Kell
*New WaitForReplyMessage() function.
*
*Revision 2.99  1994/11/17  15:40:09  Kell
*Syncclock function added.  Now can occur outside of ES_StartSequence call.
*
*Revision 2.98  1994/11/11  10:17:50  Kell
*Changed parameters on some older Flyer functions. ToasterMux, InputSelect, Start/End Headlist, Play/Record Mode.
*
*Revision 2.97  1994/11/10  02:52:08  Kell
*New InitFlyerPlay function to set input sync, and Play mode.
*
*Revision 2.96  1994/11/04  08:46:21  Kell
*ES_LoadedSlices now used WhatSlicesLoaded() call.
*
*Revision 2.95  1994/11/04  03:29:29  Kell
*Some Debugs for Hand_RecordSource, added LoadedSlices support.
*Now uses new DUMPCA macro.
*
*Revision 2.94  1994/11/02  19:11:56  Kell
*Now forces both CAF_AUDIO flags on if either is used.
*Sets audio volume depending on user setting for Jog/Shuttle.
*
*Revision 2.93  1994/10/31  17:08:45  Kell
*Now reads flyer calibration values before Tweeking.
*
*Revision 2.92  1994/10/28  14:13:08  Kell
*Added Tweek handling for Pedestal.
*
*Revision 2.91  1994/10/28  12:59:13  Kell
*Now redraws display after calling Application Slices.
*
*Revision 2.90  1994/10/27  14:00:31  Kell
*Hacks to turn a still into a 4 field sequence.
*For strobbing BM dma in sync with the GoClock %00 fields
*Checks to see if TB clock and Flyer clock stay in sync.
*
*Revision 2.89  1994/10/25  13:53:24  Kell
*Remarks
*
*Revision 2.88  1994/10/25  07:11:04  Kell
**** empty log message ***
*
*Revision 2.87  1994/10/25  07:06:52  Kell
*Fixed vhposr bug when syncing flyer and switcher clocks.
*
*Revision 2.86  1994/10/21  23:22:53  Kell
*Fixed some InputTerm bugs.
*
*Revision 2.85  1994/10/21  17:01:47  Kell
*New Hand_GetPrefs and Hand_SetPrefs handlers.
*
*Revision 2.84  1994/10/15  01:29:50  Kell
*The Hack flyer adjustment panel now uses the Editors Volume list to get a flyer volume name.
*
*Revision 2.83  1994/10/12  00:23:55  Kell
*Fixed Jogging not showing correct video channel.
*Now supports GRAZERLOAD_BIT on ES_LoadCrouton, so we can have different end points on clips that are played form Grazer, vs drug into project.
*
*Revision 2.82  1994/10/07  23:39:16  Kell
*Now handles audio only clips better.
*Code for ES_hack for calibrating the flyer manually.
*
*Revision 2.81  1994/10/05  05:53:43  Kell
*Better debugs.  ES_Hack added.
*
*Revision 2.80  1994/10/01  12:56:45  Kell
*Added Flyer_DefaultSelect for restoring muxes after record.
*
*Revision 2.79  1994/10/01  01:08:18  Kell
*Increased SHUTTLE mouse distance to 500 (from 300)
*Tied in Clip Icon making.  Though currently does BUSY wait for 3 secs!!
*
*Revision 2.78  1994/09/30  21:07:38  Kell
*Handlers for Making and Appending Icon, plus getting clip info.
*
*Revision 2.77  1994/09/29  15:27:19  Kell
*Handlers for Clip Heads added.  Now Defrag Voids clip heads.
*
*Revision 2.76  1994/09/28  22:22:38  Kell
**** empty log message ***
*
*Revision 2.75  1994/09/28  22:18:59  Kell
**** empty log message ***
*
*Revision 2.74  1994/09/28  22:15:37  Kell
*Now has ES_DefragFlyer handler.
*
*Revision 2.73  1994/09/28  19:30:57  Kell
**** empty log message ***
*
*Revision 2.72  1994/09/28  18:58:24  Kell
*Select on Clips when sequencing now works with our new clock stuff.
*
*Revision 2.71  1994/09/27  09:07:34  Kell
*New Hand_CheckRecord handler
*
*Revision 2.70  1994/09/27  08:10:58  Kell
*First attempt at ES_Record.
*ES_RecodeSource now stashes requested state for ES_Records use.
*
*Revision 2.69  1994/09/27  04:45:35  Kell
*Handlers for FlyerCommpression, RecordSource added.
*Now ES_Stop is used for play/record or sequencing.
*
*Revision 2.68  1994/09/23  08:31:05  Kell
*Shuttle now avoids the FF/REW stage mode.  1x & -1x now larger area.
*
*Revision 2.67  1994/09/22  05:10:55  Kell
*Re-enabled calls to Flyer for Record/Play mode & GetFieldClock.
*
*Revision 2.66  1994/09/14  02:01:07  Kell
*Fixed ES_ commands for loading Slices.  Was using FGC_LOAD, needed FGC_SELECTK.
*
*Revision 2.65  1994/09/14  01:03:40  Kell
*SelectK is now sent, even if slice hasn't yet been loaded.
*
*Revision 2.64  1994/09/14  00:18:52  Kell
*New handlers for Slice commands (LW,TP,CG,CFX)
*Now audio is attenuated during Shuttles.
*
*Revision 2.63  1994/09/13  19:04:45  Kell
*Hack to improve Jog/Shuttle.  NOTE: Audio not currently working here.
*
*Revision 2.62  1994/09/13  05:56:44  Kell
*First working Jog, Shuttle & Jump (since old NAB code)
*
*Revision 2.61  1994/09/08  19:23:49  Kell
*Ne PutTable, GetTable, TagSize handlers.
*PutValue now can add a NEW tag item to a FG list.
*
*Revision 2.60  1994/09/06  21:43:56  Kell
*Moved ES message table to top of file.  Added a Shuttle Table.
*
*Revision 2.59  1994/09/02  08:34:31  Kell
*Now Prvwing Clip errors are sent to the DelayError system.
*Aborting Clips via Stop button now works.
*Jog now puts pointer back where it should be.
*
*Revision 2.58  1994/09/02  03:03:23  Kell
*Fixed some Jog bugs that confused Y movements with X.
*
*Revision 2.57  1994/08/31  22:59:34  Kell
*Attempt at a new Jog routine.
*
*Revision 2.55  1994/08/30  10:28:28  Kell
*Changed some of the handler names.
*
*Revision 2.54  1994/08/27  06:58:15  Kell
*Commented out some obsolete tag items in Jog. Jog is now really broke!
*
*Revision 2.53  1994/08/09  03:53:38  Kell
*Changed return codes on ES_LoadCrouton.  Now ->FG or NULL only.
*
*Revision 2.52  1994/08/03  19:49:47  Kell
**** empty log message ***
*
*Revision 2.51  1994/08/03  06:39:22  Kell
*Now project entries remember their original location (e.g. CDROM)
*
*Revision 2.50  1994/07/27  19:27:47  Kell
**** empty log message ***
*
*Revision 2.49  1994/07/22  20:42:04  Kell
*Now using AmigaDOS's LoadSeg
*
*Revision 2.48  94/07/22  19:31:15  Kell
**** empty log message ***
*
*Revision 2.47  94/07/07  02:32:56  Kell
*Fixed errors in Load/Save/New Project commands, and ES_Startup command documentation.
*Added ES_ClearProject command.
*
*Revision 2.46  94/07/01  12:58:10  Kell
*Disabled Flyer function calls.  It's now broken!!!!
*
*Revision 2.45  94/06/04  03:59:28  Kell
*Cleaned up the Flag mess associated with who (Editor/Switcher) controls which part of the screen, and which mode we are in.
*Removed some old obsolete handlers.
*Added a NoRender function to send to the Editor (for going in/out of Setup slice).
*The SendProjectEditMessage now checks for Editor first.  Returns result.
*Fixed multiple renderings of switcher when going into Switcher mode.
*
*Revision 2.44  94/05/27  17:18:31  Kell
**** empty log message ***
*
*Revision 2.43  94/05/24  22:05:31  Kell
*ES_AUTO now does a FGC_TOMAIN command.  The AUTO handler code was way
*simplified (and now called Hand_ToMain.
*ES_SELECT command now returns BOOL.
*Many FGC_....Command calls renamed to this new naming convention.
*
*Revision 2.42  94/05/02  17:42:03  Kell
*Added SelectDefault handling.
*
*Revision 2.41  94/04/25  14:40:05  Kell
*Removed BW jog.
*Now looks at GUImode flags to see if switcher is up and honors that
*special Select.
*
*Revision 2.40  94/04/21  17:28:45  Kell
*Added ES_GUImode handling.
*
*Revision 2.39  94/03/31  13:17:38  Kell
*All sorts of new additions for NAB 94.
*
*Revision 2.38  94/03/18  17:22:29  Kell
**** empty log message ***
*
*Revision 2.37  94/03/18  09:21:43  Kell
*Sequencing now disables rendering to switcher.  Syncs DHD to SW clock.
*
*Revision 2.36  94/03/17  09:45:09  Kell
*Now disables grid rendering when redrawing switcher.
*
*Revision 2.35  94/03/15  23:59:51  Kell
**** empty log message ***
*
*Revision 2.34  94/03/15  23:48:43  Kell
*Added code for ES_FGcommand handling.
*
*Revision 2.33  94/03/15  19:07:18  Kell
*Added ES_PutValue and ES_GetValue handlers
*
*Revision 2.32  94/03/15  16:55:19  Kell
**** empty log message ***
*
*Revision 2.31  94/03/15  16:48:09  Kell
**** empty log message ***
*
*Revision 2.30  94/03/15  16:17:25  Kell
**** empty log message ***
*
*Revision 2.29  94/03/15  14:21:57  Kell
*Killed internalcrouton loading stuff.
*Finished Read/Write/New Project.  Finished crouton duplicate.
*
*Revision 2.28  94/03/13  08:01:56  Kell
*No F8 only loads the Grazer if not alread loaded. Added ES_QUIT routine.
*
*Revision 2.27  94/03/11  15:00:28  Kell
**** empty log message ***
*
*Revision 2.26  94/03/08  07:37:13  Kell
**** empty log message ***
*
*Revision 2.25  94/03/06  16:52:01  Kell
**** empty log message ***
*
*Revision 2.24  94/02/19  09:31:42  Kell
**** empty log message ***
*
*Revision 2.23  94/02/07  15:55:16  Kell
*Various changes to support the new 4.0 croutons & projects.
*
*Revision 2.22  94/01/14  13:06:03  Kell
**** empty log message ***
*
*Revision 2.21  94/01/07  17:39:47  Kell
**** empty log message ***
*
*Revision 2.20  94/01/07  17:35:23  Turcotte
**** empty log message ***
*
*Revision 2.19  93/12/28  15:22:53  Turcotte
**** empty log message ***
*
*Revision 2.18  93/12/09  19:26:39  Turcotte
**** empty log message ***
*
*Revision 2.17  93/12/09  02:43:42  Turcotte
**** empty log message ***
*
*Revision 2.16  93/12/07  02:24:31  Turcotte
**** empty log message ***
*
*Revision 2.15  93/12/06  19:27:27  Turcotte
**** empty log message ***
*
*Revision 2.14  93/12/04  00:10:59  Turcotte
**** empty log message ***
*
*Revision 2.13  93/12/04  00:06:04  Turcotte
**** empty log message ***
*
*Revision 2.12  93/12/03  17:10:47  Turcotte
*Added Select
*
*Revision 2.11  93/12/03  16:08:52  Turcotte
**** empty log message ***
*
*Revision 2.10  93/12/01  01:45:22  Turcotte
*Added project commands.
*
*Revision 2.9  93/11/30  23:04:13  Turcotte
*Added Duplicate
*
*Revision 2.8  93/11/30  18:22:48  Turcotte
**** empty log message ***
*
*Revision 2.7  93/11/30  17:20:00  Turcotte
**** empty log message ***
*
*Revision 2.6  93/11/29  16:22:23  Turcotte
*Added messages for loading and unloading croutons
*
*Revision 2.5  93/11/23  16:58:18  Turcotte
**** empty log message ***
*
*Revision 2.4  93/11/19  17:57:01  Turcotte
**** empty log message ***
*
*Revision 2.3  93/11/11  18:24:01  Turcotte
**** empty log message ***
*
*Revision 2.2  93/11/06  04:28:44  Kell
**** empty log message ***
*
*Revision 2.1  93/11/05  19:03:33  Turcotte
**** empty log message ***
*
*Revision 2.0  93/11/05  18:47:57  Turcotte
*FirstCheckIn
*
*********************************************************************

	include	"assembler.i"

	include "exec/types.i"
	include "exec/lists.i"
	include "exec/nodes.i"
	include "exec/ports.i"
	include	"libraries/dos.i"
	INCLUDE	'workbench/startup.i'
	include	"hardware/custom.i"
	include 'hardware/intbits.i'

	include	"instinct.i"
	include	"EditSwit.i"
	include "custom.i"

	include	"lib/exec_lib.i"
	include	"lib/dos_lib.i"

	include	"macros.i"s
	include "tags.i"
	include "flyer.i"

	include "vtdebug.i"
	include	"serialdebug.i"

;;SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
;DBTBC	set	1 ;debug TBC writing THIS IS ON the Ralt+Rshift+F1 HOTKEY

	ALLDUMPS

;;DBHD	set	1	;Debug HandlePEMessage
;;DBSPM	set	1	;Debug SendProject...Message stuff

;;DBHPEM	set	1	;Debug HandlePEMessageMessage
;;DBJOG	set	1	;Debug Handle_Jog
DBCLOCK	set	1	;Debug clock syncronization
;;DBCA	set	1	;debug ClipAction Structure

;;DBMTC	set	1	;debug MakeTestClip


;;SETDOHIT SET	$100	;do enforcer hits starting at $100

******************************************************************
;;TESTFIELD0 set	1	;Determine where Field 0 (I) is. Hack test.

;;FORCE2MATTE	SET	1	;Set if you want sequence to go to matte Black before they start


******************************************************************
PEMessageTab
	dc.l	Hand_DUMMY		;()
	dc.l	Hand_STARTUP		;() PUT/GETMESSAGE
	dc.l	Hand_RENDER_EDIT	;(WINDOWOPENFLAG, ScreenDepth) PUTMESSAGE  Should never get this message
	dc.l	Hand_RENDER_SWIT	;(Mode)

	dc.l	Hand_ClearProject	;(List#)
	dc.l	Hand_PanelOpen		;(FG)

	dc.l	Hand_GETPLIST		;()
	dc.l	Hand_FreeCrouton	;(FG)
	dc.l	Hand_LoadCrouton	;(name,grazerflag)
	dc.l	Hand_DuplicateCrouton	;(FG)

	dc.l	Hand_LoadProject	;(List#,name)
	dc.l	Hand_SaveProject	;(List#,name)
	dc.l	Hand_NewProject		;(List#,name)
	dc.l	Hand_Select		;(FG)
	dc.l	Hand_Auto		;(FG)
	dc.l	Hand_StartSeq		;()
	dc.l	Hand_Stop		;() used to stop playing/Recording clips & sequencing
	dc.l	Hand_QUIT		;() PUT/GETMESSAGE

	dc.l	Hand_GetValue		;(FG,TagID)
	dc.l	Hand_PutValue		;(FG,TagID,Value)
	dc.l	Hand_FGcommand		;(FG,FGCcommand)
	dc.l	Hand_PanelClose		;(FG)

	dc.l	Hand_Record		;(->name, fields, ->StartFunct, ->StopFunct, Flags)
	dc.l	Hand_Pause		;(PauseFlag)
	dc.l	Hand_Jog		;(RenderCallBack)
	dc.l	Hand_Shuttle		;(RenderCallBack)

	dc.l	Hand_InitRecord		;()
	dc.l	Hand_InitPlay		;()

	IFD	FORCE2MATTE
	dc.l	Hand_Main2Blank		;()
	ENDC
	IFND	FORCE2MATTE
	dc.l	Hand_DUMMY
	ENDC

	dc.l	Hand_GUImode		;(mode)
	dc.l	Hand_SelectDefault	;()
	dc.l	Hand_Jump		;(FG,Field)
	dc.l	Hand_ApplyTags		;(FGsource,FGdestination)

	dc.l	Hand_TagSize		;(FG, TagID)
	dc.l	Hand_GetTable		;(FG, ->Table, TableSize, TagID)
	dc.l	Hand_PutTable		;(FG, ->Table, TableSize, TagID)

	dc.l	Hand_LightWave		; (FGC_Command)
	dc.l	Hand_ToasterPaint 	; (FGC_Command)
	dc.l	Hand_ToasterCG		; (FGC_Command)
	dc.l	Hand_ChromaFX		; (FGC_Command)

	dc.l	Hand_FlyerDriveInfo 	; ->FlyerVolInfo=(->volumename, ->FlyerVolInfo)  supplied ->FlyerVolInfo maybe NULL
	dc.l	Hand_RecordSource	; (VideoSource)
	dc.l	Hand_CompressionMode 	; (mode)
	dc.l	Hand_CheckRecord 	; (), returns FERR_..., 0 if recording finished OK

	dc.l	Hand_DefragFlyer	; (->volumename)
	dc.l	Hand_StartHeadList	; ()
	dc.l	Hand_MakeClipHead 	; (->name,VidStart,VidFields,AudStart,AudFields)
	dc.l	Hand_EndHeadList  	; ()

	dc.l	Hand_MakeClipIcon	; (->name,->crud,crudsize,field)
	dc.l	Hand_FlyerClipInfo	; (->clipname, ->ClipInfo or NULL)
	dc.l	Hand_AppendIcon	 	; (->name)
	dc.l	Hand_Hack		; ('Name',->HackStructure)

	dc.l	Hand_DUMMY		; not used yet
	dc.l	Hand_GetPrefs		; (->SystemPrefs Structure) fill in current values
	dc.l	Hand_SetPrefs		; (->SystemPrefs)
	dc.l	Hand_LoadedSlices	; () returns Slice Mask
	dc.l	Hand_UnSavable		;(FG, TagID)	;marks Tag item so it doesn't get saved in the project
	dc.l	Hand_NewFieldCount	;(FG)	;This needs to be called if an FXs speed or duration has changed.
	dc.l	Hand_SavePrefs	 	;() saves an HS file. Returns ERROR. Though we usually ignore errors!

	dc.l	Hand_StartClipCutList  	;(->filename, DestructFlag)
	dc.l	Hand_AddClipCut  	;(->filename, StartField, NumFields, VidAudFlags)
	dc.l	Hand_EndClipCutList	;(DoItFlag)
	dc.l	Hand_AudioControl	;(->FlyAudCtrl, operationFlags)
	dc.l	Hand_ChangeAudio	;(->FG)  Use this to modify the currently playing clip
	dc.l	Hand_DUMMY	    	;(Type,->Name,flags,->textarray,mode) ONLY SEND TO EDITOR
	dc.l	Hand_FoundFile        	;(Type,->name,flags,->textarray,mode)
	dc.l	Hand_DUMMY	    	;(Code,Qualifier) ONLY SEND TO EDITOR
	dc.l	Hand_RecordAppend	;(->name, fields)
	dc.l	Hand_Take		;(fg)
	dc.l	Hand_MoveSoftSprite ;(X, Y)


;; New Handlers go here

PEMessageTabE

****** HandlePEMessage ******************************************************
*
*   NAME
*	HandlePEMessage -- This function handles all messages for the Project
*	                   editor.
*
*   SYNOPSIS
*	HandlePEMessage(Message)
*	                  d0
*
*   FUNCTION
*	Each ES_Type handler will be called with a pointer to the message
*	in d0.
*
*   INPUTS
*
*   RESULT
*	ES_Reply  - has been set
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************

*a5->TB
	xdef	HandlePEMessage
HandlePEMessage:
	movem.l	d0-d7/a0-a6,-(sp)

	move.l	d0,a0

*-------------------
	IFD	DBHPEM
	tst.l	d0
	bne	10$
	DEBUGMSG	DBHPEM,<HandlePEMessage: Message Pointer is NULL !!!!!!!!!!!!!!!!>
	bra	.exit
10$ 	DEBUGMEM	DBHPEM,<HandlePEMessage: Message=>,ES_Cookie(a0),#ES_SIZEOF-ES_Cookie
	ENDC
*-------------------

	move.w	ES_Type(a0),d1
	cmp.w	#(PEMessageTabE-PEMessageTab)/4,d1
	ble.s	.okcommand

	DOHIT

	moveq.l	#ES_ERR_GENERIC,d0
	move.l	d0,ES_Reply(a0)
	bra.s	.exit
.okcommand

	add.w	d1,d1
	add.w	d1,d1
	lea	PEMessageTab,a0
	move.l	0(a0,d1.w),a0

	DOHIT

	jsr	(a0)			;DON'T NEED TO SAVE REGISTERS!
.exit
	movem.l	(sp)+,d0-d7/a0-a6
	rts





******* BringUpProjectEditor ************************************************
*
*   NAME
*	BringUpProjectEditor -- Load Project editor and get it started
*   SYNOPSIS
*	BringUpProjectEditor()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
	xdef	BringUpProjectEditor
BringUpProjectEditor:
	CALLTL	DisplayWaitSprite

	XLEA	NoGrazerFlag,a0
	tst.b	(a0)
	bne.s	10$

	lea	EditWindowName,a0
	bsr	LoadProgram

	move.l	d0,TB_EditSegList(a5)	;save Edit seg list. (when message
					;comes back you will want to free it.
	bne.s	155$

* couldn't load or didn't want editor
10$
;;	XLEA	GridSelFGs,a0
;;	move.l	a0,TB_GridSelFGL(a5)

	CALLTL	ReDoDisplay
	bra	156$

155$
	bsr	SendProjectEditStartMessage	;supplies -> project FGs, TB_Screen, TB_Window
	bsr	SendProjectEditRenderMessage	;open windows & render

156$	CALLTL	DisplayNormalSprite
	rts

******* Switcher/LoadProgram *************************************************
*
*   NAME
*	LoadProgram -- Load a code segment and create process.
*
*   SYNOPSIS
*	LoadProgram(*FileName)
*	               a0
*   FUNCTION
*	This function is used be load the project editor, and create the
*	project editor process.
*
*   INPUTS
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
EDIT_STACK_SIZE	EQU	10000		;This is the size of the stack given
					;to the project editor.
LoadProgram:
	clr.l	d0
	movem.l	d0-d5/a0-a1/a6,-(sp)


	move.l	a0,d3			;file name

	move.l	TB_DOSBase(a5),a6		;start from boot dirrectory
	move.l	TB_BootLock(a5),d1
	CALLROM	CurrentDir
	move.l	d0,d5

	move.l	d3,a0			;filename
	move.l	a0,d1

	CALLROM	LoadSeg
****** Use this if you want our LoadSeg
;;	move.l	#20000,d0		;buffersize
;;	CALLTL	NLoadSegment

	move.l	d0,(sp)			;return pointer to code segment.
	beq	.exit

	move.l	d3,d1	; name
	moveq.l	#0,d2	; pri
	move.l	d0,d3
	move.l	#EDIT_STACK_SIZE,d4
	XSYS	CreateProc
	move.l	d0,d2
	bne.s	.gotprocess

	move.l	d3,d1
	clr.l	(sp)			;clear return code
	CALLTL	UnLoadSegment
	bra	.exit
.gotprocess

	lea	FakeStartup,a1

	move.b	#NT_MESSAGE,sm_Message+LN_TYPE(a1)
	move.l	TB_ARexxPort(a5),sm_Message+MN_REPLYPORT(a1)
	move.w	#sm_SIZEOF,sm_Message+MN_LENGTH(a1)

	move.l	d2,sm_Process(a1)
	move.l	d3,sm_Segment(a1)
	moveq	#1,d0
	move.l	d0,sm_NumArgs(a1)
	moveq.l	#0,d0
	move.l	d0,sm_ToolWindow(a1)
	lea	NullWBArgList,a0
	move.l	TB_BootLock(a5),wa_Lock(a0)
	move.l	a0,sm_ArgList(a1)

	move.l	d2,a0
	move.l	TB_SYSBase(a5),a6
	XSYS	PutMsg


	moveq.l	#10-1,d2
.WaitLoop
	moveq.l	#50,d1	; one second
	move.l	TB_DOSBase(a5),a6
	XSYS	Delay

* look for port
	move.l	TB_SYSBase(a5),a6
	lea	EditPortName,a1
	XSYS	FindPort
	tst.l	d0
	dbne	d2,.WaitLoop

***!!!*** WHAT IF THIS TIMED OUT BECAUSE THE EDITOR CAN'T OPEN A PORT ???

.exit
	move.l	TB_DOSBase(a5),a6
	move.l	d5,d1			;return to old directory
	CALLROM	CurrentDir
.quit
	movem.l	(sp)+,d0-d5/a0-a1/a6
	rts


****************************************************************************
* Must have ES_Type, all Data and ES_Reply fields filled out in the
* our OnlyMessage.
*
* SendMessage2Editor()
*
SendMessage2Editor:
	movem.l	d0-d1/a0-a2/a6,-(sp)
	DEBUGMSG	DBSPM,<SendMessage2Editor:>

	clr.l	(sp)			;assume no Editor present

	XLEA	NoGrazerFlag,a0
	tst.b	(a0)
	bne	.exit			;jump if Editor not open

	lea	OnlyMessage,a2

	move.b	#NT_MESSAGE,LN_TYPE(a2)
	move.l	TB_ARexxPort(a5),MN_REPLYPORT(a2)
	move.w	#ES_SIZEOF,MN_LENGTH(a2)
	move.w	#EditCookie,ES_Cookie(a2)

* Why is this clr commented out ??????
;;	clr.l	ES_Reply(a2)			;if editor is present it will
						;replace this with a valid
						;non return code.
	move.l	TB_SYSBase(a5),a6
	CALLROM	Forbid

	lea	EditPortName,a1
;;	move.l	TB_SYSBase(a5),a6
	CALLROM	FindPort
	tst.l	d0
	beq	.exit2			;NULL = Editor port not present

.gotport
	move.l	d0,a0			;port
	move.l	a2,a1			;message
;;	move.l	TB_SYSBase(a5),a6

	DEBUGMSG	DBSPM,<before PutMsg>

	CALLROM	PutMsg

	DEBUGMSG	DBSPM,<after PutMsg>

	CALLROM	Permit

	move.l	TB_ARexxPort(a5),a0
	lea	OnlyMessage,a1

	DEBUGMSG	DBSPM,<before WaitForReplyMessage>

	bsr	WaitForReplyMessage	;Will throw away this message reply
					;so ARexx handler will never see it!

	DEBUGMSG	DBSPM,<after WaitForReplyMessage>

	move.l	a2,(sp)	 ;nonzero returncode = success, ->message
	bra.s	.exit
.exit2
	CALLROM	Permit
.exit	movem.l	(sp)+,d0-d1/a0-a2/a6
	tst.l	d0
	rts

****** WaitForReplyMessage **************************************************
*
*   NAME
*	WaitForReplyMessage -- waits for a reply message to come back to a port
*
*   SYNOPSIS
*	Message = WaitForReplyMessage(Port, message)
*	  d0                           a0     a1
*
*   FUNCTION
*	This function will wait for a reply message to appear at a port.
*	It will return with a pointer to the message (no longer on the port)
*	Any other messages are still left on the port.
*
*   INPUTS
*	Port  - message port to wait on
*	Message - the message to wait for
*
*   RESULT
*	message - message that came back
*
*   BUGS
*
*****************************************************************************
	XDEF	WaitForReplyMessage
WaitForReplyMessage:
	movem.l	d0-d1/a0-a3/a6,-(sp)

	movea.l	(4).w,a6		;exec base
	movea.l	a0,a2
	movea.l a1,a3

.dosearch
	CALLROM	Forbid

	lea	MP_MSGLIST+LH_HEAD(a2),a0
.loop	move.l	(a0),a0
	tst.l	(a0)
	beq	.notfound

	cmp.b	#NT_REPLYMSG,LN_TYPE(a0)
	bne	.loop

	cmpa.l	a3,a0
	bne	.loop

	move.l	a0,(sp)			;return code
	move.l	a0,a1

	DEBUGMSG	DBSPM,<REMOVEing the particular Reply>
	REMOVE
	bra	.exit
.notfound

	moveq.l	#0,d0			;wait for a new message to come
	moveq.l	#0,d1			;to this port
	move.b	MP_SIGBIT(a2),d1
	bset	d1,d0

	CALLROM	Permit

	IFD	DBSPM
	DUMPTXT	<Z>
	ENDC

	CALLROM	Wait			;wait for a new message to be sent
					;Can have other messages piled up.
	IFD	DBSPM
	DUMPTXT	<!>
	ENDC

	bra	.dosearch

.exit
	CALLROM	Permit
	movem.l	(sp)+,d0-d1/a0-a3/a6
	rts


****** SendProjectEditMessage ***********************************************
*
*   NAME
*	SendProjectEditMessage -- This sends the project editor a message
*
*   SYNOPSIS
*	Result = SendProjectEditMessage(ES_Type,Data1,Data2,Data3,Reply)
*	                                  d0    d1    d2      d3   d4
*
*   FUNCTION
*	This function sends the message defined in EditSwit.i to the project
*	Editor. THIS IS A FRONT END TO MOST OF THE MESSAGE SENDING CALLS.
*
*   INPUTS
*	ES_Type -  see EditSwit.i
*	Data1   -  see EditSwit.i
*	Data2   -  see EditSwit.i
*	Data3   -  see EditSwit.i
*
*	a5->TB
*
*   RESULT
*	Result -  d0 is NULL if project editor port not found.
*		  You may use condition flags as a test.
*
*		  Else, d0->pointer to message used.
*		  You should check ES_Reply to see what has happened.
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditMessage
SendProjectEditMessage:
	move.l	a0,-(sp)

	lea	OnlyMessage,a0
	move.w	d0,ES_Type(a0)
	movem.l	d1-d3,ES_Data1(a0)
	move.l	d4,ES_Reply(a0)

	bsr	SendMessage2Editor

	movea.l	(sp)+,a0
	rts


*****************************************************************************
* ALL PUTMESSAGES ***********************************************************
*****************************************************************************

****** SendProjectEditRenderMessage *****************************************
*
*   NAME
*	SendProjectEditRenderMessage -- Send a render message to Project
*	                                editor
*
*   SYNOPSIS
*	message = SendProjectEditRenderMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditRenderMessage
SendProjectEditRenderMessage:
	DEBUGMSG	DBSPM,<SendProjectEditRenderMessage:>

	movem.l	d1-d3/a0,-(sp)

	move.l	#ES_RENDER_EDIT,d0
	moveq.l	#TRUE,d1			;open editor windows & render
	moveq.l	#0,d2
	GET.w	TB_InterfaceDepth,d2
	moveq.l	#0,d3
	bsr	SendProjectEditMessage
	beq.s	10$				;jump if Editor isn't loaded
	bset.b	#7,TB_DisplayRenderMode(a5)	;Editor will control top half

10$	movem.l	(sp)+,d1-d3/a0
	rts

****** SendProjectEditNoRenderMessage *****************************************
*
*   NAME
*	SendProjectEditNoRenderMessage -- Send a render message to Project
*	                                editor
*
*   SYNOPSIS
*	message = SendProjectEditNoRenderMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditNoRenderMessage
SendProjectEditNoRenderMessage:
	DEBUGMSG	DBSPM,<SendProjectEditNoRenderMessage:>

	movem.l	d1-d3,-(sp)

	bclr.b	#7,TB_DisplayRenderMode(a5)	;switcher will control top half

	move.l	#ES_RENDER_EDIT,d0
	moveq.l	#FALSE,d1			;close editor windows
	moveq.l	#0,d2
	moveq.l	#0,d3
	bsr	SendProjectEditMessage

	movem.l	(sp)+,d1-d3
	rts

****** SendProjectEditQuitMessage *****************************************
*
*   NAME
*	SendProjectEditQuitMessage -- Send a render message to Project
*	                                editor
*
*   SYNOPSIS
*	message = SendProjectEditQuitMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditQuitMessage
SendProjectEditQuitMessage:
	DEBUGMSG	DBSPM,<SendProjectEditQuitMessage:>
	movem.l	d1-d3,-(sp)

	move.l	#ES_QUIT,d0
	moveq.l	#0,d1			;open windows
	moveq.l	#0,d2
	moveq.l	#0,d3
	bsr	SendProjectEditMessage

	bset.b	#QUIT_BIT,TB_Flags4(a5)

10$	movem.l	(sp)+,d1-d3
	rts

****** SendProjectEditStartMessage: *****************************************
*
*   NAME
*	SendProjectEditStartMessage -- Send a start message to Project editor
*
*   SYNOPSIS
*	Result = SendProjectEditStartMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*
*	Data1    - screen
*	Data2    - Internal croutons
*	Data3    - Window
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditStartMessage
SendProjectEditStartMessage:
	DEBUGMSG	DBSPM,<SendProjectEditStartMessage:>

	movem.l	d1-d4/a0,-(sp)

	move.l	#ES_STARTUP,d0
	move.l	TB_Screen(a5),d1

;;	lea	InteralCroutons,a0
;;	move.l	a0,d2
	moveq	#0,d2

	move.l	TB_Window(a5),d3
	move.l	TB_ToolBoxGrids(a5),d4	;we put project in Reply

	bsr	SendProjectEditMessage

	movem.l	(sp)+,d1-d4/a0
	rts

****** SendLocateFileMessage ***********************************************
*
*   NAME
*	SendLocateFileMessage -- This sends the project editor a message
*
*   SYNOPSIS
*	Result = SendProjectEditMessage(Type,->name,flags,->textarray,mode)
*
*   FUNCTION
*	This function sends the message defined in EditSwit.i to the project
*	Editor.
*
*   INPUTS
* 	See abovef
*	a5->TB
*
*   RESULT
*	Result -  d0 is NULL if project editor port not found.
*		  You may use condition flags as a test.
*
*		  Else, d0->pointer to message used.
*		  You should check ES_Reply to see what has happened.
*
*   BUGS
*
*****************************************************************************
	XDEF	SendLocateFileMessage
SendLocateFileMessage:
	DEBUGMSG	DBSPM,<SendLocateFileMessage:>

	move.l	a0,-(sp)

	lea	OnlyMessage,a0

	move.w	#ES_LocateFile,ES_Type(a0)
	movem.l	d0-d4,ES_Data1(a0)
	clr.l	ES_Reply(a0)			;if editor is present it will
						;replace this with a valid
						;non return code.
	bsr	SendMessage2Editor
	movea.l	(sp)+,a0
	rts


*****************************************************************************
* ALL GETMESSAGES ***********************************************************
*****************************************************************************

Hand_ApplyTags

* FALL THRU TO DUMMY

****** Hand_DUMMY ***********************************************************
*
*   NAME
*	Hand_DUMMY -- This does nothing
*
*   SYNOPSIS
*	Hand_DUMMY(message)
*	              d0
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*	ES_Reply  - has been set
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_DUMMY
	DEBUGMSG	DBHD,<Hand_DUMMY:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)
	rts


******* Hand_MoveSoftSprite ************************************************
*
*   NAME
*	Hand_MoveSoftSprite -- moves the Softsprite(mousepointer) to an absolute 
*						position on the screen.			
*   SYNOPSIS
*	Hand_MoveSoftSprite(X, Y)
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
*****************************************************************************
Hand_MoveSoftSprite:
	 XLABEL		_MoveSoftSpriteABS
	movem.l	a0-a6/d0-d7,-(sp)
	move.l	d0,a1
	move.l	ES_Data1(a1),d0
	move.l	ES_Data2(a1),d1
	CALLTL	MoveSoftSpriteABS
	movem.l	(sp)+,a0-a6/d0-d7
	rts



****** Hand_Hack ***********************************************************
*
*   NAME
*	Hand_Hack -- This does nothing
*
*   SYNOPSIS
*	Hand_Hack(message)
*	              d0
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*	ES_Reply  - has been set
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************

AudioByte	set	$a2	;audio symbol character

Hand_Hack
	DEBUGMSG	DBHD,<Hand_Hack:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)	;assume no error

	move.l	TB_FlyerBase(a5),d0
	beq	666$

	movea.l	ES_Data2(a0),a1	;->Hack Structure
	move.l	ES_Data1(a0),d0

	cmpi.l	#HACK_TBCopen,d0
	beq	Hand_TBCopen

	cmpi.l	#HACK_TBCread,d0
	beq	Hand_TBCread

	cmpi.l	#HACK_TBCwrite,d0
	beq	Hand_TBCwrite

	cmpi.l	#HACK_TBCclose,d0
	beq	Hand_TBCclose

	cmpi.l	#HACK_TWEAK,d0
	beq	Hand_Tweek

666$	rts

*--------------------------------------
Hand_Tweek:
	DEBUGMSG	DBHD,<Hand_Tweek:>

	move.l	twhk_Flags(a1),d5

	btst	#HKB_READCALIB,d5
	beq.s	30$
	btst	#HKB_PLAY_A,d5
	bne	.gettwk_play_A
	btst	#HKB_PLAY_B,d5
	bne	.gettwk_play_B
	btst	#HKB_RECORD_A,d5
	bne	.gettwk_rec_A
	btst	#HKB_RECORD_B,d5
	bne	.gettwk_rec_B
	bra	666$

30$
	moveq	#0,d3			;(dflt = no save)
	btst	#HKB_SAVE,d5		;Save to NOVRAM?
	beq.s	.nosave
	moveq	#1,d3			;SAVE!
.nosave
	btst	#HKB_PLAY_A,d5
	bne	.puttwk_play_A
	btst	#HKB_PLAY_B,d5
	bne	.puttwk_play_B
	btst	#HKB_RECORD_A,d5
	bne	.puttwk_rec_A
	btst	#HKB_RECORD_B,d5
	bne	.puttwk_rec_B
	bra	666$

* Play A
.puttwk_play_A
	bsr	.ensure_play_mode

	moveq	#0,d0			;board
	move.l	#CALIB_HPLAYOFFSETA,D1	;item, assume play A
	move.l	twhk_Position(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_DACA_PHASE_EDGE,D1	;item
	move.l	twhk_Clock(a1),d2		;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_DACA_PHASE_COURSE,D1	;item
	move.l	twhk_Coarse(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_DACA_PHASE_FINE,D1	;item
	move.l	twhk_Fine(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_PEDESTALA,D1	;item

;;	move.l	twhk_Pedestal(a1),d2	;value
	move.l	#60,d2			;always D2 sync level

;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	bra	666$

* Play B
.puttwk_play_B
	bsr	.ensure_play_mode

	moveq	#0,d0			;board
	move.l	#CALIB_HPLAYOFFSETB,D1	;item, assume play A
	move.l	twhk_Position(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_DACB_PHASE_EDGE,D1	;item
	move.l	twhk_Clock(a1),d2		;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_DACB_PHASE_COURSE,D1	;item
	move.l	twhk_Coarse(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_DACB_PHASE_FINE,D1	;item
	move.l	twhk_Fine(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_PEDESTALB,D1	;item

;;	move.l	twhk_Pedestal(a1),d2	;value
	move.l	#60,d2			;always D2 sync level

;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	bra	666$

* Record A
.puttwk_rec_A
	bsr	.ensure_rec_mode

	moveq	#0,d0			;board
	move.l	#CALIB_HRECOFFSETA,D1	;item, assume play A
	move.l	twhk_Position(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib
	moveq	#0,d4			;channel A
	bra	350$

* Record B
.puttwk_rec_B
	bsr	.ensure_rec_mode

	moveq	#0,d0			;board
	move.l	#CALIB_HRECOFFSETB,D1	;item, assume play A
	move.l	twhk_Position(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib
	moveq	#1,d4			;channel B

* same for both Record A or B
350$	moveq	#0,d0			;board
	move.l	#CALIB_ADC_PHASE_EDGE,D1	;item
	move.l	twhk_Clock(a1),d2		;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_ADC_PHASE_COURSE,D1	;item
	move.l	twhk_Coarse(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

	moveq	#0,d0			;board
	move.l	#CALIB_ADC_PHASE_FINE,D1	;item
	move.l	twhk_Fine(a1),d2	;value
;	moveq	#1,d3			;d3 = save switch (set above)
	XJSR	Flyer_WriteCalib

*------
	btst	#HKB_TESTREC,d5
	beq	666$

*-------
	moveq	#0,d0			;first drive it can find
	move.l	#1<<FVIB_VIDEOREADY,d1	;that can do video
	XJSR	Flyer_VolumeName
	beq	666$
	movea.l	d0,a1

	CALLTL	DisplayWaitSprite
	lea	recordphase(pc),a0

510$	move.b	(a1)+,(a0)+
	bne	510$
	move.b	#':',-1(a0)

	move.b	#'R',(a0)+
	move.b	#'e',(a0)+
	move.b	#'c',(a0)+
	move.b	#'o',(a0)+
	move.b	#'r',(a0)+
	move.b	#'d',(a0)+
	move.b	#'P',(a0)+
	move.b	#'h',(a0)+
	move.b	#'a',(a0)+
	move.b	#'s',(a0)+
	move.b	#'e',(a0)+
	move.b	#0,(a0)+

*-------
580$	GET.l	TB_DOSBase,a6
	move.l	#recordphase,d1
	move.l	d1,a2			;used below
	XSYS	DeleteFile

	XLEA	MyClipAction,a0
	XJSR	Flyer_Defaults

	movea.l	ca_Volume(a0),a1
	move.l	a2,fv_Path(a1)			;->name

	move.b	#RT_STOPPED,ca_ReturnTime(a0)
	move.b	d4,ca_Channel(a0)		;Record Channel 0.
	move.b	#CAF_VIDEO,ca_Flags(a0)
	move.b	#CAPF_STEALOURVIDEO+CAPF_KILLOTHERVIDEO,ca_PermissFlags(a0)

	move.l	#4,ca_VidFieldCount(a0)
	XJSR	Flyer_Record	;a0->ClipAction

*-------
	lea	recordphase(pc),a0
	moveq	#0,d0			;field I
	XJSR	Flyer_OpenReadField
	move.l	d0,a0

;	move.l	#120,d0			;#lines
;	XJSR	Flyer_SkipLines

	movea.l	TB_EffectsBase+EFB_BuffA(a5),a1
	XJSR	Flyer_ReadLine

	XJSR	Flyer_CloseField

	lea	recordphase(pc),a0
	moveq	#2,d0			;field III
	XJSR	Flyer_OpenReadField
	move.l	d0,a0

;	move.l	#120,d0			;#lines
;	XJSR	Flyer_SkipLines

	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1
	XJSR	Flyer_ReadLine

	XJSR	Flyer_CloseField

;;	GET.l	TB_DOSBase,a6
	move.l	#recordphase,d1
	XSYS	DeleteFile

*-------
	CALLTL	CancelCG
	CALLTL	NoTransFreeze

	moveq	#VTI_IS_VID1,d0
	moveq	#0,d1		;bank 0
	CALLTL	Grab1Bank

	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1
	move.l	#241,d0			;line start
	move.l	#1,d1			;# of lines
	moveq	#0,d2			;bank

	moveq	#10,d3
	CALLTL	AllInterruptsOff
600$	CALLTL	SendBytes2ToasterAVEI
	exg	a0,a1
	addq.l	#1,d0
	CALLTL	SendBytes2ToasterAVEI
	addq.l	#1,d0
	dbra	d3,600$
	CALLTL	AllInterruptsOn

	PUT.w	#M_DV0,TB_MainSec
	CALLTL	CookAndServeMain
	CALLTL	DisplayNormalSprite

666$	rts

* play mode
.ensure_play_mode
	move.l	d3,-(sp)

	tst.w	RecordModeFlag
	beq	1666$
	clr.w	RecordModeFlag

	bsr	AbortPlayRec

	XJSR	Flyer_DefaultSelect

	moveq	#0,d0		;no specific board
	XJSR	Flyer_PlayMode

1666$	move.l	(sp)+,d3
	rts

* record mode
.ensure_rec_mode
	move.l	d3,-(sp)

	tst.w	RecordModeFlag
	bne	2666$
	move.w	#1,RecordModeFlag

	bsr	AbortPlayRec

	moveq	#0,d0		;no specific board
	XJSR	Flyer_RecordMode

	move.l	#FLY_VideoSource_VID1,d0
	XJSR	Flyer_InputSelect

2666$	move.l	(sp)+,d3
	rts

*------------------------
* Get Play A values
.gettwk_play_A
	subq.w	#4,sp
	lea.l	2(sp),a0
	moveq	#0,d0			;board
	move.l	#CALIB_HPLAYOFFSETA,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Position(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_DACA_PHASE_EDGE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Clock(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_DACA_PHASE_COURSE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Coarse(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_DACA_PHASE_FINE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Fine(a1)	;value

;;	moveq	#0,d0			;board
;;	move.l	#CALIB_PEDESTALA,D1	;item, assume play A
;;	XJSR	Flyer_ReadCalib
;;	move.w	(a0),d0
;;	ext.l	d0
;;	move.l	d0,twhk_Pedestal(a1)	;value

	addq.w	#4,sp
	bra	666$

* Get Play B values
.gettwk_play_B
	subq.w	#4,sp
	lea.l	2(sp),a0
	moveq	#0,d0			;board
	move.l	#CALIB_HPLAYOFFSETB,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Position(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_DACB_PHASE_EDGE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Clock(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_DACB_PHASE_COURSE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Coarse(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_DACB_PHASE_FINE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Fine(a1)	;value

;;	moveq	#0,d0			;board
;;	move.l	#CALIB_PEDESTALB,D1	;item, assume play A
;;	XJSR	Flyer_ReadCalib
;;	move.w	(a0),d0
;;	ext.l	d0
;;	move.l	d0,twhk_Pedestal(a1)	;value

	addq.w	#4,sp
	bra	666$

* Get Record A values
.gettwk_rec_A
	subq.w	#4,sp
	lea.l	2(sp),a0
	moveq	#0,d0			;board
	move.l	#CALIB_HRECOFFSETA,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Position(a1)	;value
	moveq	#0,d4			;channel A
	bra	1350$

* Get Record B values
.gettwk_rec_B
	subq.w	#4,sp
	lea.l	2(sp),a0
	moveq	#0,d0			;board
	move.l	#CALIB_HRECOFFSETB,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Position(a1)	;value
	moveq	#0,d4			;channel A
;;	bra	1350$


* same for both Record A or B
1350$	moveq	#0,d0			;board
	move.l	#CALIB_ADC_PHASE_EDGE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Clock(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_ADC_PHASE_COURSE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Coarse(a1)	;value

	moveq	#0,d0			;board
	move.l	#CALIB_ADC_PHASE_FINE,D1	;item, assume play A
	XJSR	Flyer_ReadCalib
	move.w	(a0),d0
	ext.l	d0
	move.l	d0,twhk_Fine(a1)	;value

	addq.w	#4,sp
	bra	666$

recordphase 	dcb.b	32+14,0
	CNOP	0,4

*--------------------------------------
* Returns d1 & d2 according to current TB settings

	XDEF	SetupToasterMux
SetupToasterMux
	moveq	#1,d1	;Flyer video on Flyer VID3
	moveq	#1,d2	;Flyer video on Flyer VID4

	btst.b	#FLYER3_BIT,TB_Flags4(a5)
	bne.s	10$
	moveq	#0,d1

10$	btst.b	#FLYER4_BIT,TB_Flags4(a5)
	bne.s	20$
	moveq	#0,d2
20$	rts

*--------------------------------------
* SetupPlayChannel(a0->clipaction, a5->TB)
*
* Sets up ToasterMux for the required play channel, if necessary

	XDEF	SetupPlayChannel
SetupPlayChannel
	movem.l	d0-d3,-(sp)
	tst.b	ca_Channel(a0)
	bne.s	20$

* using VID3
	btst.b	#FLYER3_BIT,TB_Flags4(a5)
	bne.s	666$
	bset.b	#FLYER3_BIT,TB_Flags4(a5)
	bra.s	30$

* using VID4
20$	btst.b	#FLYER4_BIT,TB_Flags4(a5)
	bne.s	666$
	bset.b	#FLYER4_BIT,TB_Flags4(a5)

30$	bsr.s	SetupToasterMux
	moveq	#0,d0	;all boards!!
	moveq	#0,d3	;Standard Toaster PRVW (not CAMcorder)
	XJSR	Flyer_ToasterMux

666$	movem.l	(sp)+,d0-d3
	rts

*--------------------------------------
* a0->ESmessage
*
Hand_TBCopen
	bsr	SetupToasterMux
	moveq	#0,d0	;all boards!!
	moveq	#1,d3	;TBCed video on CAMcorder
	XJSR	Flyer_ToasterMux
	rts

*--------------------------------------
* a0->ESmessage
*
Hand_TBCclose
	bsr	SetupToasterMux
	moveq	#0,d0	;all boards!!
	moveq	#0,d3	;Standard Toaster PRVW (not CAMcorder)
	XJSR	Flyer_ToasterMux
	rts

*--------------------------------------
* a0->ESmessage, a1->some Hack structure
*
Hand_TBCread
	DEBUGMSG	DBHD,<Hand_TBCread:>

	XLEA	TBCsettings,a0
	moveq	#0,d0		;only Board 0 *****!!!!!!
	move.l	#TBCOF_STATUS,d1
	XJSR	Flyer_TBCcontrol

;;	XLEA	TBCsettings,a0
	move.w	#TBC_sizeof-1,d0
10$	move.b	(a0)+,(a1)+
	dbra	d0,10$
	rts

*--------------------------------------
* a0->ESmessage, a1->some Hack structure
*
Hand_TBCwrite
	DEBUGMSG	DBHD,<Hand_TBCwrite: ---------------------->

	XLEA	TBCsettings,a0
	move.w	#TBC_sizeof-1,d0
10$	move.b	(a1)+,(a0)+
	dbra	d0,10$

	XLEA	TBCsettings,a0
	moveq	#0,d0		;only Board 0 *****!!!!!!
	move.l	#TBCOF_STATUS!TBCOF_MODES!TBCOF_ADJUST,d1

	IFD	SERDEBUG
	IFD	DBTBC
 	 btst.b	#TOGGLE_BIT,TB_Flags4(a5)
	 beq	.nodb1

	DUMPBITS.b	<Status    =>,tbc_Status(a0),<\>
	DUMPBITS.b	<Flags     =>,tbc_Flags(a0),<\>
	DUMPBITS.b	<DecFlags  =>,tbc_DecFlags(a0),<\>
	DUMPBITS.b	<EncFlags  =>,tbc_EncFlags(a0),<\>
	DUMPBITS.b	<Term      =>,tbc_Term(a0),<\>
	DUMPBITS.b	<KeyerFlags=>,tbc_KeyerFlags(a0),<\>
	DUMPUDEC.b	<InputSel  =>,tbc_InputSel(a0),<\>
	DUMPSDEC.b	<Bright    =>,tbc_Bright(a0),<\>
	DUMPUDEC.b	<Contrast  =>,tbc_Contrast(a0),<\>
	DUMPUDEC.b	<Sat       =>,tbc_Sat(a0),<\>
	DUMPSDEC.b	<Hue       =>,tbc_Hue(a0),<\>
	DUMPHEXI.W	<Phase     =>,tbc_Phase(a0),<\>
	DUMPHEXI.W	<HorAdj    =>,tbc_HorAdj(a0),<\>
	DUMPUDEC.b	<Fader     =>,tbc_Fader(a0),<\\>
.nodb1
	ENDC
	ENDC

	bchg.b	#TBCDB_AGC,tbc_DecFlags(a0)	;***!! change sense
	XJSR	Flyer_TBCcontrol
	bchg.b	#TBCDB_AGC,tbc_DecFlags(a0)	;***!! restore sense
	rts

****** Hand_STARTUP ***********************************************************
*
*   NAME
*	Hand_STARTUP -- This recognizes the editor
*
*   SYNOPSIS
*	Hand_STARTUP(message)
*	              d0
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*	ES_Reply  - has been set
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_STARTUP
	DEBUGMSG	DBHD,<Hand_STARTUP:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)

	XLEA	NoGrazerFlag,a0
	tst.b	(a0)
	beq.s	10$	;jump if already up
	clr.b	(a0)

	bsr	SendProjectEditStartMessage	;supplies -> project FGs, TB_Screen, TB_Window
	bsr	SendProjectEditRenderMessage	;display editor

10$	rts

****** Hand_QUIT ***********************************************************
*
*   NAME
*	Hand_QUIT
*
*   SYNOPSIS
*	Hand_QUIT(message)
*	              d0
*
*   FUNCTION
*	This should never be called.
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_QUIT
	DEBUGMSG	DBHD,<Hand_QUIT:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)	;no errors on QUIT

	bset.b	#QUIT_BIT,TB_Flags4(a5)

	rts

****** Hand_RENDER_EDIT ***********************************************************
*
*   NAME
*	Hand_RENDER_EDIT
*
*   SYNOPSIS
*	Hand_RENDER_EDIT(message)
*	              d0
*
*   FUNCTION
*	This should never be called.
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_RENDER_EDIT
	DEBUGMSG	DBHD,<Hand_RENDER_EDIT:>

	move.l	d0,a0
	moveq.l	#ES_ERR_GENERIC,d0
	move.l	d0,ES_Reply(a0)
	rts
****** Hand_RENDER_SWIT ***********************************************************
*
*   NAME
*	Hand_RENDER_SWIT
*
*   SYNOPSIS
*	Hand_RENDER_SWIT(message)
*	              d0
*
*   FUNCTION
*	tells Switcher to (re)render
*   INPUTS
*	Data1: TRUE means open windows if not open (and refresh)
*	       FALSE means close windows (no refresh before close)
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_RENDER_SWIT
	move.l	d0,a0
	clr.l	ES_Reply(a0)	;assume success

	DEBUGTXT	DBHD,<Hand_RENDER_SWIT: >
	DEBUGHEXI.B	DBHD,<OpenFlag=>,ES_Data1+3(a0),<\>


	tst.l	ES_Data1(a0)
	bne	2$

* Close switcher window and don't refresh imagery


* Set the Switcher to Simple refresh
*+	GET.l	TB_SYSBase,a6
*+	CALLROM	Forbid
*+	GET.l	TB_Window,a0
*+	ori.l	#WFLG_SIMPLE_REFRESH,wd_Flags(a0)
*+	movea.l	wd_RPort(a0),a0
*+	movea.l	rp_Layer(a0),a0
*+	andi.w	#~LAYERSMART,lr_Flags(a0)
*+	ori.w	#LAYERSIMPLE,lr_Flags(a0)
*+	CALLROM	Permit

	CALLTL	SoftSpriteOff
	bset.b	#5,TB_DisplayRenderMode(a5)	;Edit controls top overscan borders
	CALLTL	ClearToastDisplay		;Intuition will Stash empty switcher bottom
	bclr.b	#5,TB_DisplayRenderMode(a5)	;Switcher controls top overscan borders
	CALLTL	SoftSpriteOn

	bset.b	#6,TB_DisplayRenderMode(a5)	;editor will control bottom half
	XLEA	SwitcherArea_,a0
	or.w	#GFLG_DISABLED,gg_Flags(A0)
	bra	1$

* Open switcher window (if not open) and refresh bottom half of display
2$

* Set the Switcher to Smart refresh
*+	GET.l	TB_SYSBase,a6
*+	CALLROM	Forbid
*+	GET.l	TB_Window,a0
*+	andi.l	#~WFLG_SIMPLE_REFRESH,wd_Flags(a0)
*+	movea.l	wd_RPort(a0),a0
*+	movea.l	rp_Layer(a0),a0
*+	andi.w	#~LAYERSIMPLE,lr_Flags(a0)
*+	ori.w	#LAYERSMART,lr_Flags(a0)
*+	CALLROM	Permit

	bclr.b	#6,TB_DisplayRenderMode(a5)	;switcher will control bottom half
	XLEA	SwitcherArea_,a0
	and.w	#~GFLG_DISABLED,gg_Flags(A0)

* The following temporary flag prevents the project from also getting erased
* when going to Switcher Mode.
* (since the overscan borders normally get erased by ReDoSwitcher)
	bset.b	#5,TB_DisplayRenderMode(a5)	;Edit controls top overscan borders
	XJSR	ReDoSwitcher
	bclr.b	#5,TB_DisplayRenderMode(a5)	;Switcher controls top overscan borders

1$	rts

****** Hand_TagSize ***********************************************************
*
*   NAME
*	Hand_TagSize
*
*   SYNOPSIS
*	Hand_TagSize(message) (FG, TagID)
*	                d0
*
*   FUNCTION
*	Get Tag size from FGs taglist
*
*   INPUTS
*
*   RESULT
*	LONG result. Defaults to zero if Tag item can't be found.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_TagSize
	move.l	d0,a1
	move.l	ES_Data1(a1),a0		;crouton
	PUT.l	ES_Data2(a1),TB_TagID

	DEBUGHEXI.l	DBHD,<Hand_TagSize: tagid=>,TB_TagID(a5),< >
	CALLTL	FGC_TagInfoCommand
	GET.l	TB_TagSize,ES_Reply(a1)		;LONG value  (defaults to zero on errors)

	IFD	DBHD
	GET.l	TB_TagSize,d0
	DEBUGUDEC.l	DBHD,< TagSize=>,d0,<\>
	ENDC

	rts

****** Hand_GetValue ***********************************************************
*
*   NAME
*	Hand_GetValue
*
*   SYNOPSIS
*	Hand_GetValue(message)
*	                d0
*
*   FUNCTION
*	Get value from FGs taglist
*   INPUTS
*
*   RESULT
*	LONG result. Defaults to zero if Tag item doesn't exist or Error.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_GetValue
	move.l	d0,a1
	move.l	ES_Data1(a1),a0		;crouton
	move.l	ES_Data2(a1),d0		;TagID

	DEBUGHEXI.l	DBHD,<Hand_GetValue: tagid=>,d0,< >
	CALLTL	GetLongValue
	DEBUGUDEC.l	DBHD,<result=>,d0,<\>

	move.l	d0,ES_Reply(a1)		;LONG value  (defaults to zero)
	rts

****** Hand_GetTable ***********************************************************
*
*   NAME
*	Hand_GetTable
*
*   SYNOPSIS
*	Hand_GetTable(message) (FG, ->Table, TableSize, TagID)
*	                d0
*
*   FUNCTION
*	Get Table from FGs taglist
*   INPUTS
*
*   RESULT
*	LONG result. Defaults to zero if Tag item doesn't exist or Error.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_GetTable
	move.l	d0,a2

	movea.l	ES_Data1(a2),a0		;crouton
	movea.l	ES_Data2(a2),a1		;->data
	move.l	ES_Data3(a2),d1		;size
	move.l	ES_Data4(a2),d0		;ID

	IFD	DBHD
	DUMPHEXI.l	<Hand_GetTable: tagid=>,d0,< >
	DUMPHEXI.l	<FG=>,a0,< >
	DUMPUDEC.l	<Size=>,d1,<\>
	ENDC

	CALLTL	GetStructValue

	DEBUGMEM	DBHD,<Table>,0(a1),d1

	move.l	d0,ES_Reply(a2)		;Error code if any

	DEBUGSDEC.l	DBHD,<Hand_GetTable Reply=>,d0,<\>

	rts

****** Hand_UnSavable ***********************************************************
*
*   NAME
*	Hand_UnSavable
*
*   SYNOPSIS
*	Hand_UnSavable(message)
*	                d0
*
*   FUNCTION
*	Marks Tag item so it doesn't get saved in the project
*
*   INPUTS
*
*   RESULT
*	Error code.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_UnSavable
	move.l	d0,a2
	move.l	ES_Data1(a2),a0		;crouton
	PUT.l	ES_Data2(a2),TB_TagID	;TagID

	DEBUGHEXI.l	DBHD,<Hand_UnSavable: tagid=>,ES_Data2,< >

	CALLTL	FGC_UnSavableCommand

	move.w	TB_ErrFlag(a5),d0
	ext.l	d0
	move.l	d0,ES_Reply(a2)		;error code
	rts

****** Hand_NewFieldCount ***********************************************************
*
*   NAME
*	Hand_NewFieldCount
*
*   SYNOPSIS
*	Hand_NewFieldCount(message)
*	                d0
*
*   FUNCTION
*	This needs to be called if a Current FXs speed or duration has changed.
*
*   INPUTS
*
*   RESULT
*	Error code.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_NewFieldCount
	DEBUGMSG	DBHD,<Hand_NewFieldCount:>

	move.l	d0,a2
	move.l	ES_Data1(a2),a0		;crouton

	CALLTL	FGC_FCountCommand

	move.w	TB_ErrFlag(a5),d0
	ext.l	d0
	move.l	d0,ES_Reply(a2)		;error code
	rts

****** Hand_PutValue ***********************************************************
*
*   NAME
*	Hand_PutValue
*
*   SYNOPSIS
*	Hand_PutValue(message)
*	                d0
*
*   FUNCTION
*	Put value into FGs taglist
*   INPUTS
*
*   RESULT
*	Error code. Non zero if can't put (will add a new node if necessary)
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_PutValue
	move.l	d0,a2
	move.l	ES_Data1(a2),a0		;crouton
	move.l	ES_Data2(a2),d0		;TagID
	lea	ES_Data3(a2),a1		;->LONG Data

	moveq.l	#4,d1			;TagSize

	DEBUGHEXI.l	DBHD,<Hand_PutValue: tagid=>,d0,< >
	DEBUGUDEC.l	DBHD,<value=>,0(a1),<\>

	CALLTL	AddValue2FGtags
	move.l	d0,ES_Reply(a2)		;error code
	rts

****** Hand_PutTable ***********************************************************
*
*   NAME
*	Hand_PutTable
*
*   SYNOPSIS
*	Hand_PutTable(message)  (FG, ->Table, TableSize, TagID)
*	                d0
*
*   FUNCTION
*	Put table into FGs taglist
*   INPUTS
*
*   RESULT
*	Error code. Non zero if can't put (will add a new node if necessary)
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_PutTable
	move.l	d0,a2
	movea.l	ES_Data1(a2),a0		;crouton
	movea.l	ES_Data2(a2),a1		;->Data
	move.l	ES_Data3(a2),d1		;TagSize
	move.l	ES_Data4(a2),d0		;TagID

	DEBUGHEXI.l	DBHD,<Hand_PutTable: tagid=>,d0,< >
	DEBUGHEXI.l	DBHD,< FG=>,a0,<\>
	DEBUGMEM	DBHD,<Table>,0(a1),d1

	CALLTL	AddValue2FGtags
	move.l	d0,ES_Reply(a2)		;error code
	rts


****** CheckForFName  ****************************************
*
*   NAME
*	CheckForFName
*
*   SYNOPSIS
*	Error = CheckForFName(FILENAME) 
*	        	        A0	
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
**************************************************************
CheckForFName
	movem.l	d0-d3/a0-a6,-(sp)
	GET.l	TB_DOSBase,a6
	move.l	#0,(sp)			;until we know otherwise ok
	move.l	a0,d1
	XSYS	FilePart

	move.l	d0,a0
;	DUMPMEM	<FilePart>,(A0),#64

	tst.l	(a0)
	bne	.ok	
	move.l	#1,(sp)
.ok

	movem.l	(sp)+,d0-d3/a0-a6
	rts


****** Hand_FoundFile ***********************************************************
*
*   NAME
*	Hand_FoundFile
*
*   SYNOPSIS
*	Hand_FoundFile(message) (Type,->name,flags,->textarray,mode)
*	                d0	 Data1   2     3        4        5
*
*   FUNCTION
*	Returns back a file name, from the Grazer filerequester.
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_FoundFile

	move.l	d0,a2			;->Message

	move.l	ES_Data2(a2),d0		;name
	beq	600$			;Jump if no file name found (= cancel)

	cmpi.l	#'FRAM',ES_Data1(a2)	; is a framestore crouton?
	bne	600$

	movea.l	d0,a0			;->FileName

;;	DUMPMEM	<FILENAME>,(A0),#64
;; 040297 DEH, Was a file name really returned?
	bsr	CheckForFName
	tst.l	d0		;error if not 0
	bne	600$

	
;;	DUMPMEM	<tst.w   ES_Data5(a2)>,ES_Data5(A2),#16
	tst.l	ES_Data5(a2)		;4 or 1 field save mode
	beq.s	100$			;default = 4 field

* Assume single Field Framesave
	moveq	#1,d0
	XJSR  	ReallyProcessSaveButton	;Whatever code does a 1 field save
;; 	(d0=returned error)
	bra.s	600$

* Assume four field Framesave
100$
	moveq	#3,d0
	XJSR	ReallyProcessSaveButton	;To whatever code does a 4 field save  (d0=error)
;; 	(d0=returned error)

600$	move.l	d0,ES_Reply(a2)		;error code if any
666$	rts

****** Hand_GETPLIST ***********************************************************
*
*   NAME
*	Hand_GETPLIST -- provide project editor with fastgadget list.
*
*   SYNOPSIS
*	Hand_GETPLIST(message)
*	                d0
*
*   FUNCTION
*	asks swticher for gadget list
*   INPUTS
*
*   RESULT
*	Pointer to pointer to First node of list. (Note this is not
*	a list header structure)
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_GETPLIST
	DEBUGMSG	DBHD,<Hand_GETPLIST:>

	move.l	d0,a0
	move.l	TB_ToolBoxGrids(a5),a1
;;	move.l	(a1),ES_Reply(a0)
	move.l	a1,ES_Reply(a0)		;pointer to pointer
	rts

****** Hand_FreeCrouton *****************************************************
*
*   NAME
*	Hand_FreeCrouton -- Free a crouton loaded by ES_LoadCrouton, or
*	                    project loading.
*
*   SYNOPSIS
*	Hand_FreeCrouton(message)
*	                d0
*
*   FUNCTION
*	frees crouton in Data1.  You must be sure to unlink this crouton
*	from the current list before sending this message.
*
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_FreeCrouton:
	DEBUGMSG	DBHD,<Hand_FreeCrouton:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)
	move.l	ES_Data1(a0),a0
	move.l	TB_EfxFG(a5),d2
	move.l	a0,a2
	CALLTL	RemoveTBFG
	cmp.l	d2,a2
	bne.s	1$			;if we just removed the selected
	CALLTL	SelectStdEfx		;effect we must try to select something
1$	rts

****** Hand_LoadCrouton *****************************************************
*
*   NAME
*	Hand_LoadCrouton -- Load a crouton from a disk file.
*
*   SYNOPSIS
*	Hand_LoadCrouton(message)
*	                   d0
*
*   FUNCTION
*	Loads a crouton from disk.  This croton may not have default values
*	set.
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  Pointer to a crouton.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_LoadCrouton:
	DEBUGMSG	DBHD,<Hand_LoadCrouton:>

	move.l	d0,a2			;message
	clr.l	ES_Reply(a2)
	move.l	ES_Data1(a2),a0		;file name

	bclr.b	#GRAZERLOAD_BIT,TB_Flags3(a5)
	move.l	ES_Data2(a2),d0
	beq.s	10$
	bset.b	#GRAZERLOAD_BIT,TB_Flags3(a5)

10$	bsr	LoadDiskCrouton
	bclr.b	#GRAZERLOAD_BIT,TB_Flags3(a5)

	move.l	d0,ES_Reply(a2)		;zero if failure

;;	DEBUGMSG	DBHD,<ENDOF Hand_LoadCrouton:>
	rts

*------------------------------------------
* Returns ->FG
LoadDiskCrouton	;(A0=filename)

	movem.l	a0-a1,-(sp)

	CALLTL	LoadCroutonFile
	beq	.skip

;;	DEBUGMSG	DBHD,<LoadCroutonFile is OK>

	movea.l	a0,a1			;->filename
	movea.l	d0,a0			;->FG

	move.b	#-1,FG_DispFlag(a0)	;don't let switcher display this icon
	move.w	#2,FG_IndexID(a0)

* stash the original path into the crouton.
	move.l	#TAGID_OriginalLocation,d0
	CALLTL	AddString2FGtags

	move.l	a0,d0		;->FG
.skip	movem.l	(sp)+,a0-a1
	rts


****** Hand_DuplicateCrouton *****************************************************
*
*   NAME
*	Hand_DuplicateCrouton -- Duplicate the current crouton
*
*   SYNOPSIS
*	Hand_DuplicateCrouton(message)
*	                   d0
*
*   FUNCTION
*	Reloads a crouton from disk, and copies any changes to the new
*	crouton.
*
*   INPUTS
*	Data1   - pointer to a crouton
*   RESULT
*	ES_Reply  -  Pointer to a duplicate crouton.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_DuplicateCrouton:
	move.l	d0,a2			;message

	clr.l	ES_Reply(a2)
	move.l	ES_Data1(a2),a0		;crouton
	movea.l	FGS_FileName(a0),a0

	DEBUGTXT	DBHD,<Hand_DuplicateCrouton: file=>
	DEBUGSTR	DBHD,(a0)
	DEBUGMSG	DBHD,<>

	bsr	LoadDiskCrouton
	move.l	d0,ES_Reply(a2)
	beq.s	.skip

	move.l	ES_Data1(a2),a0		;source crouton
	move.l	d0,a1			;clone
	bsr	CloneCroutonData

	move.l	d0,a0
	CALLTL	FGC_InterpTagsCommand	;Interpret tags, update FG flags (for symbols)

.skip	rts

*---------------------------------------------
* a0=source a1=destination
CloneCroutonData
	movem.l	d0-d1/a0-a2,-(sp)
	CALLTL	FGC_SaveTagsCommand	;see if FG has any tags & where
	movea.l	a1,a0			;->destination
	GET.l	TB_Tags,d0		;no tags supplied in source
	beq.s	666$

10$	movea.l	d0,a1	 		;->node
	lea.l	TLN_SIZEOF(a1),a2 	;->first item in tag list
	PUT.l	a2,TB_Tags

	CALLTL	FGC_LoadTagsCommand

	move.l	(a1),d0		;->next node in list
	bne.s	10$		;jump if more lists

666$	movem.l	(sp)+,d0-d1/a0-a2
	rts

****** Hand_LoadProject *****************************************************
*
*   NAME
*	Hand_LoadProject -- load a project
*
*   SYNOPSIS
*	Hand_LoadProject(message)
*	                   d0
*
*   FUNCTION
*	loads a project file from disk.
*
*   INPUTS
*	Data1   - list #
*	Data2   - pointer to a filename
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_LoadProject:
	move.l	d0,a2

	move.l	#1001,d0
	move.l	ES_Data1(a2),d1		;list #
	move.l	ES_Data2(a2),a0		;filename

	DEBUGUDEC.l	DBHD,<Hand_LoadProject: listnum=>,d1,<\>
	DEBUGTXT	DBHD,<filename=>
	DEBUGSTR	DBHD,(a0)
	DEBUGMSG	DBHD,<>

	CALLTL	NewReadProject

	move.l	TB_LastGlobalError(a5),ES_Reply(a2)
	rts

****** Hand_LoadedSlices *****************************************************
*
*   NAME
*	Hand_LoadedSlices
*
*   SYNOPSIS
*	Hand_LoadedSlices(message)
*	                   d0
*
*   FUNCTION
*	Returns ULONG mask of what slices are currently loaded.
*
*   INPUTS
* 	None
*   RESULT
*	ES_Reply  -  ULONG mask
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_LoadedSlices:
	DEBUGMSG	DBHD,<Hand_LoadedSlices:>

	move.l	d0,a0
	XJSR	WhatSlicesLoaded
	move.l	d0,ES_Reply(a0)
	rts

****** Hand_SaveProject *****************************************************
*
*   NAME
*	Hand_SaveProject -- save a project
*
*   SYNOPSIS
*	Hand_SaveProject(message)
*	                   d0
*
*   FUNCTION
*	Saves a project file to disk.
*
*   INPUTS
*	Data1   - list #
*	Data2   - pointer to a filename or NULL to use current filename.
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*
****** Hand_NewProject ******
*
*   NAME
*	Hand_NewProject -- creates an empty (default) project
*
*   SYNOPSIS
*	Hand_NewProject(message)
*	                   d0
*
*   FUNCTION
*	Creates a new project with nothing in it in the Editor and on HD
*
*   INPUTS
*	Data1   - list #
*	Data2   - pointer to a filename
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************

Hand_NewProject:
	DEBUGMSG	DBHD,<Hand_NewProject:>

	move.l	d0,a2

	move.l	ES_Data1(a2),d0		;list #
	CALLTL	NewReadDefaultProject

	move.l	a2,d0
;;	bra	Hand_SaveProject

Hand_SaveProject:
	DEBUGMSG	DBHD,<Hand_SaveProject:>

	move.l	d0,a2

	XLEA	FullProjectName,a0	;last loaded project name (might be DefaultProject)
	move.l	ES_Data2(a2),d0		;filename
	beq.s	10$			;Jump if no name supplied
	move.l	d0,a0			;use supplied name

10$	move.l	#1001,d0
	move.l	ES_Data1(a2),d1		;list #

	DEBUGUDEC.l	DBHD,<Hand_SaveProject: listnum=>,d1,<\>
	DEBUGTXT	DBHD,<filename=>
	DEBUGSTR	DBHD,(a0)
	DEBUGMSG	DBHD,<>

	CALLTL	NewWriteProject

	move.l	TB_LastGlobalError(a5),ES_Reply(a2)

	rts

****** Hand_ClearProject *****************************************************
*
*   NAME
*	Hand_ClearProject -- removes all croutons from a project
*
*   SYNOPSIS
*	Hand_ClearProject(message)
*	                   d0
*
*   FUNCTION
*	Creates an empty project in the Editor
*
*   INPUTS
*	Data1   - list #
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_ClearProject:
	DEBUGMSG	DBHD,<Hand_ClearProject:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)

	move.l	ES_Data1(a0),d0		;list #
	CALLTL	NewUnloadToolbox	; remove croutons from this list
	rts

****** Hand_Select *****************************************************
*
*   NAME
*	Hand_Select -- SelectQ a Crouton
*
*   SYNOPSIS
*	Hand_Select(message)
*	               d0
*
*   FUNCTION
*	Sends a FGC_SELECT to a fg
*
*   INPUTS
*	Data1   - pointer fastgadget
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Select:
	DEBUGMSG	DBHD,<Hand_Select:>

	move.l	d0,a1
	move.l	ES_Data1(a1),a0
	CALLTL	FGC_SelectCommand

	clr.l	ES_Error(a1)		;to make sure (assume no error)
	move.w	TB_ErrFlag(a5),d0
	ext.l	d0
	move.l	d0,ES_Reply(a1)
	beq.s	10$
	move.l	TB_LastError(a5),ES_Error(a1)

10$	rts

****** Hand_FGcommand *****************************************************
*
*   NAME
*	Hand_FGcommand -- Send a FGC command to a Crouton
*
*   SYNOPSIS
*	Hand_FGcommand(message)
*	               d0
*
*   FUNCTION
*	Sends a FGC_ command to a fg
*
*   INPUTS
*	Data1   - pointer fastgadget
*	Data2	- FGC command #
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_FGcommand:
	move.l	d0,a1
	move.l	ES_Data2(a1),d0	;FGC command
	move.l	ES_Data1(a1),a0	;->FG

	DEBUGHEXI.l	DBHD,<Hand_FGcommand: FG=>,a0,< >
	DEBUGUDEC.l	DBHD,<FGCcommand=>,d0,< >

	CALLTL	SendFGC2Crouton

	moveq.l	#0,d0
	GET.w	TB_ErrFlag,d0

	DEBUGHEXI.l	DBHD,<result=>,d0,<\>

	move.l	d0,ES_Reply(a1)

	rts

****** Hand_Auto *****************************************************
*
*   NAME
*	Hand_Auto -- was _Auto
*
*   SYNOPSIS
*	Hand_Auto(message)
*	            d0
*
*   FUNCTION
*	Sends a FGC_TOMAIN to a fg
*
*   INPUTS
*	Data1   - pointer fastgadget
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Auto:
	DEBUGMSG	DBHD,<Hand_Auto:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)
	move.l	ES_Data1(a0),a0
	CALLTL	FGC_ToMainCommand
	rts


****** Hand_Take *****************************************************
*
*   NAME
*	Hand_Take -- was _Take
*
*   SYNOPSIS
*	Hand_Take(message)
*	            d0
*
*   FUNCTION
*	Sends a FGC_Take to a fg
*
*   INPUTS
*	Data1   - pointer fastgadget
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Take:
	DEBUGMSG	DBHD,<Hand_Take:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)
	move.l	ES_Data1(a0),a0
	CALLTL	FGC_TakeCommand
	rts


****** Hand_StartSeq *****************************************************
*
*   NAME
*	Hand_StartSeq -- Indicate start of sequence
*
*   SYNOPSIS
*	Hand_StartSeq(message)
*	                d0
*
*   FUNCTION
*
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_StartSeq:

	DEBUGMSG	DBHD,<Hand_StartSeq:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)

***
*-------------------
** This is used to determine which bits of the Flyer Field clock correspond
** to field I of the Toaster.  You should key on WHITE, key keying the
** 4FieldCount stillstore over Matte (=encoder), with key set to about 85 or greater.
** Then run this.  Look at it on a Betacam SP deck single framing, or a Waveform monitor.
** Or you should see only one of the numbers with black under it, the other
** will have your user interface.  The one that has black = %00 field bits on the
** flyer

	IFD	TESTFIELD0
	movem.l	d0-d7/a0-a6,-(sp)

	tst.w	TB_OLaySec(a5)	; HACK
	beq	777$

	CALLTL	DisableInterrupts

	DEA.l	TB_VTSetUp,a0
	ELHCLEAR_MATTE	a0
	CALLTL	SendELH2Toaster

4$	CALLTL	IsRMBdown
	tst.l	d0
	bne.s	4$

	XJSR	Flyer_GetFieldClock
	move.l	d0,d2

5$	XJSR	Flyer_GetFieldClock
	cmp.l	d0,d2
	beq.s	5$
	move.l	d0,d2

	CALLTL	Wait4Top

	move.w	#$8100,_custom+dmacon	;bm dma on
	andi.w	#%11,d0
	bne.s	7$
	move.w	#$100,_custom+dmacon	;bm dma off

7$	CALLTL	IsRMBdown
	tst.l	d0
	beq.s	5$

	move.w	#$8100,_custom+dmacon	;bm dma on

	ELHSET_MATTE	a0
	CALLTL	SendELH2Toaster

	CALLTL	EnableInterrupts

777$	movem.l	(sp)+,d0-d7/a0-a6

	ENDC		;TESTFIELD0

*-------------------

	CALLTL	ImageryOff
	CALLTL	InstallAVE

* This is done earlier so Head making doesn't glitch the output
;;	GET.w	TB_MainSec,d0
;;	andi.w	#M_VIDEO3!M_VIDEO4,d0
;;	beq.s	20$
;;	bsr	ForceMainToBlank
;; This Abort is usually don before Head making!
;;20$	bsr	AbortPlayRec

	bsr	SyncClocks	;if sequence starts with RT_STARTED, don't
				;bother to do this again!

666$	bset.b	#4,TB_DisplayRenderMode(a5)

	rts

**********************************************************************
	XDEF	SyncClocks
SyncClocks
	movem.l	d0-d1/a0,-(sp)

* sync up Flyer & the Switchers clocks
	tst.l	TB_FlyerBase(a5)
	beq	666$

	CALLTL	DisableInterrupts

	XJSR	Flyer_GetFieldClock
	move.l	d0,d1

10$	XJSR	Flyer_GetFieldClock
	cmp.l	d0,d1
	beq.s	10$

* Usually about 40% down field. The current count applies to this field.

	lea	_custom,a0
20$ 	move.b	vhposr(a0),d1
    	cmpi.b	#30,d1
    	bcs.s	20$	;jump if too near field start (to be safe before setting MasterTime)

;;	subq.l	#1,d0			;compensate because GetFieldClock changes 40% down the field

	PUT.l	d0,TB_MasterTime

***!!! Only a hack to see if the MasterClock is counting accurately.
	XREF	FieldBit
	clr.w	FieldBit

	move.w	#INTF_VERTB,_custom+intreq	;clear any stacked up vertical interrupts

	CALLTL	EnableInterrupts

666$	movem.l	(sp)+,d0-d1/a0
	rts

****** Hand_Stop *****************************************************
*
*   NAME
*	Hand_Stop -- Indicate end of sequence, playing or recording
*
*   SYNOPSIS
*	Hand_Stop(message)
*	               d0
*
*   FUNCTION
*
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Stop:
	DEBUGMSG	DBHD,<Hand_Stop:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)

	bsr	AbortPlayRec

	btst.b	#4,TB_DisplayRenderMode(a5)
	beq	666$			;jump if not sequencing

*-------------
	IFD	DBCLOCK
	CALLTL	AllInterruptsOff

	XJSR	Flyer_GetFieldClock
	move.l	d0,d2

5$	XJSR	Flyer_GetFieldClock
	cmp.l	d0,d2
	beq.s	5$

;	subq.l	#1,d0
	sub.l	TB_MasterTime(a5),d0
	beq	6$

	DUMPMSG		<>
	DUMPMSG		<ERROR ERROR ERROR ERROR ERROR ERROR ****!!!!!!!>
	DUMPMSG		<Flyer & Switcher Clocks not Syncronized!!!!>
;;	DUMPHEXI.L	<    FlyerTime-MasterTime = >,d0,<\>
	DUMPHEXI.L	<    FlyerTime-1 >,d2,<\>


6$
	DUMPHEXI.L	<    FlyerTime-MasterTime = >,d0,<\>
	

	CALLTL	AllInterruptsOn
	ENDC
*-------------

	bclr.b	#4,TB_DisplayRenderMode(a5)
	PUT.l	#-1,TB_SequencePosition
	PUT.l	#-1,TB_FieldCounter

	IFD	FORCE2MATTE
	GET.w	TB_MainSec,d0
	andi.w	#M_ENCODER,d0
	bne.s	30$
	move.w	StashBKG,d0	;only restore original if not on Matte
	beq.s	30$
	CALLTL	SetMatteColor
	ENDC

30$	CALLTL	InstallAVE
	CALLTL	KillAlphaKey
	CALLTL	ImageryOn
	CALLTL	ReDoDisplay
	CALLTL	InstallAVEI

666$	rts

****** Hand_Main2Blank *****************************************************
*
*   NAME
*	Hand_Main2Blank -- Indicate end of sequence
*
*   SYNOPSIS
*	Hand_Main2Blank(message)
*	               d0
*
*   FUNCTION
*	Forces Main to Matte Black if it was on a Flyer drive.
*  	This should be called if the Flyer needs to copy flyer data
*       to/from a Flyer drive, because that can glitch the Flyer output.
*
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************

	IFD	FORCE2MATTE
Hand_Main2Blank:
	DEBUGMSG	DBHD,<Hand_Main2Blank:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)

	clr.w	StashBKG		;assume Matte already black (or not used)

	GET.w	TB_MainSec,d0
	andi.w	#M_VIDEO3!M_VIDEO4,d0
	beq.s	666$

	GET.w	TB_ToastBGC,StashBKG	;if zero don't need to restore
	bsr	ForceMainToBlank
666$	rts
	ENDC

****** Hand_GUImode *****************************************************
*
*   NAME
*	Hand_GUImode -- Supply the switcher with the current display mode
*
*   SYNOPSIS
*	Hand_GUImode(message)
*	               d0
*
*   FUNCTION
*	THIS IS AN OLD COMMAND.  THE LATEST THINKING IS THAT THE SWITCHER
*	ONLY NEEDS TO BE CONCERNED WITH TWO MODES: EDITOR & SWITCHER.
*	THESE ARE DIRECTLY RELATED TO TB_DisplayRenderMode BIT 6, SO
*	TB_GUImode ISN'T CURRENTLY BEING USED.
*
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_GUImode:
	DEBUGMSG	DBHD,<Hand_GUImode:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)
	move.l	ES_Data1(a0),d0
	PUT.w	d0,TB_GUImode
	rts

****** Hand_SelectDefault *****************************************************
*
*   NAME
*	Hand_SelectDefault -- Select internal default effect (fade)
*
*   SYNOPSIS
*	Hand_SelectDefault(message)
*	               	     d0
*
*   FUNCTION
*
*
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_SelectDefault:
	DEBUGMSG	DBHD,<Hand_SelectDefault:>

	move.l	d0,a0
	clr.l	ES_Reply(a0)
	CALLTL	SelectStdEfx	;internal fade
	rts

*****************************************************
	XDEF	ForceMainToBlank
ForceMainToBlank
* Set Matte to black
	move.l	d0,-(sp)

	GET.w	TB_MainSec,d0
	andi.w	#M_ENCODER,d0
	bne.s	666$			;avoid if already on Matte

	moveq	#0,d0			;black
	SET_MATT	d0		; Change toastbase to new matte
	TEST_MATT_LOCK
	bne.s	100$
	CALLTL	SetMatteColor
	GET.l	TB_EfxFG,a0
	CALLTL	FGC_BGCommand

* Display Matte
100$	PUT.w	#M_ENCODER,TB_MainSec
	CALLTL	CookAndServeMain
666$	move.l	(sp)+,d0
	rts




*****************************************************
	IFD	CRAP

	XDEF	ForcePrvwToBlank
ForcePrvwToBlank
	PUT.w	#M_ENCODER,TB_PrvwSec
	CALLTL	CookAndServePrvw
	rts
	ENDC	;CRAP


****** Hand_Record *****************************************************
*
*   NAME
*	Hand_Record
*
*   SYNOPSIS
*	Hand_Record(message)
*	               d0
*
*   FUNCTION
*	Records a Flyer Clip
*
*   INPUTS
*  	(->name, fields, ->StartFunct, ->StopFunct, Flags)
*	ES_Data1 ES_Data2   ES_Data3     ES_Data4   ES_Data5
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Record:
	DEBUGMSG	DBHD,<Hand_Record:>

	move.l	d0,a2
	move.l	TB_FlyerBase(a5),d0
	beq	666$

	bsr	AbortPlayRec

	XLEA	MyClipAction,a0

	XJSR	Flyer_Defaults

	movea.l	ca_Volume(a0),a1
	move.l	ES_Data1(a2),fv_Path(a1)	;->name

	move.l	ES_Data5(a2),d1			;Flags

;;???	move.b	#RT_STARTED,ca_ReturnTime(a0)
	move.b	#RT_IMMED,ca_ReturnTime(a0)

	move.b	#0,ca_Channel(a0)	;Always using Channel 0 for record!!!

	move.w	#0,d0			;assume nothing to record
	tst.w	RecordVideo
	beq.s	10$
	move.b	#CAF_VIDEO,d0
10$	tst.b	MyRecordAudioGain1
	beq.s	20$
	ori.b	#CAF_AUDIOL,d0
20$	tst.b	MyRecordAudioGain2
	beq.s	30$
	ori.b	#CAF_AUDIOR,d0
30$	btst	#FLYB_APPEND,d1
	beq.s	40$
	ori.b	#CAF_APPEND,d0
40$	move.b	d0,ca_Flags(a0)
	move.b	#CAPF_STEALOURVIDEO+CAPF_KILLOTHERVIDEO,ca_PermissFlags(a0)

**!! Need flags for Record Serial port1 or port2

** This isn't currently supported on record
** Use the Hand_RecordGain call
;;	move.b	MyRecordAudioGain1,ca_VolSust1+1(a0)
;;	move.b	MyRecordAudioGain2,ca_VolSust2+1(a0)

	move.l	ES_Data2(a2),ca_VidFieldCount(a0)
	move.l	ES_Data2(a2),ca_AudFieldCount(a0)

	CALLTL	DisplayWaitSprite

	move.l	ES_Data3(a2),d0
	beq.s	100$
	movem.l	a0/a2/a5,-(sp)
	movea.l	d0,a0
	jsr	(a0)		;Wait for Record
	movem.l	(sp)+,a0/a2/a5

100$	DEBUGCA	DBCA,<Flyer_Record CA------------------->,0(a0)

	XJSR	Flyer_Record	;a0->ClipAction

	bne.s	333$		;exit with error

	move.l	ES_Data4(a2),d0
	beq.s	200$
	movem.l	a2/a5,-(sp)
	movea.l	d0,a0
	jsr	(a0)		;Wait for Abort
	movem.l	(sp)+,a2/a5
	bsr	AbortPlayRec

200$	moveq	#0,d0		;No errors
333$	CALLTL	DisplayNormalSprite
666$	move.l	d0,ES_Reply(a2)
	rts



****** Hand_RecordAppend *****************************************************
*
*   NAME
*	Hand_RecordAppend
*
*   SYNOPSIS
*	Hand_RecordAppend(message)
*	               d0
*
*   FUNCTION
*	Records fields onto an existing Flyer Clip
*
*   INPUTS
*  	(->name, fields,)
*	ES_Data1 ES_Data2
*
*   RESULT
*	ES_Reply  -  error code 0 if ok
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_RecordAppend:
	DEBUGMSG	DBHD,<Hand_RecordAppend:>

	move.l	d0,a2
	move.l	TB_FlyerBase(a5),d0
	beq	666$

	bsr	AbortPlayRec

	XLEA	MyClipAction,a0

	XJSR	Flyer_Defaults

	movea.l	ca_Volume(a0),a1
	move.l	ES_Data1(a2),fv_Path(a1)	;->name

	move.b	#RT_STOPPED,ca_ReturnTime(a0)	;Is a synchronous call

	move.b	#0,ca_Channel(a0)	;Always using Channel 0 for record!!!

	move.w	#0,d0			;assume nothing to record
	tst.w	RecordVideo
	beq.s	10$
	move.b	#CAF_VIDEO,d0
10$	tst.b	MyRecordAudioGain1
	beq.s	20$
	ori.b	#CAF_AUDIOL,d0
20$	tst.b	MyRecordAudioGain2
	beq.s	30$
	ori.b	#CAF_AUDIOR,d0
30$	move.b	d0,ca_Flags(a0)
	move.b	#CAPF_STEALOURVIDEO+CAPF_KILLOTHERVIDEO,ca_PermissFlags(a0)

	move.l	ES_Data2(a2),ca_VidFieldCount(a0)
	move.l	ES_Data2(a2),ca_AudFieldCount(a0)

100$	DEBUGCA	DBCA,<Flyer_RecordAppend CA------------------->,0(a0)

	XJSR	Flyer_AppendFields	;a0->ClipAction

	bne.s	666$		;exit with error

200$	moveq	#0,d0		;No errors
666$	move.l	d0,ES_Reply(a2)
	rts




****** Hand_Jog *****************************************************
*
*   NAME
*	Hand_Jog
*
*   SYNOPSIS
*	Hand_Jog(message)
*	           d0
*
*   FUNCTION
*	Jumps to a particular clip field
*
*   INPUTS
*	Data1   - rendercallback
*
*   RESULT
*	ES_Reply  -  resulting block #	(0 if failure)
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
JOGMAXDE	 set	60			;1 sec
JOGNOACC	 set	(JOGMAXDE+(1<<10))	;approx 18 sec
JOGMAXACC	 set	(JOGNOACC+(1<<15))	;approx 9 min

Hand_Jog:
	DEBUGMSG	DBHD,<Hand_Jog:>

	bsr	InitJogShuttle

	move.l	RCB_Max(a3),d1

;;	DUMPUDEC.l <Jog Max=>,d1,< >
;;	DUMPUDEC.l <Min=>,RCB_Min(a3),<\>

	sub.l	RCB_Min(a3),d1		;assumes Min <= Max

* Scale jog amount because DoMouseXY can't handle >= 32K of movement
	moveq	#0,d3
10$	cmp.l	#$7FFE,d1
	bls	20$			;jump if < 32K fields of Jog
	addq.w	#1,d3
	lsr.l	#1,d1
	bra.s	10$

*---------------------

* Scale Acceleration/deacceleration for clip size
20$	moveq	#-1,d2		;assume max deaccel
	cmpi.w	#JOGMAXDE,d1
	bls.s	100$		;jump if <= JOGMAXDE, use max deaccel

	cmpi.w	#JOGNOACC,d1
	bhi.s	50$		;jump if > JOGNOACC, use some accel

* Need	some deaccel
	move.w	d1,d2
	subi.w	#JOGMAXDE,d2
	lsl.w	#5,d2		;* 32K/(1<<10)
	neg.w	d2		;-32 to -30K
	bra.s	100$

* Need acceleration
50$	move.w	#$7fff,d2		;assume max accel
	cmpi.w	#JOGMAXACC,d1
	bcc.s	100$			;jump if >= JOGMAXACC

* Need some acceleration
	move.w	d1,d2
	subi.w	#JOGNOACC,d2
;;	lsl.w	#0,d2		;* 32K/(1<<15)

*--------------------
100$
	addq.w	#1,d1			;can't quite reach the limit.

;;	DUMPUDEC.w <X Max=>,d1,< >
	swap	d1
	clr.w	d1			;no Y

	move.l	RCB_Frame(a3),d0	;assumes Min <= Frame <= Max
;;	DUMPUDEC.l <Frame=>,d0,<\>
	sub.l	RCB_Min(a3),d0
	lsr.l	d3,d0			;scale it down

;;	DUMPUDEC.w <Initial X scaled=>,d0,<\>

	swap	d0
	clr.w	d0			;no Y
	lea	renderjog(pc),a0

;	DUMPUDEC.w <*** Accel=>,d2,<***\>

*   a0->render code
*  a1->abort function
*  a2->ESmessage
*  a3->RCBstruct
*  a4->RenderCall
*   d0=initialXY
*   d1=limitsXY
*   d2=accel
*   d3=scaler

	CALLTL	SoftSpriteOff
	CALLTL	DoMouseXY
	bsr	FinishJogShuttle
	CALLTL	SoftSpriteOn

666$	rts

*-------------------------------
* d0.w=frame-min, d3=scaler, a3->RCB, a4=render function
renderjog
	clr.w	d0			;forget Y
	swap	d0

;	DUMPUDEC.l <Xjog=>,d0,< >

	lsl.l	d3,d0			;scale it up

;;	DUMPUDEC.l <Xjog=>,d0,< >

	add.l	RCB_Min(a3),d0

;;	DUMPUDEC.l <scaled/offset=>,d0,< >

***!!!! Hacked to avoid non-color frame calls (only Field I accepted)
	andi.l	#~%11,d0

;;	DUMPUDEC.l <rounded=>,d0,<\>

	move.l	d0,RCB_Frame(a3)

	XLEA	MyClipAction,a0

	move.b	ca_Flags(a0),d1
	btst	#CAB_VIDEO,d1
	beq.s	10$
	move.l	d0,ca_VidStartField(a0)

10$	andi.b	#CAF_AUDIOL!CAF_AUDIOR,d1
	beq.s	20$
	move.l	d0,ca_AudStartField(a0)

20$	XJSR	Flyer_DoFindField

	movea.l	a3,a0
	jsr	(a4)

	XLEA	MyClipAction,a0
	XJMP	Flyer_WaitAction

*-------------------------------
wait4rmbup
	CALLTL	IsRMBdown
	bra	checkabort

wait4lmbup
	CALLTL	IsLMBdown

checkabort
	tst.l	d0
	beq.s	666$		;jump if abort
	moveq	#0,d0
	rts

666$
;;	DUMPMSG	<ABORTED ABORTED ABORTED>

* Turn off Audio
	XLEA	MyClipAction,a0
	tst.l	ca_VolSust1(a0)	;assumes VolSust2 always follows VolSust1 !!!
	beq.s	555$
	clr.l	ca_VolSust1(a0)

	XJSR	Flyer_DoFindField
	XJSR	Flyer_WaitAction

555$	moveq	#1,d0
	rts

*----------------
* On entry d0->ESmessage
*
* returns
*  a1->abort function
*  a2->ESmessage
*  a3->RCBstruct
*  a4->RenderCall
*
InitJogShuttle
	movea.l	d0,a2		;->ESMessage
	movea.l	ES_Data1(a2),a3	;->RenderCallBack

	GET.l	TB_Screen,a4
	move.w	sc_MouseX(a4),RCB_MouseX(a3)	; to return to when done with TBar
	move.w	sc_MouseY(a4),RCB_MouseY(a3)

	movea.l	RCB_Function(a3),a4		;render function

	lea	wait4lmbup(pc),a1		;assume LBM is down
	CALLTL	IsLMBdown
	tst.l	d0
	bne.s	100$
	lea	wait4rmbup(pc),a1		;assume RBM is down

100$	movem.l	a0-a1,-(sp)
	movea.l	RCB_FG(a3),a0
	XLEA	MyClipAction,a1
	move.b	#RT_IMMED,ca_ReturnTime(a1)
	bsr	StuffCAparams2		;Need to stuff vid start/stop
	movem.l	(sp)+,a0-a1		;& Aud start/stop so can change as jog
	rts

*-------------------------------
* On entry, make sure interrupts are on here
*  a2->ESmessage
*  a3->RCBstruct
*
* Nothing returned

FinishJogShuttle
	move.w	RCB_MouseX(a3),d0	; to return to when done with TBar
	move.w	RCB_MouseY(a3),d1
	CALLTL	MoveSoftSpriteABS	; reposition the SoftSprite

	move.l	RCB_Frame(a3),d0
***!!!! Hacked to avoid non-color frame calls (only Field I accepted)
	andi.l	#~%11,d0
	move.l	d0,RCB_Frame(a3)

	move.l	d0,ES_Reply(a2)	;final position
	rts

*********************************************************

*----------------------------
 STRUCTURE	ShuttleTBL,0

* FieldsPerFrame is never zero (use as forward table marker)
	UWORD STBL_FieldsPerFrame  ;1=field, 2=2 field frame, 4=color frame, (NEVER 0)

	WORD  STBL_NormalStep
	UWORD STBL_FramesPerSkip   	; -1 !!!!
	WORD  STBL_SkipStep
	UWORD STBL_SkipsPerSpeedChange	; -1 !!!!

	WORD   STBL_VelocityNumerator
	UWORD  STBL_VelocityDenominator

	WORD  STBL_DeltaXCenter

* DeltaX is never zero (use as reverse table marker)
	WORD  STBL_DeltaXMax

 LABEL	 STBL_SIZEOF
*----------------------------

SHUTTLELIMIT	EQU 30	;How many mouse clicks before goes into Shuttle mode
SHUTTLEWIDTH 	EQU 500	;zero is at SHUTTLEWIDTH/2

;;NUMSPEEDS 	EQU 23	;zero counts as 2 speeds
NUMSPEEDS	EQU 43

	dc.w	0	;reverse table marker

* One STRUCT ShuttleTBL for each speed.

ShuttleTable:

	dc.w	1,-1,0,-62,31,-63,1,SHUTTLEWIDTH*1/(NUMSPEEDS*2),SHUTTLEWIDTH*1/NUMSPEEDS	;-63
	dc.w	1,-1,0,-30,31,-31,1,SHUTTLEWIDTH*3/(NUMSPEEDS*2),SHUTTLEWIDTH*2/NUMSPEEDS	;-31
	dc.w	1,-1,0,-14,31,-15,1,SHUTTLEWIDTH*5/(NUMSPEEDS*2),SHUTTLEWIDTH*3/NUMSPEEDS	;-15
	dc.w	1,-1,0,-6,31,-7,1,SHUTTLEWIDTH*7/(NUMSPEEDS*2),SHUTTLEWIDTH*4/NUMSPEEDS	;-7
	dc.w	1,-1,0,-2,31,-3,1,SHUTTLEWIDTH*9/(NUMSPEEDS*2),SHUTTLEWIDTH*5/NUMSPEEDS	;-3
	dc.w	4,-4,0,-4,7,-2,1,SHUTTLEWIDTH*11/(NUMSPEEDS*2),SHUTTLEWIDTH*6/NUMSPEEDS	;-2

ShuttleREW:
	dc.w	2,0,0,-2,15,-1,1,SHUTTLEWIDTH*24/(NUMSPEEDS*2),SHUTTLEWIDTH*18/NUMSPEEDS	;-1

;;	dc.w	4,0,1,-4,3,-1,2,SHUTTLEWIDTH*15/(NUMSPEEDS*2),SHUTTLEWIDTH*8/NUMSPEEDS	;-1/2
;;	dc.w	4,0,3,-4,1,-1,4,SHUTTLEWIDTH*17/(NUMSPEEDS*2),SHUTTLEWIDTH*9/NUMSPEEDS	;-1/4
;;	dc.w	4,0,7,-4,0,-1,8,SHUTTLEWIDTH*19/(NUMSPEEDS*2),SHUTTLEWIDTH*10/NUMSPEEDS	;-1/8

* Velocity = (NormalStep+(SkipStep/(FramesPerSkip+1)))/FieldsPerFrame
*
* #fields/outputchange=FieldsPerFrame*(FramesPerSkip+1)
* #fields/speedchange=FieldsPerFrame*(FramesPerSkip+1)*(SkipsPerSpeedChange+1)
* a*(c+1)*(e+1)
*
*               +---------- FieldsPerFrame = FrameSize, how often updated
*               | +-------- NormalStep     = equals FrameSize, or 0 if <= 1X
*               | | +------ FramesPerSkip+1 = # of Frames before a Skip
*               | | | +---- SkipStep        = How far to skip (added to normal step)
*               | | | | +-- SkipsPerSpeedChange+1 = # of skips before change
*               | | | | |
*               a,b,c,d,e
*               ---------

ShuttleStop:
	dc.w	4,0,0,0,0,0,1,SHUTTLEWIDTH*42/(NUMSPEEDS*2),SHUTTLEWIDTH*24/NUMSPEEDS		;4 field freeze = 0x

;;	dc.w	4,0,7,4,0,1,8,SHUTTLEWIDTH*25/(NUMSPEEDS*2),SHUTTLEWIDTH*13/NUMSPEEDS		;1/8  = (0+(4/8))/4
;;	dc.w	4,0,3,4,1,1,4,SHUTTLEWIDTH*27/(NUMSPEEDS*2),SHUTTLEWIDTH*14/NUMSPEEDS		;1/4  = (0+(4/4))/4
;;	dc.w	4,0,1,4,3,1,2,SHUTTLEWIDTH*29/(NUMSPEEDS*2),SHUTTLEWIDTH*15/NUMSPEEDS		;1/2  = (0+(4/2))/4

ShuttleFF:
	dc.w	4,0,0,4,7,1,1,SHUTTLEWIDTH*60/(NUMSPEEDS*2),SHUTTLEWIDTH*36/NUMSPEEDS		;1    = (0+(4/1))/4

NUMSLOW EQU	36
	dc.w	4,4,0,4,7,2,1,SHUTTLEWIDTH*(1*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(1+NUMSLOW)/NUMSPEEDS		;2    = (4+(4/1))/4
	dc.w	2,2,0,4,15,3,1,SHUTTLEWIDTH*(2*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(2+NUMSLOW)/NUMSPEEDS	;3    = (2+(4/1))/2
	dc.w	1,1,0,4,31,5,1,SHUTTLEWIDTH*(3*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(3+NUMSLOW)/NUMSPEEDS	;5    = (1+(4/1))/1
	dc.w	1,1,0,8,31,9,1,SHUTTLEWIDTH*(4*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(4+NUMSLOW)/NUMSPEEDS	;9    = (1+(8/1))/1
	dc.w	1,1,0,16,31,17,1,SHUTTLEWIDTH*(5*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(5+NUMSLOW)/NUMSPEEDS	;17   = (1+(16/1))/1
	dc.w	1,1,0,32,31,33,1,SHUTTLEWIDTH*(6*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(6+NUMSLOW)/NUMSPEEDS	;33   = (1+(32/1))/1
	dc.w	1,1,0,64,31,65,1,SHUTTLEWIDTH*(7*2+2*NUMSLOW-1)/(NUMSPEEDS*2),SHUTTLEWIDTH*(7+NUMSLOW)/NUMSPEEDS	;65   = (1+(64/1))/1

	dc.w	0	;forward table marker

	CNOP	0,4

****** Hand_Shuttle *****************************************************
*
*   NAME
*	Hand_Shuttle
*
*   SYNOPSIS
*	Hand_Shuttle(message)
*	               d0
*
*   FUNCTION
*	Moves thru a clip at various rates
*
*   INPUTS
*	Data1   - rendercallback
*
*   RESULT
*	ES_Reply  -  Final field
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************

FIXEDSPEED	set	1	;if defined FF/REW only at 1x or -1x
;;ALLOWFFREW	set	1	;FF/REW allowed before shuttle. Must move SHUTTLELIMIT first.

Hand_Shuttle:
	DEBUGMSG	DBHD,<Hand_Shuttle:>

	bsr	InitJogShuttle

*  a1->abort function
*  a2->ESmessage
*  a3->RCBstruct
*  a4->RenderCall

	lea	ShuttleFF(pc),a6	;assume FF
	tst.b	RCB_Flags(a3)
	bpl.s	10$
	lea	ShuttleREW(pc),a6

*d0/d1 will be used by DeltaXMouse
* a6->current location of Shuttle data

10$	moveq	#0,d2			;accum mouse X
	move.l	RCB_Frame(a3),d3	;current frame counter

	CALLTL	SoftSpriteOff

	IFD	ALLOWFFREW
	CALLTL	DeltaXMouse	;d1=initial mouse X
	ENDC

**!!! TURN OFF MOST INTERRUPTS!!!!

20$	move.w	STBL_SkipsPerSpeedChange(a6),d4	;step counter

30$	move.w	STBL_FramesPerSkip(a6),d5

	IFD	ALLOWFFREW
*---------
* Crop to legal frame numbers
40$	cmp.l	RCB_Min(a3),d3
	bge.s	42$
	move.l	RCB_Min(a3),d3
	bra.s	47$

42$	cmp.l	RCB_Max(a3),d3
	ble.s	48$
	move.l	RCB_Max(a3),d3
47$	lea	ShuttleStop(pc),a6	;force it to stopped if end reached

* This makes sure I'm asking for the correct type of frame
48$	move.w	STBL_FieldsPerFrame(a6),d0
	subq.w	#1,d0		;1,2,4 -> 0,1,3
	not.w	d0		;-> %..1111, %..1110, %..1100
	and.w	d0,d3		;round down
	move.l	d3,RCB_Frame(a3)

*---------
***!!!! Hacked to avoid non-color frame calls (only Field I accepted)
	move.w	d3,d0
	andi.w	#3,d0
	bne.s	70$

	XLEA	MyClipAction,a0

	move.b	ca_Flags(a0),d7
	btst	#CAB_VIDEO,d7
	beq.s	72$
	move.l	d3,ca_VidStartField(a0)

72$	andi.b	#CAF_AUDIOL!CAF_AUDIOR,d7
	beq.s	73$
	move.l	d3,ca_AudStartField(a0)

73$	XJSR	Flyer_DoFindField	;will indicate 1,2 or 4 fields

	movea.l	a3,a0
	movem.l	d1-d7/a1-a6,-(sp)
	jsr	(a4)
	movem.l	(sp)+,d1-d7/a1-a6

	XLEA	MyClipAction,a0
	XJSR	Flyer_WaitAction	;wait until 1, 2 or 4 fields starts

70$	jsr	(a1)
	bne	ShuttleAbort	;abort

*---------
	CALLTL	DeltaXMouse	;d0 = delta
	add.w	d0,d2		;accum

	cmpi.w	#-SHUTTLELIMIT,d2
	ble	DoShuttle	;jump if reached lowest shuttle limit
	cmpi.w	#SHUTTLELIMIT,d2
	bge	DoShuttle	;jump if reached highest shuttle limit

*---------
	move.w	STBL_NormalStep(a6),d0
	ext.l	d0
	add.l	d0,d3

	dbra	d5,40$		;--FramesPerSkip

	move.w	STBL_SkipStep(a6),d0
	ext.l	d0
	add.l	d0,d3

	dbra	d4,30$		;--SkipsPerSpeedChange

*--------------
	IFD	FIXEDSPEED
	bra	20$
	ENDC

	IFND	FIXEDSPEED
	tst.b	RCB_Flags(a3)
	bpl.s	60$		;forward

* Reverse
	lea	-STBL_SIZEOF(a6),a0
	tst.w	STBL_DeltaXMax(a0)
	bra.s	65$

* Forward
60$	lea	STBL_SIZEOF(a6),a0
	tst.w	STBL_FieldsPerFrame(a0)
65$	beq	20$	;jump reached end of table
	movea.l	a0,a6	;new Shuttle data
	bra	20$
	ENDC

DoShuttle:  ;see above Fall Thru!!!

    ENDC 	;IFD ALLOWFFREW

* IFND ALLOWFFREW THIS WILL FALL THRU TO doing Shuttle!!!!!

**********************************
* Go into Shuttle Mode
*

* a6->current ShuttleTBL, d5=FramesPerSkip counter, d3=Frame

* This is the standard shuttle code.

shuttlestart:	;aren't really using this label

	CALLTL	DeltaXMouse		 ;d1=initial mouse X
	move.w	STBL_DeltaXCenter(a6),d2 ;initial xy

*  a1->abort function
*  a2->ESmessage
*  a3->RCBstruct
*  a4->RenderCall

*---------
* Get new shuttle position, and crop to limits
5$	CALLTL	DeltaXMouse	;d0 = delta
	add.w	d0,d2		;accum
	bpl.s	8$
	moveq	#0,d2		;don't allow <0
	bra.s	9$
8$	cmpi.w	#SHUTTLEWIDTH,d2
	bls.s	9$
	move.w	#SHUTTLEWIDTH,d2 ;don't allow beyond limit

*----------------------
* Find what Speed I'm shuttling at, d2=SHUTTLE position
9$	lea	ShuttleTable(pc),a0
	bra.s	15$
10$	lea	STBL_SIZEOF(a0),a0
15$	cmp.w	STBL_DeltaXMax(a0),d2
	bhi.s	10$
	cmpa.l	a0,a6
	beq.s	20$		;jump if same Shuttle Tbl
*----------------------

* a0->New Shuttle Table
	movea.l	a0,a6
	move.w	STBL_FramesPerSkip(a6),d5

* a6->Same Shuttle Table
20$	move.w	STBL_NormalStep(a6),d0
	ext.l	d0
	add.l	d0,d3

	dbra	d5,40$		;--FramesPerSkip
	move.w	STBL_FramesPerSkip(a6),d5

	move.w	STBL_SkipStep(a6),d0
	ext.l	d0
	add.l	d0,d3

*---------
* Crop to legal frame numbers
40$	cmp.l	RCB_Min(a3),d3
	bge.s	42$
	move.l	RCB_Min(a3),d3
	bra.s	47$

42$	cmp.l	RCB_Max(a3),d3
	ble.s	48$
	move.l	RCB_Max(a3),d3

* may or maynot be a new speed (could already be stopped)
47$	lea	ShuttleStop(pc),a0	;end reached, so force it to stopped
	move.w	STBL_DeltaXCenter(a0),d2	;a6 will get updated later

*---------

* This makes sure I'm asking for the correct type of frame
48$	move.w	STBL_FieldsPerFrame(a6),d0
	subq.w	#1,d0		;1,2,4 -> 0,1,3
	not.w	d0		;-> %..1111, %..1110, %..1100
	and.w	d0,d3		;round down
	move.l	d3,RCB_Frame(a3)

	move.w	STBL_VelocityNumerator(a6),RCB_VelocityNumerator(a3)
	move.w	STBL_VelocityDenominator(a6),RCB_VelocityDenominator(a3)

*---------
***!!!! Hacked to avoid non-color frame calls (only Field I accepted)
	move.w	d3,d0
	andi.w	#3,d0
	bne 	70$

	XLEA	MyClipAction,a0

	move.b	ca_Flags(a0),d4
	btst	#CAB_VIDEO,d4
	beq.s	72$
	move.l	d3,ca_VidStartField(a0)

72$	andi.b	#CAF_AUDIOL!CAF_AUDIOR,d4
	beq.s	73$
	move.l	d3,ca_AudStartField(a0)

*-------------------
***!!! Do we want these volumes to be based on the user set volume??
** Yes PF, this is more of that skell cut/past code!!DEH
73$	clr.l	ca_VolSust1(a0) ;assume stopped (assume VolSus1 is after VolSus2!!!)

	move.w	RCB_VelocityNumerator(a3),d4
	beq.s	52$		;jump if want no volume on Still, speed=0

	bpl.s	55$
	neg.w	d4

*-----
55$	move.w	MyAudioVolume1,d0	;assume +/- 1x
	beq.s	51$
*	cmp.w	RCB_VelocityDenominator(a3),d4
*	bls.s	50$		;jump if speed <= 1
* calculate volume1
*	mulu	RCB_VelocityDenominator(a3),d0
*	divu	d4,d0
50$
;	DUMPREG	<vol de in d4>

	cmp.w	#8,d4			;if Vel donom>8 then vol/2 
	bls	33$
	lsr.w	#1,d0
33$			
	move.w	d0,ca_VolSust1(a0)



*-----
51$	move.w	MyAudioVolume2,d0	;assume +/- 1x
	beq.s	52$
*	cmp.w	RCB_VelocityDenominator(a3),d4
*	bls.s	53$			;jump if speed <= 1
* calculate volume1
*	mulu	RCB_VelocityDenominator(a3),d0
*	divu	d4,d0
53$
	cmp.w	#8,d4			;if Vel donom>8 then vol/2
	bls	34$
	lsr.w	#1,d0
34$
	move.w	d0,ca_VolSust2(a0)

*-------------------

52$	XJSR	Flyer_DoFindField	;will indicate 1,2 or 4 fields

	movea.l	a3,a0
	movem.l	d1-d7/a1-a6,-(sp)
	jsr	(a4)
	movem.l	(sp)+,d1-d7/a1-a6

	XLEA	MyClipAction,a0
	XJSR	Flyer_WaitAction	;wait until 1, 2 or 4 fields starts

70$	jsr	(a1)
	bne	ShuttleAbort	;abort
	bra	5$

*------------------------------
ShuttleAbort:
	bsr	FinishJogShuttle

**!!! TURN ON MOST INTERRUPTS!!!!

	CALLTL	SoftSpriteOn
	rts

****** Hand_InitPlay *****************************************************
*
*   NAME
*	Hand_InitPlay
*
*   SYNOPSIS
*	Hand_InitPlay(message)
*	               d0
*
*   FUNCTION
*	Sets up the Flyer for playing
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  cleared
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_InitPlay:
	DEBUGMSG	DBHD,<Hand_InitPlay:>

	move.l	d0,a1
	bsr	InitFlyerPlay

	move.l	d0,ES_Reply(a1)
	rts

******************************
* ERROR = InitFlyerPlay()

	XDEF	InitFlyerPlay
InitFlyerPlay:
	bsr	AbortPlayRec

	XJSR	Flyer_DefaultSelect

	clr.w	RecordModeFlag

	moveq	#0,d0		;no specific board
	XJSR	Flyer_PlayMode
	rts

****** Hand_FlyerDriveInfo *****************************************************
*
*   NAME
*	Hand_FlyerDriveInfo
*
*   SYNOPSIS
*	Hand_FlyerDriveInfo(message)
*	               d0
*
*   FUNCTION
*	Get info about a particular drive
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  ->FlyerVolInfo
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_FlyerDriveInfo:
	DEBUGMSG	DBHD,<Hand_FlyerDriveInfo:>

	move.l	d0,a2
	movea.l	ES_Data1(a2),a0		;name
	movea.l	ES_Data2(a2),a1		;FlyerVolInfo  ;Maybe NULL

	XJSR	Flyer_GetVolumeInfo

	move.l	d0,ES_Reply(a2)
	rts

****** Hand_FlyerClipInfo *****************************************************
*
*   NAME
*	Hand_FlyerClipInfo
*
*   SYNOPSIS
*	Hand_FlyerClipInfo(message)
*	               d0
*
*   FUNCTION
*	Get info about a particular clip
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  ->ClipInfo
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_FlyerClipInfo:
	DEBUGMSG	DBHD,<Hand_FlyerClipInfo:>

	move.l	d0,a2
	movea.l	ES_Data1(a2),a0		;name
	movea.l	ES_Data2(a2),a1		;ClipInfo  ;Maybe NULL

	XJSR	Flyer_GetClipInfo

	move.l	d0,ES_Reply(a2)
	rts

****** Hand_CompressionMode *****************************************************
*
*   NAME
*	Hand_CompressionMode
*
*   SYNOPSIS
*	Hand_CompressionMode(message)
*	               d0
*
*   FUNCTION
*	Setup a record with a particular compression mode.
*	OLD WAY: 0=standard, 1=extended
*	3/6/95 Way: Low Nibble is mode (0-4), High Nibble is DriveSpeed (0,1)
*		To recreate the old way, extended mode, use 3 instead of 1 with drive speed 0
*		Now editor will directly pass mode for flyer (worst will still be wired to 4)
*
*   INPUTS
*
*   RESULT
*	ES_Reply  - error
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_CompressionMode:
	DEBUGMSG	DBHD,<Hand_CompressionMode:>

	move.l	d0,a0

	moveq.l	#0,d0		;all boards ???
	moveq.l	#4,d2		;worst mode
	moveq.l	#0,d3		;strategy = auto-switching via compressed size

***	moveq.l	#0,d1		;assume standard record
***	tst.l	ES_Data1(a0)
***	beq.s	20$
* extended mode
***	moveq.l	#3,d1		;2=Subnyquist, but 3 is OK and longer
	move.l	ES_Data1(a0),d1
	DUMPREG	<d1 compression mode in switcher>
20$	XJSR	Flyer_VideoCompressModes

	move.l	d0,ES_Reply(a0)
	rts


****** Hand_RecordSource *****************************************************
*
*   NAME
*	Hand_RecordSource
*
*   SYNOPSIS
*	Hand_RecordSource(message)
*	               d0
*
*   FUNCTION
*	Setup toaster output for a given record source
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  error
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_RecordSource:
	DEBUGMSG	DBHD,<Hand_RecordSource:>

	move.l	d0,a1
	clr.l	ES_Reply(a1)		;assume no errors

* see AudioControl
;;	move.w	ES_Data2+2(a1),MyRecordAudioGain1
;;	move.w	ES_Data3+2(a1),MyRecordAudioGain2

	move.l	ES_Data1(a1),d0		;video source
	move.w	d0,RecordVideo

;;	DUMPSDEC.l	<Source=>,d0,<\\>

	XJSR	Flyer_InputSelect
	rts

****** Hand_AudioControl *****************************************************
*
*   NAME
*	Hand_AudioControl
*
*   SYNOPSIS
*	Hand_AudioControl(message)
*	               d0
*
*   FUNCTION
*	Control record gain, get Overdrive indication, etc.
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  error
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_AudioControl:
	DEBUGMSG	DBHD,<Hand_AudioControl:>

	move.l	d0,a1

	move.l	ES_Data1(a1),a0		;->FlyAudCtrl
	move.l	ES_Data2(a1),d1		;flags

* just stashing the Gain for fun
	btst	#FACOB_SETGAIN,d1
	beq.s	10$
	moveq	#0,d0
	move.b	fac_LeftGain(a0),MyRecordAudioGain1
	move.b	fac_RightGain(a0),MyRecordAudioGain2

10$	moveq	#0,d0		;all boards
	XJSR	Flyer_AudioCtrl
	move.l	d0,ES_Reply(a1)
	rts

****** Hand_InitRecord *****************************************************
*
*   NAME
*	Hand_InitRecord
*
*   SYNOPSIS
*	Hand_InitRecord(message)
*	               d0
*
*   FUNCTION
*	Sets up the Flyer for playing
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  cleard
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_InitRecord:
	DEBUGMSG	DBHD,<Hand_InitRecord:>


	move.l	d0,a1
	bsr	AbortPlayRec

	moveq	#0,d0		;no specific board
	XJSR	Flyer_RecordMode

	move.w	#1,RecordModeFlag

	move.l	d0,ES_Reply(a1)
	rts


****** Hand_DefragFlyer *****************************************************
*
*   NAME
*	Hand_DefragFlyer
*
*   SYNOPSIS
*	Hand_DefragFlyer(message)
*	                   d0
*
*   FUNCTION
*	Sets up the Flyer for playing
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  error
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_DefragFlyer:
	DEBUGMSG	DBHD,<Hand_DefragFlyer:>

	move.l	d0,a1
	move.l	ES_Data1(a1),a0

	XJSR	Flyer_VoidCardHeads	;free up as much space as possible
	XJSR	Flyer_DeFrag

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_CheckRecord *****************************************************
*
*   NAME
*	Hand_CheckRecord
*
*   SYNOPSIS
*	Hand_CheckRecord(message)
*	                   d0
*
*   FUNCTION
*	Sees if the Flyer is still recording (or Playing???)
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  =0 = FERR_OKAY if recording finished OK
*                    = FERR_BUSY if not done
*                    = FERR_??? if ran out of room
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_CheckRecord:
	DEBUGMSG	DBHD,<Hand_CheckRecord:>

	move.l	d0,a1

	XLEA	MyClipAction,a0
	XJSR	Flyer_CheckAction

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_ChangeAudio *****************************************************
*
*   NAME
*	Hand_ChangeAudio
*
*   SYNOPSIS
*	Hand_ChangeAudio(message)
*	                   d0
*
*   FUNCTION
*	Sees if the Flyer is still recording
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  =0 = FERR_OKAY if recording finished OK
*                    = FERR_BUSY if not done
*                    = FERR_??? if ran out of room
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_ChangeAudio:
	DEBUGMSG	DBHD,<Hand_ChangeAudio:>

	move.l	d0,a2

	movea.l	ES_Data1(a2),a0		;FG
	XLEA	MyClipAction,a1
	bsr	StuffCAparams

	movea.l	a1,a0			;->CA
	XJSR	Flyer_ChangeAudio

	move.l	d0,ES_Reply(a2)
	rts

****** Hand_Pause *****************************************************
*
*   NAME
*	Hand_Pause
*
*   SYNOPSIS
*	Hand_Pause(message)
*	                   d0
*
*   FUNCTION
*	Start/Stop Flyer recording (or maybe Play??)
*
*   INPUTS
*
*   RESULT
*	ES_Reply  = Error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Pause
	DEBUGMSG	DBHD,<Hand_Pause:>

	move.l	d0,a1

	XLEA	MyClipAction,a0
	move.l	ES_Data1(a1),d0
	XJSR	Flyer_PauseAction

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_StartClipCutList *****************************************************
*
*   NAME
*	Hand_StartClipCutList
*
*   SYNOPSIS
*	Hand_StartClipCutList(message)
*	                   d0
*
*   FUNCTION
*	Set up for making destructive, or non-destructive clip cutting
*
*   INPUTS
*
*   RESULT
*	ES_Reply  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_StartClipCutList
	DEBUGMSG	DBHD,<Hand_StartClipCutList:>

	move.l	d0,a1

	XLEA	MyClipAction,a0
	XJSR	Flyer_Defaults

	movea.l	ca_Volume(a0),a2
	move.l	ES_Data1(a1),fv_Path(a2)	;->name
	move.l	ES_Data2(a1),d0
	XJSR	Flyer_StartClipCutList

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_AddClipCut *****************************************************
*
*   NAME
*	Hand_AddClipCut
*
*   SYNOPSIS
*	Hand_AddClipCut(message)
*	                   d0
*
*   FUNCTION
*	Specified info about a particular clip cut.  Done after StartClipCutList.
*
*   INPUTS
*
*   RESULT
*	ES_Reply = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_AddClipCut
	DEBUGMSG	DBHD,<Hand_AddClipCut:>

	move.l	d0,a1

	XLEA	MyClipAction,a0
	XJSR	Flyer_Defaults

	movea.l	ca_Volume(a0),a2
	move.l	ES_Data1(a1),fv_Path(a2)	;->name

	move.l	ES_Data4(a1),d0
	move.b	d0,ca_Flags(a0)

	btst	#CAB_VIDEO,d0
	beq.s	30$
	move.l	ES_Data2(a1),ca_VidStartField(a0)
	move.l	ES_Data3(a1),ca_VidFieldCount(a0)

30$	andi.b	#CAF_AUDIOL!CAF_AUDIOR,d0
	beq.s	40$
	move.l	ES_Data2(a1),ca_AudStartField(a0)
	move.l	ES_Data3(a1),ca_AudFieldCount(a0)

40$	XJSR	Flyer_AddClipCut

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_EndClipCutList *****************************************************
*
*   NAME
*	Hand_EndClipCutList
*
*   SYNOPSIS
*	Hand_EndClipCutList(message)
*	                   d0
*
*   FUNCTION
*	Create the cuts that have been made via AddClipCut
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_EndClipCutList
	DEBUGMSG	DBHD,<Hand_EndClipCutList:>

	move.l	d0,a1

;;	XLEA	MyClipAction,a0		;THIS IS NO LONGER REQUIRED
	move.l	ES_Data1(a1),d0
	XJSR	Flyer_EndClipCutList

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_StartHeadList *****************************************************
*
*   NAME
*	Hand_StartHeadList
*
*   SYNOPSIS
*	Hand_StartHeadList(message)
*	                   d0
*
*   FUNCTION
*	Set up ALL boards for making clip heads
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_StartHeadList:
	DEBUGMSG	DBHD,<Hand_StartHeadList:>

	move.l	d0,a1

	moveq	#0,d0			;all boards!!!
	XJSR	Flyer_StartHeadList

	move.l	d0,ES_Reply(a1)
	rts


****** Hand_EndHeadList *****************************************************
*
*   NAME
*	Hand_EndHeadList
*
*   SYNOPSIS
*	Hand_EndHeadList(message)
*	                   d0
*
*   FUNCTION
*	Create the heads that have been made via MakeClipHead
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_EndHeadList:
	DEBUGMSG	DBHD,<Hand_EndHeadList:>

	move.l	d0,a1

	moveq	#0,d0		;all boards!!!
	moveq	#1,d1		;don't abort, really do it!
	XJSR	Flyer_EndHeadList

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_MakeClipHead *****************************************************
*
*   NAME
*	Hand_MakeClipHead
*
*   SYNOPSIS
*	Hand_MakeClipHead(message)
*	                   d0
*
*   FUNCTION
*	Create the heads that have been made via MakeClipHead
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_MakeClipHead:
	DEBUGMSG	DBHD,<Hand_MakeClipHead:>

	move.l	d0,a1

	XLEA	MyClipAction,a0
	XJSR	Flyer_Defaults

	movea.l	ca_Volume(a0),a2
	move.l	ES_Data1(a1),fv_Path(a2)	;->name

	move.l	ES_Data2(a1),ca_VidStartField(a0)
	move.l	ES_Data3(a1),ca_VidFieldCount(a0)
	move.l	ES_Data4(a1),ca_AudStartField(a0)
	move.l	ES_Data5(a1),ca_AudFieldCount(a0)

	XJSR	Flyer_MakeClipHead

	move.l	d0,ES_Reply(a1)
	rts

****** Hand_MakeClipIcon *****************************************************
*
*   NAME
*	Hand_MakeClipIcon
*
*   SYNOPSIS
*	Hand_MakeClipIcon(message)
*	                   d0
*
*   FUNCTION
*	Create an ".i" icon file for a clip
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_MakeClipIcon:
	DEBUGMSG	DBHD,<Hand_MakeClipIcon:>

	move.l	d0,a2
	move.l	ES_Data1(a2),a0	;name
	move.l	ES_Data2(a2),a1	;->CrUD
	move.l	ES_Data3(a2),d0 ;CrUD size
	move.l	ES_Data4(a2),d1 ;Field#

	CALLTL	MakeClipIcon

	move.l	d0,ES_Reply(a2)
	rts

****** Hand_AppendIcon *****************************************************
*
*   NAME
*	Hand_AppendIcon
*
*   SYNOPSIS
*	Hand_AppendIcon(message)
*	                   d0
*
*   FUNCTION
*	Addes the ".i" icon file to the data file for redundency.
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_AppendIcon:
	DEBUGMSG	DBHD,<Hand_AppendIcon:>

	move.l	d0,a1

	move.l	ES_Data1(a1),a0	;name
	CALLTL	AppendClipIcon
	move.l	d0,ES_Reply(a1)
	rts

****** Hand_SetPrefs *****************************************************
*
*   NAME
*	Hand_SetPrefs
*
*   SYNOPSIS
*	Hand_SetPrefs(message)
*	                   d0
*
*   FUNCTION
*	Sets various system global parameters
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
	XREF	MT_GPI

Hand_SetPrefs:
	DEBUGMSG	DBHD,<Hand_SetPrefs:>

	move.l	d0,a2
	move.l	ES_Data1(a2),a0		;->SystemPrefs structure

* Set VID3/VID4
	moveq	#0,d0
	btst.b	#spB_FlyerVID3,spref_Flags1(a0)
	beq.s	5$
	bset	#FLYER3_BIT,d0
5$	btst.b	#spB_FlyerVID4,spref_Flags1(a0)
	beq.s	8$
	bset	#FLYER4_BIT,d0		;d0=mask of desired settings

8$	GET.b	TB_Flags4,d1
	eor.b	d1,d0			;compare against current settings
	andi.b	#FLYER3_MASK!FLYER4_MASK,d0
	beq.s	9$

* New VID3 or VID4 settings
	andi.b	#~(FLYER3_MASK!FLYER4_MASK),TB_Flags4(a5)	;turn off VID3/VID4 bits
	btst.b	#spB_FlyerVID3,spref_Flags1(a0)
	beq.s	40$
	bset.b	#FLYER3_BIT,TB_Flags4(a5)
40$	btst.b	#spB_FlyerVID4,spref_Flags1(a0)
	beq.s	45$
	bset.b	#FLYER4_BIT,TB_Flags4(a5)
45$	bsr	SetupToasterMux		;gets d1/d2
	moveq	#0,d0	;all boards!!
	moveq	#0,d3	;Standard Toaster PRVW (not CAMcorder)
	XJSR	Flyer_ToasterMux

*------------------------------
* Set termination
9$	moveq	#0,d0
	move.b	spref_Termination(a0),d0
	PUT.w	d0,TB_InputTerm
	DEA	TB_VTSetUp,a1
	ELHPUT_TERM_R	a1,d0

* Set 2/3 Monitor
	moveq.l	#0,d0
	btst.b	#spB_PrvwOLay,spref_Flags1(a0)
	beq.s	10$
	moveq.l	#-1,d0
10$	PUT.w	d0,TB_UserOn
	bne.s	20$
	ELHCLEAR_USERON	a1		; denote user interface is off
	ELHCLEAR_PVMUTE a1
	bra.s	30$

20$	ELHSET_USERON	a1		; denote user interface is on
	ELHSET_PVMUTE	a1

30$	btst.b	#AVEI_BIT,TB_Flags(a5)
	beq.s	35$
	CALLTL	InstallAVEIdoELH	; New AVEI colors if possible
	bra.s	50$
35$	CALLTL	SendELH2Toaster

* Set GPI
50$	moveq	#0,d2
	move.b	spref_GPI(a0),d2

	XCALL	ObtainSwitcherGPISettings	; get current state of GPI
	cmp.l	d0,d2
	beq	100$				; ...if all is already setup

	pea	MT_GPI			; reset previous config GPI FG
	move.l	sp,a0
	XCALL	IndexFastG
	move.l	d0,a0
	clr.w	FG_HiLiteMask(a0)

	move.l	d2,d0			; setup the new config GPI FG
	move.l	sp,a0
	XCALL	IndexFastG
	lea	4(sp),sp
	move.l	d0,a0
	move.b	FG_HiLiteVal(a0),d0
	move.b	d0,FG_HiLiteMask(a0)
	move.b	d0,FG_HiLiteMask+1(a0)

	move.l	d2,d0				; install the new GPI
	XCALL	ChangeSwitcherGPISettings	; settings

100$
;;	CALLTL	WriteHardSets		;Should I use WriteHardSets????
;;	move.l	d0,ES_Reply(a2)		;0=OK, 1=OpenError, 2=Write error

	clr.l	ES_Reply(a2)	;can't fail
	rts

****** Hand_GetPrefs *****************************************************
*
*   NAME
*	Hand_GetPrefs
*
*   SYNOPSIS
*	Hand_GetPrefs(message)
*	                   d0
*
*   FUNCTION
*	Get various system global parameters
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
	XREF	MT_GPI

Hand_GetPrefs:
	DEBUGMSG	DBHD,<Hand_GetPrefs:>

	move.l	d0,a1
	move.l	ES_Data1(a1),a0		;->SystemPrefs structure

	clr.l	(a0)			;clear everything out

* Get termination
	GET.w	TB_InputTerm,d0
	move.b	d0,spref_Termination(a0)

* Get 2/3 Monitor
	tst.w	TB_UserOn(a5)
	beq.s	20$
	bset.b	#spB_PrvwOLay,spref_Flags1(a0)

* Get VID3 state
20$	btst.b	#FLYER3_BIT,TB_Flags4(a5)
	beq.s	30$
	bset.b	#spB_FlyerVID3,spref_Flags1(a0)

* Get VID4 state
30$	btst.b	#FLYER4_BIT,TB_Flags4(a5)
	beq.s	100$
	bset.b	#spB_FlyerVID4,spref_Flags1(a0)

* Get GPI
100$	XCALL	ObtainSwitcherGPISettings	; get current state of GPI
	move.b	d0,spref_GPI(a0)

	clr.l	ES_Reply(a1)		;no errors possible
	rts

****** Hand_SavePrefs *****************************************************
*
*   NAME
*	Hand_SavePrefs
*
*   SYNOPSIS
*	Hand_SavePrefs(message)
*	                   d0
*
*   FUNCTION
*      Saves an HS file
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  = error, Though we usually ignore errors!
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_SavePrefs:
	DEBUGMSG	DBHD,<Hand_SavePrefs:>

	movea.l	d0,a0
	CALLTL	WriteHardSets		;Should I use WriteHardSets????
	move.l	d0,ES_Reply(a0)		;0=OK, 1=OpenError, 2=Write error
	rts

*******************************************************************
AbortPlayRec
	movem.l	d0/a0,-(sp)
	suba.l	a0,a0

	XJSR	Flyer_AbortAction	;kill all actions

	movem.l	(sp)+,d0/a0
	rts

****** Hand_PanelOpen ***********************************************************
*
*   NAME
*	Hand_PanelOpen
*
*   SYNOPSIS
*	Hand_PanelOpen(message) (FG)
*	                d0
*
*   FUNCTION
*	Prepare flyer for Jog/Shuttle/Jump
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_PanelOpen
	DEBUGMSG	DBHD,<Hand_PanelOpen:>

	move.l	d0,a2
	move.l	ES_Data1(a2),a3		;crouton
	clr.l	ES_Reply(a2)		;assume no errors

******
*-----------------
** THIS HACK TURNS A FRAMESTORE IN DV1 INTO 4 FIELDS OF CYCLING DATA.
** THE TOP 1/4 OF THE SOURCE = FIELD I OF DESTINATION
** THE NEXT 1/4 OF THE SOURCE = FIELD II OF DESTINATION
** THE NEXT 1/4 OF THE SOURCE = FIELD III OF DESTINATION
** THE BOTTOM 1/4 OF THE SOURCE = FIELD IV OF DESTINATION
** YOU SHOULD AVOID COLORS IN YOUR SOURCE.
** THIS WAS USED TO CREATE THE 4FieldCount FrameStore.

	IFD	CRAP
	movem.l	d0-d7/a0-a6,-(sp)

	CALLTL	AllInterruptsOff
	CALLTL	InstallAVE

	move.l	#(480/2)-1,d3	;line counter for field I/II data

662$	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
    	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1
	moveq	#0,d0		;bank

	move.l	d3,d1
	addq.w	#1,d1

* ~ReadScanLine(->destbuff, ->destcomp, ->TB, bank, scanline)
*		   a0	      a1	a5    d0     d1
	CALLTL	ReadScanLine

	lea	768(a0),a0
	lea	768(a1),a1
	add.w	#(480/2),d1	;line number for field III or IV line

	CALLTL	ReadScanLine

	lea	-768(a1),a1
	move.w	#752-1,d0
664$	move.b	(a0)+,(a1)+
	dbra	d0,664$

*----
	movea.l	TB_EffectsBase+EFB_BuffA(a5),a0
    	movea.l	TB_EffectsBase+EFB_BuffB(a5),a1

	GET.l	TB_CHIPMem,a2

	move.l	d3,d0
	cmpi.w	#(480/4),d0
	ble.s	665$
	sub.w	#(480/4),d0
	lsl.w	#2,d0
	addq.w	#2,d0
	bra.s	667$

* field I & III line
665$	lsl.w	#2,d0	;*4
	addq.w	#1,d0

667$	moveq	#1,d1		;# of lines
	moveq	#1,d2		;bank DV1

*~SendBytes2Toaster(buffa, buffb, chipchunk, linestart, #lines, bank)
*		      a0     a1    a2	        d0        d1	 d2
	CALLTL	SendBytes2Toaster

	addq.w	#2,d0
	CALLTL	SendBytes2Toaster

	dbra	d3,662$

	CALLTL	ReDoDisplay
	CALLTL	InstallAVEI
	CALLTL	AllInterruptsOn

	movem.l	(sp)+,d0-d7/a0-a6
	bra	666$

	ENDC
*-----------------

***!!!!*** This would be better done with a FGC_PANELOPEN command
	XLEA	MyClipAction,a0
	XJSR	Flyer_Defaults

	cmpi.l	#CrUD_Video,FGS_ObjectType(a3)
	beq.s	5$
	cmpi.l	#CrUD_Audio,FGS_ObjectType(a3)
	beq	6$
	rts
*-----------------------

5$	CALLTL	DoTakeNoKey

* Use opposite channel from what is showing on prvw
	GET.w	TB_PrvwSec,d0
	andi.w	#M_VIDEO3,d0
	beq.s	10$		;jump if Prvw <> VID3

* Use channel 1 = M_VIDEO4
	PUT.w	#M_VIDEO4,TB_MainSec
	move.b	#1,ca_Channel(a0)
	bra.s	20$

* Use channel 0 = M_VIDEO3
10$	PUT.w	#M_VIDEO3,TB_MainSec
	move.b	#0,ca_Channel(a0)

20$	bsr	SetupPlayChannel
	CALLTL	CookAndServeMain

*----
6$	bsr	AbortPlayRec	;to prevent confusion

* a0->ca a3->FG
	movea.l	ca_Volume(a0),a1
	move.l	FGS_FileName(a3),fv_Path(a1)

;;	clr.l	ca_ID(a0)

	move.b	#RT_STOPPED,ca_ReturnTime(a0)

*-----------
	movea.l	a0,a1
	movea.l	a3,a0		;a0->fg, a1->ca
	bsr	StuffCAparams2

	movea.l	a1,a0			;->ca
	XJSR	Flyer_BeginFindField

	lea	FindFieldCA,a1
	clr.l	(a1)			;assume failure
	move.l	d0,ES_Reply(a2)
	bne.s	666$
	move.l	a0,(a1)
666$	rts

*-------------------------------------
* a0->FG, a1->CA
* Determine if audio is wanted (this version forces stereo)
StuffCAparams2
	movem.l	d0-d2,-(sp)
	move.b	#CAPF_STEALOURVIDEO+CAPF_KILLOTHERVIDEO,ca_PermissFlags(a1)
	move.w	#(71<<8)+$80,ca_MatteY(a1)	;71.5 D2 Black

	move.b	#CAF_USEMATTE+CAF_NOPREROLL,d1  ;assume no audio

	clr.w	ca_VolSust1(a1)		;0 volume for any disabled channels
	clr.w	ca_VolSust2(a1)		;0 volume for any disabled channels

	move.l	#TAGID_Duration,d0
	CALLTL	GetLongValue
	beq.s	61$			;jump if no video
	ori.b	#CAF_VIDEO,d1

61$	move.l	#TAGID_AudioOn,d0
	CALLTL	GetLongValue
	move.l	d0,d2

	btst	#AUDB_Channel1Enabled,d2
	beq.s	62$

	move.l	#TAGID_AudioVolume1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust1(a1)	;Always set volume, even if 0
	beq.s	62$			;jump if no audio1
	ori.b	#CAF_AUDIOL,d1

;;	move.l	#TAGID_AudioVolume1,d0
;;	CALLTL	GetLongValue
;;	move.w	d0,ca_VolSust1(a1)
;;***!!! Do we want this volume to be based on the user set volume??
;;	move.w	#$ffff/2,ca_VolSust1(a1) ;this default may be changed before DoFindField
;	move.w	d0,ca_VolSust1(a1)

	move.l	#TAGID_AudioPan1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan1(a1)

62$	btst	#AUDB_Channel2Enabled,d2
	beq.s	65$

	move.l	#TAGID_AudioVolume2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust2(a1)	;Always set volume, even if 0
	beq.s	65$			;jump if no audio2
	ori.b	#CAF_AUDIOR,d1

;;	move.l	#TAGID_AudioVolume2,d0
;;	CALLTL	GetLongValue
;;	move.w	d0,ca_VolSust2(a1)
;;***!!! Do we want this volume to be based on the user set volume??
;;	move.w	#$ffff/2,ca_VolSust2(a1) ;this default may be changed before DoFindField
;	move.w	d0,ca_VolSust2(a1)

	move.l	#TAGID_AudioPan2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan2(a1)

* This hack always forces both audio channels to be on,
* even if one is disabled or has a volume of zero!!!
* This was because the flyer code could not play a mono-channel from a
* stereo recorded sample.
* As of 1-4-95 this distroys Flyer Matte & locks machine without this hack

***!!! Maybe the following hack can be removed, as it was in CroutonHandler.a
* setupaudiopreroll routine.  I was afraid to because there is no time for
* beta testing.  And with volumes of zero, it will be WYSIWYG enough.

65$	move.b	#CAF_AUDIOL!CAF_AUDIOR,d0
	and.b	d1,d0
	beq.s	66$
	ori.b	#CAF_AUDIOL!CAF_AUDIOR,d1

66$	move.b	d1,ca_Flags(a1)

	move.l	ca_VolSust1(a1),MyAudioVolume1	;assume next to MyAudioVolume2

	movem.l	(sp)+,d0-d2
	rts


*-------------------------------------
* a0->FG, a1->CA
* Determine if audio is wanted (this version supports mono)
StuffCAparams
	movem.l	d0-d2,-(sp)
	move.b	#CAPF_STEALOURVIDEO+CAPF_KILLOTHERVIDEO,ca_PermissFlags(a1)
	move.w	#(71<<8)+$80,ca_MatteY(a1)	;71.5 D2 Black

	move.b	#CAF_USEMATTE+CAF_NOPREROLL,d1  ;assume no audio

	clr.w	ca_VolSust1(a1)		;0 volume for any disabled channels
	clr.w	ca_VolSust2(a1)		;0 volume for any disabled channels

	move.l	#TAGID_Duration,d0
	CALLTL	GetLongValue
	beq.s	61$			;jump if no video
	ori.b	#CAF_VIDEO,d1

61$	move.l	#TAGID_AudioOn,d0
	CALLTL	GetLongValue
	move.l	d0,d2

	btst	#AUDB_Channel1Enabled,d2
	beq.s	62$

	move.l	#TAGID_AudioVolume1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust1(a1)	;Always set volume, even if 0

	ori.b	#CAF_AUDIOL,d1

	move.l	#TAGID_AudioPan1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan1(a1)

62$	btst	#AUDB_Channel2Enabled,d2
	beq.s	65$

	move.l	#TAGID_AudioVolume2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust2(a1)	;Always set volume, even if 0

	ori.b	#CAF_AUDIOR,d1

	move.l	#TAGID_AudioPan2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan2(a1)

65$	move.b	d1,ca_Flags(a1)

	move.l	ca_VolSust1(a1),MyAudioVolume1	;assume next to MyAudioVolume2

	movem.l	(sp)+,d0-d2
	rts


****** Hand_PanelClose ***********************************************************
*
*   NAME
*	Hand_PanelClose
*
*   SYNOPSIS
*	Hand_PanelClose(message) (FG)
*	                d0
*
*   FUNCTION
*	Remove flyer from Jog/Shuttle/Jump mode
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_PanelClose
	DEBUGMSG	DBHD,<Hand_PanelClose:>

	move.l	d0,a1
	move.l	ES_Data1(a1),a2		;crouton
	clr.l	ES_Reply(a1)		;assume never any errors !!!!

***!!!!*** This would be better done with a FGC_PANELCLOSE command
	cmpi.l	#CrUD_Video,FGS_ObjectType(a2)
	beq.s	5$
	cmpi.l	#CrUD_Audio,FGS_ObjectType(a2)
	bne.s	666$

5$	lea	FindFieldCA,a2
	move.l	(a2),d0
	beq.s	666$
	clr.l	(a2)
	movea.l	d0,a0

	move.b	#RT_STOPPED,ca_ReturnTime(a0)

	XJSR	Flyer_EndFindField

666$	rts

****** Hand_Jump ***********************************************************
*
*   NAME
*	Hand_Jump
*
*   SYNOPSIS
*	Hand_Jump(message) (FG,field) !!!! DON'T NEED FG
*	             d0
*
*   FUNCTION
*	Move to location in flyer clip
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Jump
	DEBUGMSG	DBHD,<Hand_Jump:>

	move.l	d0,a1
	move.l	ES_Data1(a1),a2		;crouton (or NULL to mute)
	clr.l	ES_Reply(a1)

	XLEA	MyClipAction,a0

;	move.b	ca_Flags(a0),d1
;	btst	#CAB_VIDEO,d1
;	beq.s	72$
	move.l	ES_Data2(a1),ca_VidStartField(a0)

;72$	andi.b	#CAF_AUDIOL!CAF_AUDIOR,d1
;	beq.s	73$
	move.l	ES_Data2(a1),ca_AudStartField(a0)

73$	
	cmp.w	#0,a2			;FG provided?
	beq.s	.mute			;No, mute audio

	movem.l	a0-a1,-(sp)
	move.l	a0,a1			;a1=CA
	move.l	a2,a0			;a0=FG
;	bsr	StuffCAparams		;Need to re-stuff volume,pan,etc.

	bclr	#CAB_VIDEO,ca_Flags(a1)	;Assume w/o video
	move.l	#TAGID_Duration,d0
	CALLTL	GetLongValue
	beq.s	.novid			;jump if no video
	bset	#CAB_VIDEO,ca_Flags(a1)
.novid
	move.l	#TAGID_AudioVolume1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust1(a1)

	move.l	#TAGID_AudioVolume2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust2(a1)

	move.l	#TAGID_AudioPan1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan1(a1)

	move.l	#TAGID_AudioPan2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan2(a1)

	movem.l	(sp)+,a0-a1
	bra.s	.doit

.mute	clr.l	ca_VolSust1(a0)
	bclr	#CAB_VIDEO,ca_Flags(a0)		;No video, just audio mute

.doit	XJSR	Flyer_DoFindField
	XJSR	Flyer_WaitAction
	rts

****** Hand_LightWave ***********************************************************
*
*   NAME
*	Hand_LightWave
*
*   SYNOPSIS
*	Hand_LightWave(message) (FGC_command)
*	                  d0
*
*   FUNCTION
*	Send a FGC message to LightWave
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_LightWave
	DEBUGMSG	DBHD,<Hand_LightWave:>

	move.l	d0,a0
	move.l	ES_Data1(a0),d1		;FGC_command
	moveq	#TDSLICEID,d0		;SLICEID
	bsr	SendSliceCommand

	move.l	d0,ES_Reply(a0)
	rts

****** Hand_ChromaFX ***********************************************************
*
*   NAME
*	Hand_ChromaFX
*
*   SYNOPSIS
*	Hand_ChromaFX(message) (FGC_command)
*	                  d0
*
*   FUNCTION
*	Send a FGC message to ChromaFX
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_ChromaFX
	DEBUGMSG	DBHD,<Hand_ChromaFX:>

	move.l	d0,a0
	move.l	ES_Data1(a0),d1		;FGC_command
	moveq	#LTSLICEID,d0		;SLICEID
	bsr	SendSliceCommand

	move.l	d0,ES_Reply(a0)
	rts

****** Hand_ToasterCG ***********************************************************
*
*   NAME
*	Hand_ToasterCG
*
*   SYNOPSIS
*	Hand_ToasterCG(message) (FGC_command)
*	                  d0
*
*   FUNCTION
*	Send a FGC message to ToasterCG
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_ToasterCG
	DEBUGMSG	DBHD,<Hand_ToasterCG:>

	move.l	d0,a0
	move.l	ES_Data1(a0),d1		;FGC_command
	moveq	#CGSLICEID,d0		;SLICEID
	bsr	SendSliceCommand

	move.l	d0,ES_Reply(a0)
	rts

****** Hand_ToasterPaint ***********************************************************
*
*   NAME
*	Hand_ToasterPaint
*
*   SYNOPSIS
*	Hand_ToasterPaint(message) (FGC_command)
*	                  d0
*
*   FUNCTION
*	Send a FGC message to ToasterPaint
*
*   INPUTS
*
*   RESULT
*	ERROR result.
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_ToasterPaint
	DEBUGMSG	DBHD,<Hand_ToasterPaint:>

	move.l	d0,a0
	move.l	ES_Data1(a0),d1		;FGC_command
	moveq	#PTSLICEID,d0		;SLICEID
	bsr	SendSliceCommand

	move.l	d0,ES_Reply(a0)
	rts

***************************************************************
* d0=SLIDEID, d1=FGC_Command
* Returns Error code.
SendSliceCommand:
	movem.l	d1-d2/a0-a1,-(sp)
	move.l	d1,d2

	clr.w	TB_ErrFlag(a5)		; assume no errors

	DEA	TB_SliceFGL,a0
	XCALL	IndexFastG		; search Slice FGL for FG
	beq	610$			; ...stop if Slice FGL corrupt
	move.l	d0,a0			; address FG

*----------------
	cmp.w	#FGC_LOAD,d2
	bne	100$

* Load
	tst.w	FG_PTRIndex(a0)
	bne	500$			; ...if already loaded

	CALLTL	FGC_SelectKCommand
	bra	400$

*----------------
100$	cmp.w	#FGC_UNLOAD,d2
	bne	200$

* Unload
	tst.w	FG_PTRIndex(a0)
	beq	500$			; ...if already unloaded

	CALLTL	FGC_UnloadCommand
	bra	400$

*----------------
200$	cmp.w	#FGC_SELECT,d2
	bne	500$			; Unknown command = no error

* Select
	tst.w	FG_PTRIndex(a0)
	beq	620$			; ...if not loaded

	CALLTL	FGC_SelectKCommand
;;	bra.s	400$



*----------------
400$	CALLTL	ReDoDisplay	;***!!!	Why isn't the Editor doing this??
	CALLTL	InstallAVEI	;***!!!

500$	move.w	TB_ErrFlag(a5),d0
	ext.l	d0

666$	movem.l	(sp)+,d1-d2/a0-a1
	rts

610$	move.l	#1,d0			;Slice FGL corrupt
	bra	666$

620$	move.l	#2,d0			;Slice is not loaded
	bra	666$

*************************************************************************
* Name=MakeTestClip()
*
* This writes out a 4 field clip with a test pattern.  See bars.a

	XDEF	MakeTestClip
MakeTestClip:
	movem.l	d0-d2/a0-a1/a6,-(sp)

	DEBUGMSG  DBMTC,<MakeTestClip:>

	clr.l	(sp)			;assume error

	GET.l	TB_FlyerBase,d0
	beq	666$			;error, unable to send message

	moveq	#0,d0			;first drive it can find
	move.l	#1<<FVIB_VIDEOREADY,d1	;that can do video
	XJSR	Flyer_VolumeName
	beq	666$
	movea.l	d0,a1

	DEBUGMSG  DBMTC,<Got FlyerVolume for Video>

	lea	testphase2(pc),a0
510$	move.b	(a1)+,(a0)+
	bne	510$
	move.b	#':',-1(a0)

	move.b	#'T',(a0)+
	move.b	#'e',(a0)+
	move.b	#'s',(a0)+
	move.b	#'t',(a0)+
	move.b	#'S',(a0)+
	move.b	#'i',(a0)+
	move.b	#'g',(a0)+
	move.b	#'n',(a0)+
	move.b	#'a',(a0)+
	move.b	#'l',(a0)+
	move.b	#0,(a0)

	GET.l	TB_DOSBase,a6
	move.l	#testphase2,d1
	XSYS	DeleteFile

*---------
* Field I
	lea	testphase2(pc),a0

	IFD	 DBMTC
	DUMPTXT </attemping to open ===">
	DUMPSTR 0(a0)
	DUMPMSG <"=== >
	ENDC

	move.l	#FWF_NEW,d0		;mode (instead of FWF_APPEND)
	moveq	#0,d1			;best compression mode
	moveq	#0,d2			;Field I
	XJSR	Flyer_OpenWriteField
	beq	666$			;couldn't open
	move.l	d0,a0			;FileHandle

	DEBUGMSG  DBMTC,<Open Field I OK>

	move.w	#(240/2)-1,d1
;a0->handle, a1->buff
591$	lea	NormalBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	lea	CompBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	dbra	d1,591$

	XJSR	Flyer_CloseField

*---------
* Field II

	lea	testphase2(pc),a0
	move.l	#FWF_APPEND,d0		;mode (instead of FWF_APPEND)
	moveq	#0,d1			;best compression mode
	moveq	#1,d2			;Field II
	XJSR	Flyer_OpenWriteField
	beq	610$			;couldn't open
	move.l	d0,a0			;FileHandle

	DEBUGMSG  DBMTC,<Open Field II OK>

	move.w	#(240/2)-1,d1
;a0->handle, a1->buff
592$	lea	CompBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$


	lea	NormalBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	dbra	d1,592$

	XJSR	Flyer_CloseField

*---------
* Field III

	lea	testphase2(pc),a0
	move.l	#FWF_APPEND,d0		;mode (instead of FWF_APPEND)
	moveq	#0,d1			;best compression mode
	moveq	#2,d2			;Field III
	XJSR	Flyer_OpenWriteField
	beq	610$			;couldn't open
	move.l	d0,a0			;FileHandle

	DEBUGMSG  DBMTC,<Open Field III OK>

	move.w	#(240/2)-1,d1
;a0->handle, a1->buff
593$	lea	CompBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	lea	NormalBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	dbra	d1,593$

	XJSR	Flyer_CloseField

*---------
* Field IV

	lea	testphase2(pc),a0
	move.l	#FWF_APPEND,d0		;mode (instead of FWF_APPEND)
	moveq	#0,d1			;best compression mode
	moveq	#3,d2			;Field IV
	XJSR	Flyer_OpenWriteField
	beq	610$			;couldn't open
	move.l	d0,a0			;FileHandle

	DEBUGMSG  DBMTC,<Open Field IV OK>

	move.w	#(240/2)-1,d1
;a0->handle, a1->buff
594$	lea	NormalBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	lea	CompBuff(pc),a1
	XJSR	Flyer_WriteLine
	bne	600$

	dbra	d1,594$

	move.l	#testphase2,(sp)	;success ->name
	bra	605$
	nop

*---------
;a0->handle
600$
	DEBUGHEXI.l  DBMTC,<Write Failed, Error#=>,d0,<\>

605$	XJSR	Flyer_CloseField

610$	tst.l	(sp)
	bne.s	666$
;;	GET.l	TB_DOSBase,a6
	move.l	#testphase2,d1
	XSYS	DeleteFile

666$	movem.l	(sp)+,d0-d2/a0-a1/a6
	rts

testphase2 	dcb.b	32+16,0


	IFD	CRAP
NormalBuff
CompBuff
	dcb.b	184,$80
	dcb.b	184,$81
	dcb.b	184,$82
	dcb.b	200,$83
	ENDC

;;	IFD	CRAP
NormalBuff	dcb.b	92,72
		dcb.b	4,200
		dcb.b	96,72
		dcb.l	368/4,((72<<24)!(136<<16)!(200<<8)!136)
		dcb.b	96,200
		dcb.b	4,72
		dcb.b	92,200

CompBuff	dcb.b	92,72
		dcb.b	4,200
		dcb.b	96,72
		dcb.l	368/4,((200<<24)!(136<<16)!(72<<8)!136)
		dcb.b	96,200
		dcb.b	4,72
		dcb.b	92,200
;;	ENDC

*************************************************************************
*************************************************************************
*************************************************************************

	xdef	EditPortName
EditPortName	dc.b	'edit.port',0

EditWindowName
	dc.b	'Edit',0

	cnop	0,4
NullWBArgList	DC.l	0
		DC.l	Bogus
Bogus:
	DC.b	'',0

*---------------------------------
	SECTION	,DATA

FindFieldCA	dc.l	0

LastShuttleTBL	 dc.l	0
LastFramesPerSkip dc.w	0

MyAudioVolume1	dc.w	0
MyAudioVolume2	dc.w	0

MyRecordAudioGain1	dc.b	2
MyRecordAudioGain2	dc.b	2

RecordVideo	dc.w	0

RecordModeFlag	dc.w	0

	IFD	FORCE2MATTE
StashBKG	dc.w	0
	ENDC

*---------------------------------
	SECTION	,BSS

FakeStartup	dcb.b	sm_SIZEOF,0
OnlyMessage	dcb.b	ES_SIZEOF,0	;This is the message used to
					;communicate with the project editor


@


2.167
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.166 1996/11/19 11:00:40 Holt Exp Holt $
d10 3
d569 1
a569 1
SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
d2439 40
d2504 1
a2504 1
	beq.s	600$			;Jump if no file name found (= cancel)
d2507 1
a2507 1
	bne.s	600$
d2511 8
a2518 1
	DUMPMEM	<tst.w   ES_Data5(a2)>,ES_Data5(A2),#16
@


2.166
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.165 1996/08/13 16:44:45 Holt Exp Holt $
d10 3
@


2.165
log
@added support for HQ6 MODE.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.164 1996/04/29 10:29:58 Holt Exp Holt $
d10 3
d678 1
d749 4
d1343 37
@


2.164
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.163 1996/02/15 11:29:34 Holt Exp Holt $
d10 3
d560 1
a560 1
;SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
a4311 1

d4313 1
@


2.163
log
@added hand_take
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.162 1996/01/30 12:59:44 Holt Exp Holt $
d10 3
d557 1
a557 1
;;SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
d567 1
a567 1
;DBCLOCK	set	1	;Debug clock syncronization
@


2.162
log
@turned off serdebug
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.161 1996/01/30 12:53:06 Holt Exp Holt $
d10 3
d668 2
d2927 33
@


2.161
log
@fixed vol to not go to 0 durring shuttle.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.160 1996/01/02 17:41:34 Holt Exp Holt $
d10 3
d551 1
a551 1
SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
@


2.160
log
@turned off debug
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.159 1995/12/27 15:46:01 Holt Exp Holt $
d10 3
d548 1
a548 1
;SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
d4032 1
a4032 1
	bne.s	70$
d4047 1
d4059 2
a4060 4

	cmp.w	RCB_VelocityDenominator(a3),d4
	bls.s	50$		;jump if speed <= 1

d4062 10
a4071 2
	mulu	RCB_VelocityDenominator(a3),d0
	divu	d4,d0
a4072 1
50$	move.w	d0,ca_VolSust1(a0)
d4078 2
a4079 4

	cmp.w	RCB_VelocityDenominator(a3),d4
	bls.s	53$		;jump if speed <= 1

d4081 8
a4088 4
	mulu	RCB_VelocityDenominator(a3),d0
	divu	d4,d0

53$	move.w	d0,ca_VolSust2(a0)
@


2.159
log
@tested clock sync
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.158 1995/10/17 15:28:25 Flick Exp Holt $
d10 3
d545 2
a546 2
SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
DBTBC	set	1 ;debug TBC writing THIS IS ON the Ralt+Rshift+F1 HOTKEY
@


2.158
log
@Hand_Jump was brain-dead, was setting A/V points based on content LAST TIME,
then reset A/V content flags for current TAG values!!  Fixes DHD_Jump
@
text
@d2 1
a2 1
* $RCSfile: PECOMM.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PECOMM.a,v 2.157 1995/10/17 12:23:31 Flick Exp Flick $
d9 5
a13 1
* $Log: PECOMM.a,v $
d542 1
a542 1
;SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
d545 1
a545 1
;	ALLDUMPS
d552 1
a552 1
;;DBCLOCK	set	1	;Debug clock syncronization
d3101 1
a3101 1
	subq.l	#1,d0
d3105 3
a3107 3
;;	DUMPMSG		<>
;;	DUMPMSG		<ERROR ERROR ERROR ERROR ERROR ERROR ****!!!!!!!>
;;	DUMPMSG		<Flyer & Switcher Clocks not Syncronized!!!!>
d3109 2
d3112 5
a3116 1
6$	CALLTL	AllInterruptsOn
d3549 1
a3549 1
	DUMPUDEC.w <*** Accel=>,d2,<***\>
d3574 1
a3574 1
	DUMPUDEC.l <Xjog=>,d0,< >
@


2.157
log
@Hand_ChangeAudio now uses modified StuffCAparams (that supports mono correctly)
Other clients of this function use the same one, now called StuffCAparams2
which coerces things to stereo quite annoyingly, but too much depends on this now!
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.156 1995/09/08 18:10:18 Flick Exp Flick $
d10 5
d5404 3
a5406 3
	move.b	ca_Flags(a0),d1
	btst	#CAB_VIDEO,d1
	beq.s	72$
d5409 2
a5410 2
72$	andi.b	#CAF_AUDIOL!CAF_AUDIOR,d1
	beq.s	73$
@


2.156
log
@Fixed deficiencies in Jog/Shuttle handling to allow scrubbing volume/balance
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.155 1995/08/20 00:59:43 Flick Exp Flick $
d10 3
d3653 1
a3653 1
	bsr	StuffCAparams		;Need to stuff vid start/stop
d5170 1
a5170 1
	bsr	StuffCAparams
d5184 2
a5185 2
* Determine if audio is wanted
StuffCAparams
d5266 57
d5443 1
a5443 1
	bclr	#CAB_VIDEO,ca_Flags(a0)		;Don't put up new video!
@


2.155
log
@Argh! Sloppy code alert! InitJogShuttle wasn't setting Flyer ReturnTime, so
we were doing this sync (instead of in parallel with RCB rendering!!!)
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.154 1995/08/14 12:49:05 Flick Exp Flick $
d10 4
d5189 3
d5206 1
d5215 1
a5215 1
	move.w	d0,ca_VolSust1(a1)
d5226 1
d5235 1
a5235 1
	move.w	d0,ca_VolSust2(a1)
d5334 1
a5334 1
;;	move.l	ES_Data1(a1),a2		;crouton
d5348 38
a5385 1
73$	XJSR	Flyer_DoFindField
@


2.154
log
@Disabled debugging
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.153 1995/08/09 12:22:09 Holt Exp Flick $
d10 3
d3645 1
@


2.153
log
@turned serdebug flag on.
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.152 1995/08/07 15:29:09 Flick Exp Holt $
d9 4
a12 1
* $Log: pecomm.a,v $
d523 1
a523 1
SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
d526 1
a526 1
	ALLDUMPS
@


2.152
log
@Nothing much, just tested/cleaned up Hand_Jog code a bit
@
text
@d2 1
a2 1
* $RCSfile: PECOMM.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PECOMM.a,v 2.151 1995/07/18 13:55:45 Flick Exp Flick $
d9 4
a12 1
* $Log: PECOMM.a,v $
d520 1
a520 1
;;SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
@


2.151
log
@PanelOpen,PanelClose now use RT_STOPPED (much safer)
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.150 1995/07/13 15:08:23 Flick Exp Flick $
d10 3
a3462 1
	moveq	#0,d3
d3465 1
d3518 2
d3542 3
d3551 1
a3551 1
;;	DUMPUDEC.l <field=>,d0,< >
@


2.150
log
@Changed hand_tweek to support writing values as USE or SAVE (OOPSKELL)
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.149 1995/07/12 12:19:18 Flick Exp Flick $
d10 3
d5140 1
a5140 1
	move.b	#RT_IMMED,ca_ReturnTime(a0)
d5276 1
a5276 1
	move.b	#RT_STARTED,ca_ReturnTime(a0)
@


2.149
log
@MakeTestClip now sets D2=field# for Flyer_OpenWriteField call
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.148 1995/07/05 15:04:59 Flick Exp Flick $
d10 3
d1346 1
a1346 1
	bne	1100$
d1348 1
a1348 1
	bne	1200$
d1350 1
a1350 1
	bne	1300$
d1352 1
a1352 1
	bne	1400$
d1355 8
a1362 2
30$	btst	#HKB_PLAY_A,d5
	bne	100$
d1364 1
a1364 1
	bne	200$
d1366 1
a1366 1
	bne	300$
d1368 1
a1368 1
	bne	400$
d1372 2
a1373 1
100$	bsr	1000$
d1378 1
a1378 1
	moveq	#1,d3			;saveflag = yes
d1384 1
a1384 1
;	moveq	#1,d3			;saveflag
d1390 1
a1390 1
;	moveq	#1,d3			;saveflag
d1396 1
a1396 1
;	moveq	#1,d3			;saveflag
d1405 1
a1405 1
;	moveq	#1,d3			;saveflag
d1411 2
a1412 1
200$	bsr	1000$
d1417 1
a1417 1
	moveq	#1,d3			;saveflag = yes
d1423 1
a1423 1
;	moveq	#1,d3			;saveflag
d1429 1
a1429 1
;	moveq	#1,d3			;saveflag
d1435 1
a1435 1
;	moveq	#1,d3			;saveflag
d1444 1
a1444 1
;	moveq	#1,d3			;saveflag
d1450 2
a1451 1
300$	bsr	2000$
d1456 1
a1456 1
	moveq	#1,d3			;saveflag = yes
d1462 2
a1463 1
400$	bsr	2000$
d1468 1
a1468 1
	moveq	#1,d3			;saveflag = yes
d1476 1
a1476 1
;	moveq	#1,d3			;saveflag
d1482 1
a1482 1
;	moveq	#1,d3			;saveflag
d1488 1
a1488 1
;	moveq	#1,d3			;saveflag
d1604 4
a1607 1
1000$	tst.w	RecordModeFlag
d1617 3
a1619 1
1666$	rts
d1622 4
a1625 1
2000$	tst.w	RecordModeFlag
d1636 3
a1638 1
2666$	rts
d1642 1
a1642 1
1100$
d1684 1
a1684 1
1200$
d1726 1
a1726 1
1300$
d1739 1
a1739 1
1400$
@


2.148
log
@Added call to FGC_InterpTagsCommand for duplicating w/ corner symbols
@
text
@d7 1
a7 1
* $Id: PECOMM.a,v 2.147 1995/06/09 16:03:28 Holt Exp Flick $
d10 3
d5499 1
a5499 1
	movem.l	d0-d1/a0-a1/a6,-(sp)
d5549 1
d5576 1
d5604 1
d5631 1
d5667 1
a5667 1
666$	movem.l	(sp)+,d0-d1/a0-a1/a6
@


2.147
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.146 1995/06/05 12:08:55 Flick Exp Holt $
d9 4
a12 1
* $Log: pecomm.a,v $
d2537 3
@


2.146
log
@Fixed VID4 bug in ES_SetPrefs
@
text
@d2 1
a2 1
* $RCSfile: PECOMM.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PECOMM.a,v 2.145 1995/04/20 11:09:09 Flick Exp Flick $
d9 4
a12 1
* $Log: PECOMM.a,v $
d2340 2
a2341 1
	tst.w	ES_Data5(a2)		;4 or 1 field save mode
@


2.145
log
@Fixed Hand_JOG for clips with > 32K fields, DoMouseXY handles 15 bits only!
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.144 1995/03/16 12:08:19 Holt Exp Flick $
d9 4
a12 1
* $Log: pecomm.a,v $
d4783 1
a4783 1
	andi.b	#~FLYER3_MASK!FLYER4_MASK,TB_Flags4(a5)	;turn off VID3/VID4 bits
@


2.144
log
@*** empty log message ***
@
text
@@


2.143
log
@fixed 333$ to 666$
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.142 1995/03/16 09:37:02 Flick Exp Holt $
d9 4
a12 1
* $Log: pecomm.a,v $
@


2.142
log
@Cleaned up Hand_RecordAppend
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.141 1995/03/15 18:59:09 CACHELIN4000 Exp Flick $
d10 3
d3366 1
a3366 1
	bne.s	333$		;exit with error
@


2.141
log
@Add ES_RecordAppend, FLYER_AddFields... just a start
@
text
@d2 1
a2 1
* $RCSfile: PEComm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PEComm.a,v 2.140 1995/03/15 13:05:12 Holt Exp CACHELIN4000 $
d9 4
a12 1
* $Log: PEComm.a,v $
d3339 1
a3339 2
	move.b	#RT_IMMED,ca_ReturnTime(a0)
	ori.b	#CAF_APPEND,d0  ; Is this even used?? AC
d3361 1
a3361 2
	move.l	ES_Data2(a2),d0
;	XJSR	Flyer_AddFields	;a0->ClipAction
@


2.140
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $RCSfile: PECOMM.A,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PECOMM.A,v 2.139 1995/03/14 13:58:39 Holt Exp Holt $
d9 4
a12 1
* $Log: PECOMM.A,v $
d597 1
d3294 76
@


2.139
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.138 1995/03/07 14:58:50 CACHELIN4000 Exp Holt $
d9 4
a12 1
* $Log: pecomm.a,v $
d481 1
a481 1
SERDEBUG	EQU	1 ;KEEP THIS ENABLED IF YOU WANT PRINTS TIED TO HOTKEY
@


2.138
log
@Re-Do HAND_CompressionMode forfast drive mode
@
text
@d2 1
a2 1
* $RCSfile: PEComm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PEComm.a,v 2.137 1995/03/02 12:35:23 pfrench Exp CACHELIN4000 $
d9 4
a12 1
* $Log: PEComm.a,v $
@


2.137
log
@Added switcher un-used rawkey handling code
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.136 1995/02/26 17:22:51 Holt Exp pfrench $
d9 4
a12 1
* $Log: pecomm.a,v $
d4045 4
a4048 1
*	0=standard, 1=extended
a4064 3

	moveq.l	#0,d1		;assume standard record

d4068 3
a4070 3
	tst.l	ES_Data1(a0)
	beq.s	20$

d4072 1
a4072 1
	moveq.l	#3,d1		;2=Subnyquist, but 3 is OK and longer
d4074 1
@


2.136
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $RCSfile: PECOMM.A,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: PECOMM.A,v 2.135 1995/02/24 18:54:44 pfrench Exp Holt $
d9 4
a12 1
* $Log: PECOMM.A,v $
d584 1
d2298 1
a2298 1
	
@


2.135
log
@fixed mangle-o code checking framestore
@
text
@d2 1
a2 1
* $RCSfile: pecomm.a,v $ - starting point of all new source code modules
d7 1
a7 1
* $Id: pecomm.a,v 2.134 1995/02/24 18:49:38 Holt Exp pfrench $
d9 4
a12 1
* $Log: pecomm.a,v $
d2294 1
@


2.134
log
@checked in so pat can work on it.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.133 1995/02/20 17:49:28 pfrench Exp Holt $
d10 3
d2296 1
a2296 1
	cmpi.l	#'FRAM',d1		; is a framestore crouton?
d2306 1
a2306 1
	XJSR  	ReallyProcessSaveButton		;Whatever code does a 1 field save
d2313 1
a2313 1
	XJSR	ReallyProcessSaveButton		;To whatever code does a 4 field save  (d0=error)
@


2.133
log
@using hardcoded FRAM data type
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.132 1995/02/20 17:27:43 pfrench Exp pfrench $
d10 3
d2302 2
a2303 1
;;	XJSR to whatever code does a 1 field save
d2309 2
a2310 1
;;	XJSR to whatever code does a 4 field save  (d0=error)
a2311 1
	nop
@


2.132
log
@Now makes sure requested frame save before continuing.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.131 1995/02/18 20:44:42 Kell Exp pfrench $
d10 3
d2290 1
a2290 1
	cmpi.l	CT_FRAMESTORE,d1	; is a framestore crouton?
@


2.131
log
@New handlers for FoundFile, and Change
Audio.  New sender for LocateFile.  Made a subroutine for all PutMsgs.
@
text
@d5 1
a5 1
* Confidental and Proprietary. All rights reserved. 
d7 1
a7 1
* $Id: pecomm.a,v 2.130 1995/02/17 16:09:54 Kell Exp Kell $
d10 4
d504 1
a504 1
	
d509 1
a509 1
	
d524 1
a524 1
	
d564 1
a564 1
	dc.l	Hand_EndClipCutList	;(DoItFlag)                          
d576 1
a576 1
*   NAME   
d599 1
a599 1
	xdef	HandlePEMessage	
d602 1
a602 1
	
d640 1
a640 1
*   NAME   
d684 1
a684 1
155$	
d693 1
a693 1
*   NAME   
d869 1
a869 1
*   NAME   
d906 1
a906 1
	
d909 1
a909 1
	
d915 2
a916 2
	
	DEBUGMSG	DBSPM,<REMOVEing the particular Reply>	
d948 1
a948 1
*   NAME   
d972 1
a972 1
*		  You should check ES_Reply to see what has happened.  
d998 1
a998 1
*   NAME   
d1019 1
a1019 1
	
d1025 1
a1025 1
	GET.w	TB_InterfaceDepth,d2		
d1031 1
a1031 1
10$	movem.l	(sp)+,d1-d3/a0	
d1036 1
a1036 1
*   NAME   
d1057 1
a1057 1
	
d1068 1
a1068 1
	movem.l	(sp)+,d1-d3	
d1073 1
a1073 1
*   NAME   
d1094 1
a1094 1
	
d1103 1
a1103 1
10$	movem.l	(sp)+,d1-d3	
d1108 1
a1108 1
*   NAME   
d1152 1
a1152 1
*   NAME   
d1171 1
a1171 1
*		  You should check ES_Reply to see what has happened.  
d1183 1
a1183 1
	
d1204 1
a1204 1
*   NAME   
d1231 1
a1231 1
*   NAME   
d1282 1
a1282 1
Hand_Tweek:	
d1430 1
a1430 1
	moveq	#0,d0			;first drive it can find	
d1442 1
a1442 1
	
d1480 1
a1480 1
	move.l	d0,a0	
d1493 1
a1493 1
	move.l	d0,a0	
d1509 1
a1509 1
	CALLTL	NoTransFreeze	
d1514 1
a1514 1
	
d1528 1
a1528 1
	dbra	d3,600$	
d1563 1
a1563 1
		
d1661 1
a1661 1
	
d1802 1
a1802 1
	
d1808 5
a1812 5
	DUMPBITS.b	<Status    =>,tbc_Status(a0),<\>	
	DUMPBITS.b	<Flags     =>,tbc_Flags(a0),<\>	
	DUMPBITS.b	<DecFlags  =>,tbc_DecFlags(a0),<\>	
	DUMPBITS.b	<EncFlags  =>,tbc_EncFlags(a0),<\>	
	DUMPBITS.b	<Term      =>,tbc_Term(a0),<\>	
d1814 8
a1821 8
	DUMPUDEC.b	<InputSel  =>,tbc_InputSel(a0),<\>	
	DUMPSDEC.b	<Bright    =>,tbc_Bright(a0),<\>	
	DUMPUDEC.b	<Contrast  =>,tbc_Contrast(a0),<\>	
	DUMPUDEC.b	<Sat       =>,tbc_Sat(a0),<\>		
	DUMPSDEC.b	<Hue       =>,tbc_Hue(a0),<\>		
	DUMPHEXI.W	<Phase     =>,tbc_Phase(a0),<\>	
	DUMPHEXI.W	<HorAdj    =>,tbc_HorAdj(a0),<\>	
	DUMPUDEC.b	<Fader     =>,tbc_Fader(a0),<\\>	
d1833 1
a1833 1
*   NAME   
d1853 1
a1853 1
	
d1869 1
a1869 1
*   NAME   
d1899 1
a1899 1
*   NAME   
d1926 1
a1926 1
*   NAME   
d1936 1
a1936 1
*	Data1: TRUE means open windows if not open (and refresh)  
d1995 1
a1995 1
	
d2011 1
a2011 1
*   NAME   
d2038 1
a2038 1
	
d2048 1
a2048 1
*   NAME   
d2074 1
a2074 1
	
d2080 1
a2080 1
*   NAME   
d2113 1
a2113 1
	
d2124 1
a2124 1
*   NAME   
d2135 1
a2135 1
*	
d2159 1
a2159 1
*   NAME   
d2170 1
a2170 1
*	
d2193 1
a2193 1
*   NAME   
d2203 1
a2203 1
*	
d2228 1
a2228 1
*   NAME   
d2238 1
a2238 1
*	
d2263 1
a2263 1
*   NAME   
d2273 1
a2273 1
*	
d2287 3
d2300 1
a2300 1
* Assume four field Framesave 
d2311 1
a2311 1
*   NAME   
d2341 1
a2341 1
*   NAME   
d2378 1
a2378 1
*   NAME   
d2426 1
a2426 1
	
d2438 2
a2439 2
	
	move.l	a0,d0		;->FG			
d2446 1
a2446 1
*   NAME   
d2510 1
a2510 1
*   NAME   
d2549 1
a2549 1
*   NAME   
d2578 1
a2578 1
*   NAME   
d2601 1
a2601 1
*   NAME   
d2636 1
a2636 1
	
d2660 1
a2660 1
*   NAME   
d2692 1
a2692 1
*   NAME   
d2725 1
a2725 1
	
d2730 1
a2730 1
*   NAME   
d2772 1
a2772 1
*   NAME   
d2803 1
a2803 1
*   NAME   
d2830 1
a2830 1
*-------------------	
d2847 1
a2847 1
	DEA.l	TB_VTSetUp,a0	
d2885 1
a2885 1
*-------------------	
d2893 1
a2893 1
;;	beq.s	20$	
d2918 1
a2918 1
			
d2922 1
a2922 1
	
d2947 1
a2947 1
*   NAME   
d2983 1
a2983 1
			
d2987 1
a2987 1
	
d3016 1
a3016 1
	CALLTL	ImageryOn	
d3024 1
a3024 1
*   NAME   
d3054 1
a3054 1
	
d3057 2
a3058 2
	beq.s	666$	
	
d3062 1
a3062 1
	ENDC	
d3066 1
a3066 1
*   NAME   
d3099 1
a3099 1
*   NAME   
d3139 1
a3139 1
	bne.s	100$	
d3166 1
a3166 1
*   NAME   
d3179 1
a3179 1
*	  
d3193 1
a3193 1
	
d3266 1
a3266 1
*   NAME   
d3292 1
a3292 1
	
d3310 1
a3310 1
*---------------------	
d3318 1
a3318 1
	bhi.s	50$		;jump if > JOGNOACC, use some accel 	
d3346 1
a3346 1
;;	DUMPUDEC.l <Frame=>,d0,<\>	
d3357 1
a3357 1
*  a1->abort function	
d3392 1
a3392 1
	
d3406 1
a3406 1
	movea.l	a3,a0	
d3419 1
a3419 1
	
d3439 1
a3439 1
	rts	
d3445 1
a3445 1
*  a1->abort function	
d3452 1
a3452 1
	movea.l	ES_Data1(a2),a3	;->RenderCallBack	
d3501 1
a3501 1
	WORD  STBL_NormalStep	
d3503 1
a3503 1
	WORD  STBL_SkipStep      
d3542 4
a3545 4
	
* Velocity = (NormalStep+(SkipStep/(FramesPerSkip+1)))/FieldsPerFrame 
*               
* #fields/outputchange=FieldsPerFrame*(FramesPerSkip+1) 
d3548 1
a3548 1
*               
d3556 1
a3556 1
*               --------- 
d3583 1
a3583 1
*   NAME   
d3612 1
a3612 1
*  a1->abort function	
d3616 1
a3616 1
	
a3636 2
	
30$	move.w	STBL_FramesPerSkip(a6),d5			
d3638 2
d3680 1
a3680 1
	movem.l	d1-d7/a1-a6,-(sp)	
d3682 1
a3682 1
	movem.l	(sp)+,d1-d7/a1-a6	
d3702 1
a3702 1
	add.l	d0,d3	
d3705 1
a3705 1
	
d3708 2
a3709 2
	add.l	d0,d3	
	
d3744 1
a3744 1
* a6->current ShuttleTBL, d5=FramesPerSkip counter, d3=Frame 
d3752 2
a3753 2
	
*  a1->abort function	
d3782 1
a3782 1
	move.w	STBL_FramesPerSkip(a6),d5			
d3787 1
a3787 1
	add.l	d0,d3	
d3791 1
a3791 1
	
d3794 1
a3794 1
	add.l	d0,d3	
d3878 1
a3878 1
	
d3882 1
a3882 1
	movem.l	d1-d7/a1-a6,-(sp)	
d3884 1
a3884 1
	movem.l	(sp)+,d1-d7/a1-a6	
d3904 1
a3904 1
*   NAME   
d3949 1
a3949 1
*   NAME   
d3982 1
a3982 1
*   NAME   
d4015 1
a4015 1
*   NAME   
d4061 1
a4061 1
*   NAME   
d4100 1
a4100 1
*   NAME   
d4126 1
a4126 1
	
d4141 1
a4141 1
*   NAME   
d4166 1
a4166 1
	
d4169 1
a4169 1
	
d4178 1
a4178 1
*   NAME   
d4202 1
a4202 1
	
d4205 1
a4205 1
	
d4211 1
a4211 1
*   NAME   
d4239 1
a4239 1
	
d4245 1
a4245 1
*   NAME   
d4271 1
a4271 1
	movea.l	ES_Data1(a2),a0		;FG	
d4277 1
a4277 1
	
d4283 1
a4283 1
*   NAME   
d4311 1
a4311 1
	
d4317 1
a4317 1
*   NAME   
d4337 1
a4337 1
Hand_StartClipCutList  	
d4349 1
a4349 1
	
d4355 1
a4355 1
*   NAME   
d4375 1
a4375 1
Hand_AddClipCut  	
d4385 1
a4385 1
	
d4400 1
a4400 1
	
d4406 1
a4406 1
*   NAME   
d4426 1
a4426 1
Hand_EndClipCutList	
d4434 1
a4434 1
	
d4440 1
a4440 1
*   NAME   
d4467 1
a4467 1
	
d4474 1
a4474 1
*   NAME   
d4502 1
a4502 1
	
d4508 1
a4508 1
*   NAME   
d4545 1
a4545 1
	
d4551 1
a4551 1
*   NAME   
d4587 1
a4587 1
*   NAME   
d4619 1
a4619 1
*   NAME   
d4651 1
a4651 1
	bset	#FLYER3_BIT,d0	
d4702 1
a4702 1
* Set GPI	
d4737 1
a4737 1
*   NAME   
d4786 1
a4786 1
* Get GPI	
d4795 1
a4795 1
*   NAME   
d4835 1
a4835 1
*   NAME   
d4893 1
a4893 1
	
d4913 1
a4913 1
	bra.s	667$	
d4959 1
a4959 1
* Use channel 1 = M_VIDEO4	
d4976 1
a4976 1
	move.l	FGS_FileName(a3),fv_Path(a1)	
d4984 1
a4984 1
	movea.l	a3,a0		;a0->fg, a1->ca		
d4991 1
a4991 1
	clr.l	(a1)			;assume failure	
a5069 2
	
	move.l	ca_VolSust1(a1),MyAudioVolume1	;assume next to MyAudioVolume2	
d5071 2
d5078 1
a5078 1
*   NAME   
d5103 1
a5103 1
	
d5109 1
a5109 1
	
d5115 1
a5115 1
	
d5124 1
a5124 1
*   NAME   
d5167 1
a5167 1
*   NAME   
d5191 1
a5191 1
	moveq	#TDSLICEID,d0		;SLICEID	
d5193 1
a5193 1
	
d5199 1
a5199 1
*   NAME   
d5223 1
a5223 1
	moveq	#LTSLICEID,d0		;SLICEID	
d5225 1
a5225 1
	
d5231 1
a5231 1
*   NAME   
d5255 1
a5255 1
	moveq	#CGSLICEID,d0		;SLICEID	
d5257 1
a5257 1
	
d5263 1
a5263 1
*   NAME   
d5287 1
a5287 1
	moveq	#PTSLICEID,d0		;SLICEID	
d5289 1
a5289 1
	
d5353 1
a5353 1
	bra	666$		
d5367 1
a5367 1
	DEBUGMSG  DBMTC,<MakeTestClip:>	
d5372 1
a5372 1
	beq	666$			;error, unable to send message	
d5374 1
a5374 1
	moveq	#0,d0			;first drive it can find	
d5380 1
a5380 1
	DEBUGMSG  DBMTC,<Got FlyerVolume for Video>	
d5412 1
a5412 1
	
d5417 2
a5418 2
	move.l	d0,a0			;FileHandle	
	
d5421 1
a5421 1
	move.w	#(240/2)-1,d1	
d5443 1
a5443 1
	move.l	d0,a0			;FileHandle	
d5447 1
a5447 1
	move.w	#(240/2)-1,d1	
d5470 2
a5471 2
	move.l	d0,a0			;FileHandle	
	
d5474 1
a5474 1
	move.w	#(240/2)-1,d1	
d5496 2
a5497 2
	move.l	d0,a0			;FileHandle	
	
d5500 1
a5500 1
	move.w	#(240/2)-1,d1	
d5528 1
a5528 1
	
d5548 1
a5548 1
		dcb.l	368/4,((72<<24)!(136<<16)!(200<<8)!136)	
d5560 1
a5560 1
;;	ENDC	
@


2.130
log
@Now informs the editor of screen depth (a variable)
Also, kills keys at end of sequence.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.129 1995/02/16 20:36:26 Kell Exp Kell $
d10 4
d563 1
a563 1
	dc.l	Hand_LocateFile	    	;(Type,->Name,flags,->textarray,mode)
d795 4
a798 18
****** SendProjectEditMessage ***********************************************
*
*   NAME   
*	SendProjectEditMessage -- This sends the project editor a message
*
*   SYNOPSIS
*	Result = SendProjectEditMessage(ES_Type,Data1,Data2,Data3,Reply)
*	                                  d0    d1    d2      d3   d4
*
*   FUNCTION
*	This function sends the message defined in EditSwit.i to the project
*	Editor.
*
*   INPUTS
*	ES_Type -  see EditSwit.i
*	Data1   -  see EditSwit.i
*	Data2   -  see EditSwit.i
*	Data3   -  see EditSwit.i
d800 1
a800 10
*	a5->TB
*
*   RESULT
*	Result -  d0 is NULL if project editor port not found.
*		  You may use condition flags as a test.
*
*		  Else, d0->pointer to message used.
*		  You should check ES_Reply to see what has happened.  
*
*   BUGS
d802 1
a802 5
*****************************************************************************
	xdef	SendProjectEditMessage
SendProjectEditMessage:
	DEBUGMSG	DBSPM,<SendProjectEditMessage:>

d804 1
a812 3
	move.w	d0,ES_Type(a2)
	movem.l	d1-d3,ES_Data1(a2)
	move.l	d4,ES_Reply(a2)
d859 2
a860 3
.exit
	movem.l	(sp)+,d0-d1/a0-a2/a6
	tst.l	d0			;->message or NULL
d942 34
d977 4
d982 1
d984 2
a985 1

a987 1

d1146 44
a1193 4
Hand_ChangeAudio	
Hand_LocateFile	 
Hand_FoundFile    

d2257 45
d4212 1
a4212 1
*	Sees if the Flyer is still recording
d4236 38
d5052 4
@


2.129
log
@Now realtime feedback on palette colors when going between 2/3 monitor modes.  Also, hack panel CancelCGs.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.128 1995/02/13 15:12:21 Kell Exp Kell $
d10 3
d27 1
a27 1
*New hardcoded data to create a clip to test TBC keying.
d36 1
a36 1
*New handlers for TBCread, TBCwrite, Pause, and Clip Cutting.
d96 1
a96 1
*New Hand_NewFieldCount and Hand_UnSavable handlers added.
d476 2
a477 2
	dc.l	Hand_STARTUP		;()
	dc.l	Hand_RENDER_EDIT	;(),  Should never get this message
d495 1
a495 1
	dc.l	Hand_QUIT		;()
d558 3
a790 153
****** SendProjectEditRenderMessage *****************************************
*
*   NAME   
*	SendProjectEditRenderMessage -- Send a render message to Project
*	                                editor
*
*   SYNOPSIS
*	message = SendProjectEditRenderMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditRenderMessage
SendProjectEditRenderMessage:
	DEBUGMSG	DBSPM,<SendProjectEditRenderMessage:>
	
	movem.l	d1-d3/a0,-(sp)

	move.l	#ES_RENDER_EDIT,d0
	moveq.l	#TRUE,d1			;open editor windows & render
	moveq.l	#0,d2
	moveq.l	#0,d3
	bsr	SendProjectEditMessage
	beq.s	10$				;jump if Editor isn't loaded
	bset.b	#7,TB_DisplayRenderMode(a5)	;Editor will control top half

10$	movem.l	(sp)+,d1-d3/a0	
	rts

****** SendProjectEditNoRenderMessage *****************************************
*
*   NAME   
*	SendProjectEditNoRenderMessage -- Send a render message to Project
*	                                editor
*
*   SYNOPSIS
*	message = SendProjectEditNoRenderMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditNoRenderMessage
SendProjectEditNoRenderMessage:
	DEBUGMSG	DBSPM,<SendProjectEditNoRenderMessage:>
	
	movem.l	d1-d3,-(sp)

	bclr.b	#7,TB_DisplayRenderMode(a5)	;switcher will control top half

	move.l	#ES_RENDER_EDIT,d0
	moveq.l	#FALSE,d1			;close editor windows
	moveq.l	#0,d2
	moveq.l	#0,d3
	bsr	SendProjectEditMessage

	movem.l	(sp)+,d1-d3	
	rts

****** SendProjectEditQuitMessage *****************************************
*
*   NAME   
*	SendProjectEditQuitMessage -- Send a render message to Project
*	                                editor
*
*   SYNOPSIS
*	message = SendProjectEditQuitMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditQuitMessage
SendProjectEditQuitMessage:
	DEBUGMSG	DBSPM,<SendProjectEditQuitMessage:>
	movem.l	d1-d3,-(sp)
	
	move.l	#ES_QUIT,d0
	moveq.l	#0,d1			;open windows
	moveq.l	#0,d2
	moveq.l	#0,d3
	bsr	SendProjectEditMessage

	bset.b	#QUIT_BIT,TB_Flags4(a5)

10$	movem.l	(sp)+,d1-d3	
	rts

****** SendProjectEditStartMessage: *****************************************
*
*   NAME   
*	SendProjectEditStartMessage -- Send a start message to Project editor
*
*   SYNOPSIS
*	Result = SendProjectEditStartMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->Message Sent to Project editor. Or NULL if no Editor.
*
*	Data1    - screen
*	Data2    - Internal croutons
*	Data3    - Window
*
*   BUGS
*
*****************************************************************************
	xdef	SendProjectEditStartMessage
SendProjectEditStartMessage:
	DEBUGMSG	DBSPM,<SendProjectEditStartMessage:>

	movem.l	d1-d4/a0,-(sp)

	move.l	#ES_STARTUP,d0
	move.l	TB_Screen(a5),d1

;;	lea	InteralCroutons,a0
;;	move.l	a0,d2
	moveq	#0,d2

	move.l	TB_Window(a5),d3
	move.l	TB_ToolBoxGrids(a5),d4	;we put project in Reply

	bsr	SendProjectEditMessage

	movem.l	(sp)+,d1-d4/a0
	rts

d967 174
d2909 3
a2911 1
30$	CALLTL	ImageryOn
@


2.128
log
@Fixed infinite loop bug in GetPrefs
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.127 1995/02/12 05:14:27 Kell Exp Kell $
d10 3
d1424 3
d4524 5
a4528 1
30$	CALLTL	SendELH2Toaster
d4531 1
a4531 1
	moveq	#0,d2
@


2.127
log
@Now handles allowing External VID3/4 on the SystemPrefs.
These will auto-switch to Flyer when required.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.126 1995/02/11 18:47:37 Kell Exp Kell $
d10 4
d4601 1
a4601 1
	beq.s	30$
@


2.126
log
@Now Jogs can handle clips larger than 18 Min.  (no limit)
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.124 1995/02/10 15:23:11 Kell Exp Kell $
d10 3
d1611 47
d1661 1
a1662 2
	moveq	#1,d1	;Flyer video on Flyer VID3
	moveq	#1,d2	;Flyer video on Flyer VID4
d1671 1
a1672 2
	moveq	#1,d1	;Flyer video on Flyer VID3
	moveq	#1,d2	;Flyer video on Flyer VID4
d4465 28
d4494 1
a4494 1
	moveq	#0,d0
d4590 10
d4601 1
a4601 1
20$	XCALL	ObtainSwitcherGPISettings	; get current state of GPI
d4782 2
a4783 1
20$	CALLTL	CookAndServeMain
@


2.125
log
@*** empty log message ***
@
text
@a3118 2
***!!!!! THIS WILL NOT WORK FOR JOGS >18 Minutes!!!!!!!!!
***!!!!! NEED TO SCALE RANGE!!
a4697 2
***!!!	NEED TO FORCE THIS VIDEO BUS INITIALLY TO BLACK!!!!

a4840 1
**!! DOES THIS CLEAR THIS CHANNEL TO MATTE IF CAF_USEMATTE IS SET???
d4871 1
a4871 1
	clr.l	ES_Reply(a1)		;assume never any errors ****!!!!
@


2.124
log
@Added AudioControl handler.  Optimized the GetStuctValue calls for GetTable.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.123 1995/01/31 10:23:50 Kell Exp Kell $
d10 3
d3109 8
a3116 2
	cmp.l	#$FFFE,d1
	bhi	666$			;jump if > 64K fields of Jog
d3123 1
a3123 1
	moveq	#-1,d2		;assume max deaccel
d3158 1
a3158 1
	swap	d0
d3160 1
a3160 1
;;	DUMPUDEC.w <Initial=>,d0,<\>
d3162 1
d3174 1
d3184 1
a3184 1
* d0.w=frame-min, a3->RCB, a4=render function
d3186 1
d3188 1
a3188 1
	ext.l	d0
@


2.123
log
@New hardcoded data to create a clip to test TBC keying.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.122 1995/01/25 18:19:23 Kell Exp Kell $
d10 3
d516 1
a516 1
	dc.l	Hand_RecordSource	; (VideoSource, Volume1, Volume2)
d541 3
a1954 4
	move.l	ES_Data1(a2),a0		;crouton
	PUT.l	ES_Data2(a2),TB_TagData
	PUT.l	ES_Data3(a2),TB_TagSize
	PUT.l	ES_Data4(a2),TB_TagID
d1956 4
d1962 1
a1962 3
	GET.l		TB_TagData,a1
	GET.l		TB_TagSize,d1
	DUMPHEXI.l	<Hand_GetTable: tagid=>,TB_TagID(a5),< >
d1967 2
a1968 2
	CALLTL	FGC_GetValueCommand

d1971 1
a1971 3
	move.w	TB_ErrFlag(a5),d0
	ext.l	d0
	move.l	d0,ES_Reply(a2)		;LONG value  (defaults to zero)
d3019 1
a3019 1
10$	tst.w	MyAudioVolume1
d3022 1
a3022 1
20$	tst.w	MyAudioVolume2
d3033 4
a3036 3
**I don't think this is currently supported on record
	move.w	MyAudioVolume1,ca_VolSust1(a0)
	move.w	MyAudioVolume2,ca_VolSust2(a0)
d3867 1
a3867 1
*	Get info about a particular drive
d3884 3
a3886 4
	move.w	ES_Data2+2(a1),MyAudioVolume1
	move.w	ES_Data3+2(a1),MyAudioVolume2

***!!!!** Audio Volume control not currently supported by Hardware!!!!
a3890 3
;;	DUMPMSG		<Hand_ReadSource:>
;;	DUMPSDEC.w	<Vol1=>,ES_Data2+2(a1),< >
;;	DUMPSDEC.w	<Vol2=>,ES_Data3+2(a1),< >
d3896 41
d5304 4
@


2.122
log
@Now complement sense of AGC flag before sending to TBC
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.121 1995/01/25 13:04:17 Kell Exp Kell $
d10 3
d5211 10
d5236 2
a5237 1
	
@


2.121
log
@TBC hack panel finished.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.120 1995/01/24 12:00:05 Kell Exp Kell $
d10 3
d1672 1
d1674 1
@


2.120
log
@New handlers for TBCread, TBCwrite, Pause, and Clip Cutting.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.119 1995/01/23 15:37:43 Kell Exp Kell $
d10 3
d424 3
a426 1
;;SERDEBUG	EQU	1
d1144 1
a1144 1
	DEBUGMSG	DBHD,<Hand_Hack !!!!!!!!!!!!!!!!!!!!!!!!!:>
d1155 4
a1158 1
	cmpi.l	#Hand_TBCread,d0
d1161 1
a1161 1
	cmpi.l	#Hand_TBCwrite,d0
d1164 3
d1174 2
d1593 22
d1618 2
d1635 2
d1645 24
d2789 4
a2792 4
	DUMPMSG		<>
	DUMPMSG		<ERROR ERROR ERROR ERROR ERROR ERROR !!!!!!!>
	DUMPMSG		<Flyer & Switcher Clocks not Syncronized!!!!>
	DUMPHEXI.L	<    FlyerTime-MasterTime = >,d0,<\>
@


2.119
log
@Hand_Hack changed to have Hack Type has a ES parameter, vs twhk_Type.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.118 1995/01/04 18:54:10 Kell Exp Kell $
d10 3
d473 1
a473 1
	dc.l	Hand_DUMMY
d523 5
a527 1
	
d1148 10
d1159 4
a1162 3
	cmpi.l	#HACK_TWEAK,ES_Data1(a0)
	bne	666$
	
d1576 2
a1577 1
recordphase 	dcb.b	32+14
d1579 29
a1607 1
	CNOP	0,4
d3930 157
d5137 1
a5137 1
testphase2 	dcb.b	32+16
@


2.118
log
@Re-enabled the code that forces both caf_AUDIOL/R on during jog/shuttle.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.117 1995/01/04 17:00:41 Kell Exp Kell $
d10 3
d511 1
a511 1
	dc.l	Hand_Hack		; (->HackStructure)
d1140 3
a1142 2
	movea.l	ES_Data1(a0),a1	;->TweakHack
	cmpi.l	#HACK_TWEAK,twhk_Type(a1)
@


2.117
log
@Don't force both channels on caf_AUDIOL/R if only playing mono.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.116 1994/12/31 05:17:31 Kell Exp Kell $
d10 3
d4458 1
a4458 2
* This hack to fix the "mono out of a stereo video clip" Cylon bug fix 
* is no longer necessary
d4460 4
a4463 5
65$	
;;	move.b	#CAF_AUDIOL!CAF_AUDIOR,d0
;;	and.b	d1,d0
;;	beq.s	66$
;;	ori.b	#CAF_AUDIOL!CAF_AUDIOR,d1
@


2.116
log
@DOHIT debugging
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.115 1994/12/31 04:05:42 Kell Exp Kell $
d10 3
d4455 2
d4458 5
a4462 4
65$	move.b	#CAF_AUDIOL!CAF_AUDIOR,d0
	and.b	d1,d0
	beq.s	66$
	ori.b	#CAF_AUDIOL!CAF_AUDIOR,d1
@


2.115
log
@Removed Matte color being forced in before sequences.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.114 1994/12/30 20:13:00 Kell Exp Kell $
d10 3
d422 3
d558 3
d570 3
@


2.114
log
@Now forcing all RenderCallBack Frames to Field I.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.113 1994/12/30 02:46:08 Kell Exp Kell $
d10 3
d419 1
d422 2
d425 1
d461 2
d464 4
d2670 1
d2677 1
d2709 1
d2725 1
d2794 5
d2810 1
a2810 1
	move.l	(sp)+,d0
d4958 2
d4961 1
@


2.113
log
@Removed dependency on TB_FlyerVolumes.  Instead using Flyer_VolumeName.
Removed Hand_FlyerVolume (not needed anymore)
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.112 1994/12/29 11:29:26 Kell Exp Kell $
d10 4
a2987 1

a2988 4

	


d3118 6
a3123 1
	move.l	RCB_Frame(a3),ES_Reply(a2)	;final position
@


2.112
log
@New debugs, and now supports QUIT_BIT to signal event loop to Quit switcher.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.111 1994/12/29 08:00:40 Kell Exp Kell $
d10 3
d410 2
d481 1
a481 1
	dc.l	Hand_FlyerVolumes	; (->)
a1249 2
	CALLTL	DisplayWaitSprite

d1251 5
a1255 4
	lea	gotvolume(pc),a0
	tst.b	(a0)
	bne.s	580$
	move.b	#1,(a0)
d1257 2
a1258 3
	GET.l	TB_FlyerVolumes,d0
	beq	666$			;error, unable to send message	
	movea.l	d0,a0			;->array of string pointers
d1260 3
a1262 3
500$	movea.l	(a0)+,a1		;next string
	tst.b	(a1)
	beq	666$			;didn't find any volumes
a1263 8
	cmpi.b	#AudioByte,(a1)
	beq.s	500$			;try next if this is an audio drive
	
	lea	recordphase(pc),a0
510$	move.b	(a1)+,(a0)+
	bne.s	510$
	subq.w	#1,a0

d1519 1
a1519 2
gotvolume	dc.b	0
recordphase 	dcb.b	32+13
a1700 28
****** Hand_FlyerVolumes ***********************************************************
*
*   NAME   
*	Hand_FlyerVolumes
*
*   SYNOPSIS
*	Hand_FlyerVolumes(message)
*	              d0
*
*   FUNCTION
*	
*   INPUTS
*
*   RESULT
*
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_FlyerVolumes
	DEBUGMSG	DBHD,<Hand_FlyerVolumes:>

	move.l	d0,a0
	PUT.l	ES_Data1(a0),TB_FlyerVolumes
	clr.l	ES_Reply(a0)		;no errors possible
	rts

d4718 3
d4723 1
a4723 9
	lea	gotvolume2(pc),a0
	tst.b	(a0)
	bne	580$
	move.b	#1,(a0)

***!! THIS SHOULD BE BUILD DYNAMICALLY, BUT I AM CURRENTLY UNABLE TO SEND
***!! A MESSAGE TO THE EDITOR IF THIS WAS INITIATED VIA AREXX, BECAUSE
***!! THE AREXX PORT WILL NOT BE WORKING SO GOOD (I'm in a wait loop).
	GET.l	TB_FlyerVolumes,d0
d4726 5
a4730 6
	movea.l	d0,a0			;->array of string pointers

500$	movea.l	(a0)+,a1		;next string
	tst.b	(a1)
	beq	666$			;didn't find any volumes
	
d4732 1
a4732 3
	cmpi.b	#AudioByte,(a1)
	beq	500$			;try next if this is an audio drive
	
d4737 1
a4737 1
	subq.w	#1,a0
a4750 4
*-------
580$


d4758 7
d4771 2
d4797 2
d4824 2
d4850 2
d4865 3
d4870 4
a4873 1
600$	XJSR	Flyer_CloseField
d4884 1
a4884 2
gotvolume2	dc.b	0
testphase2 	dcb.b	32+15
@


2.111
log
@Now don't allow non-Field Is in jogging.  Also, jog max limit upped by 1.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.110 1994/12/28 18:04:10 Kell Exp Kell $
d10 3
d400 1
a401 1
;;DBSPM	set	1	;Debug SendProject...Message stuff
d523 1
a523 1
10$	DEBUGMEM	DBHPEM,<HandlePEMessage: Message=>,ES_Cookie(a0),#ES_SIZEOF-ES_Cookie
a801 2

	DEBUGMSG	DBSPM,<SendProjectEditQuitMessage2>
d809 2
d922 1
a922 1
	beq.s	.exit2			;NULL = Editor port not present
d928 3
d933 2
d939 3
d944 3
d1004 2
d1016 5
d1023 4
d1590 3
d1909 2
d2251 2
@


2.110
log
@Now does a Forbid/permit around sending a message to the Editor.
Also, once again supports forcing Main to matte black before sequences.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.109 1994/12/23 14:49:26 Kell Exp Kell $
d10 4
d637 1
a637 1
***!!!*** Use this if you want our LoadSeg
d2479 1
a2479 1
****!!!!!!
d2492 1
a2492 1
	tst.w	TB_OLaySec(a5)	;**!!! HACK
d2935 2
a2936 2
;	DUMPUDEC.l <Max=>,d1,<  >
;	DUMPUDEC.l <Min=>,RCB_Min(a3),< >
d2939 1
a2939 1
	cmp.l	#$FFFF,d1
d2972 2
a2973 1
100$	swap	d1
d2975 4
d2980 1
a2980 1
;	DUMPUDEC.l <Frame=>,d0,<\>	
d2984 8
d3016 1
a3016 1
;	DUMPUDEC.l <X=>,d0,<\>
d3020 7
d4218 1
a4218 1
******!!!!!!!
@


2.109
log
@New debugs.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.108 1994/12/23 03:32:53 Kell Exp Kell $
d10 3
d908 3
d912 1
a912 1
	move.l	TB_SYSBase(a5),a6
d915 1
a915 1
	beq.s	.exit			;NULL = Editor port not present
d920 1
a920 1
	move.l	TB_SYSBase(a5),a6
d923 2
d930 3
d2536 7
a2542 1
	bsr	AbortPlayRec
d2651 6
a2656 1
;;	bsr	ForceMainToBlank
d2658 1
a2658 1
	CALLTL	ImageryOn
d2674 3
a2676 1
*
a2686 1
*** I THINK THIS IS AN OBSOLETE FUNCTION ****!!!!!
d2694 9
a2702 2
;;	bsr	ForceMainToBlank
	rts
a2765 2

	IFD	CRAP
d2784 4
d2789 2
d4902 1
@


2.108
log
@New debugs.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.107 1994/12/17 04:56:29 Kell Exp Kell $
d10 3
a1789 2
	DUMPHEXI.l	<Hand_GetTable: tagid=>,TB_TagID(a5),< >
	DUMPHEXI.l	<FG=>,a0,<\>
d1792 3
d1799 1
a1799 1
;;	DEBUGMEM	DBHD,<Table>,0(a1),d1
d1940 1
a1940 1
;;	DEBUGMEM	DBHD,<Table>,0(a1),d1
@


2.107
log
@New ES_FlyerVolumes handler.  Now this is received from the Editor, instead of sent to the editor.
New MakeTestClip code for making an IVectorWithPulse 4 field clip.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.106 1994/12/09 15:42:01 pfrench Exp Kell $
d10 4
a1710 2
	DEBUGTXT	DBHD,<Hand_TagSize:>

d1715 1
d1779 5
a1783 5
	move.l	d0,a1
	move.l	ES_Data1(a1),a0		;crouton
	PUT.l	ES_Data2(a1),TB_TagData
	PUT.l	ES_Data3(a1),TB_TagSize
	PUT.l	ES_Data4(a1),TB_TagID
d1799 4
a1802 1
	move.l	d0,ES_Reply(a1)		;LONG value  (defaults to zero)
@


2.106
log
@Now a little more friendly when waiting for replies
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.105 1994/12/06 23:34:32 Kell Exp pfrench $
d10 3
d459 1
a459 1
	dc.l	Hand_DUMMY		;() = ES_FlyerVolumes sent to Editor
d571 1
a571 1
	bra.s	156$
a575 1
	
a724 35
****** SendFlyerVolumesMessage *****************************************
*
*   NAME   
*	SendFlyerVolumesMessage -- Get a table of flyer volume names
*	                             
*   SYNOPSIS
*	message = SendFlyerVolumesMessage()
*
*   FUNCTION
*
*   INPUTS
*	a5->TB
*
*   RESULT
*	d0->(->volnames) array of string ptrs, empty string terminated or NULL if no Flyer
*
*   BUGS
*
*****************************************************************************
	xdef	SendFlyerVolumesMessage
SendFlyerVolumesMessage:
	DEBUGMSG	DBSPM,<SendFlyerVolumesMessage:>
	
	movem.l	d1-d4,-(sp)

	move.l	#ES_FlyerVolumes,d0
	moveq.l	#0,d1
	moveq.l	#0,d2
	moveq.l	#0,d3
	moveq.l	#4,d4
	bsr	SendProjectEditMessage

	movem.l	(sp)+,d1-d4
	rts

d882 1
a882 1
	bne.s	.exit			;jump if Editor not open
a913 1

a914 1

d952 1
a954 1
.dosearch
d958 2
a959 1
	beq.s	.notfound
d961 4
a964 1
	bne.s	.loop
a965 3
	cmpa.l	a3,a0
	bne.s	.loop
					;found the message
a977 1

a979 2
	CALLROM	Forbid

d1206 1
a1206 1
	bsr	SendFlyerVolumesMessage
a1207 5

	movea.l	d0,a0
	move.l	ES_Reply(a0),d0
	beq	666$			;jump if no flyer volumes
	
d1657 28
d4644 185
@


2.105
log
@Limited Sub-Nyquist to not it's best mode.  Using 3 instead of 2.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.104 1994/12/05 19:21:40 Kell Exp Kell $
d10 3
d1011 2
d1015 2
@


2.104
log
@New values for compression modes.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.103 1994/12/05 19:09:24 Kell Exp Kell $
d10 3
d3611 1
d3613 1
d3621 1
a3621 1
	moveq.l	#2,d1
@


2.103
log
@Support for Record compression modes.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.102 1994/11/30 22:42:22 Kell Exp Kell $
d10 3
d3609 1
a3609 1
	moveq.l	#5,d2		;worst mode
d3616 1
a3616 1
	moveq.l	#3,d1
@


2.102
log
@New SavePrefs handler.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.101 1994/11/23 16:41:33 Kell Exp Kell $
d10 3
d3588 1
d3603 11
a3613 1
	clr.l	ES_Reply(a0)		;assume no errors
d3615 1
a3615 1
;; ***!!!** Currently not supported!!!!!!
d3617 1
@


2.101
log
@New Hand_NewFieldCount and Hand_UnSavable handlers added.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.100 1994/11/18 08:54:10 Kell Exp Kell $
d10 3
d450 1
d4011 3
a4013 1
100$	CALLTL	WriteHardSets		;Should I use WriteHardSets????
d4015 1
a4015 1
	move.l	d0,ES_Reply(a2)		;0=OK, 1=OpenError, 2=Write error
d4064 30
@


2.100
log
@New WaitForReplyMessage() function.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.99 1994/11/17 15:40:09 Kell Exp Kell $
d10 3
d445 3
a447 1

d1791 67
@


2.99
log
@Syncclock function added.  Now can occur outside of ES_StartSequence call.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.98 1994/11/11 10:17:50 Kell Exp Kell $
d10 3
d362 1
d369 3
d923 3
a925 1
	bsr	WaitForReplyMessage
d940 2
a941 2
*	Message = WaitForReplyMessage(Port)
*	  d0                           a0
d946 1
d950 1
d958 1
d960 1
a960 1
	movem.l	d0-d1/a0-a2/a6,-(sp)
d962 3
a964 2
	move.l	(4).w,a6		;exec base
	move.l	a0,a2
d976 1
a976 1
	cmp.l	#OnlyMessage,a0
d982 1
a982 1
	bra.s	.exit
a988 1
	CALLROM	Wait
d990 3
a992 1
	bra.s	.dosearch
d996 1
a996 1
	movem.l	(sp)+,d0-d1/a0-a2/a6
d2386 1
a2386 1
	IFD	CRAP
d2430 2
a2431 1
	ENDC
@


2.98
log
@Changed parameters on some older Flyer functions. ToasterMux, InputSelect, Start/End Headlist, Play/Record Mode.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.97 1994/11/10 02:52:08 Kell Exp Kell $
d10 3
d2365 7
a2371 3
** to field I of the Toaster.  You should key on WHITE, keying the
** 4FieldCount stillstore over Matte (=encoder).  Then run this.
** Look at it on a Betacam SP deck single framing, or a Waveform monitor.
d2375 3
d2384 1
a2384 2

4$	CALLTL	IsLMBdown
d2403 1
a2403 1
7$	CALLTL	IsLMBdown
d2414 2
a2415 1
	movem.l	(sp)+,d0-d7/a0-a6
d2422 14
a2439 2
	bsr	AbortPlayRec

d2443 1
a2443 1
	move.l	d0,d2
d2446 1
a2446 1
	cmp.l	d0,d2
d2449 1
a2449 1
* Usually about 40% down field. The current count applies to start of next field.
d2452 2
a2453 2
20$ 	move.b	vhposr(a0),d2
    	cmpi.b	#30,d2
d2456 2
a2457 1
	subq.l	#1,d0			;compensate because GetFieldClock changes 40% down the field
d2468 1
a2468 2
666$	bset.b	#4,TB_DisplayRenderMode(a5)

@


2.97
log
@New InitFlyerPlay function to set input sync, and Play mode.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.96 1994/11/04 08:46:21 Kell Exp Kell $
d10 3
d1322 1
a1322 1
	suba.l	a0,a0		;no specific board
d1333 1
a1333 1
	suba.l	a0,a0		;no specific board
a3384 1
	move.l	a0,-(sp)
d3391 1
a3391 1
	suba.l	a0,a0		;no specific board
a3392 2

	move.l	(sp)+,a0
d3564 1
a3564 1
	suba.l	a0,a0		;no specific board
d3667 1
a3667 1
	suba.l	a0,a0		;all boards!!!
d3701 2
a3702 2
	suba.l	a0,a0		;all boards!!!
	moveq	#1,d0		;don't abort, really do it!
@


2.96
log
@ES_LoadedSlices now used WhatSlicesLoaded() call.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.95 1994/11/04 03:29:29 Kell Exp Kell $
d10 3
d1600 1
a1600 1
	bne.s	2$
d1651 1
d2511 1
d3372 4
d3377 6
d3387 2
d3392 1
a3392 3
	clr.w	RecordModeFlag

	move.l	d0,ES_Reply(a1)
@


2.95
log
@Some Debugs for Hand_RecordSource, added LoadedSlices support.
Now uses new DUMPCA macro.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.94 1994/11/02 19:11:56 Kell Exp Kell $
d10 4
d2095 2
a2096 3

	XREF	LoadedSlices
	move.l	LoadedSlices,ES_Reply(a0)
@


2.94
log
@Now forces both CAF_AUDIO flags on if either is used.
Sets audio volume depending on user setting for Jog/Shuttle.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.93 1994/10/31 17:08:45 Kell Exp Kell $
d10 4
a345 1

a348 1

d350 1
d421 2
a422 1
	
d2068 28
d2175 1
d2709 1
a2709 1
100$	XJSR	Flyer_Record	;a0->ClipAction
d2711 2
d3509 5
@


2.93
log
@Now reads flyer calibration values before Tweeking.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.92 1994/10/28 14:13:08 Kell Exp Kell $
d10 3
d2646 1
a2646 1
10$	tst.w	RecordVolume1
d2649 1
a2649 1
20$	tst.w	RecordVolume2
d2661 2
a2662 2
	move.w	RecordVolume1,ca_VolSust1(a0)
	move.w	RecordVolume2,ca_VolSust2(a0)
d3251 5
a3255 1
55$	move.w	#$ffff/2,d0	;assume +/- 1x
d3259 1
a3259 1
* caluculate volume
d3263 2
a3264 3
50$	btst.b	#CAB_AUDIOL,ca_Flags(a0)
	beq.s	51$
	move.w	d0,ca_VolSust1(a0)
d3266 2
a3267 1
51$	btst.b	#CAB_AUDIOR,ca_Flags(a0)
d3269 3
a3271 1
	move.w	d0,ca_VolSust2(a0)
d3273 6
d3467 2
a3468 2
	move.w	ES_Data2+2(a1),RecordVolume1
	move.w	ES_Data3+2(a1),RecordVolume2
d4098 3
a4100 2
***!!! Do we want this volume to be based on the user set volume??
	move.w	#$ffff/2,ca_VolSust1(a1) ;this default may be changed before DoFindField
d4117 3
a4119 2
***!!! Do we want this volume to be based on the user set volume??
	move.w	#$ffff/2,ca_VolSust2(a1) ;this default may be changed before DoFindField
d4125 14
a4138 1
65$	move.b	d1,ca_Flags(a1)
d4449 2
a4450 2
RecordVolume1	dc.w	0
RecordVolume2	dc.w	0
@


2.92
log
@Added Tweek handling for Pedestal.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.91 1994/10/28 12:59:13 Kell Exp Kell $
d10 3
d1033 3
d1037 10
d1085 4
a1088 1
	move.l	twhk_Pedestal(a1),d2	;value
d1123 4
a1126 1
	move.l	twhk_Pedestal(a1),d2	;value
d1323 137
@


2.91
log
@Now redraws display after calling Application Slices.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.90 1994/10/27 14:00:31 Kell Exp Kell $
d10 3
d1066 7
d1101 7
@


2.90
log
@Hacks to turn a still into a 4 field sequence.
For strobbing BM dma in sync with the GoClock %00 fields
Checks to see if TB clock and Flyer clock stay in sync.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.89 1994/10/25 13:53:24 Kell Exp Kell $
d10 5
d4177 1
a4177 1
	bra	500$
d4188 1
a4188 1
	bra	500$
d4199 2
a4200 1
;;	bra.s	500$
d4202 1
d4204 3
@


2.89
log
@Remarks
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.88 1994/10/25 07:11:04 Kell Exp Kell $
d10 3
d308 1
d333 2
d2132 50
d2210 6
d2252 25
a2276 1
	beq.s	666$			;jump if not sequencing
d3734 80
@


2.88
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.87 1994/10/25 07:06:52 Kell Exp Kell $
d10 3
d2144 2
a2146 5
		
;;	move.l	vposr(a0),d2
;;	DUMPHEXI.l	<vhposr=>,d2,<\>


d2149 1
a2149 1
    	bcs.s	20$	;jump if too near field start (to be safe)
a2150 1
****!!!! Will this be necessary in the final design????
@


2.87
log
@Fixed vhposr bug when syncing flyer and switcher clocks.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.86 1994/10/21 23:22:53 Kell Exp Kell $
d10 3
d2151 1
@


2.86
log
@Fixed some InputTerm bugs.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.85 1994/10/21 17:01:47 Kell Exp Kell $
d10 3
d2139 6
a2144 1
20$ 	move.w	vhposr(a0),d2
d2148 1
a2149 2

;;	DUMPHEXI.l	<Sync Time=>,d0,<\>
@


2.85
log
@New Hand_GetPrefs and Hand_SetPrefs handlers.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.84 1994/10/15 01:29:50 Kell Exp Kell $
d10 3
d311 1
a311 1
SERDEBUG	EQU	1
d1509 1
a1509 1

d3525 1
d3549 1
d3586 2
a3587 1
	GET.w	TB_InputTerm,spref_Termination(a0)
@


2.84
log
@The Hack flyer adjustment panel now uses the Editors Volume list to get a flyer volume name.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.83 1994/10/12 00:23:55 Kell Exp Kell $
d10 3
d383 4
d3464 129
@


2.83
log
@Fixed Jogging not showing correct video channel.
Now supports GRAZERLOAD_BIT on ES_LoadCrouton, so we can have different end points on clips that are played form Grazer, vs drug into project.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.82 1994/10/07 23:39:16 Kell Exp Kell $
d10 4
d305 1
a305 1
;;SERDEBUG	EQU	1
d639 35
d980 3
d1109 42
a1150 1
	GET.l	TB_DOSBase,a6
d1195 5
d1224 1
d1254 3
a1256 1
recordphase 	dc.b	'SKell0:RecordPhase',0
@


2.82
log
@Now handles audio only clips better.
Code for ES_hack for calibrating the flyer manually.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.81 1994/10/05 05:53:43 Kell Exp Kell $
d10 4
d321 1
a321 1
	dc.l	Hand_LoadCrouton	;(name)
d1622 8
a1629 1
	bsr	LoadDiskCrouton
d3408 1
d3413 1
a3413 1
	beq.s	6$
a3440 2
	XJSR	Flyer_Defaults

@


2.81
log
@Better debugs.  ES_Hack added.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.80 1994/10/01 12:56:45 Kell Exp Kell $
d10 3
d941 222
a1162 2
	clr.l	ES_Reply(a0)
	rts
d1371 1
a1371 1
	DUMPUDEC.l	< TagSize=>,d0,<\>
a1396 2
	DEBUGMSG	DBHD,<Hand_GetValue:>

a1428 2
	DEBUGMSG	DBHD,<Hand_GetTable:>

d2409 4
d2414 6
a2419 1
	XJSR	Flyer_DoFindField
d2677 11
a2687 2
	move.l	d3,ca_VidStartField(a0)	
	XJSR	Flyer_DoFindField	;will indicate 1,2 or 4 fields
d2840 4
d2846 4
d2852 1
a2852 1
	clr.l	ca_VolSust1(a0) ;assume stopped (assume VolSus1 is after VolSus2!!!)
d2933 2
d3105 2
d3396 2
d3400 2
a3405 5
	bsr	AbortPlayRec	;to prevent confusion

	XLEA	MyClipAction,a0
	XJSR	Flyer_Defaults
	exg	a0,a3		;a0->FG, a3->ca
a3406 9
	movea.l	ca_Volume(a3),a1
	move.l	FGS_FileName(a0),fv_Path(a1)	

;;	clr.l	ca_ID(a3)

	move.b	#RT_IMMED,ca_ReturnTime(a3)

*-----------

d3414 1
a3414 1
	move.b	#1,ca_Channel(a3)
d3419 1
a3419 1
	move.b	#0,ca_Channel(a3)
d3425 16
a3440 1
	movea.l	a3,a1
d3443 1
a3443 4
	move.b	#CAPF_STEALOURVIDEO+CAPF_KILLOTHERVIDEO,ca_PermissFlags(a3)
	move.w	#(71<<8)+$80,ca_MatteY(a3)	;71.5 D2 Black

	exg	a3,a0	;a0->ca, a3->FG
d3458 9
a3466 1
	move.b	#CAF_VIDEO+CAF_USEMATTE+CAF_NOPREROLL,d1  ;assume no audio
d3468 1
a3468 1
	move.l	#TAGID_AudioOn,d0
d3542 2
d3546 1
a3546 1
	lea	FindFieldCA,a2
d3588 4
d3593 6
a3598 1
	XJSR	Flyer_DoFindField
d3817 2
@


2.80
log
@Added Flyer_DefaultSelect for restoring muxes after record.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.79 1994/10/01 01:08:18 Kell Exp Kell $
d10 3
d367 1
d914 27
d1137 1
a1137 1
	DEBUGMSG	DBHD,<Hand_TagSize:>
d1144 6
a1150 1
	GET.l	TB_TagSize,ES_Reply(a1)		;LONG value  (defaults to zero on errors)
d1216 8
d1226 2
d1296 2
d1468 2
a1469 2
	move.l	ES_Data1(a2),a0		;crouton
	move.l	ES_Reply(a2),a1		;clone
d1478 1
a1478 1
	CALLTL	FGC_SaveTagsCommand		;see if FG has any tags & where
@


2.79
log
@Increased SHUTTLE mouse distance to 500 (from 300)
Tied in Clip Icon making.  Though currently does BUSY wait for 3 secs!!
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.78 1994/09/30 21:07:38 Kell Exp Kell $
d10 4
d2635 2
a3017 7

****!!!!! BOGUS WAIT FOR Flyer_AbortAction() TO WORK!!!!!
	move.w	#3*60,d0
10$	CALLTL	Wait4Top
	dbra	d0,10$


@


2.78
log
@Handlers for Making and Appending Icon, plus getting clip info.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.77 1994/09/29 15:27:19 Kell Exp Kell $
d10 3
d2248 1
a2248 1
SHUTTLEWIDTH 	EQU 300	;zero is at SHUTTLEWIDTH/2
d3013 10
a3022 4
	move.l	ES_Data1(a1),a0	;name
	move.l	ES_Data2(a1),a1	;->CrUD
	move.l	ES_Data3(a1),d0 ;CrUD size
	move.l	ES_Data4(a1),d1 ;Field#
d3025 1
a3025 1
	
d3054 1
a3054 1
	move.l	d0,a2
d3057 2
a3058 2
	CALLTL	AppendIcon
	move.l	d0,ES_Reply(a2)
@


2.77
log
@Handlers for Clip Heads added.  Now Defrag Voids clip heads.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.76 1994/09/28 22:22:38 Kell Exp Kell $
d10 3
d354 4
d2667 33
d2983 68
@


2.76
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.75 1994/09/28 22:18:59 Kell Exp Kell $
d10 3
d347 3
d1731 2
d2792 1
d2830 112
a2942 1
666$	rts
d2948 1
d2950 1
d3140 1
a3140 1
*	Hand_Jump(message) (FG,field)  ***!!!! DON'T NEED FG
@


2.75
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.74 1994/09/28 22:15:37 Kell Exp Kell $
d10 3
d2784 1
a2784 1
	XJSR	Flyer_Defrag
@


2.74
log
@Now has ES_FlyerDefrag handler.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.73 1994/09/28 19:30:57 Kell Exp Kell $
d10 3
d2754 1
a2754 1
****** Hand_FlyerDefrag *****************************************************
d2757 1
a2757 1
*	Hand_FlyerDefrag
d2760 1
a2760 1
*	Hand_FlyerDefrag(message)
d2775 2
a2776 2
Hand_FlyerDefrag:
	DEBUGMSG	DBHD,<Hand_FlyerDefrag:>
@


2.73
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.72 1994/09/28 18:58:24 Kell Exp Kell $
d10 3
d337 2
d2746 28
d2775 4
a2778 1
	DEBUGMSG	DBHD,<after Hand_InitRecord>
@


2.72
log
@Select on Clips when sequencing now works with our new clock stuff.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.71 1994/09/27 09:07:34 Kell Exp Kell $
d10 3
d1771 1
a1771 1
	PUT.l	#-1,TB_SequenceStart
@


2.71
log
@New Hand_CheckRecord handler
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.70 1994/09/27 08:10:58 Kell Exp Kell $
d10 3
d356 3
a358 1
	xdef	HandlePEMessage
a1250 62
*+****** Hand_SETRMOFF ***********************************************************
*+*
*+*   NAME   
*+*	Hand_SETRMOFF -- Turn off toolbox rendering.
*+*
*+*   SYNOPSIS
*+*	Hand_SETRMOFF(message)
*+*	                d0
*+*
*+*   FUNCTION
*+*	Turns off toolbox rendering.
*+*
*+*   INPUTS
*+*
*+*   RESULT
*+*
*+*   BUGS
*+*
*+*   SEE ALSO
*+*	EditSwit.i
*+*****************************************************************************
*+Hand_SETRMOFF
*+	DEBUGMSG	DBHD,<Hand_SETRMOFF:>
*+
*+***!!!*** I don't think this is actually ever called from the editor!!!
*+
*+	move.l	d0,a0
*+	clr.l	ES_Reply(a0)
*+	bset.b	#7,TB_DisplayRenderMode(a5)
*+	rts
*+****** Hand_SETRMON ***********************************************************
*+*
*+*   NAME   
*+*	Hand_SETRMON -- Turn on toolbox rendering.
*+*
*+*   SYNOPSIS
*+*	Hand_SETRMON(message)
*+*	                d0
*+*
*+*   FUNCTION
*+*	Turns on toolbox rendering.
*+*
*+*   INPUTS
*+*
*+*   RESULT
*+*
*+*   BUGS
*+*
*+*   SEE ALSO
*+*	EditSwit.i
*+*****************************************************************************
*+Hand_SETRMON
*+	DEBUGMSG	DBHD,<Hand_SETRMON:>
*+
*+***!!!*** I don't think this is actually ever called from the editor!!!
*+
*+	move.l	d0,a0
*+	clr.l	ES_Reply(a0)
*+	bclr.b	#7,TB_DisplayRenderMode(a5)
*+	rts


a1673 26

	IFD	CRAP
*+	CALLTL	SoftSpriteOff
*+
*+	btst.b	#4,TB_DisplayRenderMode(a5)	;are we in sequence
*+	bne.s	1$				;jump if so
*+
*+***!!!!*** WRONG!!! Just because were're on switcher doesn't mean
*+* the frame/clip was loaded!!!  Maybe we went into switcher mode
*+* after the crouton was selected!!!!!!!!!!
*+	btst.b	#SWITCHER_BIT,TB_GUImodeBottom(a5)	;on switcher ?
*+	bne.s	1$
*+
*+* Hack to allow frames to load
*+	GET.b	TB_GUImodeBottom,d2			;stash mode flag
*+	bset.b	#SWITCHER_BIT,TB_GUImodeBottom(a5)	;just like on switcher
*+	CALLTL	FGC_SelectCommand	;make sure it's selected!!
*+	PUT.b	d2,TB_GUImodeBottom		;restore mode flag
*+
*+1$	CALLTL	AllInterruptsOff
*+	CALLTL	FGC_AutoCommand
*+	CALLTL	AllInterruptsOn
*+	CALLTL	UpdateDisplay
*+	CALLTL	SoftSpriteOn
	ENDC	;CRAP

d1765 1
a1765 1
	beq.s	666$
d1768 2
d1942 3
a1944 1
	move.b	#RT_STARTED,ca_ReturnTime(a0)
d1982 1
a2431 6
* ***!!!! TO AVOID WEIRD SLIDER MOVEMENTS, WE SHOULDN'T GO CRAZY IF
* ***!!!! THE MOUSE IS DRUG FAST (>128 CLICKS).
* ***!!!! DON'T JUMP FORWARD/BACKWARD ETC.

***!!!! MUCH OF THE DOSHUTTLE CODE IS SIMILAR TO ABOVE.
***!!!! I SHOULD SHARE THE SAME CODE!!!!
d2596 1
@


2.70
log
@First attempt at ES_Record.
ES_RecodeSource now stashes requested state for ES_Records use.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.69 1994/09/27 04:45:35 Kell Exp Kell $
d10 4
d326 1
d2826 35
@


2.69
log
@Handlers for FlyerCommpression, RecordSource added.
Now ES_Stop is used for play/record or sequencing.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.68 1994/09/23 08:31:05 Kell Exp Kell $
d10 4
d1842 1
a1842 5
;;	lea	Flags1,a0
;;	btst.b	#0,(a0)
;;	beq.s	100$		;jump if playmode

100$	btst.b	#4,TB_DisplayRenderMode(a5)
d1990 3
a1992 3
*	Data1   - Parameter Structure
*	Data2	- Parameter 
*
d2004 2
a2005 4
	clr.l	ES_Reply(a2)		;assume no error

	tst.l	TB_FlyerBase(a5)
	beq.s	666$
d2009 1
a2009 4
	IFD	CRAP
StuffCAparams
	movem.l	d0-d2,-(sp)
	move.b	#CAF_VIDEO+CAF_USEMATTE+CAF_NOPREROLL,d1  ;assume no audio
d2011 1
a2011 3
	move.l	#TAGID_AudioOn,d0
	CALLTL	GetLongValue
	move.l	d0,d2
d2013 2
a2014 2
	btst	#AUDB_Channel1Enabled,d2
	beq.s	62$
d2016 1
a2016 4
	move.l	#TAGID_AudioVolume1,d0
	CALLTL	GetLongValue
	beq.s	62$			;jump if no audio1
	ori.b	#CAF_AUDIOL,d1
d2018 2
a2019 5
;;	move.l	#TAGID_AudioVolume1,d0
;;	CALLTL	GetLongValue
;;	move.w	d0,ca_VolSust1(a1)
***!!! Do we want this volume to be based on the user set volume??
	move.w	#$ffff/2,ca_VolSust1(a1) ;this default may be changed before DoFindField
d2021 21
a2041 3
	move.l	#TAGID_AudioPan1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan1(a1)
d2043 2
a2044 2
62$	btst	#AUDB_Channel2Enabled,d2
	beq.s	65$
d2046 1
a2046 4
	move.l	#TAGID_AudioVolume2,d0
	CALLTL	GetLongValue
	beq.s	65$			;jump if no audio2
	ori.b	#CAF_AUDIOR,d1
d2048 6
a2053 5
;;	move.l	#TAGID_AudioVolume2,d0
;;	CALLTL	GetLongValue
;;	move.w	d0,ca_VolSust2(a1)
***!!! Do we want this volume to be based on the user set volume??
	move.w	#$ffff/2,ca_VolSust2(a1) ;this default may be changed before DoFindField
d2055 2
a2056 3
	move.l	#TAGID_AudioPan2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_AudioPan2(a1)
d2058 6
a2063 64
65$	move.b	d1,ca_Flags(a1)
	movem.l	(sp)+,d0-d2
	rts









	ENDC


































	moveq	#0,d0		 ;channel 0!!
	move.l	ES_Data1(a2),d1	 ;start point
	move.l	ES_Data2(a2),d2	 ;end point
	lea	numfields(pc),a0 ;# fields
	clr.l	(a0)

	DUMPREG	<recordclip>


	movem.l	d1-d7/a0-a6,-(sp)
;DHD	XJSR	_RecordClip
	movem.l	(sp)+,d1-d7/a0-a6

	move.l	#(25*60)-1,d0
10$	CALLTL	Wait4Top
	dbra	d0,10$
	
d2066 4
a2069 6
	CALLTL	InstallAVEI
;;	CALLTL	DisplayNormalSprite

666$	rts

numfields	dc.l	0
a2070 2
666$	rts

a2679 3
	lea	Flags1,a0
	bclr.b	#0,(a0)		;flag that were're in play mode

d2775 5
d2781 1
a2782 2
***!!!!** Audio Volume control not currently supported !!!!

d2813 1
a2813 1

a2818 3
	lea	Flags1,a0
	bset.b	#0,(a0)		;flag that were're in record mode

d2864 2
a2865 1
5$	bsr	AbortPlayRec	;to prevent confusion
a2878 1
	CALLTL	DoTakeNoKey
d2896 2
d3256 3
a3258 2
Flags1	dc.b	0
;; Bit 0 = record mode flag
@


2.68
log
@Shuttle now avoids the FF/REW stage mode.  1x & -1x now larger area.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.67 1994/09/22 05:10:55 Kell Exp Kell $
d10 3
d284 1
a284 1
	dc.l	Hand_StopSeq		;() Also stops clip anytime
d292 2
a293 2
	dc.l	Hand_Record		;(startBlock,endBlock)
	dc.l	Hand_AbortRecord	;() NOW USE Hand_StopSeq !!!
d315 4
d1809 1
a1809 1
****** Hand_StopSeq *****************************************************
d1812 1
a1812 1
*	Hand_StopSeq -- Indicate end of sequence
d1815 1
a1815 1
*	Hand_StopSeq(message)
d1830 2
a1831 2
Hand_StopSeq:
	DEBUGMSG	DBHD,<Hand_StopSeq:>
d1838 5
a1842 1
	btst.b	#4,TB_DisplayRenderMode(a5)
d1990 2
a1991 2
*	Data1   - StartBlock
*	Data2	- EndBlock
d2004 1
a2004 1
	clr.l	ES_Reply(a2)
d2009 92
a2100 7
;;5$	CALLTL	IsLMBdown
;;	tst.l	d0
;;	bne.s	5$
;;	CALLTL	DisplayWaitSprite
;;	CALLTL	Wait4Top
;;	CALLTL	Wait4Top
	CALLTL	InstallAVE
a2101 1
	bsr	AbortPlayRec
a2128 29
****** Hand_AbortRecord *****************************************************
*
*   NAME   
*	Hand_AbortRecord
*
*   SYNOPSIS
*	Hand_AbortRecord(message)
*	                  d0
*
*   FUNCTION
*	Aborts recording or playback
*
*   INPUTS
*
*   RESULT
*	ES_Reply  -  error code 0
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_AbortRecord:

	DEBUGMSG	DBHD,<Hand_AbortRecord:>

	move.l	d0,a1
	clr.l	ES_Reply(a1)
	bsr	AbortPlayRec

a2709 111

****************************************************************
* SET UP MAIN BUS SO IT IS ON VIDEO3
**
**	move.l	d0,a2
**
**	GET.w	TB_MainSec,d0
**	TURNLIVEDVEOFF	d0
**	cmpi.w	#M_VIDEO3,d0
**	beq.s	10$
**	PUT.w	#M_VIDEO3,TB_MainSec
**	CALLTL	CookMain
**	CALLTL	CookAndServePrvw
**
**10$	clr.l	ES_Reply(a2)	;assume no Flyer
**
**	tst.l	TB_FlyerBase(a5)
**	beq	666$
**
*** STOP ANY PREVIOUS JOGGING
**	bsr	AbortPlayRec
**
**	move.l	ES_Data1(a2),a0		;->FG
**	move.l	ES_Data3(a2),d2		;field #
**
**	DEBUGUDEC.l	DBJOG,<field#=>,d2,<\>
**
*** DHD OBSOLETE!!!
**;;	move.l	#TAGID_RecStartPoint,d0
**	CALLTL	GetLongValue
**	move.l	d0,d1			;block
**	
**	DEBUGHEXI.l	DBJOG,<point=>,d1,<\>
**
**	moveq	#0,d0			;always drive 0
**
**;;	DUMPREG	<FindField=>
**
**
*** MOVE TO REQUESTED FRAME
**	movem.l	d1-d7/a0-a6,-(sp)
**;DHD	XJSR	_FindField
**	movem.l	(sp)+,d1-d7/a0-a6
**
**	move.l	d0,ES_Reply(a2)
**	beq	666$			;jump if error
**
**;;	DUMPHEXI.l	<FindField=>,d0,<\>
**
***--------------------
*** NO ERRORS
**	move.l	d0,d1
**	move.l	ES_Data1(a2),a0		;->FG
**	move.l	ES_Data2(a2),d2
**	bne	100$			;jump if new outpoint
**
*** NEW INPOINT
**	DEBUGMSG	DBJOG,<New In Point>
**
*** DHD OBSOLETE!!!
**;;	move.l	#TAGID_ClipStartPoint,d0
**
**
*** STASH NEW START POINT
**	CALLTL	PutLongValue
**	
**	DEBUGTXT	DBJOG,<1,>
**
**	move.l	#TAGID_ClipStartField,d0
**	CALLTL	GetLongValue
**	sub.l	ES_Data3(a2),d0			;oldstart-newstart
**	move.l	d0,d1	
**
**	DEBUGTXT	DBJOG,<2,>
**
**	move.l	#TAGID_Duration,d0
**	CALLTL	GetLongValue
**	add.l	d0,d1				;olddur+(oldstart-newstart)
**
**	DEBUGTXT	DBJOG,<3,>
**
*** STASH NEW DURATION
**	move.l	#TAGID_Duration,d0
**	CALLTL	PutLongValue
**	bra	666$
**
*** NEW OUTPOINT
**100$
**	DEBUGMSG	DBJOG,<New Out Point>
**
**	DEBUGTXT	DBJOG,<4,>
**
*** DHD OBSOLETE!!!
**;;	move.l	#TAGID_ClipEndPoint,d0
**	CALLTL	PutLongValue
**	
**	DEBUGTXT	DBJOG,<5,>
**
**	move.l	#TAGID_ClipStartField,d0
**	CALLTL	GetLongValue
**	move.l	ES_Data3(a3),d1			
**	sub.l	d0,d1
**
**	DEBUGTXT	DBJOG,<6,>
**
**	move.l	#TAGID_Duration,d0
**	CALLTL	PutLongValue
**
**666$	movem.l	(sp)+,d0-d3/a0-a2
**	rts

d2739 4
d2746 99
d2877 3
d2940 2
d2956 1
a2956 3
20$	XCALL	ExitShiftedKey
	clr.w	TB_OLaySec(a5)	;don't allow keying during Jog/Shuttle
	CALLTL	CookAndServeMain
d3315 3
@


2.67
log
@Re-enabled calls to Flyer for Record/Play mode & GetFieldClock.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.66 1994/09/14 02:01:07 Kell Exp Kell $
d10 3
d2286 1
a2286 1
NUMSPEEDS	EQU 31
d2302 1
a2302 1
	dc.w	2,0,0,-2,15,-1,1,SHUTTLEWIDTH*18/(NUMSPEEDS*2),SHUTTLEWIDTH*12/NUMSPEEDS	;-1
d2324 1
a2324 1
	dc.w	4,0,0,0,0,0,1,SHUTTLEWIDTH*30/(NUMSPEEDS*2),SHUTTLEWIDTH*18/NUMSPEEDS		;4 field freeze = 0x
d2331 1
a2331 1
	dc.w	4,0,0,4,7,1,1,SHUTTLEWIDTH*42/(NUMSPEEDS*2),SHUTTLEWIDTH*24/NUMSPEEDS		;1    = (0+(4/1))/4
d2333 1
a2333 1
NUMSLOW EQU	24
d2370 1
d2394 2
d2397 1
d2405 1
d2490 6
d2507 5
a2511 1
DoShuttle:
@


2.66
log
@Fixed ES_ commands for loading Slices.  Was using FGC_LOAD, needed FGC_SELECTK.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.65 1994/09/14 01:03:40 Kell Exp Kell $
d10 3
d1771 1
a1771 1
* sync up DHD & the Switchers clocks
d1777 1
a1777 4
	movem.l	d1-d7/a0-a6,-(sp)
;DHD	XJSR	_GetFieldClock
	movem.l	(sp)+,d1-d7/a0-a6

d1780 1
a1780 4
10$	movem.l	d1-d7/a0-a6,-(sp)
;DHD	XJSR	_GetFieldClock
	movem.l	(sp)+,d1-d7/a0-a6
	
a2761 2
	clr.l	ES_Reply(a1)

d2764 4
a2767 5
	movem.l	d1-d7/a0-a6,-(sp)
;DHD	XJSR	_PlayMode
	movem.l	(sp)+,d1-d7/a0-a6

666$	rts
d2793 1
d2795 1
a2795 4
	clr.l	ES_Reply(a1)

	tst.l	TB_FlyerBase(a5)
	beq	666$
d2797 2
a2798 5
	bsr	AbortPlayRec
	
	movem.l	d1-d7/a0-a6,-(sp)
;DHD	XJSR	_RecordMode
	movem.l	(sp)+,d1-d7/a0-a6
d2802 2
a2803 1
666$	rts
@


2.65
log
@SelectK is now sent, even if slice hasn't yet been loaded.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.64 1994/09/14 00:18:52 Kell Exp Kell $
d10 3
d3179 1
a3179 1
	bne.s	100$
d3184 3
a3186 2
	CALLTL	FGC_LoadCommand
	bra.s	500$
d3190 1
a3190 1
	bne.s	200$
d3195 1
d3197 1
a3197 1
	bra.s	500$
d3201 1
a3201 1
	bne.s	500$			; Unknown command = no error
d3204 2
a3205 2
;;	tst.w	FG_PTRIndex(a0)
;;	beq	620$			; ...if not loaded
a3206 1
* Send SelectK even if not loaded!
@


2.64
log
@New handlers for Slice commands (LW,TP,CG,CFX)
Now audio is attenuated during Shuttles.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.63 1994/09/13 19:04:45 Kell Exp Kell $
d10 4
d3199 4
a3202 2
	tst.w	FG_PTRIndex(a0)
	beq	620$			; ...if not loaded
@


2.63
log
@Hack to improve Jog/Shuttle.  NOTE: Audio not currently working here.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.62 1994/09/13 05:56:44 Kell Exp Kell $
d10 3
d294 5
d2570 30
a2599 2
	move.l	d3,ca_VidStartField(a0)	
	XJSR	Flyer_DoFindField	;will indicate 1,2 or 4 fields
d2920 2
d2938 2
d3028 181
d3210 2
@


2.62
log
@First working Jog, Shuttle & Jump (since old NAB code)
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.61 1994/09/08 19:23:49 Kell Exp Kell $
d10 3
d2269 3
a2271 1
NUMSPEEDS 	EQU 23	;zero counts as 2 speeds
a2283 1

d2286 2
a2287 3
	dc.w	2,0,0,-2,15,-1,1,SHUTTLEWIDTH*13/(NUMSPEEDS*2),SHUTTLEWIDTH*7/NUMSPEEDS	;-1

	dc.w	4,0,1,-4,3,-1,2,SHUTTLEWIDTH*15/(NUMSPEEDS*2),SHUTTLEWIDTH*8/NUMSPEEDS	;-1/2
d2289 3
a2291 3
ShuttleREW:
	dc.w	4,0,3,-4,1,-1,4,SHUTTLEWIDTH*17/(NUMSPEEDS*2),SHUTTLEWIDTH*9/NUMSPEEDS	;-1/4
	dc.w	4,0,7,-4,0,-1,8,SHUTTLEWIDTH*19/(NUMSPEEDS*2),SHUTTLEWIDTH*10/NUMSPEEDS	;-1/8
d2309 5
a2313 2
	dc.w	4,0,0,0,0,0,1,SHUTTLEWIDTH*22/(NUMSPEEDS*2),SHUTTLEWIDTH*12/NUMSPEEDS		;4 field freeze = 0x
	dc.w	4,0,7,4,0,1,8,SHUTTLEWIDTH*25/(NUMSPEEDS*2),SHUTTLEWIDTH*13/NUMSPEEDS		;1/8  = (0+(4/8))/4
d2316 1
a2316 2
	dc.w	4,0,3,4,1,1,4,SHUTTLEWIDTH*27/(NUMSPEEDS*2),SHUTTLEWIDTH*14/NUMSPEEDS		;1/4  = (0+(4/4))/4
	dc.w	4,0,1,4,3,1,2,SHUTTLEWIDTH*29/(NUMSPEEDS*2),SHUTTLEWIDTH*15/NUMSPEEDS		;1/2  = (0+(4/2))/4
d2318 8
a2325 10
	dc.w	4,0,0,4,7,1,1,SHUTTLEWIDTH*31/(NUMSPEEDS*2),SHUTTLEWIDTH*16/NUMSPEEDS		;1    = (0+(4/1))/4
	dc.w	4,4,0,4,7,2,1,SHUTTLEWIDTH*33/(NUMSPEEDS*2),SHUTTLEWIDTH*17/NUMSPEEDS		;2    = (4+(4/1))/4

	dc.w	2,2,0,4,15,3,1,SHUTTLEWIDTH*35/(NUMSPEEDS*2),SHUTTLEWIDTH*18/NUMSPEEDS	;3    = (2+(4/1))/2
	
	dc.w	1,1,0,4,31,5,1,SHUTTLEWIDTH*37/(NUMSPEEDS*2),SHUTTLEWIDTH*19/NUMSPEEDS	;5    = (1+(4/1))/1
	dc.w	1,1,0,8,31,9,1,SHUTTLEWIDTH*39/(NUMSPEEDS*2),SHUTTLEWIDTH*20/NUMSPEEDS	;9    = (1+(8/1))/1
	dc.w	1,1,0,16,31,17,1,SHUTTLEWIDTH*41/(NUMSPEEDS*2),SHUTTLEWIDTH*21/NUMSPEEDS	;17   = (1+(16/1))/1
	dc.w	1,1,0,32,31,33,1,SHUTTLEWIDTH*43/(NUMSPEEDS*2),SHUTTLEWIDTH*22/NUMSPEEDS	;33   = (1+(32/1))/1
	dc.w	1,1,0,64,31,65,1,SHUTTLEWIDTH*45/(NUMSPEEDS*2),SHUTTLEWIDTH*23/NUMSPEEDS	;65   = (1+(64/1))/1
d2354 2
d2448 6
d2468 1
d2881 3
a2883 3
	move.l	#TAGID_AudioVolume1,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust1(a1)
d2897 3
a2899 3
	move.l	#TAGID_AudioVolume2,d0
	CALLTL	GetLongValue
	move.w	d0,ca_VolSust2(a1)
@


2.61
log
@Ne PutTable, GetTable, TagSize handlers.
PutValue now can add a NEW tag item to a FG list.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.60 1994/09/06 21:43:56 Kell Exp Kell $
d10 4
d228 1
d315 1
a315 1
	movem.l	d0-d1/a0-a1,-(sp)
d341 1
a341 1
	jsr	(a0)
d343 1
a343 1
	movem.l	(sp)+,d0-d1/a0-a1
a799 4
************************************************************
Hand_PanelOpen
Hand_PanelClose
Hand_Jump
d1027 2
d1059 2
d1093 2
a1293 2
	movem.l	d0-d2/a0-a2,-(sp)

d1303 1
a1303 3
1$
	movem.l	(sp)+,d0-d2/a0-a2
	rts
a1329 1
	movem.l	d3/a2/a6,-(sp)
a1337 2

	movem.l	(sp)+,d3/a2/a6
a1388 1
	movem.l	d3/a2/a6,-(sp)
d1407 1
a1407 2
.skip	movem.l	(sp)+,d3/a2/a6
	rts
a1452 2
	movem.l	a2,-(sp)

a1466 1
	movem.l	(sp)+,a2
d1491 2
a1492 28
*****************************************************************************
Hand_SaveProject:
	DEBUGMSG	DBHD,<Hand_SaveProject:>

	movem.l	d0-d1/a0-a2,-(sp)

	move.l	d0,a2

	XLEA	FullProjectName,a0	;last loaded project name (might be DefaultProject)
	move.l	ES_Data2(a2),d0		;filename
	beq.s	10$			;Jump if no name supplied
	move.l	d0,a0			;use supplied name

10$	move.l	#1001,d0
	move.l	ES_Data1(a2),d1		;list #

	DEBUGUDEC.l	DBHD,<Hand_SaveProject: listnum=>,d1,<\>
	DEBUGTXT	DBHD,<filename=>
	DEBUGSTR	DBHD,(a0)
	DEBUGMSG	DBHD,<>

	CALLTL	NewWriteProject

	move.l	TB_LastGlobalError(a5),ES_Reply(a2)
	movem.l	(sp)+,d0-d1/a0-a2
	rts

****** Hand_NewProject *****************************************************
d1515 1
a1518 1
	movem.l	d0-d1/a0-a2,-(sp)
d1525 23
a1547 2
	bsr	Hand_SaveProject
	movem.l	(sp)+,d0-d1/a0-a2
a1685 1
	movem.l	d0-d2/a0-a1,-(sp)
a1716 1
	movem.l	(sp)+,d0-d2/a0-a1
a1740 1
	movem.l	 d0-d2/a0,-(sp)
a1781 1
	movem.l	(sp)+,d0-d2/a0
d1818 1
a1818 1
	bsr	ForceMainToBlank
d1846 2
d1854 1
a1854 1
	bsr	ForceMainToBlank
d1919 2
d1945 2
a1971 2
	movem.l	d0-d2/a0-a2,-(sp)

d2012 1
a2012 2
666$	movem.l	(sp)+,d0-d2/a0-a2
	rts
a2037 1
	movem.l	d0-d2/a0-a1,-(sp)
d2045 1
a2045 2
666$	movem.l	(sp)+,d0-d2/a0-a1
	rts
d2060 1
a2060 3
*	Data1   - pointer fastgadget
*	Data2	- In/Out point flag (0/1)
*	Data3	- Field
d2069 4
a2073 2
	movem.l	d0-d2/a0-a4,-(sp)

d2075 2
a2076 17

	movea.l	d0,a2		;->ESMessage
	movea.l	ES_Data1(a2),a3	;->RenderCallBack	

	GET.l	TB_Screen,a4
	move.w	sc_MouseX(a4),RCB_MouseX(a3)	; to return to when done with TBar
	move.w	sc_MouseY(a4),RCB_MouseY(a3)

	movea.l	RCB_Function(a3),a4		;render function

	lea	renderfunct(pc),a0

	lea	wait4lmbup(pc),a1		;assume LBM is down
	CALLTL	IsLMBdown
	tst.l	d0
	bne.s	100$
	lea	wait4rmbup(pc),a1		;assume RBM is down
d2078 1
a2078 1
100$	move.l	RCB_Max(a3),d1
d2086 29
a2114 1
	swap	d1
d2116 3
a2120 1

d2123 2
a2124 1
	move.l	#$1000,d2		;accel	
d2126 9
a2134 5
;a0->render code
;a1->abort functions	
;d0=initialXY
;d1=limitsXY
;d2=accel
d2137 1
a2137 6

* make sure interrupts are on here
	move.w	RCB_MouseX(a3),d0	; to return to when done with TBar
	move.w	RCB_MouseY(a3),d1
	CALLTL	MoveSoftSpriteABS	; reposition the SoftSprite

d2140 1
a2140 3
666$	move.l	RCB_Frame(a3),ES_Reply(a2)	;final position
	movem.l	(sp)+,d0-d2/a0-a4
	rts
d2144 1
a2144 1
renderfunct
d2154 4
d2159 4
a2162 1
	jmp	(a4)
d2180 11
a2190 1
	moveq	#1,d0
d2192 33
d2226 5
d2232 25
d2258 2
a2259 4
* UWORD	FieldsPerFrame	;never zero (use as forward table marker)
* WORD	NormalStep	
* WORD	SkipStep
* UWORD	FramesPerSkip	;never zero (use as reverse table marker)
d2261 2
a2262 2
* Velocity = (NormalStep+(SkipStep/FramesPerSkip))/FieldsPerFrame 
* Also SkipStep=0 then shuttle is stopped, else Direction = sign(SkipStep).
d2264 4
d2270 35
a2304 15
	dc.w	1,-1,-62,1	;-63
	dc.w	1,-1,-30,1	;-31
	dc.w	1,-1,-14,1	;-15
	dc.w	1,-1,-6,1	;-7
	dc.w	1,-1,-2,1	;-3

	dc.w	4,-4,-4,1	;-2

	dc.w	2,0,-2,1	;-1

	dc.w	4,0,-4,2	;-1/2
	dc.w	4,0,-4,4	;-1/4
	dc.w	4,0,-4,8	;-1/8
	dc.w	4,0,-4,16	;-1/16
	
d2306 2
a2307 1
	dc.w	4,0,0,1		;4 field freeze = 0x
d2309 14
a2322 15
	dc.w	4,0,4,16	;1/16
	dc.w	4,0,4,8		;1/8
	dc.w	4,0,4,4		;1/4
	dc.w	4,0,4,2		;1/2

	dc.w	4,0,4,1		;1
	dc.w	4,4,4,1		;2

	dc.w	2,2,4,1		;3
	
	dc.w	1,1,4,1		;5
	dc.w	1,1,8,1		;9
	dc.w	1,1,16,1	;17
	dc.w	1,1,32,1	;33
	dc.w	1,1,64,1	;65
d2328 247
a2684 35
****** Hand_Shuttle *****************************************************
*
*   NAME   
*	Hand_Shuttle
*
*   SYNOPSIS
*	Hand_Shuttle(message)
*	               d0
*
*   FUNCTION
*	Moves thru a clip at various rates
*
*   INPUTS
*	Data1   - pointer fastgadget
*	Data2	- In/Out point flag (0/1)
*
*   RESULT
*	ES_Reply  -  Final field
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
Hand_Shuttle:
	movem.l	d0-d2/a0-a1,-(sp)

	





666$	movem.l	(sp)+,d0-d2/a0-a1
	rts

a2706 2
	movem.l	d0-d1/a0-a1,-(sp)

d2718 1
a2718 2
666$	movem.l	(sp)+,d0-d1/a0-a1
	rts
a2741 2
	movem.l	d0-d1/a0-a1,-(sp)

d2758 1
a2758 2
666$	movem.l	(sp)+,d0-d1/a0-a1
	rts
d2762 1
a2762 1
	movem.l	a0/d0,-(sp)
d2768 214
a2981 1
*******************************************************************
d2994 9
@


2.60
log
@Moved ES message table to top of file.  Added a Shuttle Table.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.59 1994/09/02 08:34:31 Kell Exp Kell $
d10 3
d279 4
d1004 31
d1038 1
a1038 1
*	Hand_GetValue -- provide project editor with fastgadget list.
d1049 1
a1049 1
*	LONG result. Defaults to zero if Tag item doesn't exist.
d1067 34
d1104 1
a1104 1
*	Hand_PutValue -- provide project editor with fastgadget list.
d1115 1
a1115 1
*	Error code. Non zero if can't put
d1122 4
a1125 4
	move.l	d0,a1
	move.l	ES_Data1(a1),a0		;crouton
	move.l	ES_Data2(a1),d0		;TagID
	move.l	ES_Data3(a1),d1		;Value
d1127 1
a1127 2
;;	DUMPHEXI.l	<Hand_PutValue: tagid=>,d0,< >
;;	DUMPUDEC.l	<value=>,d1,<\>
d1130 32
a1161 1
	DEBUGUDEC.l	DBHD,<value=>,d1,<\>
d1163 1
a1163 1
	CALLTL	PutLongValue
d1165 2
a1166 1
	move.l	d0,ES_Reply(a1)		;error code
a1197 2


@


2.59
log
@Now Prvwing Clip errors are sent to the DelayError system.
Aborting Clips via Stop button now works.
Jog now puts pointer back where it should be.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.58 1994/09/02 03:03:23 Kell Exp Kell $
d10 5
d234 100
d788 5
a792 98
****** HandlePEMessage ******************************************************
*
*   NAME   
*	HandlePEMessage -- This function handles all messages for the Project
*	                   editor.
*
*   SYNOPSIS
*	HandlePEMessage(Message)
*	                  d0
*
*   FUNCTION
*	Each ES_Type handler will be called with a pointer to the message
*	in d0.
*
*   INPUTS
*
*   RESULT
*	ES_Reply  - has been set
*   BUGS
*
*   SEE ALSO
*	EditSwit.i
*****************************************************************************
	xdef	HandlePEMessage
HandlePEMessage:
	movem.l	d0-d1/a0-a1,-(sp)
	
	move.l	d0,a0

*-------------------
	IFD	DBHPEM
	tst.l	d0
	bne	10$
	DEBUGMSG	DBHPEM,<HandlePEMessage: Message Pointer is NULL !!!!!!!!!!!!!!!!>
	bra	.exit
10$	DEBUGMEM	DBHPEM,<HandlePEMessage: Message=>,ES_Cookie(a0),#ES_SIZEOF-ES_Cookie
	ENDC
*-------------------

	move.w	ES_Type(a0),d1
	cmp.w	#(PEMessageTabE-PEMessageTab)/4,d1
	ble.s	.okcommand
	moveq.l	#ES_ERR_GENERIC,d0
	move.l	d0,ES_Reply(a0)
	bra.s	.exit
.okcommand

	add.w	d1,d1
	add.w	d1,d1
	lea	PEMessageTab,a0
	move.l	0(a0,d1.w),a0
	jsr	(a0)
.exit
	movem.l	(sp)+,d0-d1/a0-a1
	rts

PEMessageTab
	dc.l	Hand_DUMMY		;()
	dc.l	Hand_STARTUP		;()
	dc.l	Hand_RENDER_EDIT	;(), 		Should never get this message
	dc.l	Hand_RENDER_SWIT	;(Mode)

	dc.l	Hand_ClearProject	;(List#), 	was SETRMOFF
	dc.l	Hand_DUMMY		;(), 		was SETRMON

	dc.l	Hand_GETPLIST		;()
	dc.l	Hand_FreeCrouton	;(FG)
	dc.l	Hand_LoadCrouton	;(name)
	dc.l	Hand_DuplicateCrouton	;(FG)

	dc.l	Hand_LoadProject	;(List#,name)
	dc.l	Hand_SaveProject	;(List#,name)
	dc.l	Hand_NewProject		;(List#,name)
	dc.l	Hand_Select		;(FG)
	dc.l	Hand_Auto		;(FG)
	dc.l	Hand_StartSeq		;()
	dc.l	Hand_StopSeq		;() Also stops clip anytime
	dc.l	Hand_QUIT		;()
	
	dc.l	Hand_GetValue		;(FG,TagID)
	dc.l	Hand_PutValue		;(FG,TagID,Value)
	dc.l	Hand_FGcommand		;(FG,FGCcommand)
	dc.l	Hand_DUMMY		;(),	was HiliteCrouton !!!
	
	dc.l	Hand_Record		;(startBlock,endBlock)
	dc.l	Hand_AbortRecord	;() NOW USE Hand_StopSeq !!!
	dc.l	Hand_Jog		;(FG,RenderFnc,StrtFld,MinFld,MaxFld)
	dc.l	Hand_Shuttle		;(FG,RenderFnc,StrtFld,MinFld,MaxFld,Flags)

	dc.l	Hand_InitRecord		;()
	dc.l	Hand_InitPlay		;()
	dc.l	Hand_Main2Blank		;()
	
	dc.l	Hand_GUImode		;(mode)
	dc.l	Hand_SelectDefault	;()

PEMessageTabE

d794 1
d883 1
a883 2
	moveq.l	#ES_ERR_GENERIC,d0
	move.l	d0,ES_Reply(a0)
d2076 48
@


2.58
log
@Fixed some Jog bugs that confused Y movements with X.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.57 1994/08/31 22:59:34 Kell Exp Kell $
d10 3
d759 1
a759 1
	dc.l	Hand_StopSeq		;()
d1507 2
d1512 4
a1515 4

;;	DEBUGMSG	DBHD,<end of Hand_Select>

	rts
d1712 5
d1724 1
a1724 1
	rts
d1885 1
a1885 1
;;	bsr	AbortPlayRec
d1978 5
d2015 1
d2018 7
d2239 1
a2239 4
	tst.l	TB_FlyerBase(a5)
	beq.s	666$

;;	bsr	AbortPlayRec
d2280 1
a2280 1
;;	bsr	AbortPlayRec
@


2.57
log
@Attempt at a new Jog routine.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.55 1994/08/30 10:28:28 Kell Exp Kell $
d10 3
d1040 2
a1041 2
	DUMPHEXI.l	<Hand_PutValue: tagid=>,d0,< >
	DUMPUDEC.l	<value=>,d1,<\>
d1978 4
a1981 1
	DUMPMSG	<RMB IS DOWN>
d1983 2
a1984 3
100$	move.l	RCB_Max(a3),d0
	sub.l	RCB_Min(a3),d0		;assumes Min <= Max
	cmp.l	#$FFFF,d0
d1986 1
d1988 2
a1989 1
	DUMPUDEC.l	<DURATION=>,d0,<\>
d1991 2
a1992 2
	move.l	RCB_Frame(a3),d1	;assumes Min <= Frame <= Max
	sub.l	RCB_Min(a3),d1
d2009 2
a2010 5

**!!!*** HACK
	move.l	RCB_Min(a3),d0
	add.l	RCB_Max(a3),d0
	lsr.l	#1,d0
d2012 1
a2012 1
	DUMPUDEC.l	<frame=>,d0,<\>
d2014 1
a2014 2
;;	ext.l	d0
;;	add.l	RCB_Min(a3),d0
a2033 1
666$	DUMPMSG	<ABORTED ABORTED ABORTED>
d2035 2
@


2.56
log
@Fixed project load/save.  Editor was getting bogus ->ToolBoxGrids
@
text
@d214 1
a214 1
;SERDEBUG	EQU	1
d1959 1
a1959 1
	movem.l	d0-d3/a0-a2,-(sp)
d1963 3
a1965 9
	move.l	d0,a2

	GET.w	TB_MainSec,d0
	TURNLIVEDVEOFF	d0
	cmpi.w	#M_VIDEO3,d0
	beq.s	10$
	PUT.w	#M_VIDEO3,TB_MainSec
	CALLTL	CookMain
	CALLTL	CookAndServePrvw
d1967 1
a1967 1
10$	clr.l	ES_Reply(a2)	;assume no Flyer
d1969 5
a1973 4
	tst.l	TB_FlyerBase(a5)
	beq	666$

	bsr	AbortPlayRec
d1975 1
a1975 2
	move.l	ES_Data1(a2),a0		;->FG
	move.l	ES_Data3(a2),d2		;field #
d1977 4
a1980 1
	DEBUGUDEC.l	DBJOG,<field#=>,d2,<\>
d1982 1
a1982 6
* DHD OBSOLETE!!!
;;	move.l	#TAGID_RecStartPoint,d0
	CALLTL	GetLongValue
	move.l	d0,d1			;block
	
	DEBUGHEXI.l	DBJOG,<point=>,d1,<\>
d1984 3
a1986 1
	moveq	#0,d0			;always drive 0
d1988 6
a1993 1
;;	DUMPREG	<FindField=>
d1995 3
a1997 3
	movem.l	d1-d7/a0-a6,-(sp)
;DHD	XJSR	_FindField
	movem.l	(sp)+,d1-d7/a0-a6
d1999 3
a2001 2
	move.l	d0,ES_Reply(a2)
	beq	666$			;jump if error
d2003 4
a2006 1
;;	DUMPHEXI.l	<FindField=>,d0,<\>
d2008 1
a2008 5
*--------------------
	move.l	d0,d1
	move.l	ES_Data1(a2),a0		;->FG
	move.l	ES_Data2(a2),d2
	bne	100$			;jump if new outpoint
d2010 2
a2011 2
* new inpoint
	DEBUGMSG	DBJOG,<New In Point>
d2013 1
a2013 3
* DHD OBSOLETE!!!
;;	move.l	#TAGID_ClipStartPoint,d0
	CALLTL	PutLongValue
d2015 2
a2016 22
	DEBUGTXT	DBJOG,<1,>

	move.l	#TAGID_ClipStartField,d0
	CALLTL	GetLongValue
	sub.l	ES_Data3(a2),d0			;oldstart-newstart
	move.l	d0,d1	

	DEBUGTXT	DBJOG,<2,>

	move.l	#TAGID_Duration,d0
	CALLTL	GetLongValue
	add.l	d0,d1				;olddur+(oldstart-newstart)

	DEBUGTXT	DBJOG,<3,>

	move.l	#TAGID_Duration,d0
	CALLTL	PutLongValue
	bra	666$

* new outpoint
100$
	DEBUGMSG	DBJOG,<New Out Point>
d2018 4
a2021 1
	DEBUGTXT	DBJOG,<4,>
d2023 2
a2024 3
* DHD OBSOLETE!!!
;;	move.l	#TAGID_ClipEndPoint,d0
	CALLTL	PutLongValue
d2026 6
a2031 1
	DEBUGTXT	DBJOG,<5,>
d2033 3
a2035 6
	move.l	#TAGID_ClipStartField,d0
	CALLTL	GetLongValue
	move.l	ES_Data3(a3),d1			
	sub.l	d0,d1

	DEBUGTXT	DBJOG,<6,>
a2036 2
	move.l	#TAGID_Duration,d0
	CALLTL	PutLongValue
d2038 109
a2146 2
666$	movem.l	(sp)+,d0-d3/a0-a2
	rts
@


2.55
log
@Changed some of the handler names.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.54 1994/08/27 06:58:15 Kell Exp Kell $
d10 3
d214 1
a214 1
;;SERDEBUG	EQU	1
d583 2
a584 1
	movem.l	d1-d4,ES_Data1(a2)
a1928 4

	tst.l	TB_FlyerBase(a5)
	beq.s	666$

d2183 4
a2186 7
	movem.l	d0-d7/a0-a6,-(sp)
	moveq	#0,d0		;channel 0!!
;DHD	XJSR	_AbortRecord

	moveq	#1,d0		;channel 0!!
;DHD	XJSR	_AbortRecord
	movem.l	(sp)+,d0-d7/a0-a6
@


2.54
log
@Commented out some obsolete tag items in Jog. Jog is now really broke!
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.53 1994/08/09 03:53:38 Kell Exp Kell $
d10 3
d584 1
a584 1
	move.w	#ES_SizeOf,MN_LENGTH(a2)
d708 1
a708 1
10$	DEBUGMEM	DBHPEM,<HandlePEMessage: Message=>,ES_Cookie(a0),#ES_SizeOf-ES_Cookie
d730 35
a764 35
	dc.l	Hand_DUMMY
	dc.l	Hand_STARTUP
	dc.l	Hand_RENDERE		;Should never get this message
	dc.l	Hand_RENDERS

	dc.l	Hand_ClearProject	;was SETRMOFF
	dc.l	Hand_DUMMY		;was SETRMON

	dc.l	Hand_GETPLIST
	dc.l	Hand_FreeCrouton
	dc.l	Hand_LoadCrouton
	dc.l	Hand_DupCrouton

	dc.l	Hand_LoadProject
	dc.l	Hand_SaveProject
	dc.l	Hand_NewProject
	dc.l	Hand_Select
	dc.l	Hand_ToMain	;was _Auto
	dc.l	Hand_StartSeq
	dc.l	Hand_StopSeq
	dc.l	Hand_QUIT
	
	dc.l	Hand_GetValue
	dc.l	Hand_PutValue
	dc.l	Hand_FGcommand
	dc.l	Hand_DUMMY
	
	dc.l	Hand_Record
	dc.l	Hand_AbortClip
	dc.l	Hand_Jog
	dc.l	Hand_Shuttle

	dc.l	Hand_InitRecord
	dc.l	Hand_InitPlay
	dc.l	Hand_Main2Blank
d766 2
a767 2
	dc.l	Hand_GUImode
	dc.l	Hand_SelectDefault
d864 1
a864 1
****** Hand_RENDERE ***********************************************************
d867 1
a867 1
*	Hand_RENDERE
d870 1
a870 1
*	Hand_RENDERE(message)
d884 2
a885 2
Hand_RENDERE
	DEBUGMSG	DBHD,<Hand_RENDERE:>
d891 1
a891 1
****** Hand_RENDERS ***********************************************************
d894 1
a894 1
*	Hand_RENDERS
d897 1
a897 1
*	Hand_RENDERS(message)
d913 1
a913 1
Hand_RENDERS
d917 1
a917 1
	DEBUGTXT	DBHD,<Hand_RENDERS: >
a999 1
	DUMPHEXI.l	<Hand_GetValue: tagid=>,d0,< >
a1001 1
	DUMPUDEC.l	<result=>,d0,<\>
d1145 1
a1145 1
*	Hand_SETRMON(message)
d1243 1
a1243 1
****** Hand_DupCrouton *****************************************************
d1246 1
a1246 1
*	Hand_DupCrouton -- Duplicate the current crouton
d1249 1
a1249 1
*	Hand_DupCrouton(message)
d1265 1
a1265 1
Hand_DupCrouton:
d1273 1
a1273 1
	DEBUGTXT	DBHD,<Hand_DupCrouton: file=>
d1547 1
a1547 1
****** Hand_ToMain *****************************************************
d1550 1
a1550 1
*	Hand_ToMain -- was _Auto
d1553 1
a1553 1
*	Hand_ToMain(message)
d1569 1
a1569 1
Hand_ToMain:
d1897 1
a1897 1
****** Hand_AbortClip *****************************************************
d1900 1
a1900 1
*	Hand_AbortClip
d1903 1
a1903 1
*	Hand_AbortClip(message)
d1918 1
a1918 1
Hand_AbortClip:
d1921 1
a1921 1
	DEBUGMSG	DBHD,<Hand_AbortClip:>
d2185 1
a2185 1
;DHD	XJSR	_AbortClip
d2188 1
a2188 1
;DHD	XJSR	_AbortClip
d2208 1
a2208 1
OnlyMessage	dcb.b	ES_SizeOf,0	;This is the message used to
@


2.53
log
@Changed return codes on ES_LoadCrouton.  Now ->FG or NULL only.
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.52 1994/08/03 19:49:47 Kell Exp Kell $
d10 3
d211 1
a211 4
DBHD	set	1	;Debug HandlePEMessage
DBSPM	set	1	;Debug SendProject...Message stuff

DBHPEM	set	1	;Debug HandlePEMessageMessage
d213 2
d1211 2
d1223 1
a1223 1
	beq.s	.skip
d1225 2
d1984 2
a1985 1
	move.l	#TAGID_RecStartPoint,d0
d2013 2
a2014 1
	move.l	#TAGID_ClipStartPoint,d0
d2042 2
a2043 1
	move.l	#TAGID_ClipEndPoint,d0
@


2.52
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.51 1994/08/03 06:39:22 Kell Exp Kell $
d10 3
d1207 1
a1207 1
	move.l	d0,ES_Reply(a2)		;can now be -1!!!
d1213 1
d1216 1
a1216 1
	movem.l	d1/a0,-(sp)
a1217 1
	moveq	#0,d1		;assume error
a1219 2
	cmpi.l	#-1,d0
	beq.s	.skip
d1231 2
a1232 3
	move.l	a0,d1			
.skip	move.l	d1,d0		;->FG
	movem.l	(sp)+,d1/a0
@


2.51
log
@Now project entries remember their original location (e.g. CDROM)
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.50 1994/07/27 19:27:47 Kell Exp Kell $
d10 3
d208 2
a209 1
;;DBHPEM	set	1	;Debug HandlePEMessageMessage
@


2.50
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.49 1994/07/22 20:42:04 Kell Exp Kell $
d10 3
d1206 1
a1206 1
LoadDiskCrouton	;(filename)
d1215 3
a1217 1
	move.l	d0,d1
a1218 1
	movea.l	d0,a0
d1222 5
@


2.49
log
@Now using AmigaDOS's LoadSeg
@
text
@d7 1
a7 1
* $Id: pecomm.a,v 2.48 94/07/22 19:31:15 Kell Exp Locker: Kell $
d9 4
a12 1
* $Log:	pecomm.a,v $
@


2.48
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70ad9d0 differ
@


2.47
log
@Fixed errors in Load/Save/New Project commands, and ES_Startup command documentation.
Added ES_ClearProject command.
@
text
@Binary files pecomm.a and t:,RCSt1A70ace50 differ
@


2.46
log
@Disabled Flyer function calls.  It's now broken!!!!
@
text
@Binary files pecomm.a and t:,RCSt1A70b2b10 differ
@


2.45
log
@Cleaned up the Flag mess associated with who (Editor/Switcher) controls which part of the screen, and which mode we are in.
Removed some old obsolete handlers.
Added a NoRender function to send to the Editor (for going in/out of Setup slice).
The SendProjectEditMessage now checks for Editor first.  Returns result.
Fixed multiple renderings of switcher when going into Switcher mode.
@
text
@Binary files pecomm.a and t:,RCSt1A70bd868 differ
@


2.44
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70be0d0 differ
@


2.43
log
@ES_AUTO now does a FGC_TOMAIN command.  The AUTO handler code was way
simplified (and now called Hand_ToMain.
ES_SELECT command now returns BOOL.
Many FGC_....Command calls renamed to this new naming convention.
@
text
@Binary files pecomm.a and t:,RCSt1A70be098 differ
@


2.42
log
@Added SelectDefault handling.
@
text
@Binary files pecomm.a and t:,RCSt1A70c3c00 differ
@


2.41
log
@Removed BW jog.
Now looks at GUImode flags to see if switcher is up and honors that
special Select.
@
text
@Binary files pecomm.a and t:,RCSt1A70c3218 differ
@


2.40
log
@Added ES_GUImode handling.
@
text
@Binary files pecomm.a and t:,RCSt1A70c35c8 differ
@


2.39
log
@All sorts of new additions for NAB 94.
@
text
@Binary files pecomm.a and t:,RCSt1A70c3130 differ
@


2.38
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c32a0 differ
@


2.37
log
@Sequencing now disables rendering to switcher.  Syncs DHD to SW clock.
@
text
@Binary files pecomm.a and t:,RCSt1A70c3278 differ
@


2.36
log
@Now disables grid rendering when redrawing switcher.
@
text
@Binary files pecomm.a and t:,RCSt1A70c3278 differ
@


2.35
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c3128 differ
@


2.34
log
@Added code for ES_FGcommand handling.
@
text
@Binary files pecomm.a and t:,RCSt1A70c2f00 differ
@


2.33
log
@Added ES_PutValue and ES_GetValue handlers
@
text
@Binary files pecomm.a and t:,RCSt1A70c2f00 differ
@


2.32
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c0988 differ
@


2.31
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c0988 differ
@


2.30
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c0988 differ
@


2.29
log
@Killed internalcrouton loading stuff.
Finished Read/Write/New Project.  Finished crouton duplicate.
@
text
@Binary files pecomm.a and t:,RCSt1A70c30a0 differ
@


2.28
log
@No F8 only loads the Grazer if not alread loaded. Added ES_QUIT routine.
@
text
@Binary files pecomm.a and t:,RCSt1A70c3308 differ
@


2.27
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c3330 differ
@


2.26
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c3218 differ
@


2.25
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c30a0 differ
@


2.24
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c3308 differ
@


2.23
log
@Various changes to support the new 4.0 croutons & projects.
@
text
@Binary files pecomm.a and t:,RCSt1A70c0270 differ
@


2.22
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70c35c0 differ
@


2.21
log
@*** empty log message ***
@
text
@Binary files pecomm.a and t:,RCSt1A70a6648 differ
@


2.20
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70c3b08 differ
@


2.19
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A71c5718 differ
@


2.18
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bcf28 differ
@


2.17
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bbb28 differ
@


2.16
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bcf28 differ
@


2.15
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bbcb0 differ
@


2.14
log
@*** empty log message ***
@
text
@Binary files PEcomm.a and t:,RCSt1A70bcc60 differ
@


2.13
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bba60 differ
@


2.12
log
@Added Select
@
text
@Binary files PEComm.a and t:,RCSt1A70bba60 differ
@


2.11
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bcc30 differ
@


2.10
log
@Added project commands.
@
text
@Binary files PEComm.a and t:,RCSt1A70bcc30 differ
@


2.9
log
@Added Duplicate
@
text
@Binary files PEComm.a and t:,RCSt1A70bcf28 differ
@


2.8
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70c3c88 differ
@


2.7
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70c3c88 differ
@


2.6
log
@Added messages for loading and unloading croutons
@
text
@Binary files PeComm.a and t:,RCSt1A7108258 differ
@


2.5
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bb9c8 differ
@


2.4
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bbdb0 differ
@


2.3
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A70bcb28 differ
@


2.2
log
@*** empty log message ***
@
text
@Binary files PEComm.a and t:,RCSt1A71497e0 differ
@


2.1
log
@*** empty log message ***
@
text
@Binary files PEcomm.a and t:,RCSt1A78b9e60 differ
@


2.0
log
@FirstCheckIn
@
text
@Binary files PEComm.a and t:,RCSt1A70a2178 differ
@
