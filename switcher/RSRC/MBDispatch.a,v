head	2.46;
access;
symbols;
locks; strict;
comment	@*@;


2.46
date	95.11.13.12.19.46;	author Holt;	state Exp;
branches;
next	2.45;

2.45
date	95.08.16.12.30.16;	author Holt;	state Exp;
branches;
next	2.44;

2.44
date	95.06.05.12.02.12;	author pfrench;	state Exp;
branches;
next	2.43;

2.43
date	95.04.24.13.26.06;	author pfrench;	state Exp;
branches;
next	2.42;

2.42
date	95.03.02.14.47.00;	author pfrench;	state Exp;
branches;
next	2.41;

2.41
date	95.03.02.13.00.02;	author pfrench;	state Exp;
branches;
next	2.40;

2.40
date	95.02.16.20.33.24;	author Kell;	state Exp;
branches;
next	2.39;

2.39
date	94.12.30.20.13.58;	author Kell;	state Exp;
branches;
next	2.38;

2.38
date	94.12.29.11.27.59;	author Kell;	state Exp;
branches;
next	2.37;

2.37
date	94.12.14.16.07.49;	author pfrench;	state Exp;
branches;
next	2.36;

2.36
date	94.09.14.00.16.56;	author Kell;	state Exp;
branches;
next	2.35;

2.35
date	94.09.02.08.33.19;	author Kell;	state Exp;
branches;
next	2.34;

2.34
date	94.07.27.19.28.06;	author Kell;	state Exp;
branches;
next	2.33;

2.33
date	94.07.01.12.53.27;	author Kell;	state Exp;
branches;
next	2.32;

2.32
date	94.03.13.08.07.25;	author Kell;	state Exp;
branches;
next	2.31;

2.31
date	94.03.12.17.16.01;	author Kell;	state Exp;
branches;
next	2.30;

2.30
date	94.03.12.17.10.28;	author Kell;	state Exp;
branches;
next	2.29;

2.29
date	94.02.07.15.54.51;	author Kell;	state Exp;
branches;
next	2.28;

2.28
date	93.11.23.16.58.58;	author Turcotte;	state Exp;
branches;
next	2.27;

2.27
date	93.11.19.17.56.41;	author Turcotte;	state Exp;
branches;
next	2.26;

2.26
date	93.11.06.04.27.21;	author Kell;	state Exp;
branches;
next	2.25;

2.25
date	93.11.03.22.59.58;	author Turcotte;	state Exp;
branches;
next	2.24;

2.24
date	93.09.05.00.33.19;	author Kell;	state Exp;
branches;
next	2.23;

2.23
date	93.06.05.14.36.21;	author Turcotte;	state Exp;
branches;
next	2.22;

2.22
date	93.06.05.07.45.46;	author Kell;	state Exp;
branches;
next	2.21;

2.21
date	93.06.04.23.06.57;	author Turcotte;	state Exp;
branches;
next	2.20;

2.20
date	93.06.04.17.39.13;	author Turcotte;	state Exp;
branches;
next	2.19;

2.19
date	93.05.30.13.09.31;	author Kell;	state Exp;
branches;
next	2.18;

2.18
date	93.05.29.04.18.32;	author Kell;	state Exp;
branches;
next	2.17;

2.17
date	93.05.28.23.43.08;	author Turcotte;	state Exp;
branches;
next	2.16;

2.16
date	93.05.28.06.09.38;	author Turcotte;	state Exp;
branches;
next	2.15;

2.15
date	93.05.26.11.31.27;	author Turcotte;	state Exp;
branches;
next	2.14;

2.14
date	93.05.26.10.26.28;	author Turcotte;	state Exp;
branches;
next	2.13;

2.13
date	93.05.24.16.54.25;	author Turcotte;	state Exp;
branches;
next	2.12;

2.12
date	93.05.24.07.24.23;	author Turcotte;	state Exp;
branches;
next	2.11;

2.11
date	93.05.15.03.31.30;	author Turcotte;	state Exp;
branches;
next	2.10;

2.10
date	93.05.15.01.57.43;	author Turcotte;	state Exp;
branches;
next	2.9;

2.9
date	93.05.12.09.06.39;	author Turcotte;	state Exp;
branches;
next	2.8;

2.8
date	93.05.10.01.43.29;	author Turcotte;	state Exp;
branches;
next	2.7;

2.7
date	93.05.05.00.17.01;	author Turcotte;	state Exp;
branches;
next	2.6;

2.6
date	93.05.04.03.53.51;	author Turcotte;	state Exp;
branches;
next	2.5;

2.5
date	93.04.17.21.10.27;	author Turcotte;	state Exp;
branches;
next	2.4;

2.4
date	93.04.16.04.03.10;	author Turcotte;	state Exp;
branches;
next	2.3;

2.3
date	93.01.21.04.19.23;	author Turcotte;	state Exp;
branches;
next	2.2;

2.2
date	92.09.27.23.35.03;	author Turcotte;	state Exp;
branches;
next	2.1;

2.1
date	92.09.12.02.06.30;	author Kell;	state Exp;
branches;
next	2.0;

2.0
date	92.05.18.21.18.34;	author Hartford;	state Exp;
branches;
next	;


desc
@@


2.46
log
@working on making freeze/unfreeze more logical
@
text
@********************************************************************
* mbdispatch.a
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
* $Id: MBDispatch.a,v 2.45 1995/08/16 12:30:16 Holt Exp Holt $
*
* $Log: MBDispatch.a,v $
*Revision 2.45  1995/08/16  12:30:16  Holt
*fixed switcher freeze panel.
*
*Revision 2.44  1995/06/05  12:02:12  pfrench
*Modified DoEnterKey routine to forward RAWKEY to editor
*
*Revision 2.43  1995/04/24  13:26:06  pfrench
*Plain F10 key gets sent to editor
*
*Revision 2.42  1995/03/02  14:47:00  pfrench
*Period key on NumPad needed re-directing also.
*
*Revision 2.41  1995/03/02  13:00:02  pfrench
*Added switcher un-used rawkey handling code
*
*Revision 2.40  1995/02/16  20:33:24  Kell
*Now does a UpdateDisplay when re-entering the Switcher via HotKey.
*
*Revision 2.39  1994/12/30  20:13:58  Kell
*Support of TOGGLE_BIT for enabling/disabling some serial debug prints.
*
*Revision 2.38  1994/12/29  11:27:59  Kell
*Quit Hot key will only tell editor to quit if it is loaded.  Then it will wait for editor to quit before quiting switcher.
*
*Revision 2.37  1994/12/14  16:07:49  pfrench
*Now handles towb flag bit to change to/from the switcher
*screen.  This prevents race conditions with the input
*handler, making it much more stable.
*
*Revision 2.36  1994/09/14  00:16:56  Kell
*Removed numpad "ENTER" key handler.  Now uses Editor code for quick access
*
*Revision 2.35  1994/09/02  08:33:19  Kell
*Now checking for repeated keys, vs old DisableKeyRepeat prefs calls.
*
*Revision 2.34  1994/07/27  19:28:06  Kell
**** empty log message ***
*
*Revision 2.33  1994/07/01  12:53:27  Kell
*Killed CloseCode routine.  It wasn't used anywhere.
*
*Revision 2.32  94/03/13  08:07:25  Kell
*Ctrl-Alt-F10 now can dump the Editor also.  F8 can load the editor.
*
*Revision 2.31  94/03/12  17:16:01  Kell
**** empty log message ***
*
*Revision 2.30  94/03/12  17:10:28  Kell
**** empty log message ***
*
*Revision 2.29  94/02/07  15:54:51  Kell
*Various changes to support the new 4.0 croutons & projects.
*
*Revision 2.28  93/11/23  16:58:58  Turcotte
**** empty log message ***
*
*Revision 2.27  93/11/19  17:56:41  Turcotte
**** empty log message ***
*
*Revision 2.26  93/11/06  04:27:21  Kell
**** empty log message ***
*
*Revision 2.25  93/11/03  22:59:58  Turcotte
**** empty log message ***
*
*Revision 2.24  93/09/05  00:33:19  Kell
**** empty log message ***
*
*Revision 2.23  93/06/05  14:36:21  Turcotte
**** empty log message ***
*
*Revision 2.22  93/06/05  07:45:46  Kell
*New keyboard cmd for entering Hardware Setup screen.
*
*Revision 2.21  93/06/04  23:06:57  Turcotte
**** empty log message ***
*
*Revision 2.20  93/06/04  17:39:13  Turcotte
**** empty log message ***
*
*Revision 2.19  93/05/30  13:09:31  Kell
*Added SHIFT-F10 keyboard short cut for Adjust slice.
*
*Revision 2.18  93/05/29  04:18:32  Kell
**** empty log message ***
*
*Revision 2.17  93/05/28  23:43:08  Turcotte
*Added Toggle for Effects name
*
*Revision 2.16  93/05/28  06:09:38  Turcotte
**** empty log message ***
*
*Revision 2.15  93/05/26  11:31:27  Turcotte
**** empty log message ***
*
*Revision 2.14  93/05/26  10:26:28  Turcotte
*Added key eq for new grids
*
*Revision 2.13  93/05/24  16:54:25  Turcotte
**** empty log message ***
*
*Revision 2.12  93/05/24  07:24:23  Turcotte
*Removed Popup from Requeseters, and added Rename.
*
*Revision 2.11  93/05/15  03:31:30  Turcotte
**** empty log message ***
*
*Revision 2.10  93/05/15  01:57:43  Turcotte
**** empty log message ***
*
*Revision 2.9  93/05/12  09:06:39  Turcotte
**** empty log message ***
*
*Revision 2.8  93/05/10  01:43:29  Turcotte
**** empty log message ***
*
*Revision 2.7  93/05/05  00:17:01  Turcotte
**** empty log message ***
*
*Revision 2.6  93/05/04  03:53:51  Turcotte
**** empty log message ***
*
*Revision 2.5  93/04/17  21:10:27  Turcotte
**** empty log message ***
*
*Revision 2.4  93/04/16  04:03:10  Turcotte
**** empty log message ***
*
*Revision 2.3  93/01/21  04:19:23  Turcotte
*Changes for new Grids
*
*Revision 2.2  92/09/27  23:35:03  Turcotte
*Added IDCMP flag MOUSEUP
*
*Revision 2.1  92/09/12  02:06:30  Kell
*Replaced Disable & Enable Calls.
*
*Revision 2.0  92/05/18  21:18:34  Hartford
**** empty log message ***
*
*********************************************************************
*+*******
*+
*+ MBDispatch
*+
*+ This file constitutes the main loop of the interface/switcher system.
*+ It sets up the Toaster window with area control gadgets and sets up its
*+ own environement for handling the IDCMP traffic. It then monitors the
*+ IDCMP and does as its told, which involves dispatching function code
*+ handlers of FastGadgets chosen by mouse or keyboard, if any. Assumes that
*+ it has access to all of the CPU registers.
*+
*+*******

*====	Needed include files.

	INCLUDE	'assembler.i'
	INCLUDE	'intuition/intuition.i'
	INCLUDE	'hardware/custom.i'

	INCLUDE	"lib/intuition_lib.i"
	INCLUDE	"lib/exec_lib.i"
	INCLUDE	"lib/dos_lib.i"

	INCLUDE	'instinct.i'
	include	"EditSwit.i"

	include	'macros.i'
	INCLUDE 'vtdebug.i'

	include	'serialdebug.i'

;;SERDEBUG	SET	1
	ALLDUMPS

;;DBMBD SET 1	;When defined, debug MBDispatch:

;;TILEGAME	set	1	;define if you want crouton swapping version
				;Also see NumPad.a EDITEFXCOMMENT

	XDEF	SpecialExitRKH		; make visible for Config Slice code
*					; exit Switcher routine - remove
*					; F10 exit backdoor
*					; Addendum 3/7/90:

*====	Executable code.

	SECTION	MBDispatchCode,CODE

	XDEF	MBDispatch
MBDispatch:

	DEBUGMSG DBMBD,<MBDispatch:>

*====	Perform initializations.

	lea	DataPool,a4		; address private data with A4
*					; we assume ToasterBase with A5
	move.l	sp,InitialSP(a4)	; save initial SP for exits/aborts
*					; - stays valid for the life of the
*					; interface/switcher program

;;	GET.l	TB_Window,a0		; add the area control gadgets
;;	lea	MiscArea(a4),a1		; to the window
;;	CLEARA	a2			; Addendum 9/18/90:
;;	moveq	#-1,d0			; removed and placed in Switcher.a
;;	moveq	#-1,d1			; when the Window is created
;;	GET.l	TB_ITUBase,a6
;;	CALLROM	AddGList

	XCALL	SoftSpriteOff		; Addendum 9/18/90: looks outwardly
	XCALL	SoftSpriteOn		; not elegant, but will bleed dry the
*					; queued IDCMP very effectively

*====	The interface/switcher stays in this IDCMP loop till the program
*====	is shutdown.
*====	Addendum 6/14/90: Also monitors for ARexx input using a private
*====	port for ARexx messages.

	GET.l	TB_SYSBase,a6

.WaitForAction:


					;fix for messages on port with no
					;signal.

;;	DUMPTXT	<&1>

	XCALL	ARexxHandler		; and call ARexx handler - must

;;	DUMPTXT	<&2>

	GET.l	TB_MsgPort,a0
	CALLROM	GetMsg
	move.l	d0,d0
	bne	.processmessage

;;	DUMPTXT	<&3>


	GET.l	TB_MsgPort,a0
	move.b	MP_SIGBIT(a0),d2	; signal bit for IDCMP
	GET.l	TB_ARexxPort,a0
	move.b	MP_SIGBIT(a0),d3	; signal bit for ARexx
	XCALL	ObtainSwitcherGPISigBit
	move.l	d0,d4			; signal bit for Switcher GPI or -1
*					; Addendum 8/6/90:

.WaitForInput:
	CLEAR	d0			; wait for input from either ARexx
	bset.l	d2,d0			; or the IDCMP
	bset.l	d3,d0
	tst.l	d4
	bmi.s	.NoSwitcherGPI1
	bset.l	d4,d0

.NoSwitcherGPI1:
	CALLROM	Wait
	move.l	d0,d5			; save signal mask

	tst.l	d4
	bmi.s	.LookAtARexx
	btst.l	d4,d5			; a Switcher GPI trigger?
	beq.s	.LookAtARexx		; if not - skip on to look at ARexx

	SAVE	d2-d5			; save work registers
	CALL	AutoFGRKH		; do Auto via raw key handler
	REST	d2-d5			; restore work registers
	XCALL	ReplySwitcherGPI	; enable Switcher GPIs

.LookAtARexx:
	btst.l	d3,d5			; ARexx?
	beq.s	.LookAtIDCMP		; nope - must be IDCMP - jump to it

	XCALL	ARexxHandler		; and call ARexx handler - must
*					; follow AMIGA register conventions

.LookAtIDCMP:
	btst.l	d2,d5			; IDCMP?
	beq	.WaitForInput		; if not - reloop waiting for input

.NextIDCMP:
	DEBUGMSG DBMBD,<Got IDCMP>

	tst.w	TB_MouseNest(a5)	; Addendum 9/7/90: FGC_MouseXY
	bmi.s	.MouseLeftOff		; code support
	GET.l	TB_Window,a0
	or.w	#REPORTMOUSE,wd_Flags+2(a0)	; (force mouse on)

.MouseLeftOff:
	GET.l	TB_MsgPort,a0

	DEBUGMSG DBMBD,<before GetMsg>

	CALLROM	GetMsg

.processmessage
	DEBUGMSG DBMBD,<A message to process>

	bclr.b	#TOWB_ONOFF_BIT,TB_Flags(a5)	; Addendum 1/30/91: see if
*						; switch to WB is pending as
*						; directed by HOTKEY
	beq	.NoSwitch		; ...if no switch needed

	move.l	d0,a2			; save IDCMP message pointer

	GET.l	TB_ITUBase,a6

	tst.w	TB_DisplayState(a5)	; determine to what display state
*					; we're to be going to

	beq	.SwitToBack		; is it already up?
*					; else to Toaster display

**************************************************************************
* Bringing the switcher screen up

	CALLTL	UpdateDisplay

	clr.w	TB_DisplayState(a5)	; denote we're at Toaster display

* Doing this here prevents the problem of the operating system doing
* weird things when it thinks a NONLACEed screen is being displayed
* when we may actually have a LACED Toaster copperlist being shown.
	GET.l	TB_Screen,a0
	CALLROM	ScreenToFront	;near bottom of display = LACEed

	XJSR	ReinstallCurrentCopList

	moveq	#0,d0
	CALLTL	LockToasterELH

	XCALL	AutoRequestDisable	; Addendum 3/21/90: disarm the
*					; AutoRequest function

	XCALL	DisableKeyRepeat	; Addendum 6/7/90:

	GET.l	TB_Screen,a0
	CLEAR	d0
	move.l	#-4000,d1
	CALLROM	MoveScreen
	GET.l	TB_Screen,a0		; assure Toaster screen at front
	sub.w	#SCREENFUDGEX,sc_LeftEdge(a0)	; reposition mouse in
	sub.w	#SCREENFUDGEY,sc_TopEdge(a0)	; relation to the screen

*					; re-adjust the SoftSprite
	XCALL	SoftSpriteAudioOn	; interrupt trigger and turn audio
*					; DMA back on along with SoftSprite

	CLEAR	d0			; make sure SoftSprite
	CLEAR	d1			; positioned properly
	XCALL	MoveSoftSpriteREL

	bra	.Continue

**************************************************************************
.SwitToBack:


;;	DUMPHEXI.w	<at .swittoback1 OLay=>,TB_OLaySec(a5),<\>



	PUT.w	#-1,TB_DisplayState	; denote WB display state

	XCALL	AutoRequestEnable	; Addendum 3/21/90: re-arm the
*					; AutoRequest function
;;	DUMPHEXI.w	<at .swittoback2 OLay=>,TB_OLaySec(a5),<\>

	XCALL	EnableKeyRepeat		; Addendum 6/7/90:

;;	DUMPHEXI.w	<at .swittoback3 OLay=>,TB_OLaySec(a5),<\>

	GET.l	TB_Screen,a0
	add.w	#SCREENFUDGEX,sc_LeftEdge(a0)	; reposition mouse in
	add.w	#SCREENFUDGEY,sc_TopEdge(a0)	; relation to the screen
	CLEAR	d0
	move.l	#4000,d1
	CALLROM	MoveScreen

;;	DUMPHEXI.w	<at .swittoback4 OLay=>,TB_OLaySec(a5),<\>

	XCALL	SoftSpriteAudioOff	; turn the SoftSprite completely off
;;$$
;;	DUMPHEXI.w	<at .swittoback5 OLay=>,TB_OLaySec(a5),<\>

	XCALL	CancelCG		; assure that the CG has no
*					; transparency planes up - if active

;;	DUMPHEXI.w	<at .swittoback OLay6 =>,TB_OLaySec(a5),<\>

	XCALL	CancelNonStdEfx		; Get out of any non-standard effects


;;	tst.w	TB_TValSec(a5)		; assure no mid-transitions
;;	beq.s	.NoTakeNeeded
;;	XCALL	DoTake
;;.NoTakeNeeded:
;;$$
;;	DEA.l	TB_VTSetUp,a0
;;	ELHCLEAR_WERB	a0
;;	ELHCLEAR_NOLOCK a0
;;* because it will be frozen, ELH2Sprite0 will turn WERB off also. Since
;;* EH4 will be the last sent, turning on the LOCK, the final EH0 will never
;;* be seen, but it won't matter, because we want to leave WERB off anyway!
;;* Transparency in UNLOCK will be avoided because CDS = 1, and CD = $FF.
;;	CALLTL	SendELH2Toaster

	moveq	#1,d0
	CALLTL	LockToasterELH

	move.l	TB_Screen(a5),a0
	CALLROM	ScreenToBack

	CALLROM	WBenchToFront		; insure WB brought up to the front

	XCALL	RestoreCopperList	; restore AMIGA's display
**************************************************************************

.Continue:
	move.l	a2,d0			; restore IDCMP message pointer
	GET.l	TB_SYSBase,a6		; restore pointer to exec

.NoSwitch:
	DEBUGMSG DBMBD,<No HotKey to WB>

	move.l	d0,d0
	beq	.WaitForAction		; if no ready IDCMP messages - wait
	move.l	d0,a1			; save pointer to IDCMP message

	DEBUGMSG DBMBD,<We have a ready IDCMP message>

	cmp.b	#NT_REPLYMSG,LN_TYPE(a1)
	beq	.HandleReply

	DEBUGMSG DBMBD,<Not NT_REPLYMSG>

	PUT.l	im_Seconds(a1),TB_LastSeconds	; save IDCMP timestamp
	PUT.l	im_Micros(a1),TB_LastMicros

	tst.w	TB_DisplayState(a5)	; WB active?
	beq	.NotAtWB		; ...if not - ignore

	DEBUGMSG DBMBD,<at WB>

	move.l	im_Class(a1),d0			; else WB active - swallow
	and.l	#DISKINSERTED+DISKREMOVED,d0	; all IDCMP EXCEPT for the
	bne	.CheckDiskIn			; disk change messages

	DEBUGMSG DBMBD,<Before ReplyMsg>

	pea	.NextIDCMP(pc)
	JUMPROM	ReplyMsg

.HandleReply
	DEBUGMSG DBMBD,<Got NT_REPLYMSG>
	bra	.NextIDCMP

.NotAtWB:
	cmp.l	#GADGETUP,im_Class(a1)
	beq.s	.handlegadget
	cmp.l	#GADGETDOWN,im_Class(a1) ; was one of the area control
*					; gadgets selected?
	bne	.CheckForRawKey		; if not - skip on
	DEBUGMSG DBMBD,<handle GADGETUP>

.handlegadget
	DEBUGMSG DBMBD,<handle GADGET>

	tst.b	TB_Flags(a5)		; Addendum 12/6/90:
	bmi	.TBarSneakin		; no normal (FG)gadget selection
*					; when the IMAGERY_ONOFF_BIT is set -
*					; always activates the TBar

	move.l	im_IAddress(a1),a2	; else get addressed area control
	move.l	gg_UserData(a2),a2	; gadget, and from it get address
*					; of a routine to run
*					; (area control gadget MUST supply
*					; a function routine)
	move.w	im_MouseX(a1),d3	; also get mouse coordinates within
	move.w	im_MouseY(a1),d2	; the window

	DEBUGMSG DBMBD,<before ReplyMsg2>

	CALLROM	ReplyMsg		; then reply to the message
	move.l	a2,d0
	beq	.NextIDCMP
	pea	.NextIDCMP(pc)		; now call the responce routine

	DEBUGMSG DBMBD,<before jmp (a2)>

	jmp	(a2)			; setup by the area control gadget
*					; (returns to top of the IDCMP loop)

.CheckForRawKey:
	cmp.l	#RAWKEY,im_Class(a1)	; anything on the keyboard punched?
	bne	.CheckForButtons	; if not - skip on

	DEBUGMSG DBMBD,<got RAWKEY>

;;	tst.b	TB_Flags(a5)		; Addendum 12/7/90:
;;	bmi	.SkipOut		; don't allow RAWKEYS IDCMP
;;*					; when the IMAGERY_ONOFF_BIT is set

	move.w	im_Code(a1),d2		; get RAW keycode
	move.w	im_Qualifier(a1),d3	; get qualifier field as well
	CALLROM	ReplyMsg		; reply to the message

	move.b	d2,d2			; are we dealing with a key down?
	bmi	.NextIDCMP		; if not - ignore the RAW keycode

	btst	#IEQUALIFIERB_REPEAT,d3
	bne	.NextIDCMP		; ignore if a key repeat

	PUT.w	d2,TB_KeyCode		; save the RAW down key code
	PUT.w	d3,TB_QualCode		; save the qualifier field as well

	move.w	d2,d0
	add.w	d0,d0			; for RAW key code into index
	add.w	d0,d0
	move.l	RawKeyTable(a4,d0.w),a0	; get address of routine to run
	pea	.NextIDCMP(pc)		; pre-set return address
	jmp	(a0)			; jump to RAW keycode handler

.CheckForButtons:				; Addendum 12/6/89:
	cmp.l	#MOUSEBUTTONS,im_Class(a1)	; possible right mouse button
*						; being punched?
	bne	.CheckDiskIn			; if not - skip on

	DEBUGMSG DBMBD,<got MOUSEBUTTONS>

	cmp.w	#MENUDOWN,im_Code(a1)	; right mouse button down?
	bne	.SkipOut		; if not - skip on

	DEBUGMSG DBMBD,<got MENUDOWN>

	PUT.w	#-1,TB_ButtonFlag	; denote the right button is being
*					; used for FG selection

.TBarSneakin:
	CALLROM	ReplyMsg		; we have the right mouse button down
*					; - first reply to the message

	GET.l	TB_TBarFGL,d0		; activate the T-Bar - if we can
	beq	.NextIDCMP
	move.l	d0,a0			; get routine to be run from
*					; the T-Bar FastGadget selection
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq	.NextIDCMP		; if none - skip out
	pea	.NextIDCMP(pc)
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECT,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers
	clr.w	TB_ButtonFlag(a5)	; denote default condition of left
*					; mouse button being used as the
*					; FG selector

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9999$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9999$:
	XJUMP	ReDoDisplay

.CheckDiskIn:
	cmp.l	#DISKINSERTED,im_Class(a1)	; Addendum 3/2/90:
*						; floppy disk inserted?
	bne	.CheckDiskOut			; if not - skip on

	DEBUGMSG DBMBD,<got DISKINSERTED>

;;$$
;;	move.w	im_Qualifier(a1),d0
;;	move.l	InputIDBase(pc),a6
;;	CALLROM	GetEntry
;;	GET.l	TB_SYSBase,a6
;;$$

	CALLROM	ReplyMsg		; reply to the message
	XCALL	FloppyInOut		; do possible string table updates
	XCALL	UpDateFC		; do possible Switcher file comment
	pea	.NextIDCMP(pc)		; update and display refresh
	XJUMP	UpdateDisplay

.CheckDiskOut:
	cmp.l	#DISKREMOVED,im_Class(a1)	; Addendum 3/2/90:
*						; floppy disk removed?
	bne	.Mousey			; if not - skip on

	DEBUGMSG DBMBD,<got DISKREMOVED>

;;$$
;;	move.w	im_Qualifier(a1),d0
;;	move.l	InputIDBase(pc),a6
;;	CALLROM	GetEntry
;;	GET.l	TB_SYSBase,a6
;;$$

	CALLROM	ReplyMsg		; reply to the message
	XCALL	FloppyInOut		; do possible string table updates
	XCALL	UpDateFC		; do possible Switcher file comment
	pea	.NextIDCMP(pc)		; update and display refresh
	XJUMP	UpdateDisplay

.Mousey:
	cmp.l	#MOUSEMOVE,im_Class(a1)	; Addendum 9/7/90: part of
	bne	.IntuiTicks		; FGC_MouseXY support

	DEBUGMSG DBMBD,<got MOUSEMOVE>

	move.l	im_MouseX(a1),TB_MouseX(a5)	; stash the X/Y coordinates
	CALLROM	ReplyMsg			; ...all we needed

	GET.l	TB_EfxFG,d0		; notify the active crouton entity
	beq	.NextIDCMP		; with an FGC_MouseXY - if we can
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq	.NextIDCMP
	SAVE	a4-a6
	moveq	#FGC_MOUSEXY,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	a4-a6
	bra	.NextIDCMP

.IntuiTicks:
	cmp.l	#INTUITICKS,im_Class(a1)	; Addendum 1/24/91: check
	bne.s	.SkipOut			; interlace/copper list
*						; synchronization

	DEBUGMSG DBMBD,<got INTUITICKS>

	CALLROM	ReplyMsg		; release the message

 IFD XXX
	CLEAR	d2			; assume no re-synch needed

;;	CALLROM	Disable
	CALLTL	AllInterruptsOff	;SKELL 9/11/92

	move.w	CHIPBASE+vhposr,d0	; snapshot beam position

	cmp.w	#VBEAMSYNCH<<8,d0	; are we too close to where
*					; SoftSprite audio interrupt ignites?
	bcc.s	.LeaveDisable		; ...if so - exit immediately

	cmp.w	#10<<8,d0		; too close to the top or bottom of
*					; the frame?
	bcs.s	.LeaveDisable		; ...if so - exit immediately

	move.w	CHIPBASE+vposr,d0	; get frame flop bit
	move.b	$BFE801,d1		; and XOR it with low bit of VSynch
	add.w	d0,d0			; TOD
	addx.b	d1,d0
	and.w	#1,d0
	cmp.w	.LaceSynch(pc),d0	; has their relationship changed?
	beq.s	.LeaveDisable		; ...if not - exit immediately

	move.w	d0,.LaceSynch		; else save new relationship
	moveq	#-1,d2			; and denote re-synch needed

.LeaveDisable:
;;	CALLROM	Enable
	CALLTL	AllInterruptsOn	;SKELL 9/11/92

	tst.l	d2			; re-synch needed?
	beq	.NextIDCMP		; ...if not

;;$$
SEROUT	MACRO
	btst.b	#5,$DFF018		; wait till transmit buffer is ready
	beq.s	*-8

	move.w	#\1&$FF+$100,$DFF030	; place data byte in transmit buffer
*					; outfitted with stop bit
	ENDM

	SEROUT	'*'
;;$$

	XCALL	ReinstallCurrentCopList	; else re-install the copper list
*					; so that it will fix the synch
*					; problem

	bra	.NextIDCMP		; ...continue

.LaceSynch:
	DC.w	0
 ENDC ; XXX

 IFD XXX
	CLEAR	d4

;;	CALLROM	Disable			; keep to ourselves
	CALLTL	AllInterruptsOff	;SKELL 9/11/92

	move.w	CHIPBASE+vhposr,d0	; snapshot beam position

	cmp.w	#VBEAMSYNCH<<8,d0	; are we too close to where
*					; SoftSprite audio interrupt ignites?
	bcc.s	.LeaveDisable		; ...if so - exit immediately

	cmp.w	#10<<8,d0		; too close to the top or bottom of
*					; the frame?
	bcs.s	.LeaveDisable		; ...if so - exit immediately

	move.w	CHIPBASE+vposr,d2
	move.b	$BFE801,d3
	moveq	#-1,d4

.LeaveDisable:
;;	CALLROM	Enable
	CALLTL	AllInterruptsOn	;SKELL 9/11/92

	tst.l	d4
	beq	.NextIDCMP

	move.w	#'0'+$100,d0
	tst.w	d2
	bpl.s	.NotLongFrame
	addq.b	#2,d0
.NotLongFrame:
	and.b	#1,d3
	add.b	d3,d0

	btst.b	#5,$DFF018
	beq.s	*-8
	move.w	d0,$DFF030
 ENDC ; XXX

	bra	.NextIDCMP

.SkipOut:
	DEBUGMSG DBMBD,<unknowm Message - ReplyMsg>

	CALLROM	ReplyMsg		; reply to the message
	bra	.NextIDCMP		; but otherwise ignore it

*====	Area control window gadgets for selection of FGs via the mouse.

MiscCode:
	DEBUGMSG DBMBD,<MiscCode:>

	GET.l	TB_TBarFGL,d0		; test for TBar select
	beq	1$

	DEBUGMSG DBMBD,<TBar select?>

	move.l	d0,a0
	moveq	#1,d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

1$:
	GET.l	TB_TransFGL,d0		; test for Transition FGs select
	beq	2$

	DEBUGMSG DBMBD,<Transition FGs select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

2$:
	GET.l	TB_ClipFGL,d0		; test for Clip FGs select
	beq	3$

	DEBUGMSG DBMBD,<Clip FGs select?>

	move.l	d0,a0
	moveq	#0,d0			; test all fast gadgets
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

3$:
	GET.l	TB_FMCountFGL,d0	; test for Frame Count select
	beq	4$

	DEBUGMSG DBMBD,<FrameCount select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

4$:
	GET.l	TB_NumPadFGL,d0		; test for Numeric FGs select
	beq	5$

	DEBUGMSG DBMBD,<Numeric FGs select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

5$:
	GET.l	TB_GridSelFGL,d0	; test for Grid Select FGs select
	beq	6$

	DEBUGMSG DBMBD,<Grid Select FGs select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

6$:
	GET.l	TB_MiscFGL,d0		; test for misc FastGadgets select
	beq	10$	;.NoSelect

	DEBUGMSG DBMBD,<Misc FastGadgets select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect
;	beq.s	.NoSelect


;++++++

;CtrlCode:
10$
	GET.l	TB_MainFGL,d0		; test for Main row FGs select
	beq	11$

	DEBUGMSG DBMBD,<Main row FGs select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

11$:
	GET.l	TB_PrvwFGL,d0		; test for Preview row FGs select
	beq	12$

	DEBUGMSG DBMBD,<Prvw Row select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

12$:
	GET.l	TB_LumKeyFGL,d0		; test for LumKey row FGs select
	beq	13$

	DEBUGMSG DBMBD,<LumKey Row select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

13$:
	GET.l	TB_SliceFGL,d0		; test for Slice FGs select
	beq	14$

	DEBUGMSG DBMBD,<Slice FGs select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne	.DoSelect

14$:
	GET.l	TB_MiscFGL,d0		; test for misc FastGadgets select
	beq	.NoSelect

	DEBUGMSG DBMBD,<misc Fastgadgets select?>

	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	beq	.NoSelect



.DoSelect:
	DEBUGMSG DBMBD,<.DoSelect: Actually selecting something>

	move.l	d0,a0			; else get routine to be run from
*					; the FastGadget selected
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq	.NoSelect		; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECT,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0

	DEBUGMSG DBMBD,<before FGC_SELECT>

	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	DEBUGMSG DBMBD,<before ClearWindowIDCMP>

	XJSR	ClearWindowIDCMP

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne	9$			; if a total refresh - skip to it

	DEBUGMSG DBMBD,<before UpdateDisplay>

	XJUMP	UpdateDisplay		; else do a selective update
9$:
	DEBUGMSG DBMBD,<before ReDoDisplay>

	XJUMP	ReDoDisplay

.NoSelect:
	rts

ToolCode:
	GET.l	TB_ToolBoxPTR,a0	; indirection added 9/12/89
	move.l	(a0),d0			; see if one of the FastGadgets
	beq.s	.NoSelect		; in the active toolbox area was
	move.l	d0,a0			; selected
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	beq.s	.NoSelect		; if none selected - skip out
	move.l	d0,a0			; else get routine to be run from
*					; the FastGadget selected
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.NoSelect		; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECT,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	XJSR	ClearWindowIDCMP

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	1$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
1$:
	XJUMP	ReDoDisplay

.NoSelect:
	rts

 ifeq 1
CtrlCode:
	GET.l	TB_MainFGL,d0		; test for Main row FGs select
	beq.s	1$
	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne.s	.DoSelect

1$:
	GET.l	TB_PrvwFGL,d0		; test for Preview row FGs select
	beq.s	2$
	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne.s	.DoSelect

2$:
	GET.l	TB_LumKeyFGL,d0		; test for LumKey row FGs select
	beq.s	3$
	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne.s	.DoSelect

3$:
	GET.l	TB_SliceFGL,d0		; test for Slice FGs select
	beq.s	4$
	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	bne.s	.DoSelect

4$:
	GET.l	TB_MiscFGL,d0		; test for misc FastGadgets select
	beq.s	.NoSelect
	move.l	d0,a0
	CLEAR	d0
	move.w	d3,d1
	XCALL	MouseFastGList
	beq.s	.NoSelect

.DoSelect:
	move.l	d0,a0			; else get routine to be run from
*					; the FastGadget selected
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.NoSelect		; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECT,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.NoSelect:
	rts

 endc

*====	Handler routines for dispatching RAW key codes.

*---	Support empty area here.....

NOPRKH:
	moveq	#ES_SwitcherRAWKEY,d0	; d0 = Message Type
	move.l	d2,d1			; d1 = Code
	move.l	d3,d2			; d2 = Qualifier
	XJSR	SendProjectEditMessage	; send message to editor
	rts				;

*---	Support Main row.

MainRowRKH:
	moveq	#IEQUALIFIER_RALT+IEQUALIFIER_RSHIFT,d0
	eor.b	d3,d0
	beq.s	ToggleDebugBit		;Ralt+Rshift+F1 = Debugging toggle usually
					;used to enable Serial debug prints

	move.w	d2,d0			; get the function row RAW key code
	sub.w	#$50,d0			; form into Index value
	DEA	TB_MainFGL,a0		; and try to find the FG
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*---
ToggleDebugBit
	bchg.b	#TOGGLE_BIT,TB_Flags4(a5)
	rts

*---	Support Preview row.

PrvwRowRKH:
	move.w	d2,d0			; get the numeric row RAW key code
	subq.w	#$01,d0			; form into Index value
	DEA	TB_PrvwFGL,a0		; and try to find the FG
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*---	Support LumKey row.
LumKeyRowERKH:
	tst.b	d3			; vanilla e
	beq.s	LumKeyRowRKH		; yup - do the normal LumKeyRowE

	moveq	#~(IEQUALIFIER_LSHIFT+IEQUALIFIER_RSHIFT),d0	; only an
	and.b	d3,d0						; Shift key
	bne.s	10$						; qualifier?

	moveq	#4,d0
	bra	GridSelRowCont	;select grid E

10$	rts

LumKeyRowRKH:
	move.w	d2,d0			; get the QWERTY row RAW key code
	sub.w	#$10,d0			; form into Index value
	DEA	TB_LumKeyFGL,a0		; and try to find the FG
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*---	Support ToolBox Grid Select row.

GridSelRowGRKH:
	moveq.l	#6,d0
	bra.s	GridSelRowCont
GridSelRowHRKH:
	moveq.l	#7,d0
	bra.s	GridSelRowCont
GridSelRowIRKH:
	moveq.l	#8,d0
	bra.s	GridSelRowCont

GridSelRowARKH:
	CLEAR	d0			; place Index in D0
	bra.s	GridSelRowCont		; jump to continue

GridSelRowBRKH:
	moveq	#1,d0			; place Index in D0
	bra.s	GridSelRowCont		; jump to continue

GridSelRowCRKH:
	moveq	#2,d0			; place Index in D0
	bra.s	GridSelRowCont		; jump to continue

GridSelRowDRKH:
	tst.b	d3			; vanilla d?
	beq.s	.DoGridD		; yup - do the normal Freeze

	moveq	#~(IEQUALIFIER_LSHIFT+IEQUALIFIER_RSHIFT),d0	; only an
	and.b	d3,d0						; Shift key
	beq.s	.DoGridD					; qualifier?

	moveq	#~(IEQUALIFIER_LALT+IEQUALIFIER_RALT),d0	; only an
	and.b	d3,d0						; ALT key
	bne.s	.Exit						; qualifier?
*								; exit if not
	XCALL	SWMotionCode2		; fielD Freeze
	XJUMP	UpdateDisplay		; do a selective update

.Exit	rts

.DoGridD moveq	#3,d0			; place Index in D0

GridSelRowCont:
	XDEF	GridSelRowCont
	DEA	TB_GridSelFGL,a0	; try to find the FG
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*---	Support Transition FGs.

TakeFGRKH:
	moveq	#1,d0			; place Index in D0
	bra.s	TransFGCont		; jump to continue

AutoFGRKH:
	CLEAR	d0			; place Index in D0

TransFGCont:
	DEA	TB_TransFGL,a0		; try to find the FG
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	moveq	#FGC_SELECTK,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*****************************************************************************
*	This function toggles printing of Effects name.
*****************************************************************************
toggleFXmode
	bchg.b	#FXCOMMENT_BIT,TB_Flags2(a5)
	CALLTL	UpdateDisplay
	rts

 ifeq 0
*---	Support Numeric select FGs.

NumFGsRKH:
	XDEF	NumFGsRKH
	move.w	d2,d0			; get the top number pad row
*					; RAW key code
	sub.w	#$5A-1,d0		; form into Index value
	DEA	TB_NumPadFGL,a0		; and try to find the FG
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	tst.b	FG_MouseFlag(a0)	; Addendum 6/7/90: no key select for
	bne.s	.Exit			; those NumPad FGs that are disabled
*					; for mouse input
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts
 endc

********************************************************
**---	Support special characters to the Numeric FG.
*
**
**	Removed By Pat-o-matic to send these keys along
**	to the project editor.
*
*NumFGDirectRKH0:
*	PUT.w	#0,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH1:
*	PUT.w	#1,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH2:
*	PUT.w	#2,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH3:
*	PUT.w	#3,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH4:
*	PUT.w	#4,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH5:
*	PUT.w	#5,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH6:
*	PUT.w	#6,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH7:
*	PUT.w	#7,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH8:
*	PUT.w	#8,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKH9:
*	PUT.w	#9,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKHBS:
*	PUT.w	#10,TB_KeyCode
*	bra.s	NumFGDirectRKH
*
*NumFGDirectRKHEnter:
*	GET.w	TB_QualCode,d0				; Addendum 8/9/90:
*	move.w	d0,d1
*
*; no longer	and.w	#IEQUALIFIER_LALT+IEQUALIFIER_RALT,d1	; now a special case
*; use keyboard	bne	FSDeleteEntry				; for ALT+ENTER
*
**	Addendum 8/28/90: special case for AMIGA+ENTER
*
*	and.w	#IEQUALIFIER_LCOMMAND+IEQUALIFIER_RCOMMAND,d0
*	bne	FSRenameEntry
********************************************************

	XDEF	DoEnterKey
DoEnterKey:
	moveq	#ES_SwitcherRAWKEY,d0	; d0 = Message Type
	move.l	#$43,d1			; d1 = Code
	moveq	#0,d2			; d2 = Qualifier
	XJSR	SendProjectEditMessage	; send message to editor
	rts
;	xdef	DoEnterKey
;	PUT.w	#11,TB_KeyCode

NumFGDirectRKH:
	GET.l	TB_NumPadFGL,d0		; get NumPad FG
	beq.s	.Exit			; if not around - early exit

	move.l	d0,a0			; address the NumPad FG
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_RAWKEY,-(sp)	; indicate to the application code
*					; that it has RAWKEYs coming to it
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*----	For handling the Freeze toggle button.
*----	Addendum 5/24/90:

FreezeRKH:
	tst.b	d3			; vanilla F/f?
	beq.s	.DoFreeze		; yup - do the normal Freeze

	moveq	#~(IEQUALIFIER_LSHIFT+IEQUALIFIER_RSHIFT),d0	; only an
	and.b	d3,d0						; Shift key
	bne.s	10$						; qualifier?

	moveq	#5,d0
	bra	GridSelRowCont		;Do Grid F select

10$	moveq	#~(IEQUALIFIER_LALT+IEQUALIFIER_RALT),d0	; only an
	and.b	d3,d0						; ALT key
	bne.s	.Exit						; qualifier?
*								; exit if not

	pea	8$(pc)			; else perform motion removal
	XJUMP	SWMotionCode		; Frame Freeze

.DoFreeze:
	cmp.w	#VIDEOTYPE_FREEZE4,TB_VideoFlagPri(a5)	; video frozen?
	beq.s	.Exit					; ...OK if so

	GET.l	TB_EfxFG,d0		; any controlling FG system?
	beq.s	.Exit			; exit if not
	move.l	d0,a0
	move.l	FG_Function(a0),d0	; any function to be run?
	beq.s	.Exit			; exit if not
	PUT.w	#VIDEOTYPE_FREEZE4,TB_VideoFlagSec	; else denote
*							; frozen video
	SAVE	a4-a6
	moveq	#FGC_FREEZE,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)			; send the FG system an FGC_FREEZE
	lea	12(sp),sp		; command
	REST	a4-a6

	XJSR	Panelupdate		; new test code 081595DEH			

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
8$:
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*----	For handling the Live toggle button.
*----	Addendum 10/10/90:
LiveRKH:
	cmp.w	#VIDEOTYPE_LIVE,TB_VideoFlagPri(a5)	; video live?
	beq.s	.Exit					; ...OK if so

	GET.l	TB_EfxFG,d0		; any controlling FG system?
	beq.s	.Exit			; exit if not
	move.l	d0,a0
	move.l	FG_Function(a0),d0	; any function to be run?
	beq.s	.Exit			; exit if not
	PUT.w	#VIDEOTYPE_LIVE,TB_VideoFlagSec		; else denote
*							; live video
	SAVE	a4-a6
	moveq	#FGC_FREEZE,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)			; send the FG system an FGC_FREEZE
	lea	12(sp),sp		; command
	REST	a4-a6

	XJSR	Panelupdate		; new test code 081595DEH			

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay
.Exit:
	rts

*----	For handling keyboard selection of Slow/Medium/Fast FGs.
*----	Addendum 5/24/90:
	xref	FC4_FG
VarSpeedRKH
	lea	FC4_FG,a0
	bra.s	SelectSpeed


SpeedSelectToggleRKH
	XCALL	SpeedSelectToggle
	XCALL	UpdateDisplay
	rts

SlowSpeedRKH:
	moveq	#FMCSLOWID,d0
	bra.s	DoSpeedRKH

MedSpeedRKH:
	moveq	#FMCMEDID,d0
	bra.s	DoSpeedRKH

FastSpeedRKH:
	moveq	#FMCFASTID,d0

DoSpeedRKH:
;;	DEA	TB_FMCountFGL,a0	; try to find the speed control FG
	lea	FGList,a0
	XCALL	IndexFastG
	beq.s	Exitsp			; if no FG found - early exit

	move.l	d0,a0
SelectSpeed
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	Exitsp			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

Exitsp:
	rts

	xref	FMCountFGs
FGList	dc.l	FMCountFGs

*----	For selecting the CG slice FG (if any) by keystroke.
*----	Addendum 5/25/90:

CGSelectRKH:
	XDEF	CGSelectRKH
	moveq	#CGSLICEID,d0		; try to find the CG slice FG
	DEA	TB_SliceFGL,a0
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0
	jsr	(a0)			; call the selected routine
	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*----	The following is backdoor code for NewTek internal use only.
*----	Addendum 10/13/89:

SpecialExitRKH0:
	moveq	#IEQUALIFIER_CONTROL+IEQUALIFIER_LALT,d0
	eor.b	d3,d0
	beq.s	SpecialExitRKH		; exit only if F10 pressed along with
*					; just CONTROL+LEFT ALT
	tst.b	d3
**	beq.s	.MTSliceSelect		; Jump if only F10
	beq	NOPRKH			; Send to editor if only F10

	moveq	#IEQUALIFIER_RALT+IEQUALIFIER_RSHIFT,d0
	eor.b	d3,d0
	bne.s	.Exit

* only RALT-RSHIFT-F10 = Manual Adjust Slice
	btst.b	#MAINFEEDBACK_BIT,TB_Flags2(a5)
	beq.s	.Exit			; Don't allow Hardware Setup if old Toaster

* Hardware setup slice
	moveq	#AJSLICEID,d0		; try to find the config slice FG
	bra.s	10$

.MTSliceSelect:
	moveq	#MTSLICEID,d0		; try to find the config slice FG

10$	DEA	TB_SliceFGL,a0
	XCALL	IndexFastG
	beq.s	.Exit			; if no FG found - early exit

	move.l	d0,a0
	move.l	FG_Function(a0),d0	; get the function to be invoked
	beq.s	.Exit			; if none - skip out
	SAVE	a4-a6			; save registers we can't lose
	move.l	a5,-(sp)		; pointer to ToasterBase
	move.l	a0,-(sp)		; pointer to FastGadget
	move.l	#FGC_SELECTK,-(sp)	; indicate to the application code
*					; that it is being selected
	move.l	d0,a0

;;	tst.w	TB_TValSec(a5)
;;	beq.s	5$
	XCALL	DoTakeNoKey

5$	jsr	(a0)			; call the selected routine

	lea	12(sp),sp		; clean off the stack
	REST	a4-a6			; restore registers

	tst.w	TB_CleanUp(a5)		; determine what needs to be done
*					; to refresh the interface display
	bne.s	9$			; if a total refresh - skip to it
	XJUMP	UpdateDisplay		; else do a selective update
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

SpecialExitRKH:
	XLEA	NoGrazerFlag,a0
	tst.b	(a0)
	bne.s	SpecialExit
	XJMP	SendProjectEditQuitMessage

	XDEF	SpecialExit
SpecialExit:
	GET.l	TB_Window,a0		; Addendum 5/24/90: Added this code
	move.l	wd_FirstGadget(a0),a0	; so that some FG entities, as well
	clr.w	gg_GadgetID(a0)		; as other Toaster system entities,
*					; would not identify the Switcher
*					; display and attempt to render into
*					; it - primary reason for putting
*					; this in was the FGC_UNLOAD of the
*					; Paint slice

	move.l	DataPool+InitialSP,sp	; reset SP so that we can
*					; exit this code section
	rts				; exit.....

*====	Force key mode off handler.
*====	Addendum 10/10/90:

KeyOffRKH:
	GET.w	TB_KeyModePri,d1	; get current setting of key mode
	bpl.s	.Exit			; ...if already setup

	bclr.l	#15,d1			; denote keying off

	GET.l	TB_EfxFG,d0		; flag TB FG crouton - if any
	beq.s	.Exit
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.Exit
	PUT.w	d1,TB_KeyModeSec
	SAVE	a4-a6
	moveq	#FGC_CLIP,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	a4-a6

	tst.w	TB_CleanUp(a5)
	bne.s	9$

	XJUMP	UpdateDisplay
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*====	Force key mode on to black clipping handler.
*====	Addendum 10/10/90:

KeyBlackRKH:
	GET.w	TB_KeyModePri,d0	; get current setting of key mode
	bpl.s	.DoKBLK			; ...if currently off
	tst.b	d0			; test for key clip type
	bmi.s	.Exit			; ...if already setup to black

.DoKBLK:
	GET.l	TB_EfxFG,d0		; flag TB FG crouton - if any
	beq.s	.Exit
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.Exit
	PUT.w	#$80FF,TB_KeyModeSec	; denote keying on and clip of black
	SAVE	a4-a6
	moveq	#FGC_CLIP,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	a4-a6

	tst.w	TB_CleanUp(a5)
	bne.s	9$

	XJUMP	UpdateDisplay
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*====	Force key mode on to white clipping handler.
*====	Addendum 10/10/90:

KeyWhiteRKH:
	GET.w	TB_KeyModePri,d0	; get current setting of key mode
	bpl.s	.DoKWHT			; ...if currently off
	tst.b	d0			; test for key clip type
	bpl.s	.Exit			; ...if already setup to white

.DoKWHT:
	GET.l	TB_EfxFG,d0		; flag TB FG crouton - if any
	beq.s	.Exit
	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.Exit
	PUT.w	#$8001,TB_KeyModeSec	; denote keying on and clip of white
	SAVE	a4-a6
	moveq	#FGC_CLIP,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	a4-a6

	tst.w	TB_CleanUp(a5)
	bne.s	9$

	XJUMP	UpdateDisplay
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*====	Clip up handler.
*====	Addendum 10/10/90:

ClipUpRKH:
	GET.w	TB_ClipAPri,d0		; get current clip level position
	cmp.w	#ClipAMax,d0		; room to expand?
	bcc.s	.Exit			; if not...

	addq.w	#1,d0			; else bump up clip level

	GET.l	TB_EfxFG,d1		; a controlling crouton to talk to?
	beq.s	.Exit			; if not...
	move.l	d1,a0
	move.l	FG_Function(a0),d1
	beq.s	.Exit			; on no function code to call...

	PUT.w	d0,TB_ClipASec		; denote the new CLIP position level
*					; in ToasterBase

	XCALL	SoftSpriteOff

	SAVE	a4-a6			; send out a CLIP command to the
	moveq	#FGC_CLIP,d0		; controlling crouton
	SAVE	d0/a0/a5
	move.l	d1,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	a4-a6

	XCALL	SoftSpriteOn

	tst.w	TB_CleanUp(a5)
	bne.s	9$

	XJUMP	UpdateDisplay
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*====	Clip down handler.
*====	Addendum 10/10/90:

ClipDownRKH:
	GET.w	TB_ClipAPri,d0		; get current clip level position
	beq.s	.Exit			; if no room to reduce...

	subq.w	#1,d0			; else bump down clip level

	GET.l	TB_EfxFG,d1		; a controlling crouton to talk to?
	beq.s	.Exit			; if not...
	move.l	d1,a0
	move.l	FG_Function(a0),d1
	beq.s	.Exit			; on no function code to call...

	PUT.w	d0,TB_ClipASec		; denote the new CLIP position level
*					; in ToasterBase

	XCALL	SoftSpriteOff

	SAVE	a4-a6			; send out a CLIP command to the
	moveq	#FGC_CLIP,d0		; controlling crouton
	SAVE	d0/a0/a5
	move.l	d1,a0
	jsr	(a0)
	lea	12(sp),sp
	REST	a4-a6

	XCALL	SoftSpriteOn

	tst.w	TB_CleanUp(a5)
	bne.s	9$

	XJUMP	UpdateDisplay
9$:
	XJUMP	ReDoDisplay

.Exit:
	rts

*====	Special close FastGadget. Can be externally referenced.

*+	XDEF	CloseCode
*+CloseCode:
*+	movem.l	4(sp),d0/a4/a5		; get ToasterBase in A5,
*+*					; the FastGadget pointer in A4 and
*+*					; the FGC_xxxx command in D0
*+	add.w	d0,d0			; form into index
*+	add.w	d0,d0
*+	move.l	.Table(pc,d0.w),a0
*+	jmp	(a0)			; and jump to the appropriate
*+*					; handler code
*+
*+	CNOP	0,4
*+.Table:
*+	DC.l	.NOP			; Load command
*+	DC.l	.NOP			; UnLoad command
*+	DC.l	.SelectIt		; Select command - only thus!
*+	DC.l	.NOP			; Remove command
*+	DC.l	.NOP			; Take command
*+	DC.l	.NOP			; TBar command
*+	DC.l	.NOP			; Speedo command
*+	DC.l	.NOP			; Generate TB FG command
*+	DC.l	.NOP			; Select quiet command
*+	DC.l	.NOP			; Remove quiet command
*+	DC.l	.NOP			; Number value command
*+	DC.l	.NOP			; Select by key command
*+	DC.l	.NOP			; Update FastGadget imagery command
*+	DC.l	.NOP			; RawKeys command
*+	DC.l	.NOP			; (extra as of now)
*+	DC.l	.NOP			; (extra as of now)
*+
*+.NOP:
*+	rts				; just like the label says....
*+
*+.SelectIt:
*+	move.l	a4,a0			; setup call to FastGadget
*+	GET.l	TB_Window,a1		; select call (no requester)
*+	XCALL	CompBoolSelect
*+	beq.s	.Continue		; if not selected - skip
*+
*+	move.l	DataPool+InitialSP,sp	; reset SP so that we can
*+*					; exit this code section
*+
*+.Continue:
*+	rts				; return to caller and continue


*====	Numeric keypad '+' key handler.
*====	Addendum 3/20/90:

PlusKey:
	xdef	PlusKey

	move.l	TB_NUMCGPAGES(a5),d1
	add.l	TB_NumFramestores(a5),d1

	move.l	TB_CURRENTPOPUP(a5),d0
	addq.l	#1,d0
	cmp.l	d1,d0
	blt.s	2$
	moveq.l	#0,d0
	tst.l	TB_CGPAGEARRAY(a5)		;if cg not loaded skip over
	bne.s	2$				;first entry in popup "Load Book"
	moveq.l	#1,d0
2$	move.l	d0,TB_CURRENTPOPUP(a5)
	XJSR	UpdateNumPadFromCurrent
	CALLTL	UpdateDisplay
	rts


 ifeq 1

	GET.l	TB_CurrSelFG,d0		; get active NumPad FG recipient
	beq	.ExitQ			; if none - skip out

	move.l	d0,a0			; address the FG
	move.w	FG_IndexID(a0),d0	; and get the ID
	subq.w	#CGSELID,d0		; !we assume valid IDs and sequence!

	dbf	d0,.NotCG		; if not a CG FG - skip on

;;;;	bra	.ExitQ			; do nothing for now....

	CLEAR	d0
	GET.w	TB_NumPadSec,d0		; get current page #
	addq.w	#1,d0			; and increment it
	cmp.w	#100,d0
	bcs.s	.NoPageWrap		; take into account wrap-around
	CLEAR	d0

.NoPageWrap:
	PUT.w	d0,TB_NumPadSec		; place updated page #

	XCALL	GetFirstLine		; get string corresponding to page #
	move.l	d0,a0
	GET.l	TB_FCStringSec,a1
	XCALL	STRcopy
	bra	.Exit

.NotCG:
	dbf	d0,.NotTBFG		; if not a crouton FG - skip on

	GET.l	TB_ToolBoxPTR,a0	; are we dealing with an empty grid?
	move.l	(a0),d0
	beq	.ExitQ			; if so - exit doing nothing

	CLEAR	d0
	CLEAR	d1
	GET.w	TB_NumPadSec,d0		; first form index number - 0-127
	divu	#10,d0
	subq.w	#1,d0
	bmi.s	.ShortCut
	cmp.w	#3,d0
	bls.s	.OK10s			; if 10s digit OK - skip on

	moveq	#32,d0
	bra.s	.ShortCut

.OK10s:
	lsl.w	#3,d0
	move.w	d0,d1
	swap	d0
	subq.w	#1,d0
	bmi.s	.OK1s
	cmp.w	#7,d0
	bls.s	.OK1s			; if 1s digit OK - skip on

	moveq	#7,d0

.OK1s:
	add.w	d1,d0

.ShortCut:
	move.l	TB_ToolBoxGrids(a5),a0
	GET.l	TB_ToolBoxPTR,d2
	sub.l	a0,d2
	lsr.w	#2,d2
	mulu	#TBFG_GRIDSIZE,d2
	add.w	d2,d0			; got NumPad

	GET.l	TB_ToolBoxPTR,a0	; find next sequential crouton - or
	move.l	(a0),a0			; the crouton if the only one
	move.l	a0,a1			; denote start crouton as the
	move.w	FG_IndexID(a1),d1	; the Best one found yet
	bra.s	.LoopTail		; jump into search loop

.Loop:
	move.l	d2,a0			; address next crouton
	move.w	FG_IndexID(a0),d2	; get its value as Current

	cmp.w	d2,d0			; Current <= NumPad?
	bge.s	.Current_LE_NumPad	; yup - jump to other test set

* Current > NumPad
	cmp.w	d1,d0			; Best <= NumPad?
	bge.s	.TakeNewBest		; yup - Current the new Best

* Current > NumPad && Best > NumPad
	cmp.w	d1,d2			; Best > Current?
	blt.s	.TakeNewBest		; if so - Current the new Best
	bra.s	.LoopTail		; else ignore Current

.Current_LE_NumPad:
	cmp.w	d1,d0			; Best > NumPad?
	blt.s	.LoopTail		; yup - ignore Current

* Best <= NumPad
	cmp.w	d1,d2			; Best <= Current?
	bge.s	.LoopTail		; yup - ignore Current

.TakeNewBest:
	move.l	a0,a1			; make Current the new Best
	move.w	d2,d1

.LoopTail:
	move.l	(a0),d2			; get next crouton
	bne.s	.Loop			; reloop if another exists

	divu	#TBFG_GRIDSIZE,d1	; get Best into interface NumPad
	clr.w	d1
	swap	d1
	divu	#TBFG_GRIDACROSS,d1
	addq.w	#1,d1
	add.w	d1,d1
	move.w	d1,d0
	add.w	d1,d1
	add.w	d1,d1
	add.w	d1,d0
	swap	d1
	addq.w	#1,d1
	add.w	d1,d0
	PUT.w	d0,TB_NumPadSec		; place the new interface NumPad

	lea	FGS_Comment(a1),a0	; get pointer to TBFG comment string
	GET.l	TB_FCStringSec,a1
	XCALL	STRcopy
	bra.s	.Exit

.NotTBFG:
*					; we assume FrameStore by now....

	moveq	#-1,d3			; get non-table element prefix

	GET.w	TB_NumPadSec,d0		; get starting table index position

	move.w	d0,d2			; use direct for wrap-around counter

	move.w	#1000,d1		; get primary counter
	sub.w	d0,d1
	subq.w	#2,d1
	bmi.s	.NoPriLoop		; if at top position - short cut
*					; to wrap around search

	addq.w	#1,d0
	mulu	#14,d0			; index into FrameStore table for
	GET.l	TB_FSStrings,a0		; primary search
	add.l	d0,a0

.PriLoop:
	cmp.b	(a0),d3			; an entry?
	bne.s	.NewFS			; yup - skip out
	lea	14(a0),a0
	dbf	d1,.PriLoop		; else reloop

.NoPriLoop:
	GET.l	TB_FSStrings,a0		; else setup for wrap-around search

.WrapLoop:
	cmp.b	(a0),d3			; an entry?
	bne.s	.NewFS			; yup - skip out
	lea	14(a0),a0
	dbf	d2,.WrapLoop		; else reloop

	bra.s	.ExitQ			; if no new entry found -
*					; exit having done nothing

.NewFS:
	move.l	a0,d0			; form new NumPad value
	sub.l	TB_FSStrings(a5),d0
	divu	#14,d0
	PUT.w	d0,TB_NumPadSec

	lea	1(a0),a0		; update the file comment
	GET.l	TB_FCStringSec,a1
	XCALL	STRcopy

.Exit:
	XJUMP	UpdateDisplay		; merely update the display - this
*					; routine never has a situation arise
*					; where ReDoDisplay() would be needed

.ExitQ:
	rts
 endc
*====	Numeric keypad '-' key handler.
*====	Addendum 3/20/90:

MinusKey:
	xdef	MinusKey
						; calculate length of list
	move.l	TB_NumFramestores(a5),d1
	bne.s	5$
	tst.l	TB_CGPAGEARRAY(a5)
	beq.s	4$				; if cg not loaded and no frams abort
5$	add.l	TB_NUMCGPAGES(a5),d1

	move.l	TB_CURRENTPOPUP(a5),d0
	subq.l	#1,d0
	bmi.s	3$
	bne.s	2$
	tst.l	TB_CGPAGEARRAY(a5)	; if cg not loaded do not let first
	bne.s	2$			; thing in popup be selected "Load Book"
3$	move.l	d1,d0
	beq.s	2$
	subq.l	#1,d0
2$	move.l	d0,TB_CURRENTPOPUP(a5)
	XJSR	UpdateNumPadFromCurrent
	CALLTL	UpdateDisplay
4$	rts

 ifeq 1
	GET.l	TB_CurrSelFG,d0		; get active NumPad FG recipient
	beq	.ExitQ			; if none - skip out

	move.l	d0,a0			; address the FG
	move.w	FG_IndexID(a0),d0	; and get the ID
	subq.w	#CGSELID,d0		; !we assume valid IDs and sequence!

	dbf	d0,.NotCG		; if not a CG FG - skip on

;;;;	bra	.ExitQ			; do nothing for now....

	CLEAR	d0
	GET.w	TB_NumPadSec,d0		; get current page #
	subq.w	#1,d0			; and decrement it
	bpl.s	.NoPageWrap		; take into account wrap-around
	moveq	#99,d0

.NoPageWrap:
	PUT.w	d0,TB_NumPadSec		; place updated page #

	XCALL	GetFirstLine		; get string corresponding to page #
	move.l	d0,a0
	GET.l	TB_FCStringSec,a1
	XCALL	STRcopy
	bra	.Exit

.NotCG:
	dbf	d0,.NotTBFG		; if not a crouton FG - skip on

	GET.l	TB_ToolBoxPTR,a0	; are we dealing with an empty grid?
	move.l	(a0),d0
	beq	.ExitQ			; if so - exit doing nothing

	CLEAR	d0
	CLEAR	d1
	GET.w	TB_NumPadSec,d0		; first form index number - 0-127
	divu	#10,d0
	subq.w	#1,d0
	bmi.s	.ShortCut
	cmp.w	#3,d0
	bls.s	.OK10s			; if 10s digit OK - skip on

	moveq	#32,d0
	bra.s	.ShortCut

.OK10s:
	lsl.w	#3,d0
	move.w	d0,d1
	swap	d0
	subq.w	#1,d0
	bpl.s	.AboveZero

	CLEAR	d0
	bra.s	.OK1s

.AboveZero:
	cmp.w	#7,d0
	bls.s	.OK1s			; if 1s digit OK - skip on

	moveq	#8,d0

.OK1s:
	add.w	d1,d0

.ShortCut:
	move.l	TB_ToolBoxGrids(a5),a0
	GET.l	TB_ToolBoxPTR,d2
	sub.l	a0,d2
	lsr.w	#2,d2
	mulu	#TBFG_GRIDSIZE,d2
	add.w	d2,d0			; got NumPad

	GET.l	TB_ToolBoxPTR,a0	; find next sequential crouton - or
	move.l	(a0),a0			; the crouton if the only one
	move.l	a0,a1			; denote start crouton as the
	move.w	FG_IndexID(a1),d1	; the Best one found yet
	bra.s	.LoopTail		; jump into search loop

.Loop:
	move.l	d2,a0			; address next crouton
	move.w	FG_IndexID(a0),d2	; get its value as Current

	cmp.w	d2,d0			; Current >= NumPad?
	ble.s	.Current_GE_NumPad	; yup - jump to other test set

* Current < NumPad
	cmp.w	d1,d0			; Best >= NumPad?
	ble.s	.TakeNewBest		; yup - Current the new Best

* Current < NumPad && Best < NumPad
	cmp.w	d1,d2			; Best < Current?
	bgt.s	.TakeNewBest		; if so - Current the new Best
	bra.s	.LoopTail		; else ignore Current

.Current_GE_NumPad:
	cmp.w	d1,d0			; Best < NumPad?
	bgt.s	.LoopTail		; yup - ignore Current

* Best <= NumPad
	cmp.w	d1,d2			; Best >= Current?
	ble.s	.LoopTail		; yup - ignore Current

.TakeNewBest:
	move.l	a0,a1			; make Current the new Best
	move.w	d2,d1

.LoopTail:
	move.l	(a0),d2			; get next crouton
	bne.s	.Loop			; reloop if another exists

	divu	#TBFG_GRIDSIZE,d1	; get Best into interface NumPad
	clr.w	d1
	swap	d1
	divu	#TBFG_GRIDACROSS,d1
	addq.w	#1,d1
	add.w	d1,d1
	move.w	d1,d0
	add.w	d1,d1
	add.w	d1,d1
	add.w	d1,d0
	swap	d1
	addq.w	#1,d1
	add.w	d1,d0
	PUT.w	d0,TB_NumPadSec		; place the new interface NumPad

	lea	FGS_Comment(a1),a0	; get pointer to TBFG comment string
	GET.l	TB_FCStringSec,a1
	XCALL	STRcopy
	bra.s	.Exit

.NotTBFG:
*					; we assume FrameStore by now....

	moveq	#-1,d3			; get non-table element prefix

	GET.w	TB_NumPadSec,d0		; get starting table index position

	move.w	#1000-1,d2
	sub.w	d0,d2			; get wrap-around counter

	move.w	d0,d1			; get primary counter
	subq.w	#1,d1
	bmi.s	.NoPriLoop		; if at top position - short cut
*					; to wrap around search

	subq.w	#1,d0
	mulu	#14,d0			; index into FrameStore table for
	GET.l	TB_FSStrings,a0		; primary search
	add.l	d0,a0

.PriLoop:
	cmp.b	(a0),d3			; an entry?
	bne.s	.NewFS			; yup - skip out
	lea	-14(a0),a0
	dbf	d1,.PriLoop		; else reloop

.NoPriLoop:
	GET.l	TB_FSStrings,a0		; else setup for wrap-around search
	lea	(1000-1)*14(a0),a0

.WrapLoop:
	cmp.b	(a0),d3			; an entry?
	bne.s	.NewFS			; yup - skip out
	lea	-14(a0),a0
	dbf	d2,.WrapLoop		; else reloop

	bra.s	.ExitQ			; if no new entry found -
*					; exit having done nothing

.NewFS:
	move.l	a0,d0			; form new NumPad value
	sub.l	TB_FSStrings(a5),d0
	divu	#14,d0
	PUT.w	d0,TB_NumPadSec

	lea	1(a0),a0		; update the file comment
	GET.l	TB_FCStringSec,a1
	XCALL	STRcopy

.Exit:
	XJUMP	UpdateDisplay		; merely update the display - this
*					; routine never has a situation arise
*					; where ReDoDisplay() would be needed

.ExitQ:
	rts
 endc
*====	Handler for toggling User On/Off interface state.
*====	Addendum 7/2/90:

ToggleUserOnOff:
	SAVE	a4-a6			; save registers can't afford to lose

	XCALL	MTSliceUserOnOffK	; call external handler

	REST	a4-a6
	rts

 ifeq 1
********************************************************************
* Removed by Pat-o-matic, num-key period now goes to editor
*
*====	Semi-automatic help sequence for aiding frame store saving.
*====	Addendum 7/30/90:

FSAutomatic:
	GET.l	TB_CurrSelFG,a0		; are we enabled for this operation?
	cmp.w	#FSSELID,FG_IndexID(a0)	; (frame save selected on NumPad)
	bne	.ExitQ			; if not - quick exit

	btst.b	#IMAGERY_ONOFF_BIT,TB_Flags(a5)
	bne	.ExitQ

	GET.w	TB_NumPadSec,d0		; get current frame store table entry
	mulu	#14,d0
	GET.l	TB_FSStrings,a0
	add.l	d0,a0
	cmp.b	#-1,(a0)
	beq.s	.ShortCut		; if already at a empty entry - skip

	moveq	#-1,d3			; get non-table element prefix

	GET.w	TB_NumPadSec,d0		; get starting table index position

	move.w	d0,d2			; use direct for wrap-around counter

	move.w	#1000,d1		; get primary counter
	sub.w	d0,d1
	subq.w	#2,d1
	bmi.s	.NoPriLoop		; if at top position - short cut
*					; to wrap around search

	addq.w	#1,d0
	mulu	#14,d0			; index into FrameStore table for
	GET.l	TB_FSStrings,a0		; primary search
	add.l	d0,a0

.PriLoop:
	cmp.b	(a0),d3			; an empty entry?
	beq.s	.EmptyFS		; yup - skip out
	lea	14(a0),a0
	dbf	d1,.PriLoop		; else reloop

.NoPriLoop:
	GET.l	TB_FSStrings,a0		; else setup for wrap-around search

.WrapLoop:
	cmp.b	(a0),d3			; an empty entry?
	beq.s	.EmptyFS		; yup - skip out
	lea	14(a0),a0
	dbf	d2,.WrapLoop		; else reloop

	bra.s	.ExitQ			; if no empty entry found -
*					; exit having done nothing

.EmptyFS:
	move.l	a0,d0			; form new NumPad value
	sub.l	TB_FSStrings(a5),d0
	divu	#14,d0
	PUT.w	d0,TB_NumPadSec

	GET.l	TB_FCStringSec,a0	; denote file comment string as empty
	clr.b	(a0)

	XCALL	UpdateDisplay		; update Switcher imagery

.ShortCut:
	DEA	TB_NumPadFGL,a0		; activate the file comment string
	moveq	#FCMNTID,d0
	XCALL	IndexFastG
	beq.s	.ExitQ			; if file comment FG not found

	move.l	d0,a0
	move.l	FG_Function(a0),d0
	beq.s	.ExitQ			; if no function code
	SAVE	a4-a6
	moveq	#FGC_SELECT,d1
	SAVE	d1/a0/a5
	move.l	d0,a0
	jsr	(a0)			; activate the file comment string
	lea	12(sp),sp		; via FGC_SELECT
	REST	a4-a6

.ExitQ:
	rts
*
********************************************************************
 endc

*====	Delete current FrameStore entry in the NumPad system, if enabled and
*====	a FrameStore entry exists.
*====	Addendum 8/9/90:
	xdef	FSDeleteEntry
FSDeleteEntry:

	movem.l	d0-d7/a0-a6,-(sp)

	lea	DataPool,a4		; address private data with A4

 ifeq 1
	GET.l	TB_CurrSelFG,a0		; are we enabled for this operation?
	cmp.w	#FSSELID,FG_IndexID(a0)	; (frame save selected on NumPad)
	bne	.ExitQ			; if not - quick exit
 endc
	GET.w	TB_NumPadSec,d0		; get current frame store table entry
	mulu	#14,d0
	GET.l	TB_FSStrings,a0
	add.l	d0,a0
	cmp.b	#-1,(a0)
	beq	.ExitQ			; if already at a empty entry - skip

	move.l	a0,d4			; save the pointer in case we need
*					; it later on

	CLEAR	d0			; build the filename to delete
	GET.w	TB_NumPadSec,d0
	moveq	#1,d1
	lea	1(a0),a0
	GET.l	TB_FileBuff,a1
	XCALL	BuildFileName

	CLEAR	d0				; assure that the user really
	move.l	#DISKINSERTED+DISKREMOVED,d1	; wants to delete the
	lea	DeleteFSFileMsg(a4),a1		; framestore entry

;	GET.l	TB_FCString,a0
	GET.l	TB_FileBuff,a0
;	move.l	d0,a1
	tst.b	(a0)
	beq.s	1$
	exg.l	a0,a1
1$
	lea	YesMsg(a4),a2
	lea	NoMsg(a4),a3
	XCALL	DoSwitcherRequester
	ble.s	.ExitQ

*				; OK - the user really wants to do this....

	GET.l	TB_DOSBase,a6

	CLEAR	d1			; save current directory
	CALLROM	CurrentDir
	move.l	d0,d2

	XCALL	LockFS			; get to current FS directory
	beq.s	.RestoreDir		; ...if we couldn't lock FS directory
	move.l	d0,d3			; save the lock

	GET.l	TB_FileBuff,d1		; now attempt to delete the
	CALLROM	DeleteFile		; framestore entry file
	move.l	d0,d0
	beq.s	.UnLock			; ...if file was not deleted

*				; the file was deleted

	move.l	d4,a0			; clear out FrameStore entry
	move.w	#$FF00,(a0)

	GET.l	TB_FCStringSec,a0	; denote file comment string as empty
	clr.b	(a0)

; Not needed	XCALL	UpdateDisplay		; update Switcher imagery

.UnLock:
	move.l	d3,d1			; release the FS directory lock
	CALLROM	UnLock

.RestoreDir:
	move.l	d2,d1			; restore original directory
	CALLROM	CurrentDir

	GET.l	TB_SYSBase,a6		; restore exec pointer in a6

.ExitQ:
	movem.l	(sp)+,d0-d7/a0-a6
	rts

*====	Rename current FrameStore entry in the NumPad system, if enabled and
*====	a FrameStore entry exists.
*====	Addendum 8/28/90:

FSRenameEntry:
	GET.l	TB_CurrSelFG,a0		; are we enabled for this operation?
	cmp.w	#FSSELID,FG_IndexID(a0)	; (frame save selected on NumPad)
;	bne	.ExitQ			; if not - quick exit
	beq.s	FSRenameEntryQ
	rts
	xdef	FSRenameEntryQ
FSRenameEntryQ:
	lea	DataPool,a4
	GET.w	TB_NumPadSec,d0		; get current frame store table entry
	mulu	#14,d0
	GET.l	TB_FSStrings,a0
	add.l	d0,a0
	cmp.b	#-1,(a0)
	beq	.ExitQ			; if already at a empty entry - skip

	move.l	a0,d5			; save the pointer in case we need
*					; it later on

	lea	1(a0),a0		; see if a name change is needed
	GET.l	TB_FCString,a1
	XCALL	STRcmp
;;;;	beq	.ExitQ			; ...if none required
	bne.s	.DoRename		; Addendum 11/20/90: following code

	CLEAR	d0				; help user to do the right
	move.l	#DISKINSERTED+DISKREMOVED,d1	; thing....
	lea	HelpRenameFSFileMsg1(a4),a0
	lea	HelpRenameFSFileMsg2(a4),a1
	move.l	d0,a2
	lea	CancelMsg(a4),a3
	XCALL	DoSwitcherRequester
	bra	.ExitQ

.DoRename:
	CLEAR	d0			; build the filename to be renamed
	GET.w	TB_NumPadSec,d0
	moveq	#1,d1
	GET.l	TB_FileBuff,a1
	XCALL	BuildFileName

	CLEAR	d0			; build the new rename filename
	GET.w	TB_NumPadSec,d0
	moveq	#1,d1
	GET.l	TB_FCString,a0
	GET.l	TB_FileBuff,a1
	lea	32(a1),a1
	XCALL	BuildFileName

*					; Addendum 11/20/90: following code
	lea	RenameFSFileMsg1(a4),a0
	GET.l	TB_FileBuff,a1
	lea	64(a1),a1
	move.l	a1,a2
	XCALL	STRcopy
	lea	-64+7(a2),a0
	XCALL	STRcopy
	lea	1(a1),a1
	move.l	a1,a3
	lea	RenameFSFileMsg2(a4),a0
	XCALL	STRcopy
	lea	-32+7(a2),a0
	XCALL	STRcopy
	lea	RenameFSFileMsg3(a4),a0
	XCALL	STRcopy

	CLEAR	d0				; assure that the user really
	move.l	#DISKINSERTED+DISKREMOVED,d1	; wants to rename the
	move.l	a2,a0				; framestore entry
	move.l	a3,a1
	lea	YesMsg(a4),a2
	lea	NoMsg(a4),a3
	XCALL	DoSwitcherRequester
;;;;	ble.s	.ExitQ
	bgt.s	.GoDoIt

;;	XCALL	UpDateFC		; assure file comment restored
;;	XCALL	UpdateDisplay
	bra.s	.ExitQ

*				; OK - the user really wants to do this....

.GoDoIt:
	GET.l	TB_DOSBase,a6

	CLEAR	d1			; save current directory
	CALLROM	CurrentDir
	move.l	d0,d3

	XCALL	LockFS			; get to current FS directory
	beq.s	.RestoreDir		; ...if we couldn't lock FS directory
	move.l	d0,d4			; save the lock

	GET.l	TB_FileBuff,d1		; now attempt to rename the
	moveq	#32,d2			; framestore entry file
	add.l	d1,d2
	CALLROM	Rename
	move.l	d0,d0
	beq.s	.UnLock			; ...if file was not deleted

*				; the file was renamed

	GET.l	TB_FCString,a0		; outfit the FrameStore entry
	XCALL	STRlen
	move.l	d5,a1
	move.b	d0,(a1)+
	XCALL	STRcopy

.UnLock:
	move.l	d4,d1			; release the FS directory lock
	CALLROM	UnLock

.RestoreDir:
	move.l	d3,d1			; restore original directory
	CALLROM	CurrentDir

	GET.l	TB_SYSBase,a6		; restore exec pointer in a6

.ExitQ:
	rts

	IFD	TILEGAME
*====	This code allows the swap of 2 TB FGs. It is not of industrial grade
*====	since it really won't be part of the shipping Toaster.

Swap2TBFGs:
	SAVE	d0-d3/a0-a3/a6
	GET.l	TB_EfxFG,a3	; active controlling TB FG pointer in A3
	move.l	a3,a0		; - its TB FGL anchor pointer in D3
	CALL	GetTBFGLBase
	beq	.ExitQ
	move.l	d0,d3

	CALL	NextGadgetDown	; wait till we get a GADGETDOWN event

	move.l	d0,d1		; get selected TB FG pointer in D0/A2
	swap	d1		; - its TB FGL anchor pointer always in
	move.l	d0,d2		; TB_ToolBoxPTR
	CLEAR	d0
	GET.l	TB_ToolBoxPTR,a0
	move.l	(a0),a0
;;	move.l	d0,a1
	XCALL	MouseFastGList
	beq	.CheckEmptySwap

	cmp.l	a3,d0
	beq	.ExitQ

	move.l	d0,a2				; swap placement info
	move.w	FG_IndexID(a2),d0
	move.w	FG_IndexID(a3),FG_IndexID(a2)
	move.w	d0,FG_IndexID(a3)

	move.l	a2,a0				; install the changes
	XCALL	PutNewLocTB
	move.l	a3,a0
	XCALL	PutNewLocTB

	cmp.l	TB_ToolBoxPTR(a5),d3		; check for grid swaps
	beq.s	.BothOnDisplayGrid

	moveq	#1,d0				; swap the TB FGs on their
	move.l	a2,a0				; respective FGLs
	GET.l	TB_ToolBoxPTR,a1
	XCALL	RemoveFastGList

	moveq	#1,d0
	move.l	a3,a0
	move.l	d3,a1
	XCALL	RemoveFastGList

	moveq	#1,d0
	moveq	#-1,d1
	move.l	a2,a0
	move.l	d3,a1
	XCALL	AddFastGList

	moveq	#1,d0
	moveq	#-1,d1
	move.l	a3,a0
	GET.l	TB_ToolBoxPTR,a1
	XCALL	AddFastGList

	GET.l	TB_SYSBase,a6
	CALLROM	Forbid
	XCALL	SoftSpriteOff
	bra.s	.Display1Only

.BothOnDisplayGrid:
	GET.l	TB_SYSBase,a6
	CALLROM	Forbid
	XCALL	SoftSpriteOff

	moveq	#1,d0
	CLEAR	d1
	move.l	a2,a0
	GET.l	TB_Window,a1
;;	move.l	d1,a2
	XCALL	DrawFastGList

.Display1Only:
	moveq	#1,d0
	CLEAR	d1
	move.l	a3,a0
	GET.l	TB_Window,a1
;;	move.l	d1,a2
	XCALL	DrawFastGList

	XCALL	SoftSpriteOn
	CALLROM	Permit

.ExitQ:
	REST	d0-d3/a0-a3/a6
	rts

.CheckEmptySwap:
	move.l	d2,d0
	clr.w	d0
	swap	d0
	CLEAR	d1
	move.w	d2,d1

	cmp.w	#TBFG_WIDTH*TBFG_GRIDACROSS+TBFG_LEFTEDGE,d0
	bhi	.ExitQ

	cmp.w	#TBFG_LEFTEDGE,d0
	bcs	.ExitQ

	cmp.w	#TBFG_HEIGHT*TBFG_GRIDROWS+TBFG_TOPEDGE,d1
	bhi	.ExitQ

	cmp.w	#TBFG_TOPEDGE,d1
	bcs	.ExitQ

	sub.w	#TBFG_TOPEDGE,d1	; form new IndexID value in D0
	divu	#TBFG_HEIGHT,d1
	mulu	#TBFG_GRIDACROSS,d1

	sub.w	#TBFG_LEFTEDGE,d0
	divu	#TBFG_WIDTH,d0
	add.w	d1,d0

	GET.l	TB_ToolBoxPTR,d1
	move.l	TB_ToolBoxGrids(a5),a0
	sub.l	a0,d1
	lsr.w	#2,d1
	mulu	#TBFG_GRIDSIZE,d1
	add.w	d1,d0

	move.w	d0,FG_IndexID(a3)
	move.l	a3,a0
	XCALL	PutNewLocTB

	cmp.l	TB_ToolBoxPTR(a5),d3
	beq.s	.SameDisplayGrid

	moveq	#1,d0
	move.l	a3,a0
	move.l	d3,a1
	XCALL	RemoveFastGList

	moveq	#1,d0
	moveq	#-1,d1
	move.l	a3,a0
	GET.l	TB_ToolBoxPTR,a1
	XCALL	AddFastGList

	GET.l	TB_SYSBase,a6
	CALLROM	Forbid
	XCALL	SoftSpriteOff
	bra	.Display1Only

.SameDisplayGrid:
	GET.l	TB_SYSBase,a6
	CALLROM	Forbid
	XCALL	SoftSpriteOff
	move.l	d3,a0
	XCALL	ToolBoxFill
	bra	.Display1Only

*====	Waits until the next GADGETDOWN IDCMP message comes along and returns
*====	the X/Y coordinate. Ignores any other IDCMP event type.

NextGadgetDown:
	SAVE	d1-d3/a0/a1/a6
	GET.l	TB_SYSBase,a6

.Loop1:
	GET.l	TB_MsgPort,a0
	CALLROM	WaitPort

.Loop2:
	GET.l	TB_MsgPort,a0
	CALLROM	GetMsg
	tst.l	d0
	beq.s	.Loop1

	move.l	d0,a1
	move.l	im_Class(a1),d2
	move.l	im_MouseX(a1),d3
	CALLROM	ReplyMsg

	cmp.l	#GADGETDOWN,d2
	bne.s	.Loop2

	move.l	d3,d0
	REST	d1-d3/a0/a1/a6
	rts

*====	Find TB FG list anchor or NULL if not in any TB FGL.

GetTBFGLBase:
	SAVE	d1/a1/a2
	move.l	TB_ToolBoxGrids(a5),a2	; 4 TB FGLs to look through
	move.l	TB_NUMGRIDS(a5),d1
	subq.l	#1,d1

.Loop1:
	move.l	a2,a1			; address TB FGL anchor

.Loop2:
	move.l	(a1),d0			; look through the TB FGL
	beq.s	.Loop2End
	cmp.l	d0,a0
	beq.s	.FoundIt
	move.l	d0,a1
	bra.s	.Loop2

.Loop2End:
	lea	4(a2),a2
	dbf	d1,.Loop1

	REST	d1/a1/a2		; if not found return 0
	rts

.FoundIt:
	move.l	a2,d0			; if found return list anchor
	REST	d1/a1/a2
	rts

	ENDC	;TILEGAME

*====	Private data area. Base register will be A4.

	SECTION	MBDispatch,DATA

DataPool:

	DATASYM	InitialSP,DataPool
	DS.l	1			; holds initial entry SP

*----	Table for invoking RAW key code handlers.

	DATASYM	RawKeyTable,DataPool

	DC.l	NOPRKH			; 00
	DC.l	PrvwRowRKH		; 01
	DC.l	PrvwRowRKH		; 02
	DC.l	PrvwRowRKH		; 03
	DC.l	PrvwRowRKH		; 04
	DC.l	PrvwRowRKH		; 05
	DC.l	PrvwRowRKH		; 06
	DC.l	PrvwRowRKH		; 07
	DC.l	NOPRKH			; 08
	DC.l	NOPRKH			; 09
	DC.l	NOPRKH			; 0A
	DC.l	NOPRKH			; 0B
	DC.l	NOPRKH			; 0C
	DC.l	NOPRKH			; 0D
	DC.l	NOPRKH			; 0E
	DC.l	NOPRKH ;NumFGDirectRKH0	; 0F

	DC.l	LumKeyRowRKH		; 10
	DC.l	LumKeyRowRKH		; 11
	DC.l	LumKeyRowERKH		; 12
	DC.l	LumKeyRowRKH		; 13
	DC.l	LumKeyRowRKH		; 14
	DC.l	LumKeyRowRKH		; 15
	DC.l	LumKeyRowRKH		; 16
	DC.l	GridSelRowIRKH		; 17
	DC.l	KeyOffRKH		; 18 Addendum 10/10/90:
	DC.l	NOPRKH			; 19
	DC.l	KeyBlackRKH		; 1A Addendum 10/10/90:
	DC.l	KeyWhiteRKH		; 1B Addendum 10/10/90:
	DC.l	NOPRKH			; 1C
	DC.l	NOPRKH; NumFGDirectRKH1	; 1D
	DC.l	NOPRKH; NumFGDirectRKH2	; 1E
	DC.l	NOPRKH; NumFGDirectRKH3	; 1F

	DC.l	GridSelRowARKH		; 20
	DC.l	SpeedSelectToggleRKH	; 21
	DC.l	GridSelRowDRKH		; 22
	DC.l	FreezeRKH		; 23 Addendum 5/24/90:
	DC.l	GridSelRowGRKH		; 24
	DC.l	GridSelRowHRKH		; 25
	DC.l	NOPRKH			; 26
	DC.l	NOPRKH			; 27
	DC.l	LiveRKH			; 28 Addendum 10/10/90:
	DC.l	NOPRKH			; 29
	DC.l	NOPRKH			; 2A
	DC.l	NOPRKH			; 2B
	DC.l	NOPRKH			; 2C
	DC.l	NOPRKH; NumFGDirectRKH4	; 2D
	DC.l	NOPRKH; NumFGDirectRKH5	; 2E
	DC.l	NOPRKH; NumFGDirectRKH6	; 2F

	DC.l	NOPRKH			; 30
	DC.l	NOPRKH			; 31
	DC.l	NOPRKH			; 32
	DC.l	GridSelRowCRKH		; 33
	DC.l	NOPRKH			; 34
	DC.l	GridSelRowBRKH		; 35
	DC.l	NOPRKH			; 36
	DC.l	VarSpeedRKH			; 37
	DC.l	SlowSpeedRKH		; 38 Addendum 5/24/90:
	DC.l	MedSpeedRKH		; 39 Addendum 5/24/90:
	DC.l	FastSpeedRKH		; 3A Addendum 5/24/90:
	DC.l	NOPRKH			; 3B
	DC.l	NOPRKH; FSAutomatic	; 3C Addendum 7/30/90:
	DC.l	NOPRKH; NumFGDirectRKH7	; 3D
	DC.l	NOPRKH; NumFGDirectRKH8	; 3E
	DC.l	NOPRKH; NumFGDirectRKH9	; 3F

	DC.l	AutoFGRKH		; 40
	DC.l	NOPRKH; NumFGDirectRKHBS; 41
	DC.l	NOPRKH			; 42
	DC.l	NOPRKH		;;NumFGDirectRKHEnter	; 43 removed for 4.0
	DC.l	TakeFGRKH		; 44
	DC.l	NOPRKH			; 45
	DC.l	NOPRKH			; 46
	DC.l	NOPRKH			; 47
	DC.l	NOPRKH			; 48
	DC.l	NOPRKH			; 49
	DC.l	MinusKey		; 4A Addendum 3/20/90:
	DC.l	NOPRKH			; 4B
	DC.l	NOPRKH ;ClipDownRKH	; 4C Addendum 11/24/91:
	DC.l	NOPRKH ;ClipUpRKH	; 4D Addendum 11/24/91:
	DC.l	NOPRKH			; 4E
	DC.l	NOPRKH			; 4F

	DC.l	MainRowRKH		; 50	;F1
	DC.l	MainRowRKH		; 51
	DC.l	MainRowRKH		; 52
	DC.l	MainRowRKH		; 53
	DC.l	MainRowRKH		; 54
	DC.l	MainRowRKH		; 55
	DC.l	MainRowRKH		; 56

	IFD	TILEGAME
	DC.l	Swap2TBFGs		; 57
	ENDC

	IFND	TILEGAME
	DC.l	ToggleEditor		; 57
	ENDC

	DC.l	CGSelectRKH		; 58 Addendum 10/16/90:
	DC.l	SpecialExitRKH0		; 59 Addendum 10/10/90: exit/config F10
	DC.l	NOPRKH	;NumFGsRKH		; 5A	;cg
	DC.l	toggleFXmode	;NOPRKH	;NumFGsRKH		; 5B	;fx
	DC.l	NOPRKH	;NumFGsRKH		; 5C	;load
	DC.l	NOPRKH	;NumFGsRKH		; 5D	;save
	DC.l	PlusKey			; 5E Addendum 3/20/90:
	DC.l	ToggleUserOnOff		; 5F Addendum 7/2/90:

	DC.l	NOPRKH			; 60
	DC.l	NOPRKH			; 61
	DC.l	NOPRKH			; 62
	DC.l	NOPRKH			; 63
	DC.l	NOPRKH			; 64
	DC.l	NOPRKH			; 65
	DC.l	NOPRKH			; 66
	DC.l	NOPRKH			; 67
	DC.l	NOPRKH			; 68
	DC.l	NOPRKH			; 69
	DC.l	NOPRKH			; 60
	DC.l	NOPRKH			; 6A
	DC.l	NOPRKH			; 6B
	DC.l	NOPRKH			; 6C
	DC.l	NOPRKH			; 6D
	DC.l	NOPRKH			; 6E
	DC.l	NOPRKH			; 6F

	DC.l	NOPRKH			; 70
	DC.l	NOPRKH			; 71
	DC.l	NOPRKH			; 72
	DC.l	NOPRKH			; 73
	DC.l	NOPRKH			; 74
	DC.l	NOPRKH			; 75
	DC.l	NOPRKH			; 76
	DC.l	NOPRKH			; 77
	DC.l	NOPRKH			; 78
	DC.l	NOPRKH			; 79
	DC.l	NOPRKH			; 70
	DC.l	NOPRKH			; 7A
	DC.l	NOPRKH			; 7B
	DC.l	NOPRKH			; 7C
	DC.l	NOPRKH			; 7D
	DC.l	NOPRKH			; 7E
	DC.l	NOPRKH			; 7F

*----	Real intuition boolean gadgets with no imagery to aid in selection
*----	of FastGadgets.

ToggleEditor
* For use to be getting this message the project editor must not be up.
	XLEA	NoGrazerFlag,a0
	tst.b	(a0)	;jump if already up!
	beq.s	10$
	clr.b	(a0)
	XJSR	BringUpProjectEditor
10$	rts

	XDEF	SwitcherWGList		; Addendum 9/18/90: so Switcher can
SwitcherWGList:				; get access to following GList

	DATASYM	MiscArea,DataPool	; gadgets to map the display into
*					; categories of FastGadgets
	xdef	SwitcherArea_
SwitcherArea_:
	DC.l	ToolArea_
	DC.w	MISCLEFT,MISCTOP
	DC.w	MISCWIDTH,MISCHEIGHT
	DC.w	DEFGFLAGS
	DC.w	DEFGACTI
	DC.w	DEFGTYPE
	DC.l	0,0,0,0,0
	DC.w	'SW'			; Addendum 4/5/90: screen ID
	DC.l	MiscCode

	DATASYM	ToolArea,DataPool
	xdef	ToolArea_
ToolArea_:
	DC.l	0			;CtrlArea_
	DC.w	TOOLLEFT,TOOLTOP
	DC.w	TOOLWIDTH,TOOLHEIGHT
	DC.w	DEFGFLAGS
	DC.w	DEFGACTI
	DC.w	DEFGTYPE
	DC.l	0,0,0,0,0
	DC.w	0
	DC.l	ToolCode

 ifeq 1					;there are now only two gadgets on the switcher
	DATASYM	CtrlArea,DataPool
CtrlArea_:
	DC.l	0
	DC.w	CTRLLEFT,CTRLTOP
	DC.w	CTRLWIDTH,CTRLHEIGHT
	DC.w	DEFGFLAGS
	DC.w	DEFGACTI
	DC.w	DEFGTYPE
	DC.l	0,0,0,0,0
	DC.w	0
	DC.l	CtrlCode
 endc
	DATASYM	DeleteFSFileMsg,DataPool
	DC.b	'Delete the FrameStore entry?',0

	DATASYM	RenameFSFileMsg1,DataPool
	DC.b	'Rename FrameStore ',0

	DATASYM	RenameFSFileMsg2,DataPool
	DC.b	'to ',0

	DATASYM	RenameFSFileMsg3,DataPool
	DC.b	'?',0

	DATASYM	HelpRenameFSFileMsg1,DataPool
	DC.b	'No new name specified. Enter a new',0

	DATASYM	HelpRenameFSFileMsg2,DataPool
	DC.b	'name before the Rename operation.',0

	DATASYM	YesMsg,DataPool
	DC.b	'YES',0

	DATASYM	NoMsg,DataPool
	DC.b	'NO',0

	DATASYM	CancelMsg,DataPool
	DC.b	'CANCEL',0

	END
@


2.45
log
@fixed switcher freeze panel.
@
text
@d7 1
a7 1
* $Id: MBDispatch.a,v 2.44 1995/06/05 12:02:12 pfrench Exp Holt $
d10 3
@


2.44
log
@Modified DoEnterKey routine to forward RAWKEY to editor
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.43 1995/04/24 13:26:06 pfrench Exp pfrench $
d9 4
a12 1
* $Log: mbdispatch.a,v $
d1481 2
a1495 1

d1515 2
a1522 1

@


2.43
log
@Plain F10 key gets sent to editor
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.42 1995/03/02 14:47:00 pfrench Exp pfrench $
d10 3
d1400 1
d1402 7
a1408 2
	xdef	DoEnterKey
	PUT.w	#11,TB_KeyCode
@


2.42
log
@Period key on NumPad needed re-directing also.
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.41 1995/03/02 13:00:02 pfrench Exp pfrench $
d10 3
d1611 2
a1612 1
	beq.s	.MTSliceSelect		; Jump if only F10
@


2.41
log
@Added switcher un-used rawkey handling code
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.40 1995/02/16 20:33:24 Kell Exp pfrench $
d10 3
d2341 4
d2428 3
d2943 1
a2943 1
	DC.l	FSAutomatic		; 3C Addendum 7/30/90:
@


2.40
log
@Now does a UpdateDisplay when re-entering the Switcher via HotKey.
@
text
@d5 1
a5 1
* Confidental and Proprietary. All rights reserved. 
d7 1
a7 1
* $Id: mbdispatch.a,v 2.39 1994/12/30 20:13:58 Kell Exp Kell $
d10 3
d160 2
d221 1
a221 1
	
d642 1
a642 1
	CALLTL	AllInterruptsOff	;SKELL 9/11/92	
d667 1
a667 1
	CALLTL	AllInterruptsOn	;SKELL 9/11/92	
d698 1
a698 1
	CALLTL	AllInterruptsOff	;SKELL 9/11/92	
d716 1
a716 1
	CALLTL	AllInterruptsOn	;SKELL 9/11/92	
d1049 5
a1053 1
	rts				; does nothing....
d1327 63
a1389 45
*---	Support special characters to the Numeric FG.

NumFGDirectRKH0:
	PUT.w	#0,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH1:
	PUT.w	#1,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH2:
	PUT.w	#2,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH3:
	PUT.w	#3,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH4:
	PUT.w	#4,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH5:
	PUT.w	#5,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH6:
	PUT.w	#6,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH7:
	PUT.w	#7,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH8:
	PUT.w	#8,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKH9:
	PUT.w	#9,TB_KeyCode
	bra.s	NumFGDirectRKH

NumFGDirectRKHBS:
	PUT.w	#10,TB_KeyCode
	bra.s	NumFGDirectRKH
a1390 12
NumFGDirectRKHEnter:
	GET.w	TB_QualCode,d0				; Addendum 8/9/90:
	move.w	d0,d1

; no longer	and.w	#IEQUALIFIER_LALT+IEQUALIFIER_RALT,d1	; now a special case
; use keyboard	bne	FSDeleteEntry				; for ALT+ENTER

*	Addendum 8/28/90: special case for AMIGA+ENTER

	and.w	#IEQUALIFIER_LCOMMAND+IEQUALIFIER_RCOMMAND,d0
	bne	FSRenameEntry

d1635 1
a1635 1
	
d2885 1
a2885 1
	DC.l	NumFGDirectRKH0		; 0F
d2900 3
a2902 3
	DC.l	NumFGDirectRKH1		; 1D
	DC.l	NumFGDirectRKH2		; 1E
	DC.l	NumFGDirectRKH3		; 1F
d2917 3
a2919 3
	DC.l	NumFGDirectRKH4		; 2D
	DC.l	NumFGDirectRKH5		; 2E
	DC.l	NumFGDirectRKH6		; 2F
d2934 3
a2936 3
	DC.l	NumFGDirectRKH7		; 3D
	DC.l	NumFGDirectRKH8		; 3E
	DC.l	NumFGDirectRKH9		; 3F
d2939 1
a2939 1
	DC.l	NumFGDirectRKHBS	; 41
d2950 2
a2951 2
	DC.l	ClipDownRKH		; 4C Addendum 11/24/91:
	DC.l	ClipUpRKH		; 4D Addendum 11/24/91:
@


2.39
log
@Support of TOGGLE_BIT for enabling/disabling some serial debug prints.
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.38 1994/12/29 11:27:59 Kell Exp Kell $
d10 3
d161 1
d308 2
d349 5
d358 1
d362 2
d370 3
d375 2
d379 3
@


2.38
log
@Quit Hot key will only tell editor to quit if it is loaded.  Then it will wait for editor to quit before quiting switcher.
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.37 1994/12/14 16:07:49 pfrench Exp Kell $
d10 3
d1027 5
d1061 5
d2918 1
a2918 1
	DC.l	MainRowRKH		; 50
d2935 1
a2935 1
	DC.l	SpecialExitRKH0		; 59 Addendum 10/10/90: exit/config
@


2.37
log
@Now handles towb flag bit to change to/from the switcher
screen.  This prevents race conditions with the input
handler, making it much more stable.
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.36 1994/09/14 00:16:56 Kell Exp pfrench $
d10 5
d155 1
a155 1
;SERDEBUG	SET	1
d209 2
d214 2
d221 1
d223 1
d1606 4
a1609 2

	XJSR	SendProjectEditQuitMessage
d1611 2
@


2.36
log
@Removed numpad "ENTER" key handler.  Now uses Editor code for quick access
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.35 1994/09/02 08:33:19 Kell Exp Kell $
d10 3
d150 1
a150 1
;;SERDEBUG	SET	1
d275 1
a275 1
	beq.s	.NoSwitch		; ...if no switch needed
d280 48
a327 3
;; Bug 3.0 Crash	CALLROM	OpenWorkBench		; check to make sure WB to goto
	move.l	d0,d0
	beq.s	.Continue		; if WB didn't open
d330 1
d366 3
d372 1
@


2.35
log
@Now checking for repeated keys, vs old DisableKeyRepeat prefs calls.
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.34 1994/07/27 19:28:06 Kell Exp Kell $
d10 3
d2823 1
a2823 1
	DC.l	NumFGDirectRKHEnter	; 43
@


2.34
log
@*** empty log message ***
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.33 1994/07/01 12:53:27 Kell Exp Kell $
d10 3
d409 3
@


2.33
log
@Killed CloseCode routine.  It wasn't used anywhere.
@
text
@d7 1
a7 1
* $Id: mbdispatch.a,v 2.32 94/03/13 08:07:25 Kell Exp Locker: Kell $
d9 4
a12 1
* $Log:	mbdispatch.a,v $
@


2.32
log
@Ctrl-Alt-F10 now can dump the Editor also.  F8 can load the editor.
@
text
@Binary files mbdispatch.a and t:,RCSt1A70bd868 differ
@


2.31
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A70c3330 differ
@


2.30
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A70b8c08 differ
@


2.29
log
@Various changes to support the new 4.0 croutons & projects.
@
text
@Binary files mbdispatch.a and t:,RCSt1A70b8c08 differ
@


2.28
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A70c35c0 differ
@


2.27
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A70bbdb0 differ
@


2.26
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A70bcb28 differ
@


2.25
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A78b9e60 differ
@


2.24
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A70a9df0 differ
@


2.23
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A78afc50 differ
@


2.22
log
@New keyboard cmd for entering Hardware Setup screen.
@
text
@Binary files MBDispatch.a and t:,RCSt1A70a26a8 differ
@


2.21
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A78b0150 differ
@


2.20
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A70a2078 differ
@


2.19
log
@Added SHIFT-F10 keyboard short cut for Adjust slice.
@
text
@Binary files mbdispatch.a and t:,RCSt1A70a2078 differ
@


2.18
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A78b0280 differ
@


2.17
log
@Added Toggle for Effects name
@
text
@Binary files mbdispatch.a and t:,RCSt1A78b0168 differ
@


2.16
log
@*** empty log message ***
@
text
@Binary files MBDispatch.a and t:,RCSt1A70b19c0 differ
@


2.15
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A70b19c0 differ
@


2.14
log
@Added key eq for new grids
@
text
@Binary files mbdispatch.a and t:,RCSt1A7740530 differ
@


2.13
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A7740530 differ
@


2.12
log
@Removed Popup from Requeseters, and added Rename.
@
text
@Binary files MBDispatch.a and t:,RCSt1A704a9d0 differ
@


2.11
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A70b1e48 differ
@


2.10
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A70bb828 differ
@


2.9
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A70cad68 differ
@


2.8
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A74bb670 differ
@


2.7
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A74baa28 differ
@


2.6
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A74bb900 differ
@


2.5
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A74bb7a0 differ
@


2.4
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A74bb7a0 differ
@


2.3
log
@Changes for new Grids
@
text
@Binary files MBDispatch.a and t:,RCSt1A74c8260 differ
@


2.2
log
@Added IDCMP flag MOUSEUP
@
text
@Binary files MBDispatch.a and t:,RCSt1A78bbda0 differ
@


2.1
log
@Replaced Disable & Enable Calls.
@
text
@Binary files mbdispatch.a and t:,RCSt1A02a0358 differ
@


2.0
log
@*** empty log message ***
@
text
@Binary files mbdispatch.a and t:,RCSt1A031c9b8 differ
@
