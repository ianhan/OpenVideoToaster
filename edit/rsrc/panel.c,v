head	2.147;
access;
symbols;
locks; strict;
comment	@*@;


2.147
date	97.04.01.10.44.07;	author Holt;	state Exp;
branches;
next	2.146;

2.146
date	96.11.21.13.34.53;	author Holt;	state Exp;
branches;
next	2.145;

2.145
date	96.11.18.18.40.35;	author Holt;	state Exp;
branches;
next	2.144;

2.144
date	96.07.29.10.29.31;	author Holt;	state Exp;
branches;
next	2.143;

2.143
date	95.12.26.18.19.59;	author Holt;	state Exp;
branches;
next	2.142;

2.142
date	95.10.28.02.02.12;	author Flick;	state Exp;
branches;
next	2.141;

2.141
date	95.10.17.16.59.57;	author Flick;	state Exp;
branches;
next	2.140;

2.140
date	95.10.12.16.37.18;	author Flick;	state Exp;
branches;
next	2.139;

2.139
date	95.10.09.23.31.04;	author Flick;	state Exp;
branches;
next	2.138;

2.138
date	95.10.09.16.37.59;	author Flick;	state Exp;
branches;
next	2.137;

2.137
date	95.10.06.18.50.52;	author Flick;	state Exp;
branches;
next	2.136;

2.136
date	95.10.05.18.46.03;	author Flick;	state Exp;
branches;
next	2.135;

2.135
date	95.10.05.03.48.03;	author Flick;	state Exp;
branches;
next	2.134;

2.134
date	95.10.03.18.10.46;	author Flick;	state Exp;
branches;
next	2.133;

2.133
date	95.10.02.15.47.29;	author Flick;	state Exp;
branches;
next	2.132;

2.132
date	95.09.28.10.15.07;	author Flick;	state Exp;
branches;
next	2.131;

2.131
date	95.09.25.13.42.57;	author Flick;	state Exp;
branches;
next	2.130;

2.130
date	95.09.19.12.35.19;	author Flick;	state Exp;
branches;
next	2.129;

2.129
date	95.09.13.12.33.09;	author Flick;	state Exp;
branches;
next	2.128;

2.128
date	95.08.18.17.01.29;	author Flick;	state Exp;
branches;
next	2.127;

2.127
date	95.08.16.10.57.32;	author Flick;	state Exp;
branches;
next	2.126;

2.126
date	95.08.09.17.57.22;	author Flick;	state Exp;
branches;
next	2.125;

2.125
date	95.07.27.18.11.03;	author Flick;	state Exp;
branches;
next	2.124;

2.124
date	95.07.14.16.03.41;	author Flick;	state Exp;
branches;
next	2.123;

2.123
date	95.07.13.13.04.19;	author Flick;	state Exp;
branches;
next	2.122;

2.122
date	95.06.20.23.31.37;	author Flick;	state Exp;
branches;
next	2.121;

2.121
date	95.06.15.12.37.17;	author Flick;	state Exp;
branches;
next	2.120;

2.120
date	95.06.13.18.44.07;	author Flick;	state Exp;
branches;
next	2.119;

2.119
date	95.04.28.13.32.00;	author Flick;	state Exp;
branches;
next	2.118;

2.118
date	95.04.28.12.07.10;	author Flick;	state Exp;
branches;
next	2.117;

2.117
date	95.04.25.15.09.29;	author Flick;	state Exp;
branches;
next	2.116;

2.116
date	95.04.24.16.28.03;	author Flick;	state Exp;
branches;
next	2.115;

2.115
date	95.04.19.08.19.37;	author pfrench;	state Exp;
branches;
next	2.114;

2.114
date	95.04.18.19.44.59;	author pfrench;	state Exp;
branches;
next	2.113;

2.113
date	95.03.16.14.37.16;	author CACHELIN4000;	state Exp;
branches;
next	2.112;

2.112
date	95.03.10.18.37.58;	author CACHELIN4000;	state Exp;
branches;
next	2.111;

2.111
date	95.03.09.18.05.18;	author CACHELIN4000;	state Exp;
branches;
next	2.110;

2.110
date	95.03.09.10.19.01;	author CACHELIN4000;	state Exp;
branches;
next	2.109;

2.109
date	95.03.07.16.08.17;	author CACHELIN4000;	state Exp;
branches;
next	2.108;

2.108
date	95.03.03.11.45.55;	author CACHELIN4000;	state Exp;
branches;
next	2.107;

2.107
date	95.02.28.19.20.29;	author CACHELIN4000;	state Exp;
branches;
next	2.106;

2.106
date	95.02.27.13.41.57;	author CACHELIN4000;	state Exp;
branches;
next	2.105;

2.105
date	95.02.26.14.20.52;	author CACHELIN4000;	state Exp;
branches;
next	2.104;

2.104
date	95.02.24.11.13.07;	author CACHELIN4000;	state Exp;
branches;
next	2.103;

2.103
date	95.02.22.10.16.51;	author CACHELIN4000;	state Exp;
branches;
next	2.102;

2.102
date	95.02.20.12.32.25;	author CACHELIN4000;	state Exp;
branches;
next	2.101;

2.101
date	95.02.19.16.57.40;	author CACHELIN4000;	state Exp;
branches;
next	2.100;

2.100
date	95.02.19.01.49.58;	author CACHELIN4000;	state Exp;
branches;
next	2.99;

2.99
date	95.02.13.14.37.47;	author CACHELIN4000;	state Exp;
branches;
next	2.98;

2.98
date	95.02.11.17.53.39;	author CACHELIN4000;	state Exp;
branches;
next	2.97;

2.97
date	95.02.03.12.46.46;	author pfrench;	state Exp;
branches;
next	2.96;

2.96
date	95.02.01.17.53.39;	author CACHELIN4000;	state Exp;
branches;
next	2.95;

2.95
date	95.01.25.18.36.38;	author CACHELIN4000;	state Exp;
branches;
next	2.94;

2.94
date	95.01.24.18.06.37;	author CACHELIN4000;	state Exp;
branches;
next	2.93;

2.93
date	95.01.24.16.50.57;	author CACHELIN4000;	state Exp;
branches;
next	2.92;

2.92
date	95.01.24.11.20.21;	author CACHELIN4000;	state Exp;
branches;
next	2.91;

2.91
date	95.01.13.12.56.59;	author CACHELIN4000;	state Exp;
branches;
next	2.90;

2.90
date	94.12.31.02.11.29;	author CACHELIN4000;	state Exp;
branches;
next	2.89;

2.89
date	94.12.28.17.38.30;	author CACHELIN4000;	state Exp;
branches;
next	2.88;

2.88
date	94.12.24.12.42.26;	author CACHELIN4000;	state Exp;
branches;
next	2.87;

2.87
date	94.12.23.16.12.53;	author CACHELIN4000;	state Exp;
branches;
next	2.86;

2.86
date	94.12.23.11.38.44;	author CACHELIN4000;	state Exp;
branches;
next	2.85;

2.85
date	94.12.22.20.48.27;	author CACHELIN4000;	state Exp;
branches;
next	2.84;

2.84
date	94.12.07.00.13.12;	author CACHELIN4000;	state Exp;
branches;
next	2.83;

2.83
date	94.12.05.20.05.59;	author CACHELIN4000;	state Exp;
branches;
next	2.82;

2.82
date	94.12.05.19.24.24;	author CACHELIN4000;	state Exp;
branches;
next	2.81;

2.81
date	94.12.04.22.57.03;	author CACHELIN4000;	state Exp;
branches;
next	2.80;

2.80
date	94.12.03.18.34.56;	author CACHELIN4000;	state Exp;
branches;
next	2.79;

2.79
date	94.11.30.23.24.43;	author CACHELIN4000;	state Exp;
branches;
next	2.78;

2.78
date	94.11.30.11.24.23;	author CACHELIN4000;	state Exp;
branches;
next	2.77;

2.77
date	94.11.18.16.53.19;	author CACHELIN4000;	state Exp;
branches;
next	2.76;

2.76
date	94.11.04.16.54.02;	author CACHELIN4000;	state Exp;
branches;
next	2.75;

2.75
date	94.11.04.00.29.53;	author CACHELIN4000;	state Exp;
branches;
next	2.74;

2.74
date	94.11.03.23.02.42;	author CACHELIN4000;	state Exp;
branches;
next	2.73;

2.73
date	94.11.02.20.21.55;	author CACHELIN4000;	state Exp;
branches;
next	2.72;

2.72
date	94.10.31.17.08.37;	author CACHELIN4000;	state Exp;
branches;
next	2.71;

2.71
date	94.10.27.23.16.07;	author CACHELIN4000;	state Exp;
branches;
next	2.70;

2.70
date	94.10.25.18.09.51;	author CACHELIN4000;	state Exp;
branches;
next	2.69;

2.69
date	94.10.24.17.11.52;	author CACHELIN4000;	state Exp;
branches;
next	2.68;

2.68
date	94.10.24.12.20.51;	author CACHELIN4000;	state Exp;
branches;
next	2.67;

2.67
date	94.10.20.11.56.02;	author CACHELIN4000;	state Exp;
branches;
next	2.66;

2.66
date	94.10.12.20.41.32;	author CACHELIN4000;	state Exp;
branches;
next	2.65;

2.65
date	94.10.12.17.37.36;	author CACHELIN4000;	state Exp;
branches;
next	2.64;

2.64
date	94.10.11.21.38.52;	author CACHELIN4000;	state Exp;
branches;
next	2.63;

2.63
date	94.10.10.17.18.20;	author CACHELIN4000;	state Exp;
branches;
next	2.62;

2.62
date	94.10.07.11.39.24;	author CACHELIN4000;	state Exp;
branches;
next	2.61;

2.61
date	94.10.06.23.04.11;	author CACHELIN4000;	state Exp;
branches;
next	2.60;

2.60
date	94.10.06.23.01.33;	author CACHELIN4000;	state Exp;
branches;
next	2.59;

2.59
date	94.10.06.10.47.02;	author CACHELIN4000;	state Exp;
branches;
next	2.58;

2.58
date	94.10.05.16.27.45;	author CACHELIN4000;	state Exp;
branches;
next	2.57;

2.57
date	94.10.05.01.04.36;	author CACHELIN4000;	state Exp;
branches;
next	2.56;

2.56
date	94.10.04.17.52.55;	author CACHELIN4000;	state Exp;
branches;
next	2.55;

2.55
date	94.10.03.18.47.44;	author CACHELIN4000;	state Exp;
branches;
next	2.54;

2.54
date	94.10.02.00.30.17;	author CACHELIN4000;	state Exp;
branches;
next	2.53;

2.53
date	94.10.02.00.02.42;	author CACHELIN4000;	state Exp;
branches;
next	2.52;

2.52
date	94.10.01.01.06.10;	author Kell;	state Exp;
branches;
next	2.51;

2.51
date	94.09.30.21.56.28;	author CACHELIN4000;	state Exp;
branches;
next	2.50;

2.50
date	94.09.30.11.29.41;	author CACHELIN4000;	state Exp;
branches;
next	2.49;

2.49
date	94.09.29.23.47.14;	author CACHELIN4000;	state Exp;
branches;
next	2.48;

2.48
date	94.09.29.16.28.18;	author CACHELIN4000;	state Exp;
branches;
next	2.47;

2.47
date	94.09.29.15.52.14;	author CACHELIN4000;	state Exp;
branches;
next	2.46;

2.46
date	94.09.29.12.20.30;	author CACHELIN4000;	state Exp;
branches;
next	2.45;

2.45
date	94.09.28.18.17.29;	author CACHELIN4000;	state Exp;
branches;
next	2.44;

2.44
date	94.09.28.14.47.29;	author CACHELIN4000;	state Exp;
branches;
next	2.43;

2.43
date	94.09.28.00.02.01;	author CACHELIN4000;	state Exp;
branches;
next	2.42;

2.42
date	94.09.27.17.22.10;	author CACHELIN4000;	state Exp;
branches;
next	2.41;

2.41
date	94.09.24.15.12.19;	author CACHELIN4000;	state Exp;
branches;
next	2.40;

2.40
date	94.09.23.10.33.53;	author CACHELIN4000;	state Exp;
branches;
next	2.39;

2.39
date	94.09.20.23.39.48;	author CACHELIN4000;	state Exp;
branches;
next	2.38;

2.38
date	94.09.13.20.16.48;	author CACHELIN4000;	state Exp;
branches;
next	2.37;

2.37
date	94.09.12.18.52.12;	author CACHELIN4000;	state Exp;
branches;
next	2.36;

2.36
date	94.09.12.13.03.05;	author CACHELIN4000;	state Exp;
branches;
next	2.35;

2.35
date	94.09.10.20.10.39;	author CACHELIN4000;	state Exp;
branches;
next	2.34;

2.34
date	94.09.09.20.49.39;	author CACHELIN4000;	state Exp;
branches;
next	2.33;

2.33
date	94.09.09.19.59.34;	author CACHELIN4000;	state Exp;
branches;
next	2.32;

2.32
date	94.09.09.13.46.38;	author CACHELIN4000;	state Exp;
branches;
next	2.31;

2.31
date	94.09.06.22.26.50;	author CACHELIN4000;	state Exp;
branches;
next	2.30;

2.30
date	94.09.05.19.06.38;	author CACHELIN4000;	state Exp;
branches;
next	2.29;

2.29
date	94.09.04.17.52.56;	author CACHELIN4000;	state Exp;
branches;
next	2.28;

2.28
date	94.09.03.17.50.23;	author CACHELIN4000;	state Exp;
branches;
next	2.27;

2.27
date	94.09.02.20.17.18;	author CACHELIN4000;	state Exp;
branches;
next	2.26;

2.26
date	94.09.02.14.51.10;	author CACHELIN4000;	state Exp;
branches;
next	2.25;

2.25
date	94.09.02.08.25.34;	author Kell;	state Exp;
branches;
next	2.24;

2.24
date	94.09.01.21.14.12;	author CACHELIN4000;	state Exp;
branches;
next	2.23;

2.23
date	94.09.01.20.45.18;	author CACHELIN4000;	state Exp;
branches;
next	2.22;

2.22
date	94.09.01.18.27.58;	author Kell;	state Exp;
branches;
next	2.21;

2.21
date	94.09.01.15.06.31;	author CACHELIN4000;	state Exp;
branches;
next	2.20;

2.20
date	94.08.31.23.07.21;	author Kell;	state Exp;
branches;
next	2.19;

2.19
date	94.08.31.21.25.40;	author CACHELIN4000;	state Exp;
branches;
next	2.18;

2.18
date	94.08.31.18.10.02;	author CACHELIN4000;	state Exp;
branches;
next	2.17;

2.17
date	94.08.30.17.30.31;	author CACHELIN4000;	state Exp;
branches;
next	2.16;

2.16
date	94.08.30.10.44.37;	author Kell;	state Exp;
branches;
next	2.15;

2.15
date	94.08.30.09.45.06;	author CACHELIN4000;	state Exp;
branches;
next	2.14;

2.14
date	94.08.27.16.41.14;	author CACHELIN4000;	state Exp;
branches;
next	2.13;

2.13
date	94.08.24.12.06.31;	author CACHELIN4000;	state Exp;
branches;
next	2.12;

2.12
date	94.07.27.20.47.52;	author CACHELIN4000;	state Exp;
branches;
next	2.11;

2.11
date	94.07.22.11.41.18;	author CACHELIN4000;	state Exp;
branches;
next	2.10;

2.10
date	94.07.11.17.58.46;	author CACHELIN4000;	state Exp;
branches;
next	2.9;

2.9
date	94.07.06.22.35.58;	author CACHELIN4000;	state Exp;
branches;
next	2.8;

2.8
date	94.07.06.21.49.52;	author CACHELIN4000;	state Exp;
branches;
next	2.7;

2.7
date	94.07.04.18.34.12;	author CACHELIN4000;	state Exp;
branches;
next	2.6;

2.6
date	94.06.22.10.45.00;	author CACHELIN4000;	state Exp;
branches;
next	2.5;

2.5
date	94.06.08.16.17.55;	author CACHELIN4000;	state Exp;
branches;
next	2.4;

2.4
date	94.06.07.10.16.41;	author CACHELIN4000;	state Exp;
branches;
next	2.3;

2.3
date	94.04.26.13.50.54;	author CACHELIN4000;	state Exp;
branches;
next	2.2;

2.2
date	94.04.25.12.36.30;	author CACHELIN4000;	state Exp;
branches;
next	2.1;

2.1
date	94.04.23.17.44.23;	author CACHELIN4000;	state Exp;
branches;
next	2.0;

2.0
date	94.04.20.17.31.57;	author CACHELIN4000;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.147
log
@commeted out 5.0code for 4.2
@
text
@/* $Id: panel.c,v 2.146 1996/11/21 13:34:53 Holt Exp Holt $
* $Log: panel.c,v $
*Revision 2.146  1996/11/21  13:34:53  Holt
*fixed problem with keys not draging in time. hardcoded action in keyadjust.
*
*Revision 2.145  1996/11/18  18:40:35  Holt
*added code to validate keys after in/out points are moved.
*
*Revision 2.144  1996/07/29  10:29:31  Holt
*added part of the audioenv panel.
*
*Revision 2.143  1995/12/26  18:19:59  Holt
*changed several fixtimestr calls to get back cframe aligned times
*
*Revision 2.142  1995/10/28  02:02:12  Flick
*No longer clear PlayFG when entering FlyPanel, added misc INTUITICKS debugging
*
*Revision 2.141  1995/10/17  16:59:57  Flick
*Left/Right arrow keys not timeout and go quiet, up/down keys cleaned up lots, go quiet
*work on single sliders now, too.  "Cutting clip..." reads "Processing clips" for non-destr.
*
*Revision 2.140  1995/10/12  16:37:18  Flick
*FlyPanel/RAWKEY_LEFT&RIGHT would only Flyer jog if PL_DUAL (changed to PL_FLYER)
*
*Revision 2.139  1995/10/09  23:31:04  Flick
*Fixed quick adjust shadow math (always positive!)
*
*Revision 2.138  1995/10/09  16:37:59  Flick
*Removed unnecessary usage of popup.h
*
*Revision 2.137  1995/10/06  18:50:52  Flick
*LiveFlyer changed to DualFlyer to allow FlyPanel to shuttle on single sliders too
*
*Revision 2.136  1995/10/05  18:46:03  Flick
*Record panel now uses all new Flyer_ functions (no more ES!)
*Now warns instead of crashing when proc/cutting non-existent clip in project
*Fixed bug with skipping "cut?" requester in cutting room
*
*Revision 2.135  1995/10/05  03:48:03  Flick
*Fixed bad quick tune + shadow bug on outpoint (miscomputed min value -- would fall of the Earth)
*Quick tune shadow feature would refuse to work with audio-only and video-only clips -- fixed
*Cut/proc panels right arrow key would cause hit after clicking on new sub-clip in bar
*Removed unused Qual[] array of video qualities, //'d lots of extra debugging to reduce data size
*
*Revision 2.134  1995/10/03  18:10:46  Flick
*Quick adjust now uses TCDarkFont (removed RectFill's)
*ReOrg from drive info panel now exits panel when donw
*Made 2 versions of verif.req. on starting clip cutting (based on raw or existing clip)
*Raw clip warning skipped if disabled in prefs
*
*Revision 2.133  1995/10/02  15:47:29  Flick
*Cutting room panel: doesn't put up "destroys original" req if came from rec panel
*If user cancels this req, cleans up properly now and drops back into cutting panel.
*Added Dest Drive popup in processing panel.
*Quick tune now support shadow function, hotkeys shuffled around again, uses beveled hilite
*box now, ready to use new TCDarkFont (when fixed), added arrow keys (???)
*
*Revision 2.132  1995/09/28  10:15:07  Flick
*Now uses RawKeyCodes.h, cutting/proc panels now work correctly within subdirs, subclip name
*string was being activated too early on panel open, looks better now, quick tune panel now
*supports arrow keys and ganging points together w/ SPACE bar, fixed deadlock when releasing
*ALT while jogging.
*
*Revision 2.131  1995/09/25  13:42:57  Flick
*Added Dropped line to RawRec panel, added Quick tune panel & support fn's
*Cutting/Proc panels: fixed drive name bug, activates name string when new name built
*
*Revision 2.130  1995/09/19  12:35:19  Flick
*Changed panels to use less hard-coded buttons (i.e. Continue/Cancel), moved almost all to
*GenButtons that can have custom options (like, uh, text label!)
*
*Revision 2.129  1995/09/13  12:33:09  Flick
*Ancillary functions moved to new PanelHelp.c to reduce code bulge
*Added 3-color audio meters with clip and peak hold.  Support for Switcher fix
*on ES_Jump by adding DHD_Jump "quiet" option.
*Lots of new stuff for CutClipPanel: new calling args to be used both destr. and
*non-destructively, support "include" popup, verification requester on "continue"
*for destructive version, lots of fixes on icon slider, new logic when adding a
*new clip (fills all space, Left/Right ALT options).
*
*Revision 2.128  1995/08/18  17:01:29  Flick
*Lotsa changes to FlyPanel: left/right arrow keys would break if you touched any
*other gadgets except for duoslide stuff.  They now also stop a play if in prog.
*Duoslider knob would "miss" the first grab after playing clip
*In/Out point strings work much better -- (used to clobber wrong points, or
*could not be highlighted, or would lose tag values on exit: unless you were
*nice and hit RETURN after making changed)
*
*Revision 2.127  1995/08/16  10:57:32  Flick
*Added support for SHADOW function
*Fixed some knob trashing on "remove" in cutting panels, fixed 'S' still function
*Added duplicate name test before cutting clips (now may re-enter panel to fix)
*
*Revision 2.126  1995/08/09  17:57:22  Flick
*Reworked CutClipPanel, make it use a shared structure to make it easier to add
*features to such as: N & P hotkeys to navigate thru subclips
*Fixed bugs where knobs trashed each other for subclips
*Selected subclip is now always rendered last, so it's fully visible
*
*Revision 2.125  1995/07/27  18:11:03  Flick
*Added support for DELETE button in markclips/clip proc panels
*Fixed destr. cutting room to not reopen if partially cut/tossed original
*
*Revision 2.124  1995/07/14  16:03:41  Flick
*Fixed ReOrg on audio drives, removed spkr symbol from volname in requester
*
*Revision 2.123  1995/07/13  13:04:19  Flick
*More debugging to test DHD_CheckRecord use during play (not happening)
*
*Revision 2.122  1995/06/20  23:31:37  Flick
*Added "height" member to QualPL structure
*
*Revision 2.121  1995/06/15  12:37:17  Flick
*Icon creation will now succeed even if CutClipPanel gives bogus icon field
*
*Revision 2.120  1995/06/13  18:44:07  Flick
*Added error checking to cutting room/clip processing
*Will take you back to panel if problems occur
*
*Revision 2.119  1995/04/28  13:32:00  Flick
*Record raw clip pause button no longer hilites unless recording
*Record & Re-org buttons in record panel handle 0 Flyer drives correctly now
*
*Revision 2.118  1995/04/28  12:07:10  Flick
*Fixed long-standing record panel bug (if 1 Flyer drive)
*Cleaned up many other dangerous if/for/while instructions that had code
*  which was not protected by { }
*
*Revision 2.117  1995/04/25  15:09:29  Flick
*Reworked UpdateAudIndicator to make 2nd clip LED correct level, not be "sticky"
*Also improved response time of LED's and reduces pointer flashiness
*
*Revision 2.116  1995/04/24  16:28:03  Flick
*Fixed RenderSlide to handle field #'s above 64K (18 minutes)
*
*Revision 2.115  1995/04/19  08:19:37  pfrench
*Fixed Mungwall hit on close clip reqester via ENTER key
*
*Revision 2.114  1995/04/18  19:44:59  pfrench
*Non-working attempt at fixing enter on clip panel bug
*
*Revision 2.113  1995/03/16  14:37:16  CACHELIN4000
**** empty log message ***
*
*Revision 2.112  1995/03/10  18:37:58  CACHELIN4000
*Fix CrUD
*
*Revision 2.111  1995/03/09  18:05:18  CACHELIN4000
*Add tags to flyerstill cruds, limit crashiness of icon slider
*
*Revision 2.110  1995/03/09  10:19:01  CACHELIN4000
*Cutting roiom flyerstill support
*
*Revision 2.109  1995/03/07  16:08:17  CACHELIN4000
*Handle new DroppedFrames error, fix pause->record bug
*
*Revision 2.108  1995/03/03  11:45:55  CACHELIN4000
*Fix clip length rounding on cutting room, pause/stop/rec interaction, etc.
*
*Revision 2.107  1995/02/28  19:20:29  CACHELIN4000
*Fix logic bug in pause, gadget highlight, move clip indicator over
*
*Revision 2.106  1995/02/27  13:41:57  CACHELIN4000
*Change audio bargraph to indicators
*
*Revision 2.105  1995/02/26  14:20:52  CACHELIN4000
*Allow Stop, Rec to function while record is paused, fix FixTime() for len.s
*
*Revision 2.104  1995/02/24  11:13:07  CACHELIN4000
*Fix flags confusion on cutting room, etc.
*
*Revision 2.103  1995/02/22  10:16:51  CACHELIN4000
*Fix cutting room (i hope)!
*
*Revision 2.102  1995/02/20  12:32:25  CACHELIN4000
**** empty log message ***
*
*Revision 2.101  1995/02/19  16:57:40  CACHELIN4000
**** empty log message ***
*
*Revision 2.100  1995/02/19  01:49:58  CACHELIN4000
*Add Audio VUs, Cutting Room SMPTE trix
*
*Revision 2.99  1995/02/13  14:37:47  CACHELIN4000
**** empty log message ***
*
*Revision 2.98  1995/02/11  17:53:39  CACHELIN4000
*Add audio record level support functions, BarGraph struct
*
*Revision 2.97  1995/02/03  12:46:46  pfrench
*Removed direct serial debugging calls
*
*Revision 2.96  1995/02/01  17:53:39  CACHELIN4000
*Fix Pause, CuttingRoom Icons, Process Room
*
*Revision 2.95  1995/01/25  18:36:38  CACHELIN4000
*Add MOUSEMOVE support to MiniPanel()
*
*Revision 2.94  1995/01/24  18:06:37  CACHELIN4000
**** empty log message ***
*
*Revision 2.93  1995/01/24  16:50:57  CACHELIN4000
*Add Icon making for CuttingRoom
*
*Revision 2.92  1995/01/24  11:20:21  CACHELIN4000
*Cutting Room functions, panel support
*
*Revision 2.91  1995/01/13  12:56:59  CACHELIN4000
*Add support for PL_PARTNER to RCB functions,
*update available sizes after record, etc.
*
*Revision 2.90  1994/12/31  02:11:29  CACHELIN4000
**** empty log message ***
*
*Revision 2.89  1994/12/28  17:38:30  CACHELIN4000
*Keep Panels from opening above EditTop->TopEdge
*
*Revision 2.88  1994/12/24  12:42:26  CACHELIN4000
**** empty log message ***
*
*Revision 2.87  1994/12/23  16:12:53  CACHELIN4000
*turn off serial debug statements
*
*Revision 2.86  1994/12/23  11:38:44  CACHELIN4000
*Use PropEnd for string limits
*
*Revision 2.85  1994/12/22  20:48:27  CACHELIN4000
*Prevent video recording on audio drives
*
*Revision 2.84  1994/12/07  00:13:12  CACHELIN4000
*Audio drive name bug fixed, rec vavilable updates on drive/compression changes
*
*Revision 2.83  1994/12/05  20:05:59  CACHELIN4000
*Use global CurCompMode for retain compression settings
*
*Revision 2.82  1994/12/05  19:24:24  CACHELIN4000
*Quash verminous infestation in CutClipPanel(), add NO_CUTTINGROOM define
*I got a car today!! Ha Ha.  Paid $800 in sales tax though aieee!
*
*Revision 2.81  1994/12/04  22:57:03  CACHELIN4000
*Bring CurClipPanel into modern age, add SetHiLo()
*
*Revision 2.80  1994/12/03  18:34:56  CACHELIN4000
*Add QuickTune gadget, etc.
*
*Revision 2.79  1994/11/30  23:24:43  CACHELIN4000
* PL_SMREF)
*
*Revision 2.78  1994/11/30  11:24:23  CACHELIN4000
*Skip over Internal flyer sources 'til TBC stuff is ready
*
*Revision 2.77  1994/11/18  16:53:19  CACHELIN4000
*I don't remember what I changed...
*
*Revision 2.76  1994/11/04  16:54:02  CACHELIN4000
*PL_PLAY support
*
*Revision 2.75  94/11/04  00:29:53  CACHELIN4000
*Set InPL=AInPL, OutPL=AOutPL  on Audio only panel ==> Enforcer happy now
*
*Revision 2.74  94/11/03  23:02:42  CACHELIN4000
*Add flyer error messages to record panel, remove audio toggle handling trix
*
*Revision 2.73  94/11/02  20:21:55  CACHELIN4000
*Prevent recording of clips w/out audio or video
*
*Revision 2.72  94/10/31  17:08:37  CACHELIN4000
*Fix diff-update bug
*
*Revision 2.71  94/10/27  23:16:07  CACHELIN4000
*Set new PLine->Win in Panel() calls, change DrawPanel f'n to use PLine->Win
*
*Revision 2.70  94/10/25  18:09:51  CACHELIN4000
**** empty log message ***
*
*Revision 2.69  94/10/24  17:11:52  CACHELIN4000
*Add MiniPanel() for simplified non-flyer panel calls...
*
*Revision 2.68  94/10/24  12:20:51  CACHELIN4000
*Break non-DUAL flyer sliders... fix others
*
*Revision 2.67  94/10/20  11:56:02  CACHELIN4000
**** empty log message ***
*
*Revision 2.66  94/10/12  20:41:32  CACHELIN4000
**** empty log message ***
*
*Revision 2.65  94/10/12  17:37:36  CACHELIN4000
**** empty log message ***
*
*Revision 2.64  94/10/11  21:38:52  CACHELIN4000
*DuoSlide/PL_DUAL implementation
*
*Revision 2.63  94/10/10  17:18:20  CACHELIN4000
*Add record (SPACE) hotkey
*
*Revision 2.62  94/10/07  11:39:24  CACHELIN4000
*let EZgads go negative...
*
*Revision 2.61  94/10/06  23:04:11  CACHELIN4000
*Connect up audio shuttle real good.
*
*Revision 2.59  94/10/06  10:47:02  CACHELIN4000
*Audio control fixes...
*
*Revision 2.58  94/10/05  16:27:45  CACHELIN4000
*Fix Comment editing bug in Panel() (Param2 vs PropEnd for str max)
*
*Revision 2.57  94/10/05  01:04:36  CACHELIN4000
*Add PNL_DIFF add-on (G5) to UpdateDiff()
*
*Revision 2.56  94/10/04  17:52:55  CACHELIN4000
*Fix string/Popup bug on record panel
*
*Revision 2.55  94/10/03  18:47:44  CACHELIN4000
*Un-hilite REC before writing icon, Don't record if record button used to stop
*
*Revision 2.54  94/10/02  00:30:17  CACHELIN4000
**** empty log message ***
*
*Revision 2.53  94/10/02  00:02:42  CACHELIN4000
*fix PNL_SKIP type bug...
*
*Revision 2.52  94/10/01  01:06:10  Kell
*Now calls code to make a clip icon after record.
*
*Revision 2.51  1994/09/30  21:56:28  CACHELIN4000
**** empty log message ***
*
*Revision 2.50  94/09/30  11:29:41  CACHELIN4000
*Set Startup record source to 1 (camcorder in)
*
*Revision 2.49  94/09/29  23:47:14  CACHELIN4000
*Add NoticeWindow, WaitSprite to reorganize f'n
*
*Revision 2.48  94/09/29  16:28:18  CACHELIN4000
*
*Revision 2.44  94/09/28  14:47:29  CACHELIN4000
*Dummied out NewClip MarkClips button
*
*Revision 2.42  94/09/27  17:22:10  CACHELIN4000
*Record Panel work: Poll CheckRecord, guestimate recorded duration, use PL_LEN
*
*Revision 2.40  94/09/23  10:33:53  CACHELIN4000
*Record Panel, CutCLip Panel work, Audio controls
*
*Revision 2.39  94/09/20  23:39:48  CACHELIN4000
*PNL_SKIP support, etc.
*
*Revision 2.38  94/09/13  20:16:48  CACHELIN4000
*Fixes to CroutonString, RMB Shuttle, update strings without an <enter>
*
*Revision 2.37  94/09/12  18:52:12  CACHELIN4000
*DHD_Shuttle On Now...  other coolish fixes..
*
*Revision 2.36  94/09/12  13:03:05  CACHELIN4000
*Move all PLine member functions to PLine.c to allow compile/link to succeed
*
*Revision 2.35  94/09/10  20:10:39  CACHELIN4000
**** empty log message ***
*
*Revision 2.34  94/09/09  20:49:39  CACHELIN4000
**** empty log message ***
*
*Revision 2.32  94/09/09  13:46:38  CACHELIN4000
*Gurm
*
*Revision 2.31  94/09/06  22:26:50  CACHELIN4000
*PNL_CROUTON type enhancements
*
*Revision 2.30  94/09/05  19:06:38  CACHELIN4000
*ES_Jump support added { DHD_Jump() }
*
*Revision 2.27  94/09/02  20:17:18  CACHELIN4000
*MouseX, many fixes for DHD
*
*Revision 2.21  1994/09/01  15:06:31  CACHELIN4000
*fix hit
*
*Revision 2.20  94/08/31  23:07:21  Kell
*New debugs.  Some changes to just before the mousemove call to DHD_Jog.
*
*Revision 2.18  94/08/31  18:10:02  CACHELIN4000
*Flyer Control Work .. RCB
*
*Revision 2.17  94/08/30  17:30:31  CACHELIN4000
*Work on Flyer commands,
*Replace GadIndx hack with PLine->Flags kludge.
*
*Revision 2.16  94/08/30  10:44:37  Kell
*Changed SendSwitcherReply calls to work with new ESParams structures.
*Disabled some obsolete calls for record, shuttle etc.
*
*Revision 2.15  1994/08/30  09:45:06  CACHELIN4000
*Change ES_Messages to use ESparams struct
*
*Revision 2.14  94/08/27  16:41:14  CACHELIN4000
*reverse Continue, Cancel positions
*
*Revision 2.13  94/08/24  12:06:31  CACHELIN4000
*Add Audio Fine-tune to clip panel
*
*Revision 2.8  94/07/06  21:49:52  CACHELIN4000
*Record Panel tweaks, drop-frame fix
*
*Revision 2.6  94/06/22  10:45:00  CACHELIN4000
*Remove Control Panel data to Controls.c, left abstract panel code
*
*Revision 2.4  94/06/07  10:16:41  CACHELIN4000
*Complete rework...
*
*Revision 2.2  94/04/25  12:36:30  CACHELIN4000
*Comment out Audio Test code
*
*Revision 2.0  94/04/20  17:31:57  CACHELIN4000
*FirstCheckIn
*
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
*********************************************************************/

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/sghooks.h>
#include <graphics/gfxmacros.h>
#include <graphics/gfxbase.h>
#include <graphics/text.h>

#include <edit.h>
#include <stdio.h>
#include <string.h>
#include <dos.h>
#include <time.h>
#include <editwindow.h>
#include <project.h>
#include <gadgets.h>
#include <prophelp.h>
#include <grazer.h>
#include <editswit.h>
#include <crouton_all.h>
#include <request.h>
#include <tags.h>
#include <panel.h>
#include <flyer.h>
#include <RawKeyCodes.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
#include <proto/diskfont.h>

//#define SERDEBUG	1
#include <serialdebug.h>

#ifndef PROTO_PASS
#include <proto.h>
#else
#include "edit:proto/PanData.p"
#endif


//#define	CUT_ROOM_HELP	1

#define	AUDIO_BYTE	0xA2
#define CAF_AUDIO	CAF_AUDIOL|CAF_AUDIOR

#define RAW_REC 		RAWKEY_SPACE
#define RAW_IN 		RAWKEY_PAD_LPAREN		// num-pad '('
#define RAW_OUT 		RAWKEY_PAD_RPAREN		// num-pad ')'
#define RAW_DEL 		RAWKEY_PAD_ASTER		// num-pad '*'
#define RAW_LEN 		RAWKEY_PAD_SLASH		// num-pad '/'

extern VOID SoftSpriteOn(VOID);
extern VOID SoftSpriteOff(VOID);

extern struct Gadget StringGadg;
extern struct StringInfo StrInf;
extern struct BoolInfo BoolInf;
extern char strbuf[],strubuf[];
extern struct StringExtend TCExt;
extern int	CurGrid,CurRow,CurCol;
extern struct FastGadget *CurFG,*FirstFG,*PlayFG;
extern struct Screen *EditScreen;
extern struct Gadget Gadget1;
extern struct TextFont *DarkFont,*YellowFont,*TCFont,*TCDarkFont;
extern struct TextAttr TextAttr;
extern struct EditWindow *EditTop,*EditBottom;
extern struct TextExtent LastExtent;
extern char TempCh[],TempC2[],*DTNames[];
extern UBYTE *TempMem,*TempMem2;
extern struct TagItem nw_ti[2];
extern ULONG CRuDTypes[];
extern struct PanelLine *EasyPanelPL;
/* extern struct PanelLine *RawRecPL,*MarkClipPL; */
extern struct ESParams1 ESparams1;
extern struct ESParams2 ESparams2;
extern struct ESParams3 ESparams3;
extern struct ESParams4 ESparams4;
extern ULONG CurFlyDrive,CurFlySource,CurFlyTracks,CurCompMode;
extern UBYTE *FlyerDrives[],LClipping,RClipping;
extern struct Library *FlyerBase;
extern LONG FlyerDriveCount;
extern struct RenderCallBack *MyRCB;
extern struct EditPrefs UserPrefs;		// User preferences live here

extern __asm void MoveSoftSpriteABS( register __d0 ULONG X, register __d1 ULONG Y);

#define REC_FLAGS		SMART_REFRESH +BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED
#define STD_FLAGS		SIMPLE_REFRESH+BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED

struct ExtNewWindow ClipNW = {
	0,0,	/* window XY origin relative to TopLeft of screen */
	324,200,	/* window width and height */
	1,0,	/* detail and block pens */
	MOUSEBUTTONS+MOUSEMOVE+IDCMP_GADGETUP+IDCMP_GADGETDOWN+IDCMP_RAWKEY,	/* IDCMP flags */
	STD_FLAGS,
//	SMART_REFRESH+BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED,	/* other window flags */
	NULL,	/* first gadget in gadget list */
	NULL,	/* custom CHECKMARK imagery */
	NULL,	/* window title */
	NULL,	/* custom screen pointer */
	NULL,	/* custom bitmap */
	5,5,	/* minimum width and height */
	656,400,	/* maximum width and height */
	CUSTOMSCREEN,	/* destination screen type */
	&nw_ti[0]
};

struct PanelLine *CurPLine,*Start,*LastTime,*temp,*ALastTime,*GetsTicks;
struct Gadget *FirstG=0,*Down=0,*EZGad=NULL,*In=NULL,*Out=NULL,*Del=NULL,*Len=NULL,*LastString=NULL;
struct AEDKey	*GAEDNode;


LONG	ft,Adder;
ULONG	Ticks,WinFlags,GadInd,*LoTime=0,*HiTime=0,*ALoTime=0,*AHiTime=0,*SMPTime=0,smpte_base=0;
BOOL	Wide=FALSE,Playing=FALSE;


#define QUAL_NUM	6 		// number of entires in Qual array
#define DEF_QUALITY	0 	// default quality
//UBYTE	*Qual[] = {" D2 ","Beta SP"," Hi-8 ","S-VHS","VHS","Recognizable",""};
//Old struct for 4.0x
//struct PanelLine QualPL={ PNL_POPUP,PPOS_LEFT,"Video Quality",0,(LONG *)Qual,0,QUAL_NUM };
//New struct for 4.1
//struct PanelLine QualPL={ PNL_POPUP,PPOS_LEFT,"Video Quality",0,0,(LONG *)Qual,0,QUAL_NUM };
char pstr[100],*PatienceMsg[]={"Patience please...     ",pstr};
static char *DropErr[] = {"ERROR: Flyer dropped fields while recording.","Drive may be too slow for this quality mode."};
char ClipName[CLIP_PATH_MAX],ClipName2[CLIP_PATH_MAX],ClipPath[CLIP_PATH_MAX];
char	*AVparts[] = {"Video","Audio","Video+Audio",""};




ULONG __inline EZJump(ULONG t)
{
	return(t/EZ_DELAY);
}

//!!!*******************************************************************
// WARNING: This function once looked like MiniPanel below which in turn,
// once looked like an implemented design.  Let this function, with its peers,
// grow upon itself, and stand as an eternal admonition against software
// implementation with ill-defined requirements.  If you need to modify this
// crufty code, god help you. I can offer no defense, save the immortal plea
// of Adolph Eichmann  "I was just following orders".
//
// Returns FALSE if Cancel was selected
//#define MARKUP
UWORD __asm FlyPanel(REG(a0) struct EditWindow *Edit,REG(a1) struct PanelLine *PLine, REG(d0) UWORD XPMode)
{
	WORD H,ID,A,qual,X1,Y1,Lines=0;
	struct Gadget *ThisG=0;
//	struct Gadget *ContCan;
	struct Window *Window=0;
	struct RastPort *RP;
	struct PanelLine *InPL=NULL,*OutPL=NULL,*AInPL=NULL,*AOutPL=NULL,*PlayPL=NULL;
	BOOL Going = TRUE, DualFlyer = FALSE,LiveFlyer = FALSE, LoudFlyer = FALSE;
	UWORD Success = PAN_CANCEL;
	struct IntuiMessage *IntuiMsg;
	ULONG Y=0,d,*V,TilQuiet=0;
//	LONG F;

	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL;
	Len=NULL; LastString=NULL;
//	PlayFG=NULL;
	Wide=FALSE;
	SMPTime = &smpte_base;

	for(Start = PLine; PLine->Type && !Wide; PLine++ )
	{
		if ((PPOS_WIDER & PLine->Align) || (PPOS_HALF2 & PLine->Align))
			Wide=TRUE;
	}

	ClipNW.Flags = STD_FLAGS;			// Default window flags

	H = PNL_Y1;
	X1 = Y1 = 0;
	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine->Type != PNL_SKIP)
		{
			if (PPOS_HALF2 & PLine->Align)
				X1 = PNL_WIDTH;

			// Call the gadget's create function
//			DUMPUDECL("X=",X1," ");
//			DUMPUDECL("Y=",H,"\\");
			if(PLine->Create)		Y1=PLine->Create(X1,H,PLine,&ThisG);

			if(PPOS_WIDER & PLine->Align)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				if (Y>0)
				{
//					DUMPUDECL("Maxing ",Y," ");
//					DUMPUDECL("and ",Y1,"\\");
					H += MAX(Y,Y1);		// Don't forget left half
				}
				else
				{
//					DUMPUDECL("Adding ",Y1,"\\");
					H += Y1;					// Was no left half
				}
				X1 = 0;
				Y = 0;
			}

			if(PLine->Flags)
			{
				if(PLine->Flags & PL_FLYER)
					LiveFlyer = TRUE;

				if(PLine->Flags&PL_IN)
				{
					if(PLine->Flags&PL_AUDIO)
					{
						AInPL=PLine;
						if(!In) In=PLine->StrGadg;
						if(PLine->Flags&PL_DUAL)
						{
							AOutPL=PLine;
							if(!Out) Out=PLine->StrGadg->NextGadget;
						}
					}
					else
					{
						InPL=PLine;
						In=PLine->StrGadg;
						if(PLine->Flags&PL_DUAL)
						{
							OutPL=PLine;
							Out=PLine->StrGadg->NextGadget;
						}
					}
				}
				else if(PLine->Flags&PL_OUT)
				{
					if(PLine->Flags&PL_AUDIO)
					{
						AOutPL=PLine;
						if(!Out) Out=PLine->StrGadg;
					}
					else
					{
						OutPL=PLine;
						Out=PLine->StrGadg;
					}
				}
				else if(PLine->Flags&PL_DEL)
					Del=PLine->StrGadg;
				else if(PLine->Flags&PL_LEN)
					Len=PLine->StrGadg;
				else if(PLine->Flags&PL_PLAY)
					PlayPL=PLine;
				if(PLine->Flags&PL_SMREF)			// Somebody wants smart refresh
					ClipNW.Flags = REC_FLAGS;
			}
			if( AInPL && AOutPL )
			{
				DualFlyer = TRUE;
				LoudFlyer = TRUE;
				if( !InPL ) InPL=AInPL;
				if( !OutPL)  OutPL=AOutPL;
			}
			else if( InPL && OutPL)
				DualFlyer = TRUE;
			Lines++;
		}
	}

	if(X1>0) H += MAX(Y,Y1);  // last gad...

//	if(Wide) X1=PNL_WIDTH;
//	if(ContCan=CreateContCancel(X1,H,&ThisG,XPMode))
//		H += (UWORD)(PNL_YADD + ContCan->Height);
//	else goto ErrExit;

	ClipNW.Width = PNL_WIDTH + (Wide ? PNL_WIDTH:0);
	ClipNW.Height = H;
	ClipNW.Screen = EditScreen;
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = EditTop->Window->TopEdge; // MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
	ClipNW.FirstGadget = NULL;

	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);

	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		SoftSpriteOff();				// Shut off for the duration -- faster, and less flash

		RP = Window->RPort;
		ClipNW.Flags = STD_FLAGS;
		WinFlags=Window->IDCMPFlags;
		SetDrMd(RP,JAM2);
		AddGList(Window,FirstG,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		SetFont(RP,DarkFont);
//		RefreshGList(ContCan,Window,NULL,-1);
		H = PNL_Y1;

#ifdef MARKUP
			SetAPen(RP,PAL_BLACK);
			Move(RP,PNL_X1,0);
			Draw(RP,PNL_X1,H);
			Move(RP,PNL_WIDTH,0);
			Draw(RP,PNL_WIDTH,H);
			Move(RP,PNL_WIDTH-PNL_X1,0);
			Draw(RP,PNL_WIDTH-PNL_X1,H);
#endif

		PLine = Start;
		X1 = 0;
		Y = 0;
		while (PLine->Type)
		{
			if(PLine->Type != PNL_SKIP)
			{
//				DUMPSTR(" . ");

#ifdef MARKUP
				SetAPen(RP,PAL_BLACK);
				Move(RP,0,H);
				Draw(RP,PNL_X1,H);
				Move(RP,PNL_WIDTH,H);
				Draw(RP,PNL_WIDTH-PNL_X1,H);
#endif
				PLine->Win = Window;

				if (PPOS_HALF2 & PLine->Align)
					X1 = PNL_WIDTH;

				// Call the gadget's draw function
				if(PLine->Draw)	Y1=PLine->Draw(X1,H,PLine,Window);

				if(PPOS_WIDER & PLine->Align)
				{
					X1 = PNL_WIDTH;
					Y = Y1;
				}
				else
				{
					if (Y>0)
						H += MAX(Y,Y1);		// Don't forget left half
					else
						H += Y1;					// Was no left half
					X1 = 0;
					Y = 0;
				}
			}
			PLine++;
		}
//		DUMPMSG("Lines Drawn...");

		SoftSpriteOn();

		LastTime=NULL;
		if( DualFlyer )
		{
			LastTime=InPL;
			if(OutPL==InPL)
				HiTime = OutPL->Param2;		// if DUOSLIDE
			else
				HiTime = OutPL->Param;
			LoTime = &InPL->PropStart;
			SMPTime = &InPL->PropStart;
			MyRCB->Frame = (ULONG)(*InPL->Param - *SMPTime)<<1;
			MyRCB->Max = (*HiTime - *SMPTime)<<1;
			MyRCB->Min = (*LoTime - *SMPTime)<<1;
			MyRCB->FG = CurFG;
			MyRCB->win = Window;
			MyRCB->pline = LastTime;
			if( LoudFlyer )
			{
				LastTime= AInPL;
				AHiTime = AOutPL->Param2; // !!! ASSUME DUAL
				ALoTime = &AInPL->PropStart;
			}
		}

		// handle window events
		goto GetEm;
		while (Going)
		{
			WaitPort(Window->UserPort);
GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort))
			{
				switch(IntuiMsg->Class)
				{
				case IDCMP_GADGETDOWN:
//					DUMPMSG	("GADGETDOWN");
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					if(LastString && LastString!=ThisG)
//					if(LastString)
					{
//						DUMPSTR("LastString: ");
//						DUMPMSG(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
						if(PLine = (struct PanelLine *)LastString->UserData)
						{
//							DUMPHEXIL("LastPLine=",(LONG)PLine,"\\");
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								//Y=FixTimeStr(PLine,Window,FALSE);
								Y=FixTimeStr(PLine,Window,TRUE);
								if( (PLine->Flags&PL_FLYER) && !(PLine->Flags&PL_AUDIO) )
								{
									MyRCB->Frame = (ULONG)(Y- *SMPTime)<<1;
									MyRCB->Max = (*HiTime - *SMPTime)<<1;
									MyRCB->Min = (*LoTime - *SMPTime)<<1;
//									DUMPUDECL("Jumping1 to ",(LONG)MyRCB->Frame,"\\");
									DHD_JustJump(MyRCB);
								}
								else if((PLine->Flags&PL_AUDIO) && (PLine->Flags&PL_DUAL) )
								{
									MyRCB->Frame = (ULONG)(Y - *SMPTime)<<1;
									MyRCB->Max = (*AHiTime - *SMPTime)<<1;
									MyRCB->Min = (*ALoTime - *SMPTime)<<1;
//									DUMPUDECL("Jumping2 to ",(LONG)MyRCB->Frame,"\\");
									DHD_JustJump(MyRCB);
								}
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if (*PLine->Param>PLine->PropEnd)
									*PLine->Param=PLine->PropEnd;
								if (*PLine->Param<PLine->PropStart)
									*PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else if(LastString->GadgetID==STRING_ID)
							{
//								DUMPSTR("strncpy");
//								DUMPHEXIL("( ",(LONG)PLine->Param," , ");
//								DUMPSTR(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
//								DUMPUDECL(" , ",(LONG)PLine->PropEnd,")\\ ");
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->PropEnd);
							}
						}
						LastString=NULL;
					}
					if(!(PLine = (struct PanelLine *)ThisG->UserData)) break;
//					DUMPHEXIL("PLine=",(LONG)PLine,"\\");
					if(ID==STRING_ID)	LastString=ThisG;

					if( (PLine==InPL) || (PLine==OutPL) ||  (PLine==AInPL) || (PLine==AOutPL) )
					{
						LastTime=PLine;
						if(PlayPL && PlayFG)  // Must stop play to do Jog/Shuttle/Jump mode
						{
							DUMPMSG("GadgetDown: Abort Play");
//							PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) 0);
							if (PlayPL->Handle)
								PlayPL->Handle(PlayPL,0,Window);		// STOP!
//							break;
						}
					}

					if(PLine->Handle) PLine->Handle(PLine,IntuiMsg,Window);
					break;

				case IDCMP_GADGETUP:
//					DUMPMSG	("GADGETUP");

					if (Down) Down = NULL;
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;

					if(LastString && LastString!=ThisG)
					{
//						DUMPSTR("LastString: ");
//						DUMPMSG(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
						if(PLine = (struct PanelLine *)LastString->UserData)
						{
//							DUMPHEXIL("LastPLine=",(LONG)PLine,"\\");
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								//Y=FixTimeStr(PLine,Window,FALSE);
								Y=FixTimeStr(PLine,Window,TRUE);
								if( (PLine->Flags&PL_FLYER) && !(PLine->Flags&PL_AUDIO) )
								{
									MyRCB->Flags = DHD_STR_UPDATE;
									MyRCB->Frame = (ULONG)(Y- *SMPTime)<<1;
									MyRCB->Max = (*HiTime - *SMPTime)<<1;
									MyRCB->Min = (*LoTime - *SMPTime)<<1;
//									DUMPUDECL("Jumping3 to ",(LONG)MyRCB->Frame,"\\");
									DHD_JustJump(MyRCB);
									MyRCB->Flags = 0;
								}
								else if(PLine->Flags&PL_AUDIO)
								{
									MyRCB->Flags = DHD_STR_UPDATE;
									MyRCB->Frame = (ULONG)(Y - *SMPTime)<<1;
									MyRCB->Max = (*AHiTime - *SMPTime)<<1;
									MyRCB->Min = (*ALoTime - *SMPTime)<<1;
//									DUMPUDECL("Jumping4 to ",(LONG)MyRCB->Frame,"\\");
									DHD_JustJump(MyRCB);
									MyRCB->Flags = 0;
								}
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else if(LastString->GadgetID==STRING_ID)
							{
//								DUMPSTR("strncpy");
//								DUMPHEXIL("( ",(LONG)PLine->Param," , ");
//								DUMPSTR(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
//								DUMPUDECL(" , ",(LONG)PLine->PropEnd,")\\ ");
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->PropEnd);
							}
						}
						LastString=NULL;
					}

					PLine = (struct PanelLine *)ThisG->UserData;
					if(PLine && PLine->Handle)
					{
						// (STRING_ID handlers kill LastString here...)

						PLine->Handle(PLine,IntuiMsg,Window);

						DoGenButtons(PLine,Window,&Success,&Going);
					}
//					else switch (ID)
//					{
//						case ID_DARK_CONTINUE:
//							DUMPMSG	("CONTINUE");
//							Success = PAN_CONTINUE;
//						case ID_REQ_DARK_CANCEL:
//							Going = FALSE;			//Success was initialized to FALSE
//							break;
//						case ID_FINE_TUNE:
//							Going = FALSE;
//							Success = PAN_EXPERT;
//							break;
//						case ID_QUICK_TUNE:
//							Going = FALSE;
//							Success = PAN_EASY;
//							break;
//					}
					break;

				case IDCMP_INTUITICKS:
					DUMPMSG	("-tick-");

					if (TilQuiet>0)
					{
						if ((--TilQuiet)==0)
						{
							DHD_Quiet(Flds2Frms(MyRCB->Frame));
							ModifyIDCMP(Window,WinFlags);
						}
					}

					if (PLine = GetsTicks)
					{
						if (PLine->Handle)
						{
							PLine->Handle(PLine,IntuiMsg,Window);
							break;
						}
					}

					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						DUMPMSG	("No EZgad");
						ModifyIDCMP(Window,WinFlags);
						EZGad=NULL;
						break;
					}

					if( !(PLine=(struct PanelLine *)EZGad->UserData) )
					{
						DUMPMSG	("No UserData");
						break;
					}

//					if( DualFlyer && (PLine->Flags&PL_DUAL) )
					if( LiveFlyer && (PLine->Flags&PL_FLYER) )		// Allow on Flyer singles too
					{
						DUMPMSG("(maybe)");
						if(!EZJump(Ticks++)) break;  // skip ticks

						DUMPMSG("shuttle...");
						ModifyIDCMP(Window,WinFlags); // turn off ticks
						MyRCB->pline = PLine;
						if(PLine->Flags & PL_IN)
							MyRCB->Frame = (ULONG)(*PLine->Param - *SMPTime)<<1;
						else
							MyRCB->Frame = (ULONG)(*(PLine->Param2) - *SMPTime)<<1;

						// If shadowed, don't touch min/max, they have been done in SetHiLo()!
						if (!(PLine->Flags & PL_SHADOW))
						{
							if( (PLine->Flags&PL_FLYER) && !(PLine->Flags&PL_AUDIO) )
							{
								MyRCB->Max = (*HiTime - *SMPTime)<<1;
								MyRCB->Min = (*LoTime - *SMPTime)<<1;
							}
							else if(PLine->Flags&PL_AUDIO)
							{
								MyRCB->Max = (*AHiTime - *SMPTime)<<1;
								MyRCB->Min = (*ALoTime - *SMPTime)<<1;
							}
						}
						if(Adder>0)
							MyRCB->Flags = 0;
						else
							MyRCB->Flags = DHD_PLAY_REV;
						DHD_Shuttle(MyRCB);
						EZGad=NULL;
						UpdateAllDiff(RP,Start,Window);
					}
					else
					{
						// Handle ticks to EZ gadgets
						TickEZLenPL((struct PanelLine *)EZGad->UserData,Window,EZJump(Ticks++));

////					if( (F=*(PLine->Param)) || (Adder>0))
//						if( ((F=*(PLine->Param))>=PLine->PropStart) || (Adder>0))  // negative #s
//							F += Adder*EZJump(Ticks++);
//						else break;
//						if(Adder<0)
//							*(PLine->Param) = (F>=PLine->PropStart ? F:PLine->PropStart);
//						else
//							*(PLine->Param) = (F<=PLine->PropEnd ? F:PLine->PropEnd);
//						UpdatePanProp(PLine,Window);
//						UpdatePanStr(PLine,Window);
//						UpdateAllDiff(RP,Start,Window);
					}
					break;

				case IDCMP_MOUSEMOVE:
					if(Down)
					{
						PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,Window);
					}
					break;

				case IDCMP_MOUSEBUTTONS:
//					DUMPMSG	("MOUSEBUTTON");

					if(Down)
					{
						PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,Window);
					}

					if(!DualFlyer) break;
					A = IntuiMsg->Code;

					DUMPHEXIL("LastTime=",(LONG)LastTime,"\\");

#if FUNKY_RMB_SHUTTLE
					if( LastTime && (A==IECODE_RBUTTON))
					{
						if( LastTime->Flags&PL_FLYER )
						{
							MyRCB->Frame = (ULONG)(*LastTime->Param - *SMPTime)<<1;
							MyRCB->FG = CurFG;
							MyRCB->Max = (*HiTime - *SMPTime)<<1;
							MyRCB->Min = (*LoTime - *SMPTime)<<1;
							MyRCB->win = Window;
							MyRCB->pline = LastTime;
							if(IntuiMsg->MouseX>372) MyRCB->Flags = 0;
							else  MyRCB->Flags = DHD_PLAY_REV;
						}
						DHD_Shuttle(MyRCB);
					}
#endif

					if (Down) Down = NULL;

#if 0
					// Quiet audio on click nowhere
					if (LastTime && (A==IECODE_LBUTTON))
					{
						if (LastTime->Flags & PL_IN)
							DHD_Quiet(*LastTime->Param - *SMPTime);
						else
							DHD_Quiet(*LastTime->Param2 - *SMPTime);
					}
#endif
					break;


				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					if(A<0x80)
					{
						qual = IntuiMsg->Qualifier;
						DUMPHEXIB("Key Code: ",A,"\\");
						switch(A)
						{
							case	RAWKEY_SPACE:
							case	RAWKEY_TAB:
								if ((PlayPL) && (PlayPL->Handle))
								{
									if(PlayFG)
									{
										PlayPL->Handle(PlayPL,0,Window);		// Stop!
//										PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) 0);
									}
									else
									{
										PlayPL->Handle(PlayPL,(struct IntuiMessage *)1,Window);	// Start!
//										PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) CurFG);
									}
								}
								break;
							case	RAW_IN:
								if(InPL)
								{
									LastTime=InPL;
									if(OutPL==InPL) HiTime = (OutPL->Param2);
									else HiTime = OutPL->Param;
									LoTime = &InPL->PropStart;
								}
								else if(AInPL)
								{
									LastTime=AInPL;
									if(OutPL==InPL) HiTime = (AOutPL->Param2);
									else AHiTime = AOutPL->Param;
									ALoTime = &AInPL->PropStart;
								}
								if(In)	ActivateGadget(In,Window,NULL);
								break;
							case	RAW_OUT:
								if(OutPL)
								{
									LastTime=OutPL;
									LoTime = InPL->Param;
									HiTime = &OutPL->PropEnd;
								}
								else if(AOutPL)
								{
									LastTime=AOutPL;
									ALoTime = AInPL->Param;
									AHiTime = &AOutPL->PropEnd;
								}
								if(Out)	ActivateGadget(Out,Window,NULL);
								break;
							case	RAW_LEN:
								if(Len)	ActivateGadget(Len,Window,NULL);
								break;
							case	RAW_DEL:
								if(Del)	ActivateGadget(Del,Window,NULL);
								break;
							case	RAWKEY_LEFT:
								DUMPHEXIL("LastTime=",(LONG)LastTime,"\\");
								if(LastTime==NULL) break;

								if(PlayPL && PlayFG)  // Must stop play to do Jog/Shuttle/Jump mode
								{
//									DUMPMSG("Abort Play");
									if (PlayPL->Handle)
										PlayPL->Handle(PlayPL,0,Window);		// STOP!
//									PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) 0);
								}

								if(qual & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
									d = 30;
								else if(qual & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									d = (LastTime->PropEnd - LastTime->PropStart)/10+1;
								else
									d=(LastTime->Flags&PL_CFRAME) ? 2:1;

								if(LastTime->Flags & PL_IN)
									V=LastTime->Param;
								else
									V=LastTime->Param2;

								Y = *V;
//								*V = (Y>=LastTime->PropStart+d ? Y-d:LastTime->PropStart);

								if(LastTime->Flags&PL_AUDIO)
									*V = (Y >= *ALoTime+d) ? Y-d:*ALoTime;
								else
									*V = (Y >= *LoTime+d) ? Y-d:*LoTime;

								DUMPHEXIL("(flags=",(LONG)LastTime->Flags,")\\");
								if(LastTime->Flags&PL_FLYER)
								{
									MyRCB->Frame = (ULONG)(*V - *SMPTime)<<1;
									DUMPHEXIL("Frm=",(LONG)MyRCB->Frame," ");
									DUMPHEXIL("(Max=",(LONG)MyRCB->Max," ");
									DUMPHEXIL("Min=",(LONG)MyRCB->Min,")\\");
									MyRCB->pline = LastTime;
									DHD_Jump(MyRCB,FALSE);

									WinFlags=Window->IDCMPFlags;
									ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
									TilQuiet = 5;
								}
								else {
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
								}
								UpdateAllDiff(RP,Start,Window);
								break;
							case RAWKEY_RIGHT:
								if(LastTime==NULL) break;

								if(PlayPL && PlayFG)  // Must stop play to do Jog/Shuttle/Jump mode
								{
//									DUMPMSG("Abort Play");
									if (PlayPL->Handle)
										PlayPL->Handle(PlayPL,0,Window);		// STOP!
//									PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) 0);
								}

								if(qual & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
									d = 30;
								else if(qual & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									d = (LastTime->PropEnd - LastTime->PropStart)/10+1;
								else
									d=(LastTime->Flags&PL_CFRAME) ? 2:1;
								if(LastTime->Flags & PL_IN) V=LastTime->Param;
								else V=LastTime->Param2;
								Y = *V;
								if(LastTime->Flags&PL_AUDIO)
									*V = (Y<=*AHiTime-d ? Y+d:*AHiTime);
								else
									*V = (Y<=*HiTime-d ? Y+d:*HiTime);
								if(LastTime->Flags&PL_FLYER)
								{
									MyRCB->Frame = (ULONG)(*V - *SMPTime)<<1;
									MyRCB->pline = LastTime;
									DHD_Jump(MyRCB,FALSE);

									WinFlags=Window->IDCMPFlags;
									ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
									TilQuiet = 5;
								}
								else {
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
								}
								UpdateAllDiff(RP,Start,Window);
								break;
							case RAWKEY_UP:
								if(LastTime==NULL) break;

								if(PlayPL && PlayFG)  // Must stop play to do Jog/Shuttle/Jump mode
								{
//									DUMPMSG("Abort Play");
									if (PlayPL->Handle)
										PlayPL->Handle(PlayPL,0,Window);		// STOP!
//									PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) 0);
								}

								if(LastTime->Flags & PL_IN)
									V=LastTime->Param;
								else
									V=LastTime->Param2;

								if(qual & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
								{
									if(LastTime->Flags&PL_AUDIO)
										*V = *AHiTime;
									else
										*V = *HiTime;

									if(LiveFlyer)
									{
										MyRCB->Frame = (ULONG)(*V - *SMPTime)<<1;
										MyRCB->pline = LastTime;
										DHD_Jump(MyRCB,TRUE);
									}
									else {
										UpdatePanProp(LastTime,Window);
										UpdatePanStr(LastTime,Window);
									}
									UpdateAllDiff(RP,Start,Window);
								}
#if 0
								else if(qual & IEQUALIFIER_CONTROL )
								{
									if(LastTime->Flags&PL_AUDIO)
										*V = *AHiTime;
									else
										*V = *HiTime;

									if(LiveFlyer)
									{
										MyRCB->Frame = (ULONG)(*V - *SMPTime)<<1;
										MyRCB->pline = LastTime;
										MyRCB->Flags = DHD_PLAY_REV;
										DHD_Jog(MyRCB);
									}
									else {
										UpdatePanProp(LastTime,Window);
										UpdatePanStr(LastTime,Window);
									}
									UpdateAllDiff(RP,Start,Window);
								}
#endif
								break;
							case RAWKEY_DOWN:
								if(LastTime==NULL) break;

								if(PlayPL && PlayFG)  // Must stop play to do Jog/Shuttle/Jump mode
								{
//									DUMPMSG("Abort Play");
									if (PlayPL->Handle)
										PlayPL->Handle(PlayPL,0,Window);		// STOP!
//									PlayPL->UserFun(PlayPL,IntuiMsg,(APTR) 0);
								}

								if(LastTime->Flags & PL_IN)
									V=LastTime->Param;
								else
									V=LastTime->Param2;

								if(qual & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
								{
									if(LastTime->Flags&PL_AUDIO)
										*V = *ALoTime;
									else
										*V = *LoTime;

									if(LiveFlyer)
									{
										MyRCB->Frame = (ULONG)(*V - *SMPTime)<<1;
										MyRCB->pline = LastTime;
										DHD_Jump(MyRCB,TRUE);
									}
									else {
										UpdatePanProp(LastTime,Window);
										UpdatePanStr(LastTime,Window);
									}
									UpdateAllDiff(RP,Start,Window);
								}
#if 0
								else if(qual & IEQUALIFIER_CONTROL )
								{
									if(LastTime->Flags&PL_AUDIO)
										*V = *ALoTime;
									else
										*V = *LoTime;

									if(LiveFlyer)
									{
										MyRCB->Frame = (ULONG)(*V - *SMPTime)<<1;
										MyRCB->pline = LastTime;
										MyRCB->Flags = 0;
										DHD_Jog(MyRCB);
									}
									else {
										UpdatePanProp(LastTime,Window);
										UpdatePanStr(LastTime,Window);
									}
									UpdateAllDiff(RP,Start,Window);
								}
#endif
								break;
						}
					}
					if ((A == RAWKEY_PAD_ENTER)||(A == RAWKEY_RETURN))
					{
						Going = FALSE;
						Success=TRUE;
					}
					else if(A == RAWKEY_HELP)
					{
						if(XPMode==TUNE_FINE)
						{
							Success = PAN_EXPERT;
							Going = FALSE;
						}
						else if(XPMode==TUNE_QUICK)
						{
							Success = PAN_EASY;
							Going = FALSE;
						}

//						else
//							Success = PAN_CONTINUE;
//						if(XPMode) Success = PAN_EXPERT;
//						else Success=TRUE;
					}
					else if((A == RAWKEY_ESC)) Going = FALSE;
					break;
				}
				ReplyMsg((struct Message *)IntuiMsg);
			}
		}

		CloseWindow(Window);
		WaitBlit();

// update modified parameters
		PLine = Start;
		while (PLine->Type)
		{
			switch(PLine->Type) {
			case PNL_IN_TYPE:
			case PNL_OUT_TYPE:
				if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
				else *(PLine->Param) = 0;
				break;
			}
			PLine++;
		}
	}

ErrExit:
	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine && PLine->Destroy && (PLine->Type!=PNL_SKIP) )
			PLine->Destroy(PLine);
	}
//	if (ContCan) FreeGadgets(ContCan);
	return(Success);
}

char RecMsg[] = "Record Clip";
WORD AudMode = 0;

#define aud1_ID		ID_BOOL+714
#define aud2_ID		ID_BOOL+715
#define aud3_ID		ID_BOOL+716
#define ST_ID			ID_BOOL+717
#define MX_ID			ID_BOOL+718
#define INSTR_ID		ID_BOOL+719
#define OUTSTR_ID		ID_BOOL+720
#define IN_ID			ID_BOOL+721
#define OUT_ID			ID_BOOL+722
#define CD_ID			ID_BOOL+723
#define AE_ID			ID_BOOL+724
#define JUMP_SIZE		30

#define EV_GAD			0X2000
#define EV_GAD01		EV_GAD+1
#define EV_GAD02		EV_GAD+2
#define EV_GAD03		EV_GAD+3
#define EV_GAD04		EV_GAD+4
#define EV_GAD05		EV_GAD+5
#define EV_GAD06		EV_GAD+6
#define EV_GAD07		EV_GAD+7
		




#define AUDIO_LEVEL_UPDATE_TIME	 0		// Every tick
UWORD __asm NewClipPanel(REG(a0) struct EditWindow *Edit )
{
	WORD H = PNL_Y1,ID,A,X1=0,Y1=0,Lines=0;
	struct Gadget *ThisG=0,*Record=NULL,*Pause=NULL,*ExtraGads,*gadptr;
//	struct Gadget *ContCan;
	struct Window *Window=0;
	struct RastPort *RP;
	BOOL Going = TRUE, Recording=FALSE,RecordedAlready=FALSE,Paused=FALSE,AudioOnly=FALSE;
	UWORD Success = PAN_CANCEL,audlev,clipping;
	struct PanelLine *PLine=EasyPanelPL,*LenPL=NULL,*DropPL=NULL,
										*FlyPL=NULL,*AudPL=NULL;
	struct IntuiMessage *IntuiMsg;
	LONG Y=0,F=0,RecStartM=0,RecStartS=0,PauseS=0,PauseM=0,TPauseS=0,TPauseM=0,AudUpdate=0;
	char *FlyDrive,*tempdrive;
	int err;
//	struct AudIndicator *AudBarR=NULL,*AudBarL=NULL;
	struct SegBarGraph *AudBarR=NULL,*AudBarL=NULL;

	DHD_InitRecord(0,0xC0DED00D);
	DHD_SetupRecord(CurFlySource,CurCompMode);

	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL; LastString=NULL;
	Wide=TRUE;
//	t=(char *)&audlev;
//	DUMPHEXIL("New Clip Panel @@",(LONG)PLine,"\\");
	for( Start = PLine; PLine->Type; PLine++ )
	{
		if(PLine->Type != PNL_SKIP)
		{
//			DUMPHEXIL("Pline->Create @@",(LONG)PLine->Create,"\\");
			if (PPOS_HALF2 & PLine->Align)
				X1 = PNL_WIDTH;

			// Call the gadget's create function
			if(PLine->Create)		Y1=PLine->Create(X1,H,PLine,&ThisG);
			if(PPOS_WIDER & PLine->Align)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
				else
					H += Y1;					// Was no left half
				X1 = Y = 0;
			}
			if(PLine->Flags)
			{
				if(PLine->Flags&PL_AVAIL)
					F= H - PIN_H +4 ;   // for aligning Reorganize button, or 0 for short panel
				else if(PLine->Flags&PL_LEN)
					LenPL=PLine;
				else if(PLine->Flags&PL_FLYER)
					FlyPL=PLine;
				else if(PLine->Flags&PL_AUDIO)
					AudPL=PLine;
			}

			if (PLine->PLID == PLID_DROPIND)
				DropPL=PLine;

			Lines++;
		}
	}
	if(X1>0) H += MAX(Y,Y1);  // last gad...
	if(Wide) X1=PNL_WIDTH;
	ClipNW.Width = PNL_WIDTH + (Wide ? PNL_WIDTH:0);
	ClipNW.Height = H;	//+PNL_YADD+24;
	ClipNW.Screen = EditScreen;
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = EditTop->Window->TopEdge; // MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
	ClipNW.FirstGadget = NULL;
	ClipNW.Flags = REC_FLAGS;
	if( !(ExtraGads=CreateNewClipGads((struct NewWindow *)&ClipNW,F,&ThisG)) )
		goto rErrExit;
	for (gadptr=ExtraGads; gadptr; gadptr=gadptr->NextGadget)
	{
		if (gadptr->GadgetID == ID_VCR_REC)
			Record = gadptr;
		if (gadptr->GadgetID == ID_VCR_PAUSE)
			Pause = gadptr;
	}

	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		SoftSpriteOff();				// Shut off for the duration -- faster, and less flash

		RP = Window->RPort;
		WinFlags=Window->IDCMPFlags;
		SetDrMd(RP,JAM2);
		AddGList(Window,FirstG,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		SetFont(RP,DarkFont);
		for(PLine = Start; PLine->Type; PLine++)
			PLine->Win=Window;
		DrawPanel(Start);
		NewBorderBox(RP,Record->LeftEdge-Record->Width-6,Record->TopEdge-4,
				Record->LeftEdge+(Record->Width<<1)+3,Record->TopEdge+Record->Height+3,BOX_REV);
		RefreshGList(ExtraGads,Window,NULL,-1);

		SoftSpriteOn();

		if (F
//		&& (AudBarL = InitAudIndicator(20,Record->TopEdge-18,16,8,1,&LClipping,Window))
//		&& (AudBarR = InitAudIndicator(20+(Window->Width>>1),Record->TopEdge-18,16,8,1,&RClipping,Window)) )
		&& (AudBarL = InitBarGraph(8,Record->TopEdge-66,207,8,255,Window))
		&& (AudBarR = InitBarGraph(8+(Window->Width>>1),Record->TopEdge-66,207,8,255,Window)) )
		{
			clipping	= GetRecSense();			// Get clipping info
			audlev	= GetAudioMeters();		// Get level meters
			UpdateBarGraph(AudBarL,audlev>>8,	((clipping>>8) >1) );
			UpdateBarGraph(AudBarR,audlev&0xFF,	((clipping & 0xFF) >1) );
//			UpdateAudIndicator(AudBarL,t[0]);
//			UpdateAudIndicator(AudBarR,t[1]);
			ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
			WinFlags |= IDCMP_INTUITICKS;
			AudUpdate=AUDIO_LEVEL_UPDATE_TIME;
//			DUMPMSG("AudBars OK!!!");
		}
		else if(F)
		{
//			DUMPMSG("AudBars FAILED!!!");
			goto wErrExit;
		}

		if(FlyPL)
		{
			FlyDrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
			if(*FlyDrive==AUDIO_BYTE)
				FlyDrive+=2; // Skip speaker symbol char and space
			strcpy(ClipName,FlyDrive);
			strcat(ClipName,TEMP_CLIP_NAME);
//			DUMPSTR("Set Name: "); DUMPMSG(ClipName);
		}

		// handle window events
		goto GetEm;
		while (Going) {
				WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
				switch(IntuiMsg->Class) {
				case IDCMP_GADGETDOWN:
					DUMPSTR("GADGETDOWN..... ");
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					if(Paused && ( (ID!=ID_VCR_PAUSE) && (ID!=ID_REQ_STOP) && (ID!=ID_VCR_REC)) )
						break;

					if(PLine = (struct PanelLine *)ThisG->UserData)
					{
						if(PLine->Handle) PLine->Handle(PLine,IntuiMsg,Window);
						if( (PLine==FlyPL) || (PLine->Type==PNL_POPUP) )
						{
							UpdateAllDiff(RP,Start,Window);
							DUMPMSG	("pline");
						}
					}
					else switch(ID) // handle VCR Rec/Play button
					{
						case ID_VCR_REC:
							DUMPMSG	("ID_VCR_REC");
							break;
						case ID_VCR_PAUSE:
							DUMPMSG("Pause Down");
							break;
						case ID_REQ_STOP:
							DUMPMSG	("ID_REQ_STOP");
							if(Recording)
							{
								Record->Flags &= ~GFLG_SELECTED;
								RefreshGList(Record,Window,NULL,1);
								Pause->Flags &= ~GFLG_SELECTED;
								RefreshGList(Pause,Window,NULL,1);
								ModifyIDCMP(Window,WinFlags);

								Flyer_AbortRecord();		// Could take a bit to wrap up
								Paused=FALSE;
								Recording=FALSE;
//								DHD_MakeClipIcon(ClipName);
								if(Y = (IntuiMsg->Seconds - RecStartS - TPauseS)*30)
									Y += (3*IntuiMsg->Micros)/100000;  // should add (1000000-RecStartM)
								else
									Y += (3*(IntuiMsg->Micros - RecStartM - TPauseS))/100000;
								*LenPL->Param = (Y+1)&0xFFFFFFFE; // even up
								CTRL_SetDrive(FlyPL,IntuiMsg,NULL);
								UpdateAllDiff(RP,Start,Window);
							}
							break;
					}
					break;

				case IDCMP_GADGETUP:
					DUMPMSG	("GADGETUP");
					if (Down) Down = NULL;
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					if(Paused && !((ID==ID_VCR_PAUSE) || (ID==ID_VCR_REC) ) )
						break;
					PLine = (struct PanelLine *)ThisG->UserData;
					if(Recording && !Paused && (ID!=ID_VCR_PAUSE))
					{
						Recording = FALSE;
						Record->Flags &= ~GFLG_SELECTED;
						RefreshGList(Record,Window,NULL,1);

						Flyer_AbortRecord();		// Could take a bit to wrap up

//						DHD_MakeClipIcon(ClipName);
						if(Y = (IntuiMsg->Seconds - RecStartS- TPauseS)*30)
							Y += (3*IntuiMsg->Micros)/100000;
						else // I'm not sure the - TPauseM part here is necessary or proper
							Y += (3*(IntuiMsg->Micros - RecStartM- TPauseM))/100000;
						*LenPL->Param = (Y+1)&0xFFFFFFFE; // even up
						UpdateDiff(RP,LenPL,Window);
						if(ID==ID_VCR_REC) break;
					}

					if((PLine) && (PLine->Handle) )
					{
						PLine->Handle(PLine,IntuiMsg,Window);


						if (PLine->Flags & PL_GENBUTT)
						{
							switch ((ULONG)PLine->Param)
							{
							case GB_CONTINUE:
								// This intercept standard handler, special needs here
								if (RecordedAlready && !AudioOnly)
									DHD_MakeClipIcon(ClipName);
								Success = PAN_CONTINUE;
								Going = FALSE;
								break;
							case GB_CANCEL:
								// This intercept standard handler, special needs here
								Going = FALSE;
								CrDeleteFile(ClipName);
								break;
							case GB_REORG:			// Reorganize?
								// This intercept standard handler, special needs here

								DUMPMSG	("Re-Organize");

								if(FlyerDriveCount>0)		// Don't reorg if no drives
								{
									tempdrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
									if (MaybeDoReorg(Window,tempdrive))
									{
										CTRL_SetDrive(FlyPL,IntuiMsg,NULL);
										UpdateAllDiff(RP,Start,Window);
									}
								}
								break;
							default:
								DoGenButtons(PLine,Window,&Success,&Going);
								break;
							}
						}
					}
					else switch (ID)
					{
						case ID_VCR_REC:

							if(FlyerDriveCount==0) {	// Don't record if no drives
								Record->Flags &= ~GFLG_SELECTED;
								RefreshGList(Record,Window,NULL,1);
							}
							else {
								if(FlyPL)
								{
									FlyDrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
									if(*FlyDrive==AUDIO_BYTE)
									{
										FlyDrive+=2; // Skip speaker symbol char and space
										AudioOnly = TRUE;
									}
									else AudioOnly = FALSE;

									strcpy(ClipName,FlyDrive);
									strcat(ClipName,TEMP_CLIP_NAME);
									DUMPSTR("Set Name: "); DUMPMSG(ClipName);
								}
								WinFlags=Window->IDCMPFlags;
								Recording=TRUE;
								ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
								if(Paused)  // Pause off
								{
									Paused=FALSE;
									Flyer_Pause(FALSE);
									Record->Flags |= GFLG_SELECTED;
									RefreshGList(Record,Window,NULL,1);
									Pause->Flags &= ~GFLG_SELECTED;
									RefreshGList(Pause,Window,NULL,1);
									TPauseS += IntuiMsg->Seconds - PauseS; // Add this pause duration
									if(IntuiMsg->Seconds == PauseS)
										TPauseM += IntuiMsg->Micros  - PauseM; // to total paused time
								}
								else
								{
									Paused=FALSE;
									*LenPL->Param = 0;
									TPauseS=0; TPauseM=0;
									PauseS=0; PauseM=0;
									RecStartS=IntuiMsg->Seconds;
									RecStartM=IntuiMsg->Micros;
									ClearFlyerStatus();
									Flyer_Record(ClipName,0);
									RecordedAlready=TRUE;
								}
							}
							break;
						case ID_REQ_STOP:
							break;
						case ID_VCR_PAUSE:
							if (!Recording)	// Just un-render if not recording
							{
								ThisG->Flags &= ~GFLG_SELECTED;
								RefreshGList(ThisG,Window,NULL,1);
							}
							else if (Paused)  // Pause off
							{
								Paused=FALSE;
								Flyer_Pause(FALSE);
								Record->Flags |= GFLG_SELECTED;
								RefreshGList(Record,Window,NULL,1);
								ThisG->Flags &= ~GFLG_SELECTED;
								RefreshGList(ThisG,Window,NULL,1);
								TPauseS += IntuiMsg->Seconds - PauseS; // Add this pause duration
								if(IntuiMsg->Seconds == PauseS)
									TPauseM += IntuiMsg->Micros  - PauseM; // to total paused time
							}
							else // Start Pause
							{
								Paused=TRUE;
								Flyer_Pause(TRUE);
								Record->Flags &= ~GFLG_SELECTED;
								RefreshGList(Record,Window,NULL,1);
								Pause->Flags |= GFLG_SELECTED;
								RefreshGList(Pause,Window,NULL,1);
								PauseS = IntuiMsg->Seconds; // reset current pause time
								PauseM = IntuiMsg->Micros;
							}
							DUMPMSG("Pause Up");
							break;
//						case ID_DARK_CONTINUE:  // called with NO_CUTTING_ROOM def'd
//							if( RecordedAlready && !AudioOnly ) DHD_MakeClipIcon(ClipName);
//							Success = PAN_CONTINUE;
//							Going = FALSE;
//							break;
//						case ID_REQ_DARK_CANCEL:
//							Going = FALSE;
//							CrDeleteFile(ClipName);
//							break;
//						case ID_MARK_PANEL: // called without NO_CUTTING_ROOM def'd
//							Going = FALSE;			//Success was initialized to FALSE
//							Success = PAN_EXPERT;
//							break;
//						case ID_REORG:
//							DUMPMSG	("Re-Organize");
//							if(FlyerDriveCount>0)		// Don't reorg if no drives
//							{
//								tempdrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
//								if (MaybeDoReorg(Window,tempdrive))
//								{
//									CTRL_SetDrive(FlyPL,IntuiMsg,NULL);
//									UpdateAllDiff(RP,Start,Window);
//								}
//------
//								if(*tempdrive==AUDIO_BYTE)
//									tempdrive+=2; // Skip speaker symbol char and space
//
//								sprintf(pstr,"If I reorganize %s, it may take a while... ",tempdrive);
//								if(BoolRequest(Window,pstr))
//								{
//									sprintf(pstr,"Reorganizing Flyer drive %s",tempdrive);
//									OpenNoticeWindow(Window,PatienceMsg,2,FALSE);
//									DisplayWaitSprite();
//									DHD_Reorganize(tempdrive);
//									DisplayNormalSprite();
//									CloseNoticeWindow();
//									CTRL_SetDrive(FlyPL,IntuiMsg,NULL);
//									UpdateAllDiff(RP,Start,Window);
//								}
//							}
							break;
					}
					break;
				case IDCMP_MOUSEMOVE:
				case IDCMP_MOUSEBUTTONS:
					if(Down)
					{
						PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,Window);
					}
					break;

				case IDCMP_INTUITICKS:
					if(Recording && !Paused)
					{
						if((RecStartS==0)&&(RecStartM==0))
						{
							RecStartS=IntuiMsg->Seconds;
							RecStartM=IntuiMsg->Micros;
						}
						if(Y = (IntuiMsg->Seconds - RecStartS- TPauseS)*30)
							Y += (3*IntuiMsg->Micros)/100000;
						else
							Y += (3*(IntuiMsg->Micros - RecStartM - TPauseM))/100000;
						*LenPL->Param = (Y+1)&0xFFFFFFFE; // even up
						UpdateDiff(RP,LenPL,Window);

						// If Flyer dropped fields, update the drop count display
						if (DropPL)
						{
							if (CheckFlyerStatus(NULL, (ULONG *)DropPL->Param)==FERR_DROPPEDFLDS)
							{
								UpdateDiff(RP,DropPL,Window);
							}
						}

//						if(FlyPL->PropEnd>1)		// Why test for >1 Flyer drive?!?!?
//						{
							err = Flyer_CheckRecord();
//							DUMPSDECL	("Check: ",(LONG)err,"\\");
							if(err!=FERR_BUSY)
							{
								switch(err)
								{
									case FERR_EXISTS:
										if(BoolRequest(Window,"Temporary clip already recorded, re-record it?"))
										{
											CrDeleteFile(ClipName);
											*LenPL->Param = 0;
											RecStartS= 0; // IntuiMsg->Seconds;
											RecStartM=0; // IntuiMsg->Micros;
											TPauseS=0; TPauseM=0;
											PauseS=0; PauseM=0;
											ClearFlyerStatus();
											Flyer_Record(ClipName,0);
											CTRL_SetDrive(FlyPL,IntuiMsg,NULL);
										}
										else {
											Recording=FALSE;
											ModifyIDCMP(Window,WinFlags);
											Record->Flags &= ~GFLG_SELECTED;
											RefreshGList(Record,Window,NULL,1);
										}
										break;
									case FERR_EXHAUSTED:
										sprintf(pstr,"Recording stopped, Flyer drive %s full.",((char **)FlyPL->Param)[FlyPL->PropStart]);
										Recording=FALSE;
										ModifyIDCMP(Window,WinFlags);
										Record->Flags &= ~GFLG_SELECTED;
										RefreshGList(Record,Window,NULL,1);
										ContinueRequest(Window,pstr);
										break;
									case FERR_DROPPEDFLDS:
//										ContinueRequest(Window,
//											"Gosh, d-d-do you think we c-c-ould try that one again?");
										DUMPMSG	("FERR_DROPPEDFLDS");
										Recording=FALSE;
										ModifyIDCMP(Window,WinFlags);
										Record->Flags &= ~GFLG_SELECTED;
										RefreshGList(Record,Window,NULL,1);
										SimpleRequest(Window,DropErr,2,REQ_CENTER | REQ_H_CENTER,NULL);
										break;
									case FERR_OKAY:
										DUMPMSG	("FERR_OKAY");
										Recording=FALSE;
										ModifyIDCMP(Window,WinFlags);
										Record->Flags &= ~GFLG_SELECTED;
										RefreshGList(Record,Window,NULL,1);
//										DHD_MakeClipIcon(ClipName);
										break;
									default:
										DUMPSDECL	("Default: Flyer_CheckRecord=",(LONG)err,"\\");
										Recording=FALSE;
										ModifyIDCMP(Window,WinFlags);
										Record->Flags &= ~GFLG_SELECTED;
										RefreshGList(Record,Window,NULL,1);
										sprintf(pstr,"Recording stopped: Internal Flyer Error # %d.",err);
										ContinueRequest(Window,pstr);
										break;
								}
							}
//						}
					}
					else if(!Paused) ModifyIDCMP(Window,WinFlags);
					if(AudUpdate) AudUpdate--;
					else if(AudBarL && AudBarR)
					{
						AudUpdate=AUDIO_LEVEL_UPDATE_TIME;
//						if(FlyerBase) audlev=GetRecSense();
						if (FlyerBase)
						{
							clipping	= GetRecSense();			// Get clipping info
							audlev	= GetAudioMeters();		// Get level meters
						}
						else
						{
							audlev=((IntuiMsg->Micros>>3)&0x0707);
							clipping = 0;
						}

						UpdateBarGraph(AudBarL,audlev>>8,	((clipping>>8) >1) );
						UpdateBarGraph(AudBarR,audlev&0xFF,	((clipping & 0xFF) >1) );
//						UpdateAudIndicator(AudBarL,t[0]);
//						UpdateAudIndicator(AudBarR,t[1]);
					}
					break;
				case IDCMP_RAWKEY:
					DUMPMSG	("IDCMP_RAWKEY");
					A = IntuiMsg->Code;
					if(A>0x80) break;
					if(Paused && A!=RAWKEY_SPACE)
						break;
					if(Recording && !Paused)
					{
						Recording = FALSE;
						Record->Flags &= ~GFLG_SELECTED;
						RefreshGList(Record,Window,NULL,1);

						Flyer_AbortRecord();		// Could take a bit to wrap up

//						DHD_MakeClipIcon(ClipName);
						ModifyIDCMP(Window,WinFlags);
						if(Y = (IntuiMsg->Seconds - RecStartS - TPauseS)*30)
							Y += (3*IntuiMsg->Micros)/100000;
						else
							Y += (3*(IntuiMsg->Micros - RecStartM - TPauseM))/100000;
						*LenPL->Param = (Y+1)&0xFFFFFFFE; // even up
						UpdateDiff(RP,LenPL,Window);
						if(A==RAWKEY_SPACE) break;
					}
					switch(A)
					{
						case RAWKEY_PAD_ENTER:
						case RAWKEY_RETURN:
							if(RecordedAlready) DHD_MakeClipIcon(ClipName);
							Going = FALSE;
							Success=TRUE;
							break;
						case RAWKEY_HELP:
							break;
						case RAWKEY_ESC:
							CrDeleteFile(ClipName);
							Going = FALSE;
							break;
						case RAWKEY_SPACE:
							if(Paused)  // Pause off
							{
								Paused=FALSE;
								Record->Flags |= GFLG_SELECTED;
								RefreshGList(Record,Window,NULL,1);
								TPauseS += IntuiMsg->Seconds - PauseS; // Add this pause duration
								if(IntuiMsg->Seconds == PauseS)
									TPauseM += IntuiMsg->Micros  - PauseM; // to total paused time
								Flyer_Pause(Paused);
								break;
							}

							if(FlyPL)
							{
								FlyDrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
								if(*FlyDrive==AUDIO_BYTE)
								{
									FlyDrive+=2; // Skip speaker symbol char and space
									AudioOnly = TRUE;
								}
								else AudioOnly = FALSE;
								strcpy(ClipName,FlyDrive);
								strcat(ClipName,TEMP_CLIP_NAME);
								DUMPSTR("Set Name: "); DUMPMSG(ClipName);
							}
							WinFlags=Window->IDCMPFlags;
							Recording=TRUE;
							ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
							*LenPL->Param = 0;
							RecStartS=IntuiMsg->Seconds;
							RecStartM=IntuiMsg->Micros;
							ClearFlyerStatus();
							Flyer_Record(ClipName,0);
							Record->Flags |= GFLG_SELECTED;
							RefreshGList(Record,Window,NULL,1);
							RecordedAlready=TRUE;
							break;
					}
					break;
				case IDCMP_REFRESHWINDOW: // shouldn't ever come in...
//					DUMPMSG("IDCMP_REFRESHWINDOW");
					break;
				} // message switch
				ReplyMsg((struct Message *)IntuiMsg);
			}
		}
wErrExit:
		CloseWindow(Window);
		WaitBlit();
	}
rErrExit:
	ClipNW.Flags = STD_FLAGS;
	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine && PLine->Destroy && (PLine->Type != PNL_SKIP))
			PLine->Destroy(PLine);
	}
	DHD_InitPlay(0,0xC0DED00D);
	if (ExtraGads) FreeGadgets(ExtraGads);
//	if(AudBarL) FreeAudIndicator(AudBarL);
//	if(AudBarR) FreeAudIndicator(AudBarR);
	if(AudBarL) FreeBarGraph(AudBarL);
	if(AudBarR) FreeBarGraph(AudBarR);

	DUMPSTR	(" OK so far .....   ");
	return(Success);
}



UWORD __asm CutClipPanel(
		REG(a0) struct EditWindow *Edit,
		REG(a1) struct FastGadget *FG,
		REG(a2) struct PanelLine *PLine,
		REG(d0) BOOL destructive,
		REG(d1) char *SrcName)
{
#ifdef CUT_ROOM_HELP
// Help screen data
static char *HelpMsg[] = {
		"   Keyboard Shortcuts",
		" -- Keypad --",
		"   (   Enter In  point",
		"   )   Enter Out point",
		"   /   Enter Comment",
		"   *   Enter Name",
		" -- Arrows --",
		"         left/right  Fine adjust current point",
		"   ALT   left/right  Coarse adjust current point",
		"   SHIFT left/right  Adjust by 1 second",
		"   SHIFT down        Move current point to minimum",
		"   SHIFT up          Move current point to maximum",
		" -- Other --",
		"   +   Select next clip",
		"   -   Select previous clip",
		"   s   Make current clip a still",
		"   x   Remove current clip"
	};
#endif

	struct Gadget CDisp = {
		NULL,0,0,20,20,
		GFLG_GADGHNONE,
		RELVERIFY,
		BOOLGADGET,
		NULL,NULL,NULL,NULL,NULL,CD_ID,NULL
	};

	struct CutClipData	ccd;				// Structure passable to sub-routines

	WORD H = PNL_Y1,ID,A,qf,X1=0,Y1=0,Lines=0;
	struct NewClip	*tcl=NULL,*ncl;
	struct ClipInfo	*ci;
	struct Gadget *ThisG=NULL,*Clips,*Comm;
//	struct Gadget *ContCan,*LastGad=NULL,*RecGadget=NULL;
	BOOL Going,ListOpen=FALSE,FromRawClip;
	UWORD Success;
//	struct PanelLine *PLine = MarkClipPL;
	struct PanelLine *partsPL=NULL,*destPL=NULL;
	struct IntuiMessage *IntuiMsg;
	struct StringInfo *si;
	ULONG Y=0,t,d,*V,ClipFlags,TilQuiet=0;
//	ULONG *Strip;
	char *FlyDrive,DrvName[31];
	ULONG	error;
	char *MPtr[3];
	int	i,ok,stripbase;

//---
	ccd.cl=NULL;
	ccd.ClipDisp=NULL;
	ccd.Window=NULL;
	ccd.Frame = NULL;		// May not be an icon slider!
	ccd.FramePL=NULL;

	strcpy(ClipName2,"NewClip.");		// Default name prefix

	// Lookup name of FastGadget, unless one is provided
	if (SrcName==NULL)
	{
		FromRawClip = FALSE;			// Cutting up an existing clip

		SrcName = ((struct ExtFastGadget *)FG)->FileName;

		DUMPMSG("Object to work with is called...");
		DUMPMSG(SrcName);

		for(FlyDrive=DrvName,Y=0; Y<=30; Y++)
		{
			if ((*FlyDrive++ = SrcName[Y]) == ':')		// Copy byte, stop if ':' hit
				break;
		}
		*FlyDrive = 0;		// Null terminate
		FlyDrive = DrvName;

		// Derive the source clip's volume:path (this will be applied to all new files made)
		strcpy(ClipPath,SrcName);
		*FilePart(ClipPath)=0;			// Trim off the file part (may leave nothing if no path)
	}
	else
	{
		FromRawClip = TRUE;			// Just cutting up the raw clip

		// Cutting raw clip, so get name of current drive
		FlyDrive = FlyerDrives[CurFlyDrive];
		if(*FlyDrive==AUDIO_BYTE)
			FlyDrive+=2; // Skip speaker symbol char and space

		// Prepend just the volume: name before all files made here
		strcpy(ClipPath,FlyDrive);
	}

	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL;
	Wide=TRUE;

	for (Start=PLine; PLine->Type; PLine++ )
	{
		if(PLine->Type != PNL_SKIP)
		{
			if (PPOS_HALF2 & PLine->Align)
				X1 = PNL_WIDTH;

			// Call the gadget's create function
			if(PLine->Create)		Y1=PLine->Create(X1,H,PLine,&ThisG);

			if(PPOS_WIDER & PLine->Align)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
				else
					H += Y1;					// Was no left half
				X1 = 0;
				Y = 0;
			}

			if(PLine->Flags)
			{
				if(PLine->Flags&PL_DUAL)
				{
					ccd.TimePL = PLine;
					In=ccd.TimePL->StrGadg;
					Out=ccd.TimePL->StrGadg->NextGadget;
				}
				else if(PLine->Flags&PL_DEL)
				{
					ccd.String=PLine->StrGadg;
					ccd.StrPL = PLine;
				}
				else if(PLine->Flags&PL_LEN)
					ccd.LenPL=PLine;
				else if(PLine->Flags&PL_PLAY)
					partsPL = PLine;
//					Strip=(ULONG *)&PLine->Param;
				else if(PLine->Flags&PL_AUDIO)
				{
					ccd.FramePL=PLine;
					ccd.Frame=ccd.FramePL->StrGadg;
				}
				else if(PLine->Flags&PL_AVAIL)
				{
					ccd.CommPL=PLine;
					Comm=PLine->StrGadg;
				}
			}

			if (PLine->PLID == PLID_DESTPOPUP)
				destPL=PLine;

			Lines++;
		}
	}

	ccd.Tmax = ccd.TimePL->PropEnd;
	ccd.Tmin = ccd.TimePL->PropStart;
	if(X1>0) H += MAX(Y,Y1);  // last gad...
	if(Wide) X1=PNL_WIDTH;
	ClipNW.Width = PNL_WIDTH + (Wide ? PNL_WIDTH:0);

	ClipNW.Height = H;
	ClipNW.Screen = EditScreen;
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = EditTop->Window->TopEdge; // MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
	ClipNW.FirstGadget = NULL;

	// Tack clip bar gadget onto end of list
	Clips=&CDisp;
	ThisG->NextGadget = Clips;


ReOpen:
	Going = TRUE;
	Success = PAN_CANCEL;
	ccd.clipnumdigits = 2;	// Start with .01
	ccd.clipnum = 0;

	strncpy(ClipName,SrcName,CLIP_PATH_MAX);		// Make copy of source clip name

	ci=DHD_ClipInfo(ClipName);
	if (ci)
	{
//		if(ci->Flags&CIF_HASVIDEO)
//			*Strip |= 1;
//		else
//			*Strip &= ~1;
//		if(ci->Flags&CIF_HASAUDIO)
//			*Strip |= 2;
//		else
//			*Strip &= ~2;
		if (ci->Flags&CIF_HASVIDEO)
		{
			if (ci->Flags&CIF_HASAUDIO)
			{
				// Audio/Video clip
				stripbase = 0;
				partsPL->PropStart = 2;
				partsPL->PropEnd = 3;
			}
			else
			{
				// Video only
				stripbase = 0;
				partsPL->PropStart = 0;
				partsPL->PropEnd = 1;
			}
		}
		else
		{
			if (ci->Flags&CIF_HASAUDIO)
			{
				// Audio only
				stripbase = 1;
				partsPL->PropStart = 0;
				partsPL->PropEnd = 1;
			}
			else
			{
				Success = PAN_CANCEL;
				goto rErrExit;					// Not a Flyer clip, just abort
			}
		}
		partsPL->Param = (long *)&AVparts[stripbase];
	}
	else
	{
		// Aargh!  Trying to operate on a clip that no longer exists!!
		sprintf(pstr,"Error - clip \"%ls\" no longer exists",ClipName);
		ContinueRequest(EditTop->Window,pstr);

		Success = PAN_CANCEL;
		goto rErrExit;
	}

	if (!destructive)
	{
//		DUMPSTR("Non-Destructive cutting on clip: ");
//		DUMPMSG(ClipName);

		DHD_StartClipList(ClipName,CUTCLIP_PRESERVE);
		ListOpen = TRUE;

//		for(Y=0; Y<=20 && ClipName[Y]!=':'; Y++)
//			FlyD[Y] = ClipName[Y];
//		FlyD[Y] = ClipName[Y++];
//		FlyD[Y] = 0;
//		FlyDrive = FlyD;
	}
	else
	{
//		DUMPSTR("Destructive cutting on clip: ");
//		DUMPMSG(ClipName);

		DHD_StartClipList(ClipName,CUTCLIP_DESTROY);
		ListOpen = TRUE;
	}

	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	if (ccd.Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		SoftSpriteOff();				// Shut off for the duration -- faster, and less flash

		ccd.RP = ccd.Window->RPort;
		SetDrMd(ccd.RP,JAM2);
		if(!ccd.ClipDisp)
		{
			if(!(ccd.ClipDisp=InitClipDisplay(16,
				ccd.TimePL->PropGadg->TopEdge+ccd.TimePL->PropGadg->Height+20,
				ccd.Window->Width-32,24,ccd.Tmin,ccd.Tmax,ccd.Window)))
			{
				SoftSpriteOn();
				goto rErrExit;
			}
			sprintf(ClipName,"%s%0*d",ClipName2,ccd.clipnumdigits,++ccd.clipnum);
			if(ccd.cl=AddClip(ccd.ClipDisp,ccd.Tmin,ccd.Tmax,CLIP_ACTIVE,ClipName))
			{
				ccd.StrPL->Param = (LONG *) ccd.cl->Name;
				strncpy(((struct StringInfo *)ccd.String->SpecialInfo)->Buffer,ccd.cl->Name,CLIP_NAME_MAX-1);

				ccd.CommPL->Param = (LONG *) ccd.cl->Comment;
			}
			ccd.TimePL->Param = &ccd.cl->in;
			ccd.TimePL->Param2 = &ccd.cl->out;
			ccd.LenPL->Param = ccd.TimePL->Param2;
			ccd.LenPL->Param2 = ccd.TimePL->Param;
			if (ccd.FramePL)
			{
				ccd.FramePL->Param = &ccd.cl->icon;
				ccd.FramePL->PropEnd = ccd.cl->out;
				ccd.FramePL->PropStart = ccd.cl->in;
	//			ccd.FramePL->G2 =(struct Gadget *) (ccd.cl->in-ccd.Tmin);
				AHiTime = &ccd.FramePL->PropEnd;
				ALoTime = &ccd.FramePL->PropStart;
			}
		}
		else ccd.ClipDisp->RP=ccd.Window->RPort;

		if(ccd.cl) ccd.StrPL->Param = (LONG *) ccd.cl->Name;
		Clips->LeftEdge = ccd.ClipDisp->X;
		Clips->TopEdge = ccd.ClipDisp->Y;
		Clips->Width = ccd.ClipDisp->W;
		Clips->Height = ccd.ClipDisp->H;

		AddGList(ccd.Window,FirstG,0,-1,NULL);

		// Setup outline for panel window
		NewBorderBox(ccd.RP,0,0,ccd.Window->Width-1,ccd.Window->Height-1,BOX_CP_BORDER);

		SetFont(ccd.RP,DarkFont);
//		RefreshGList(ContCan,ccd.Window,NULL,-1);
		DrawClipDisplay(ccd.ClipDisp);

		X1 = 0;
		Y = 0;
		H = PNL_Y1;
		for (PLine=Start;PLine->Type; PLine++)
		{
			if(PLine->Type != PNL_SKIP)
			{
				if (PPOS_HALF2 & PLine->Align)
					X1 = PNL_WIDTH;

				// Call the gadget's draw function
				PLine->Win = ccd.Window;

				if(PLine->Draw)	Y1=PLine->Draw(X1,H,PLine,ccd.Window);

				if(PPOS_WIDER & PLine->Align)
				{
					X1 = PNL_WIDTH;
					Y = Y1;
				}
				else
				{
					if (Y>0)
						H += MAX(Y,Y1);		// Don't forget left half
					else
						H += Y1;					// Was no left half
					X1 = 0;
					Y = 0;
				}
			}
		}

		// Activate name string gadget
		si = (struct StringInfo *) ccd.String->SpecialInfo;
		si->BufferPos = strlen(si->Buffer);		// Move cursor past end
		ActivateGadget(ccd.String,ccd.Window,NULL);

		SoftSpriteOn();

		HiTime = (ccd.TimePL->Param2);
		LoTime = &ccd.TimePL->PropStart;
		MyRCB->Frame = (ULONG)(*ccd.TimePL->Param - ccd.Tmin)<<1;
		MyRCB->Max = (*HiTime - ccd.Tmin)<<1;
		MyRCB->Min = (*LoTime - ccd.Tmin)<<1;
		MyRCB->FG = FG;
		MyRCB->win = ccd.Window;
		MyRCB->pline = ccd.TimePL;

		// handle window events
		goto GetEm;
		while (Going)
		{
				WaitPort(ccd.Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(ccd.Window->UserPort)) {
				switch(IntuiMsg->Class)
				{
				case IDCMP_GADGETDOWN:
//					DUMPMSG	("GADGETDOWN");
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					if(PLine = (struct PanelLine *)ThisG->UserData)
					{
						if(PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,ccd.Window);

						// If possibly changed in/out points, refresh clip display/icon slider
						if ((PLine==ccd.TimePL) && (ID == ID_LR_KNOB))
						{
							DUMPMSG("Post/Jog refresh");
							DrawClipDisplay(ccd.ClipDisp);
							LegalizeIconSlide(&ccd);		// Clip icon pos/move knob
						}
					}
					break;

				case IDCMP_GADGETUP:
					DUMPMSG	("GADGETUP");
					if (Down) Down = NULL;
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					PLine = (struct PanelLine *)ThisG->UserData;
					if((PLine) && (PLine->Handle) )
					{
						DUMPMSG	("HANDLE");
						PLine->Handle(PLine,IntuiMsg,ccd.Window);

						// If possibly changed in/out points, refresh clip display/icon slider
						if( PLine==ccd.TimePL )
						{
							DrawClipDisplay(ccd.ClipDisp);
							LegalizeIconSlide(&ccd);		// Clip icon pos/move knob
						}

						if(PLine==ccd.StrPL)					// Entered name string manually?
						{
							char	*ptr,c;
							BOOL	numonend=FALSE;

							ptr = ((struct StringInfo *)ccd.String->SpecialInfo)->Buffer;
							for (i=strlen(ptr)-1 ; i>0 ; i--)
							{
								c = ptr[i];
								if ((c<'0') || (c>'9'))
								{
									// Copy new prefix (even if no number on end)
									strncpy(ClipName2,ptr,i+1);		// Copy just the prefix

									if (numonend)		// Have specific number/fmt to use?
									{
										ClipName2[i+1] = 0;					// Terminate
										stcd_l(&ptr[i+1],(LONG *)&ccd.clipnum);	// Get new number
										ccd.clipnumdigits = strlen(&ptr[i+1]);		// Get # digits
									}
									else
									{
										ClipName2[i+1] = '.';				// Add '.' for them
										ClipName2[i+2] = 0;					// Terminate
										ccd.clipnum = 0;				// Start with .01
										ccd.clipnumdigits = 2;
									}
									break;
								}
								else numonend = TRUE;					// Yes, we can store this
							}
							ActivateGadget(Comm,ccd.Window,NULL);
						}

						DUMPHEXIL("Flags=",(LONG)PLine->Flags,"\\");
						if (PLine->Flags & PL_GENBUTT)
						{
							switch ((ULONG)PLine->Param)
							{
							case GB_REMOVE:		// Remove
								DUMPMSG	("DEL!");
								RemoveActiveClip(&ccd);		// Remove definition
								break;
							case GB_PREV:			// Prev
								PrevActiveClip(&ccd);		// Previous def
								break;
							case GB_NEXT:			// Next
								NextActiveClip(&ccd);		// Next def
								break;
							case GB_RECPANEL:		// To record panel
								Playing=FALSE;
								Going = FALSE;
								Success = PAN_RECORD;
//								DHD_Abort(0);
								break;
							case GB_CONTINUE:
							case GB_CANCEL:
								Playing=FALSE;
//								DHD_Abort(0);
								// (fall thru to std handler)
							default:
								DoGenButtons(PLine,ccd.Window,&Success,&Going);	// Other genbutt's
								break;
							}
						}
					}
					else switch (ID)
					{
//						case ID_DARK_CONTINUE:
//							DUMPMSG	("CONTINUE");
//							Success = PAN_CONTINUE;
//						case ID_REQ_DARK_CANCEL:
//							Playing=FALSE;
//							Going = FALSE;			//Success was initialized to FALSE
////							DHD_Abort(0);
//							break;
//						case ID_REC_PANEL:
//							Playing=FALSE;
//							Going = FALSE;			//Success was initialized to FALSE
//							Success = PAN_EASY;
////							DHD_Abort(0);
//							break;
						case CD_ID:
							if(ccd.cl)
							{
								BOOL	newnameup = FALSE;

								// Okay, clicked in the bar somewhere -- determine where
								t=ccd.Tmin + ((IntuiMsg->MouseX - ccd.ClipDisp->X)*0xFFFF)/ccd.ClipDisp->Scale;
								t&=~1;
								DUMPUDECW("MouseX= ",(WORD)IntuiMsg->MouseX,"  ");
								if( !(tcl=GetClip(ccd.ClipDisp,t)) )
								{
									DUMPUDECL("No Clip Found at ",(LONG)t,"\\");
									sprintf(ClipName,"%s%0*d",ClipName2,ccd.clipnumdigits,++ccd.clipnum);

									// Just add a piece, just so it's sorted into list
									tcl=AddClip(ccd.ClipDisp,t,t,CLIP_ACTIVE,ClipName);
									if (tcl)
									{
										newnameup = TRUE;

										// Left ALT means pointing at in-point
										if (!(IntuiMsg->Qualifier & IEQUALIFIER_LALT))
										{
											// Move inpoint to end of prev (or minimum if none)
											if( (ncl=(struct NewClip *)tcl->Node.mln_Pred) && ncl->Node.mln_Pred)
												tcl->in = ncl->out+FRAME_QUANT;
											else
												tcl->in = ccd.ClipDisp->MinVal;
										}

										// Right ALT means pointing at out-point
										if (!(IntuiMsg->Qualifier & IEQUALIFIER_RALT))
										{
											// Move outpoint to begin of prev (or maximum if none)
											if( (ncl=(struct NewClip *)tcl->Node.mln_Succ) && ncl->Node.mln_Succ)
												tcl->out = ncl->in-FRAME_QUANT;
											else
												tcl->out = ccd.ClipDisp->MaxVal;
										}
									}

//									tcl=AddClip(ccd.ClipDisp,in,out,CLIP_ACTIVE,ClipName);

//									if( (ncl=(struct NewClip *)tcl->Node.mln_Succ) && ncl->Node.mln_Succ )
//										tcl->out = ncl->in-FRAME_QUANT;
//									else
//										tcl->out=ccd.ClipDisp->MaxVal;
								}
								else DUMPUDECL("Hit clip at ",(LONG)t,"\\");

								if(tcl)
								{
									// Do everything to highlight new guy
									ChangeActiveClip(&ccd,tcl);

									if (newnameup)
									{
										// Activate name string gadget
										si = (struct StringInfo *) ccd.String->SpecialInfo;
										si->BufferPos = strlen(si->Buffer);		// Move cursor past end
										ActivateGadget(ccd.String,ccd.Window,NULL);
									}
								}
							}
							break;
					}
					break;

				case IDCMP_MOUSEMOVE:
				case IDCMP_MOUSEBUTTONS:
					if(Down)
					{
						PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,ccd.Window);
					}
					break;

				case IDCMP_INTUITICKS:
					if (TilQuiet>0)
					{
						if ((--TilQuiet)==0)
						{
							DHD_Quiet(Flds2Frms(MyRCB->Frame));
							ModifyIDCMP(ccd.Window,WinFlags);
						}
					}

					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						ModifyIDCMP(ccd.Window,WinFlags);
						EZGad=NULL;
						break;
					}
					if(!EZJump(Ticks++)) break;  // skip ticks
					ModifyIDCMP(ccd.Window,WinFlags); // turn off ticks
					if(MyRCB->pline->Flags&PL_IN)
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param) - ccd.Tmin)<<1;
					else
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param2) - ccd.Tmin)<<1;
					DUMPUDECL("Hi Time:",MyRCB->Max,"     " );
					DUMPUDECL("Lo Time:",MyRCB->Min,"    \\" );
					if(Adder>0) MyRCB->Flags = 0;
					else  MyRCB->Flags = DHD_PLAY_REV;
					DHD_Shuttle(MyRCB);
					EZGad=NULL;
					DrawClipDisplay(ccd.ClipDisp);
					LegalizeIconSlide(&ccd);			// Clip icon position, update slider
					UpdateAllDiff(ccd.RP,Start,ccd.Window);
					break;

				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					if(A<0x80)
					{
						qf = IntuiMsg->Qualifier;
						DUMPHEXIB("Key Code: ",A,"\\");
						switch(A)
						{
							case	RAW_IN:
								if(!In)	break;
								ActivateGadget(In,ccd.Window,NULL);
								ccd.TimePL->Flags &= ~PL_OUT;
								ccd.TimePL->Flags |= PL_IN;
								break;
							case	RAW_OUT:
								if(!Out)	break;
								ActivateGadget(Out,ccd.Window,NULL);
								ccd.TimePL->Flags &= ~PL_IN;
								ccd.TimePL->Flags |= PL_OUT;
								break;
							case	RAW_DEL:
								if(!ccd.String) break;
								ActivateGadget(ccd.String,ccd.Window,NULL);
								break;
							case	RAW_LEN:
								if(!Comm) break;
								ActivateGadget(Comm,ccd.Window,NULL);
								break;
							case	RAWKEY_X:
								RemoveActiveClip(&ccd);			// Do all necessary
								break;
							case	RAWKEY_LEFT:
								if(qf & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
									d = 30;
								else if(qf & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									d = (ccd.TimePL->PropEnd - ccd.TimePL->PropStart)/10+1;
								else
									d=(ccd.TimePL->Flags&PL_CFRAME) ? 2:1;

								if (ccd.TimePL->Flags & PL_IN)
									V=ccd.TimePL->Param;
								else
									V=ccd.TimePL->Param2;

								Y = *V;
								*V = (Y>=(*LoTime+d)) ? (Y-d) : (*LoTime);
								MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
								DHD_Jump(MyRCB,FALSE);

								WinFlags=ccd.Window->IDCMPFlags;
								ModifyIDCMP(ccd.Window,WinFlags|IDCMP_INTUITICKS);
								TilQuiet = 5;

								if (ccd.FramePL)
								{
									ccd.FramePL->PropEnd = ccd.cl->out;
									ccd.FramePL->PropStart = ccd.cl->in;
									if(ccd.cl->in==ccd.cl->out)
									{
										ccd.FramePL->PropEnd += 2;
										ccd.cl->icon=ccd.cl->in;
									}
								}

								UpdateAllDiff(ccd.RP,Start,ccd.Window);
								break;
							case RAWKEY_RIGHT:
								if(qf & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
									d = 30;
								else if(qf & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									d = (ccd.TimePL->PropEnd - ccd.TimePL->PropStart)/10+1;
								else
									d=(ccd.TimePL->Flags&PL_CFRAME) ? 2:1;

								if (ccd.TimePL->Flags & PL_IN)
									V=ccd.TimePL->Param;
								else
									V=ccd.TimePL->Param2;
								Y = *V;
								*V = (Y<=(*HiTime-d)) ? (Y+d) : (*HiTime);
								MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
								DHD_Jump(MyRCB,FALSE);

								WinFlags=ccd.Window->IDCMPFlags;
								ModifyIDCMP(ccd.Window,WinFlags|IDCMP_INTUITICKS);
								TilQuiet = 5;

								if (ccd.FramePL)
								{
									ccd.FramePL->PropEnd = ccd.cl->out;
									ccd.FramePL->PropStart = ccd.cl->in;
									if(ccd.cl->in==ccd.cl->out)
									{
										ccd.FramePL->PropEnd += 2;
										ccd.cl->icon=ccd.cl->in;
									}
								}
								UpdateAllDiff(ccd.RP,Start,ccd.Window);
								break;
							case RAWKEY_UP:
								if (ccd.TimePL->Flags & PL_IN)
									V=ccd.TimePL->Param;
								else
									V=ccd.TimePL->Param2;

								if(qf & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
								{
									*V = *HiTime;
									MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
									MyRCB->pline = ccd.TimePL;
									DHD_Jump(MyRCB,TRUE);
									UpdateAllDiff(ccd.RP,Start,ccd.Window);
								}
#if 0
								else if(qf & IEQUALIFIER_CONTROL )
								{
									*V = *HiTime;
									MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
									MyRCB->pline = ccd.TimePL;
									MyRCB->Flags = DHD_PLAY_REV;
									DHD_Jog(MyRCB);
									UpdateAllDiff(ccd.RP,Start,ccd.Window);
								}
#endif
								if (ccd.FramePL)
								{
									if(ccd.cl->in==ccd.cl->out)
									{
										ccd.FramePL->PropEnd += 2;
										ccd.cl->icon=ccd.cl->in;
									}
								}
								break;
							case RAWKEY_DOWN:
								if (ccd.TimePL->Flags & PL_IN)
									V=ccd.TimePL->Param;
								else
									V=ccd.TimePL->Param2;
								if(qf & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
								{
									*V = *LoTime;
									MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
									MyRCB->pline = ccd.TimePL;
									DHD_Jump(MyRCB,TRUE);
									UpdateAllDiff(ccd.RP,Start,ccd.Window);
								}
#if 0
								else if(qf & IEQUALIFIER_CONTROL )
								{
									*V = *LoTime;
									MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
									MyRCB->pline = ccd.TimePL;
									MyRCB->Flags = 0;
									DHD_Jog(MyRCB);
									UpdateAllDiff(ccd.RP,Start,ccd.Window);
								}
#endif
								if (ccd.FramePL)
								{
									if(ccd.cl->in==ccd.cl->out)
									{
										ccd.FramePL->PropEnd += 2;
										ccd.cl->icon=ccd.cl->in;
									}
								}
								break;
							case RAWKEY_S:			// make still
								// First, grab "out" point
								ccd.TimePL->Flags &= ~PL_IN;
								ccd.TimePL->Flags |= PL_OUT;
								SetHiLo(ccd.TimePL);

								V=ccd.TimePL->Param2;		// Adjust out point
								*V = *LoTime;			// Go as low as possible
								MyRCB->Frame = (ULONG)(*V - ccd.Tmin)<<1;
								MyRCB->pline = ccd.TimePL;
								MyRCB->Flags = 0;
								DHD_Jump(MyRCB,TRUE);
								UpdateAllDiff(ccd.RP,Start,ccd.Window);

								if (ccd.FramePL)
								{
									if(ccd.cl->in==ccd.cl->out)
									{
										ccd.FramePL->PropEnd += 2;
										ccd.cl->icon=ccd.cl->in;
									}
								}
								DrawClipDisplay(ccd.ClipDisp);
								LegalizeIconSlide(&ccd);			// Clip icon position, update slider
								break;
							case RAWKEY_N:			// next clip
							case RAWKEY_PLUS:		// ditto
							case RAWKEY_PAD_PLUS:	// ditto
								NextActiveClip(&ccd);
								break;
							case RAWKEY_P:				// prev clip
							case RAWKEY_MINUS:		// ditto
							case RAWKEY_PAD_MINUS:	// ditto
								PrevActiveClip(&ccd);
								break;
#ifdef CUT_ROOM_HELP
							case RAWKEY_HELP:
								//*** CTRL+HELP ---> Put up "Help" requester
								SimpleRequest(ccd.Window,HelpMsg,17,REQ_H_CENTER,NULL);
								break;
#endif
						}
					}
					else if( (A==(RAW_KEYUP|RAWKEY_LEFT))
							|| (A==(RAW_KEYUP|RAWKEY_RIGHT))
							||	(A==(RAW_KEYUP|RAWKEY_DOWN))
							|| (A==(RAW_KEYUP|RAWKEY_UP)) )	// key-up
					{
						DrawClipDisplay(ccd.ClipDisp);
						LegalizeIconSlide(&ccd);			// Clip icon position, update slider
					}
					if ((A == RAWKEY_PAD_ENTER)||(A == RAWKEY_RETURN))
					{
						Going = FALSE;
						Playing=FALSE;
						Success = PAN_CONTINUE;
					}
					else if((A == RAWKEY_ESC)) Going = FALSE;
					break;
				}
				ReplyMsg((struct Message *)IntuiMsg);
			}
		}
		CloseWindow(ccd.Window);
		WaitBlit();
	}
rErrExit:

	partsPL->PropStart += stripbase+1;

//	DUMPUDECL("(Include code would have been ",partsPL->PropStart,")\\");

 if((Success == PAN_CONTINUE) && (ccd.ClipDisp))		// Do it?
 {
	// Compute destination volume/path
	if (destPL)
	{
		if (destPL->PropStart != FlyerDriveCount)		// "Same as Source"?
		{
			FlyDrive = FlyerDrives[destPL->PropStart];	// Find volume string picked
			if(*FlyDrive==AUDIO_BYTE)
				FlyDrive+=2;					// Skip speaker symbol char and space

			// Prepend just the selected volume name before all files made here
			strcpy(ClipPath,FlyDrive);
		}
	}

//	DUMPSTR("Processing to path:");
//	DUMPMSG(ClipPath);

	if (FromRawClip)
	{
		if (WFF_WARN_CUTTING & UserPrefs.WarnFlags)		// Req only if enabled
			MPtr[0] = "Are you sure you want to begin cutting?";
		else
			MPtr[0] = NULL;
	}
	else
		MPtr[0] = "This will destroy the original clip!";

	if ((!destructive) || (MPtr[0] == NULL) || (BoolRequest(EditTop->Window,MPtr[0])))
	{
		// If any name exists or are used multiple times, reopen and fix!
		ok = ClipDisplayNameCheck(ccd.ClipDisp,ClipPath,EditTop->Window);
		if (ok<0)
			goto ReOpen;

//		if (ok && (*Strip))
		if (ok)
		{
			ClipFlags=0;
//			if((*Strip&1))
			if (partsPL->PropStart & 1)
				ClipFlags |= CAF_VIDEO;
//			if((*Strip&2))
			if (partsPL->PropStart & 2)
				ClipFlags |= CAF_AUDIO;

			error = CutClipDownload(ccd.ClipDisp,ClipPath,ClipFlags);
			if (error == FERR_OKAY)
			{
				if (destructive)
					sprintf(pstr,"              Cutting clips on drive %s",FlyDrive);
				else
					sprintf(pstr,"              Processing clips on drive %s",FlyDrive);
				OpenNoticeWindow(EditTop->Window,PatienceMsg,2,FALSE);

				// Close the cut list -- this lets the Flyer make all the clips
				error = DHD_EndClipList(1);
				ListOpen = FALSE;

				DUMPMSG("List is closed");

				// If includes video, make an icon for each sub-clip
				if(ClipFlags&CAF_VIDEO)
				{
					DUMPMSG("Making icons");
					ClipDisplayIcons(ccd.ClipDisp,ClipPath);
				}

				CloseNoticeWindow();

				// Check for Flyer refusing to cut clip because all pieces won't fit
				if (error == FERR_FULL)
				{
					if (destructive)			// Destructive version
					{
						MPtr[0] = "All the new clips will not fit in original clip's space";
						MPtr[1] = "Re-adjust in/out points to reduce overlap";
						SimpleRequest(EditTop->Window,MPtr,2,REQ_CENTER|REQ_H_CENTER,NULL);
						goto ReOpen;
					}
					else						// (Non-destructive)
					{
						MPtr[0] = "One or more clips would not fit on drive, and were";
						MPtr[1] = "therefore skipped.  Processing panel will re-open";
						MPtr[2] = "showing only those that were skipped";
						SimpleRequest(EditTop->Window,MPtr,3,REQ_CENTER|REQ_H_CENTER,NULL);

						//	Check what clips succeeded, remove them from list
						RemoveClipsDone(ccd.ClipDisp,ClipPath,EditTop->Window);

						goto ReOpen;
					}
				}
				else if (error != FERR_OKAY)			// Failed somehow?
				{
					MPtr[0] = "Failed to cut all clips";
					sprintf(pstr,"Internal error %ld",error);
					MPtr[1] = pstr;
					SimpleRequest(EditTop->Window,MPtr,2,REQ_CENTER|REQ_H_CENTER,NULL);
					if (!destructive)
						goto ReOpen;			// Let'em try again
					else
						error = FERR_OKAY;	// Must not retry, as original is likely gone!!!
				}
			}
			else
			{
				DHD_EndClipList(0);		// Abort list
				ListOpen = FALSE;
			}

			if (error != FERR_OKAY)
				goto ReOpen;
		}

		// If destructive clip cutting was performed, destroy original
		if(destructive)
		{
//			strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);				// OBSOLETE!!
//			strncat(ClipName,TEMP_CLIP_NAME,CLIP_PATH_MAX);
			CrDeleteFile(SrcName);
		}
	}
	else
	{
		// Do this if user panics at the "destroy original clip" req
		DHD_EndClipList(0);		// Abort list
		ListOpen = FALSE;
		goto ReOpen;
	}
 }

	if (ccd.ClipDisp)
		FreeClipDisplay(ccd.ClipDisp);

	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine && PLine->Destroy && (PLine->Type != PNL_SKIP))
			PLine->Destroy(PLine);
	}

	// If we failed to finish download to Flyer, close it
	if (ListOpen)
		DHD_EndClipList(0);

	return(Success);
}




UWORD __asm MiniPanel(REG(a0) struct EditWindow *Edit,REG(a1) struct PanelLine *PLine, REG(d0) UWORD XPMode)
{
	WORD H = PNL_Y1,ID,A,B,X1=0,Y1=0,Lines=0;
	struct Gadget *ThisG=0;
//	struct Gadget *ContCan;
	struct Window *Window=0;
	struct RastPort *RP;
	BOOL Going = TRUE;
	UWORD Success = PAN_CANCEL;
	struct IntuiMessage *IntuiMsg;
	struct StringInfo *si;
	ULONG Y=0;
//	LONG F;

	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL; LastString=NULL;
	Wide=FALSE;
	for(Start = PLine; PLine->Type && !Wide; PLine++ )
	{
		if ((PPOS_WIDER & PLine->Align) || (PPOS_HALF2 & PLine->Align))
			Wide=TRUE;
	}

	ClipNW.Flags = STD_FLAGS;		// Default window flags

	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine->Type != PNL_SKIP)
		{
			if (PPOS_HALF2 & PLine->Align)
				X1 = PNL_WIDTH;

			// Call the gadget's create function
			if(PLine->Create)		Y1=PLine->Create(X1,H,PLine,&ThisG);

			if(PPOS_WIDER & PLine->Align)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
				else
					H += Y1;					// Was no left half
				X1 = 0;
				Y = 0;
			}
			if(PLine->Flags)
			{
				if(PLine->Flags&PL_IN)
					In=PLine->StrGadg;
				else if(PLine->Flags&PL_OUT)
					Out=PLine->StrGadg;
				else if(PLine->Flags&PL_DEL)
					Del=PLine->StrGadg;
				else if(PLine->Flags&PL_LEN)
					Len=PLine->StrGadg;
				if(PLine->Flags&PL_SMREF)		// Somebody wants smart refresh
					ClipNW.Flags = REC_FLAGS;
			}
			Lines++;
		}
	}

	if(X1>0) H += MAX(Y,Y1);  // last gad...
	if(Wide) X1=PNL_WIDTH;


//	if(ContCan=CreateContCancel(X1,H,&ThisG,XPMode))
//		H += (UWORD)(PNL_YADD + ContCan->Height);
//	else goto ErrExit;


	ClipNW.Width = PNL_WIDTH + (Wide ? PNL_WIDTH:0);
	ClipNW.Height = H;
	ClipNW.Screen = EditScreen;
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = EditTop->Window->TopEdge; // MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
	ClipNW.FirstGadget = NULL;
	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		SoftSpriteOff();				// Shut off for the duration -- faster, and less flash

		RP = Window->RPort;
		ClipNW.Flags = STD_FLAGS;
		SetDrMd(RP,JAM2);
		AddGList(Window,FirstG,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		SetFont(RP,DarkFont);
//		RefreshGList(ContCan,Window,NULL,-1);
		H = PNL_Y1;

		PLine = Start;
		X1 = 0;
		Y = 0;
		while (PLine->Type)
		{
			if(PLine->Type != PNL_SKIP)
			{
				PLine->Win = Window;

				if (PPOS_HALF2 & PLine->Align)
					X1 = PNL_WIDTH;

				// Call the gadget's draw function
				if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,Window);

				if(PLine->Flags & PL_ACTIVATE)
				{
					si = (struct StringInfo *) PLine->StrGadg->SpecialInfo;
					si->BufferPos = strlen(si->Buffer);		// Move cursor past end
					ActivateGadget(PLine->StrGadg,Window,NULL);
				}

				if(PPOS_WIDER & PLine->Align)
				{
					X1 = PNL_WIDTH;
					Y = Y1;
				}
				else
				{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
				else
					H += Y1;					// Was no left half
					X1 = 0;
					Y = 0;
				}
			}
			PLine++;
		}

		SoftSpriteOn();

		// handle window events
		goto GetEm;
		while (Going)
		{
				WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
				switch(IntuiMsg->Class) {
				case IDCMP_GADGETDOWN:
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					if(LastString)
					{
						if(PLine = (struct PanelLine *)LastString->UserData)
						{
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								//Y=FixTimeStr(PLine,Window,FALSE);
								Y=FixTimeStr(PLine,Window,TRUE);
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strcpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer);
						}
						LastString=NULL;
					}
					if(!(PLine = (struct PanelLine *)ThisG->UserData)) break;
					if(ID==STRING_ID)	LastString=ThisG;
					if(PLine->Handle) PLine->Handle(PLine,IntuiMsg,Window);
					break;

				case IDCMP_GADGETUP:
//					DUMPMSG	("GADGETUP");

					if (Down)
					{
						Down = NULL;
						ModifyIDCMP(Window,WinFlags);
					}
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;

					if(LastString && LastString!=ThisG)
					{
						if(PLine = (struct PanelLine *)LastString->UserData)
						{
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								//FixTimeStr(PLine,Window,FALSE);
								FixTimeStr(PLine,Window,TRUE);
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->PropEnd);
						}
						LastString=NULL;
					}

					PLine = (struct PanelLine *)ThisG->UserData;

					if(PLine && PLine->Handle)
					{
						PLine->Handle(PLine,IntuiMsg,Window);

						DoGenButtons(PLine,Window,&Success,&Going);

						if (PLine->Flags & PL_GENBUTT)
						{
							switch ((ULONG)PLine->Param)
							{
							case GB_REORG:		// Reorg drive
								Going = FALSE;				// Exit panel
								Success = PAN_EASY;		// Re-open panel again
								break;
							}
						}

					}
//					else switch (ID)
//					{
//						case ID_DARK_CONTINUE:
//							DUMPMSG	("CONTINUE");
//							Success = PAN_CONTINUE;
//						case ID_REQ_DARK_CANCEL:
//							Going = FALSE;			//Success was initialized to FALSE
//							break;
//						case ID_FINE_TUNE:
//							Going = FALSE;
//							Success = PAN_EXPERT;
//							break;
//						case ID_QUICK_TUNE:
//							Going = FALSE;
//							Success = PAN_EASY;
//							break;
//					}
					break;

				case IDCMP_MOUSEMOVE:
				case IDCMP_MOUSEBUTTONS:
					if(Down)
					{
						PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,Window);
					}
					break;

				case IDCMP_INTUITICKS:
					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						ModifyIDCMP(Window,WinFlags);
						EZGad=NULL;
						break;
					}

					// Handle ticks to EZ gadgets
					TickEZLenPL((struct PanelLine *)EZGad->UserData,Window,EZJump(Ticks++));

//					if(EZJump(Ticks++))  // skip ticks
//					{
//						if( !(PLine=(struct PanelLine *)EZGad->UserData) ) break;
//
//						if( ((F=*PLine->Param) >= PLine->PropStart) || (Adder>0))  // negative #s
//							F += Adder*EZJump(Ticks);
//						else break;
//						if(Adder<0)
//							*(PLine->Param) = (F>=PLine->PropStart ? F:PLine->PropStart);
//						else
//							*(PLine->Param) = (F<=PLine->PropEnd ? F:PLine->PropEnd);
//						UpdatePanProp(PLine,Window);
//						UpdatePanStr(PLine,Window);
//						UpdateAllDiff(RP,Start,Window);
//					}
					break;

				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					if(A<0x80)
					{
						B = IntuiMsg->Qualifier;
						DUMPHEXIB("Key Code: ",A,"\\");
						switch(A)
						{
							case	RAW_IN:
								if(In)	ActivateGadget(In,Window,NULL);
								break;
							case	RAW_OUT:
								if(Out)	ActivateGadget(Out,Window,NULL);
								break;
							case	RAW_LEN:
								if(Len)	ActivateGadget(Len,Window,NULL);
								break;
							case	RAW_DEL:
								if(Del)	ActivateGadget(Del,Window,NULL);
								break;
							case	RAWKEY_PAD_ENTER:
							case	RAWKEY_RETURN:
								Going = FALSE;
								Success=TRUE;
								break;
							case	RAWKEY_HELP:
								if(XPMode==TUNE_FINE)
								{
									Success = PAN_EXPERT;
									Going = FALSE;
								}
								else if(XPMode==TUNE_QUICK)
								{
									Success = PAN_EASY;
									Going = FALSE;
								}
//								else
//									Success = PAN_CONTINUE;
								break;
//							case	RAWKEY_F9:  // Inert on panels without Quick/fine tune button
//								if(XPMode==TUNE_FINE) Success = PAN_EXPERT;
//								else if(XPMode==TUNE_QUICK) Success = PAN_EASY;
//								else break;
//								Going = FALSE;
//								break;
							case	RAWKEY_ESC:
								Going = FALSE;
								break;
						}
					}
					break;
				}
				ReplyMsg((struct Message *)IntuiMsg);
			}
		}

		CloseWindow(Window);
		WaitBlit();

// update modified parameters
		PLine = Start;
		while (PLine->Type)
		{
			switch(PLine->Type) {
			case PNL_IN_TYPE:
			case PNL_OUT_TYPE:
				if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
				else *(PLine->Param) = 0;
				break;
			}
			PLine++;
		}
	}
//ErrExit:
	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine && PLine->Destroy && (PLine->Type!=PNL_SKIP) )
			PLine->Destroy(PLine);
	}
//	if (ContCan) FreeGadgets(ContCan);

	return(Success);
}


/*********************************************
*
* Allocate and init Envelope Type Gadget
*
*********************************************/
struct AudEnvDisp *NewEnvGad(	struct RastPort *RP,
									 	struct RastPort *DBRP,
									 	UWORD X,
									 	UWORD Y,
										UWORD W,
										UWORD H,
										ULONG GADID)
{
	struct AudEnvDisp *aev;

	// allocate the Envelope structure

	if (aev = AllocMem(sizeof(struct AudEnvDisp),MEMF_PUBLIC|MEMF_CLEAR))
	{

		// init the Envelope structure
		aev->X=X;
		aev->Y=Y;
		aev->W=W;
		aev->H=H;
		aev->InPoint=0;
		aev->OutPoint=0;
		aev->MinVal=0;
		aev->MaxVal=0;
		aev->HScale=0;
		aev->VScale=0;
		aev->KeyCount=0;
		aev->RP=RP;
		aev->DRP=DBRP;
		aev->DBM=DBRP->BitMap;
		aev->SELECTED_KEY=NULL;

		NewList(&aev->AEDKeys);
	
		// init the Envelope Gadget structure
		aev->EnvDispGadget.NextGadget=NULL;
		aev->EnvDispGadget.LeftEdge=X-2;
		aev->EnvDispGadget.TopEdge=Y-2;
		aev->EnvDispGadget.Width=W+6;
		aev->EnvDispGadget.Height=H+5;
		aev->EnvDispGadget.Flags=GFLG_GADGHNONE;
		aev->EnvDispGadget.Activation=RELVERIFY|GACT_IMMEDIATE; //|GACT_FOLLOWMOUSE;
		aev->EnvDispGadget.GadgetType=BOOLGADGET;
		aev->EnvDispGadget.GadgetRender=NULL;
		aev->EnvDispGadget.GadgetText=NULL;
		aev->EnvDispGadget.MutualExclude=NULL;
		aev->EnvDispGadget.SpecialInfo=NULL;
		aev->EnvDispGadget.GadgetID=GADID;
		aev->EnvDispGadget.UserData=NULL;
		return(aev);
	}
	else
		return(NULL);

}


/*************************************************************
*
* ValidEnvTag - Fix audio Env Tag due to in/out point changs.
*
*************************************************************/
void	ValidEnvTag(struct AudioEnv *AEtag,LONG InPoint, LONG OutPoint,UWORD Mode)
{

struct VE_Key	{
	struct MinNode	MN;
	ULONG	Time;
	UWORD	Flags;
	UWORD	VOL1;
	UWORD	VOL2;
	WORD	PAN1;
	WORD	PAN2;
	};

	struct MinList AE_VList;
	struct VE_Key	*NewAE_VNode,*AE_VNode,*OldAE_VNode;
	ULONG FInPoint,FOutPoint,curr_time;
	
	UWORD	 i;

	FInPoint	= InPoint*2;
	FOutPoint = OutPoint*2;

	DUMPUDECL("\\FInPoint  ",FInPoint,"\\");
	DUMPUDECL("FOutPoint ",FOutPoint,"\\");


	if(AEtag->Keysused==0)
	{
		AEtag->AEKeys[0].GoTime=FInPoint;
		AEtag->AEKeys[0].NumOfFlds=0;
		AEtag->AEKeys[0].Flags=0x666;
 		AEtag->AEKeys[0].VOL1=65535/2;  
 		AEtag->AEKeys[0].VOL2=65535/2;  
 		AEtag->AEKeys[0].PAN1=-32768;  
 		AEtag->AEKeys[0].PAN2=32767;

		AEtag->AEKeys[0].GoTime=FInPoint+4;
		AEtag->AEKeys[0].NumOfFlds=FOutPoint-FInPoint-4;
		AEtag->AEKeys[0].Flags=0x666;
 		AEtag->AEKeys[0].VOL1=65535/2;  
 		AEtag->AEKeys[0].VOL2=65535/2;  
 		AEtag->AEKeys[0].PAN1=-32768;  
 		AEtag->AEKeys[0].PAN2=32767;
	}
	else
	{
		NewList(&AE_VList);
		for(i=0;i<AEtag->Keysused;i++)
		{
			if(NewAE_VNode=AllocMem(sizeof(struct VE_Key),MEMF_PUBLIC|MEMF_CLEAR))
			{
				AddTail(&AE_VList,NewAE_VNode);
				NewAE_VNode->Time = AEtag->AEKeys[i].GoTime+AEtag->AEKeys[i].NumOfFlds;
				NewAE_VNode->Flags = AEtag->AEKeys[i].Flags;
				NewAE_VNode->VOL1 = AEtag->AEKeys[i].VOL1;
				NewAE_VNode->VOL2 = AEtag->AEKeys[i].VOL2;
				NewAE_VNode->PAN1 = AEtag->AEKeys[i].PAN1;
				NewAE_VNode->PAN2	= AEtag->AEKeys[i].PAN2;
			}
		}

		// Scan list remove nodes outside In/Out points.
		AE_VNode=AE_VList.mlh_Head; 
		do 
		{
			if((AE_VNode->Time<FInPoint)||(AE_VNode->Time>FOutPoint))
			{
				OldAE_VNode=AE_VNode;
				AE_VNode=AE_VNode->mln_Succ;
				Remove(OldAE_VNode);
				DUMPUDECL("Node gotime ",OldAE_VNode->Time,"\\");
				DUMPUDECL("Freeing node ",OldAE_VNode,"\\");
				FreeMem(OldAE_VNode,sizeof(struct VE_Key));
			}
			else
			{
				AE_VNode=AE_VNode->mln_Succ;
			}
		} while(AE_VNode->mln_Succ);	

		// count keys in list
		i=0;
		for(AE_VNode=AE_VList.mlh_Head;AE_VNode->mln_Succ;AE_VNode=AE_VNode->mln_Succ)
		{
			i++;
		}

		if(i==0)
		{
			NewAE_VNode=AllocMem(sizeof(struct VE_Key),MEMF_PUBLIC|MEMF_CLEAR);
			AddTail(&AE_VList,NewAE_VNode);

			NewAE_VNode->Time=FInPoint;
			NewAE_VNode->Flags = 0x666;
			NewAE_VNode->VOL1 = 65535/2;
			NewAE_VNode->VOL2 = 65535/2;
			NewAE_VNode->PAN1 = -32768;
			NewAE_VNode->PAN2	= 32767;
 
			NewAE_VNode=AllocMem(sizeof(struct VE_Key),MEMF_PUBLIC|MEMF_CLEAR);
			AddTail(&AE_VList,NewAE_VNode);

			NewAE_VNode->Time=FOutPoint;
			NewAE_VNode->Flags = 0x666;
			NewAE_VNode->VOL1 = 65535/2;
			NewAE_VNode->VOL2 = 65535/2;
			NewAE_VNode->PAN1 = -32768;
			NewAE_VNode->PAN2	= 32767;
		}
	
		if(i==1) 
		{
			OldAE_VNode=AE_VList.mlh_Head;
			NewAE_VNode=AllocMem(sizeof(struct VE_Key),MEMF_PUBLIC|MEMF_CLEAR);
			AddTail(&AE_VList,NewAE_VNode);
			NewAE_VNode->Flags = OldAE_VNode->Flags;
			NewAE_VNode->VOL1 = OldAE_VNode->VOL1;
			NewAE_VNode->VOL2 = OldAE_VNode->VOL2;
			NewAE_VNode->PAN1 = OldAE_VNode->PAN1;
			NewAE_VNode->PAN2	= OldAE_VNode->PAN2;

			OldAE_VNode->Time=FInPoint;
			NewAE_VNode->Time=FOutPoint;
		}	
	
		if(i>1)
		{
			AE_VNode=AE_VList.mlh_Head;
			AE_VNode->Time=FInPoint;

			AE_VNode=AE_VList.mlh_TailPred;
			AE_VNode->Time=FOutPoint;
		}			

		curr_time=FInPoint;
		i=0;
		for(AE_VNode=AE_VList.mlh_Head;AE_VNode->mln_Succ;AE_VNode=AE_VNode->mln_Succ)
		{
			DUMPHEXIL("Copying Node to table ",AE_VNode,"\\");
			AEtag->AEKeys[i].GoTime = curr_time;
			AEtag->AEKeys[i].NumOfFlds = AE_VNode->Time-curr_time;
			AEtag->AEKeys[i].Flags = AE_VNode->Flags;	
			AEtag->AEKeys[i].VOL1 = AE_VNode->VOL1;
			AEtag->AEKeys[i].VOL2 = AE_VNode->VOL2;
			AEtag->AEKeys[i].PAN1 = AE_VNode->PAN1;
			AEtag->AEKeys[i].PAN2 = AE_VNode->PAN2;
			curr_time=AE_VNode->Time;
			if(curr_time==FInPoint)
				curr_time += 4;
			i++;
		}
		AEtag->Keysused = i;

		while(AE_VNode=RemHead(&AE_VList)) 
		{ 
			DUMPHEXIL("Final Freeing node ",AE_VNode,"\\");
			FreeMem(AE_VNode,sizeof(struct VE_Key));	
		}
	}
}




/*************************************************************
*
* TagtoKL - Make Key list from AudEnv16 struct.
*
*************************************************************/
void	TagtoKL(struct AudEnvDisp *aev,struct AudioEnv *AEtag)
{
	struct AEDKey *NewAEDNode;
	UWORD	 i;


	if(AEtag->Keysused==0)
	{
		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			AddTail(&aev->AEDKeys,NewAEDNode);	
			//DUMPHEXIL("&aev.AEDKeys=",(LONG)&aev.AEDKeys,"  ");
			//DUMPHEXIL("NewAEDNode=",(LONG)NewAEDNode,"\\");
			NewAEDNode->Time = aev->InPoint;
			NewAEDNode->Scaled_Time = 0;
			NewAEDNode->Value = 65535/2;
			NewAEDNode->Scaled_Val = NewAEDNode->Value/1307;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = TimeLocked;
		}

		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			AddTail(&aev->AEDKeys,NewAEDNode);	
			//DUMPHEXIL("&aev.AEDKeys=",(LONG)&aev.AEDKeys,"  ");
			//DUMPHEXIL("NewAEDNode=",(LONG)NewAEDNode,"\\");
			NewAEDNode->Time = aev->OutPoint;
			NewAEDNode->Scaled_Time = 0;
			NewAEDNode->Value = 65535/2;
			NewAEDNode->Scaled_Val = NewAEDNode->Value/1307;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = TimeLocked;
		}
	}
	else
	{
		

		DUMPUDECL("\\aev->InPoint        = ",aev->InPoint,"\\");
		DUMPUDECL("aev->OutPoint           = ",aev->OutPoint,"\\");
		DUMPUDECL("AEtag->AEKeys[0].GoTime = ",AEtag->AEKeys[0].GoTime,"\\ \\");

		for(i=0;i<AEtag->Keysused;i++)
		{
			if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
			{
				AddTail(&aev->AEDKeys,NewAEDNode);
				NewAEDNode->Time = ((AEtag->AEKeys[i].GoTime+AEtag->AEKeys[i].NumOfFlds)/2);
				NewAEDNode->Scaled_Time = 0;
				NewAEDNode->Value = 0xffff-AEtag->AEKeys[i].VOL1;
				NewAEDNode->Scaled_Val = NewAEDNode->Value/1307;
				NewAEDNode->Act = AEDKey_act;
				NewAEDNode->Att = Deleteable;					
			}
		}	
		NewAEDNode=aev->AEDKeys.mlh_TailPred;
		NewAEDNode->Att = TimeLocked;					
		
		NewAEDNode=aev->AEDKeys.mlh_Head;
		NewAEDNode->Att = TimeLocked;					
	}
}



/*************************************************************
*
* KLtoTag - Make AudEnv16-Tag from a key list.
*
*************************************************************/
void	KLtoTag(struct AudEnvDisp *aev,struct AudioEnv *AEtag)
{
	struct AEDKey *AEDNode;
	struct MinList *AEDHead;
	ULONG	 curr_time;
	int i=-1;
	struct AEKey *CurrKey;


	AEDHead = &aev->AEDKeys;	

	curr_time=aev->InPoint;
	DUMPUDECL("CurrTime",curr_time,"\\");
	

	for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
	{
		i++;
		CurrKey=&AEtag->AEKeys[i];

		CurrKey->Flags=0x0666;
		CurrKey->GoTime=curr_time*2;
		CurrKey->NumOfFlds=(AEDNode->Time-curr_time)*2;
		DUMPUDECL("Durr of ramp",CurrKey->NumOfFlds,"\\");
		
		CurrKey->VOL1=0xffff-AEDNode->Value;
		CurrKey->VOL2=0xffff-AEDNode->Value;
		CurrKey->PAN1=-32768;
		CurrKey->PAN2=32767;
		
		curr_time=AEDNode->Time;
		if(curr_time==aev->InPoint)
			curr_time += 2;

	}
	AEtag->Keysused = i+1;
	AEtag->Flags 	=	0;
}




/*************************************************
*
*
*	SetTimeBounds -- Sets Panel Line PropStart/End
*
*
*************************************************/
void	SetTimeBounds(struct AudEnvDisp *aev,
						  struct PanelLine *PTime)
{
	
	struct AEDKey *prev,*next;



	if(aev->SELECTED_KEY)
	{	
		if(aev->SELECTED_KEY->Att&0x01)
		{
			DUMPMSG	("Got key its timelocked");
			PTime->PropStart=aev->SELECTED_KEY->Time;
			PTime->PropEnd=aev->SELECTED_KEY->Time;
		}	
		else
		{
			next=aev->SELECTED_KEY->mln_Succ;
			prev=aev->SELECTED_KEY->mln_Pred;

			DUMPMSG	("Got key, not timelocked");
			PTime->PropStart=prev->Time+4;
			PTime->PropEnd=next->Time-4;
		}
	}
}



/*************************************************
*
*
* AdjKeyValStr -- 
*
*
*************************************************/
void	AdjKeyValStr(struct AudEnvDisp *aev,
						 struct AEDKey *SelNode,
						 struct PanelLine *PNum,
						 struct Window *Window)
{

	*PNum->Param=(100-(SelNode->Value/655));
	UpdatePanStr(PNum,Window);
	DUMPMSG	("In adjkeyval after updatestring");

}


/*************************************************
*
*
* AdjKeyTimeStr -- 
*
*
*************************************************/
void	AdjKeyTimeStr(struct AudEnvDisp *aev,
						  struct AEDKey *SelNode,
						  struct PanelLine *PTime,
						  struct Window *Window)
{
	*PTime->Param=SelNode->Time;
	UpdatePanStr(PTime,Window);
	DUMPMSG	("In adjkeyTime after updatestring");

}




/**************************************************
*
* SelectEnvKey -- Select the envlope key closest to
*						where user clicked, or none(NULL)
*
**************************************************/
struct AudEnvDisp  *SelectEnvKey(struct AudEnvDisp *aev,
											UWORD	X, UWORD Y, 
											struct PanelLine *PTime)
{
	struct MinList	*AEDHead;
	struct AEDKey	*AEDNode,*SelNode=NULL;
	UWORD Selabs_off=1000,abs_off=1000;	
	

	X -= aev->X; 
	Y -= aev->Y;	

	//DUMPHEXIW("In SelectEnvKey\\X= ",(UWORD)X,"\\");
	//DUMPHEXIW("Y= ",(UWORD)Y,"\\");

	AEDHead=&aev->AEDKeys;
	
	for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
	{
		abs_off=(abs((AEDNode->Scaled_Time-aev->MinVal)-X)+abs(AEDNode->Scaled_Val-Y));
		//DUMPHEXIW("abs_off= ",(UWORD)abs_off,"\\");
		if(abs_off<=12)
		{	
			if(SelNode)
			{
				if(abs_off<Selabs_off)
				{	
					SelNode=AEDNode;
					Selabs_off=abs_off;
				}
			}
			else
			{	
				SelNode=AEDNode;
				Selabs_off=abs_off;
			}
		}
	}

	if(SelNode)
	{
		for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
		{
			if(AEDNode->Act!=AEDKey_Inact)
				AEDNode->Act=AEDKey_act;
		}		
		SelNode->Act=AEDKey_sel;
		RedrawAudioevn(aev);

	}
	aev->SELECTED_KEY=SelNode;
	SetTimeBounds(aev,PTime);
	return(SelNode);
}




/**************************************************************
*
* SelectNextEnvKey -- Select the Next key to the one selected
*
**************************************************************/
struct AudEnvDisp  *SelectNextEnvKey(struct AudEnvDisp *aev,
												 struct PanelLine *PTime)
{
	struct MinList	*AEDHead;
	struct AEDKey	*AEDNode,*SelNode=NULL;

	AEDHead=&aev->AEDKeys;
	for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
	{
		if(AEDNode->Act==AEDKey_sel)
		{
			AEDNode->Act=AEDKey_act;
			SelNode = AEDNode->mln_Succ;
			SelNode->Act=AEDKey_sel;

		}
	}		
	RedrawAudioevn(aev);
	aev->SELECTED_KEY=SelNode;
	//SetPTimeLimits(aev,PTime);
	SetTimeBounds(aev,PTime);
	return(SelNode);
}	




/**************************************************************
*
* SelectPrevEnvKey -- Select the prev key to the one selected
*
**************************************************************/
struct AudEnvDisp  *SelectPrevEnvKey(struct AudEnvDisp *aev,
												 struct PanelLine *PTime)
{
	struct MinList	*AEDHead;
	struct AEDKey	*AEDNode,*SelNode=NULL;

	AEDHead=&aev->AEDKeys;
	for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
	{

		if(AEDNode->Act==AEDKey_sel)
		{
			AEDNode->Act=AEDKey_act;
			SelNode = AEDNode->mln_Pred;
			SelNode->Act=AEDKey_sel;

		}

	}		
	RedrawAudioevn(aev);
	aev->SELECTED_KEY=SelNode;
	//SetPTimeLimits(aev,PTime);
	SetTimeBounds(aev,PTime);
	return(SelNode);
}



/******************************************************
*
*	DeleteEnvKey --
*
*
******************************************************/
void	DeleteEnvKey(struct AudEnvDisp *aev,
						 struct AEDKey *AEDNode,
 						 struct Window *Window,
						 struct PanelLine *PTime,
						 struct PanelLine *PNum)

{
	struct AEDKey *BNode;

	if(AEDNode -> Att & 0x02)
	{
		BNode = SelectPrevEnvKey(aev,PTime);
		Remove(AEDNode);
		FreeMem(AEDNode,sizeof(struct AEDKey));	
		RedrawAudioevn(aev);
		AdjKeyTimeStr(aev,BNode,PTime,Window);
		AdjKeyValStr(aev,BNode,PNum,Window);
	}
}


/******************************************************
*
* Timematch - See if any nodes fall on this time code.
*
*
******************************************************/
BOOL	Timematch(struct AudEnvDisp *aev,ULONG TIME)
{
	struct MinList *AEDHead;
	struct AEDKey  *AEDNode;
	BOOL	Match=FALSE;


	AEDHead=&aev->AEDKeys;
	for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
	{
		if(AEDNode->Time==TIME)
			Match=TRUE;
	}		
	return(Match);
}





/******************************************************
*
* CreateEnvKey	-- 
*				  		
*
******************************************************/
void	CreateEnvKey(struct AudEnvDisp *aev,
						 struct Window *Window,
				 		 struct IntuiMessage *IntuiMsg,
						 struct PanelLine *PTime,
						 struct PanelLine *PNum)

{
	struct MinList *AEDHead;
	struct AEDKey  *NewAEDNode, *AEDNode, *SN_Hi, *SN_Low;
	UWORD  MX,MY;
	ULONG	 NewTime;

	MX=IntuiMsg->MouseX-aev->X;

	if(IntuiMsg->MouseY<aev->Y)
		MY=0;
	else 
	{
		if(IntuiMsg->MouseY>(aev->Y+aev->H-10))
			MY=50;
		else 
			MY=IntuiMsg->MouseY-aev->Y+2;
	}	
	NewTime=((((MX+aev->MinVal)*aev->HScale)/256)/4)*4;
	
	AEDHead = &aev->AEDKeys;
	AEDNode = AEDHead->mlh_TailPred;
	

	if((MX<(aev->X+aev->W))&
		(NewTime<AEDNode->Time)&
		(!Timematch(aev,NewTime)))
	{	
		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			NewAEDNode->Time = NewTime;
			NewAEDNode->Scaled_Time = MX+aev->MinVal;
			NewAEDNode->Value = MY*1310;
			NewAEDNode->Scaled_Val = MY;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = Deleteable;
		}

		SN_Hi = AEDHead->mlh_Head;

		SN_Low = SN_Hi;
		SN_Hi = SN_Hi->mln_Succ;

		while(NewAEDNode->Time>SN_Hi->Time)
		{
			SN_Low = SN_Hi;
			SN_Hi = SN_Hi->mln_Succ;
		}
	
		Insert(AEDHead,NewAEDNode,SN_Low);
	
		if(aev->SELECTED_KEY)
		{
			aev->SELECTED_KEY->Act = AEDKey_act;
		}
		NewAEDNode->Act=AEDKey_sel;
		aev->SELECTED_KEY=NewAEDNode;

		//SelectEnvKey(aev,IntuiMsg->MouseX,IntuiMsg->MouseY,PTime);

		RedrawAudioevn(aev);
		AdjKeyTimeStr(aev,NewAEDNode,PTime,Window);
		AdjKeyValStr(aev,NewAEDNode,PNum,Window);
		SetTimeBounds(aev,PTime);

	}
}



#define	XAcc	16*32
#define	YAcc	16*32
/******************************************************
*
* AdjKeyValue 	--	Make changes on key values based on 
*				  		mouse input.
*
******************************************************/
void	AdjKeyValue(struct AudEnvDisp *aev,
				 struct AEDKey *SelNode,
				 struct IntuiMessage *IntuiMsg)
{
	LONG	SCRATCH;


	SCRATCH = SelNode->Value;
	SCRATCH += (IntuiMsg->MouseY*YAcc);
	if(SCRATCH<0)
		SCRATCH=0;
	if(SCRATCH>65535) 
		SCRATCH=65535;
		
	SelNode->Value = (UWORD)SCRATCH;
	
	SelNode->Scaled_Val = SelNode->Value/1307;
	
	DUMPHEXIW("SelNode->Value ",(UWORD)SelNode->Value,"\\");
}


/**************************************************
*
* AdjKeyTime -- Make changes on key values based on 
*				 	 mouse input.
*
**************************************************/
void	AdjKeyTime(struct AudEnvDisp *aev,
				 struct AEDKey *SelNode,
				 struct IntuiMessage *IntuiMsg)
{
	LONG	SCRATCH;
	LONG	mmy;
	ULONG	HI_BOUND,LO_BOUND,CURTIME;
	struct AEDKey *prev,*next;

	next=SelNode->mln_Succ;
	prev=SelNode->mln_Pred;
	
	HI_BOUND=next->Time;
	LO_BOUND=prev->Time;

	mmy=IntuiMsg->MouseX;

	SCRATCH = SelNode->Time;

	SCRATCH += mmy*4;
	
	CURTIME=(((ULONG)SCRATCH)/4)*4;

	if(CURTIME<=LO_BOUND)
		CURTIME=LO_BOUND+4;

	if(CURTIME>=HI_BOUND)
		CURTIME=HI_BOUND-4;
	
	SelNode->Time = (ULONG)CURTIME;
	
	SelNode->Scaled_Time = (SelNode->Time*256)/aev->HScale;
	
	DUMPHEXIL("SelNode->Time ",(ULONG)SelNode->Time,"\\");

}



/**************************************************
*
* HandleKeyDrag --  Handle Envelope Key Draging
*
*
**************************************************/
void HandleKeyDrag(struct AudEnvDisp *aev,
						 struct Window *Window,
						 struct IntuiMessage *IntuiMsg,
						 struct AEDKey *SelNode,
						 UBYTE  RButton, 
						 struct PanelLine *PTime,
						 struct PanelLine *PNum)
{
	BOOL mouseup=FALSE;
	UWORD	MX,MY;
	UBYTE KeyAtt;

	MX=IntuiMsg->MouseX;
	MY=IntuiMsg->MouseY;

	ReplyMsg((struct Message *)IntuiMsg);		//Orignal GadgetDown/RButton msg.
	SoftSpriteOff();
	ReportMouse(1,Window);
	ModifyIDCMP(Window,WinFlags|IDCMP_DELTAMOVE);
	KeyAtt=SelNode->Att;


	if(SelNode)
	{	
		AdjKeyTimeStr(aev,SelNode,PTime,Window);
		AdjKeyValStr(aev,SelNode,PNum,Window);
	}
	while(!mouseup)
	{
		WaitPort(Window->UserPort);
		while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) 
		{
			//DUMPHEXIL("Got IntuiMsg Class: ",IntuiMsg->Class," \\");

			switch(IntuiMsg->Class)
			{
			case IDCMP_GADGETUP:
				mouseup=TRUE;
				break;

			case IDCMP_MOUSEMOVE:
				if(SelNode)
				{
					if(RButton)
					{
						if(!(KeyAtt & 0x01))  //TimeLocked
						{
							AdjKeyTime(aev,SelNode,IntuiMsg);
							RedrawAudioevn(aev);
							AdjKeyTimeStr(aev,SelNode,PTime,Window);
						}
					}
					else
					{
						//DUMPHEXIW("MouseX= ",IntuiMsg->MouseX,"\\");
						//DUMPHEXIW("MouseY= ",IntuiMsg->MouseY,"\\");
						AdjKeyValue(aev,SelNode,IntuiMsg);	
						RedrawAudioevn(aev);
						AdjKeyValStr(aev,SelNode,PNum,Window);
					}
				}
				break;

			case IDCMP_MOUSEBUTTONS:
				if(IntuiMsg->Code==MENUUP)
					mouseup=TRUE;
				else
					if(IntuiMsg->Code==SELECTUP)
						mouseup=TRUE;
				break;

			}
			ReplyMsg((struct Message *)IntuiMsg);
			if(mouseup) break;		
		}
	}
	ReportMouse(0,Window);
	ModifyIDCMP(Window,WinFlags);
	ESparams2.Data1 = MX+Window->LeftEdge;
	ESparams2.Data2 = MY+Window->TopEdge;
	SendSwitcherReply(ES_MoveSprite,&ESparams2);
	SoftSpriteOn();
}




/**************************************************
*
* HandleEnvGad --  Handle Envelope Type Gadget
*
* 
* STATUS={KEY_DRAG,KEY_CREATE,KEY_DELETE}
*
*
*
**************************************************/
void HandleEnvGad(struct AudEnvDisp *aev,
						struct Window *Window,
						struct IntuiMessage *IntuiMsg,
						UBYTE	STATUS, 
						struct PanelLine *PTime,
						struct PanelLine *PNum)

{
	if(IntuiMsg->Code==MENUDOWN)
	{
		if(STATUS==KEY_DRAG)
				HandleKeyDrag(aev,Window,IntuiMsg,
								  SelectEnvKey(aev,IntuiMsg->MouseX,IntuiMsg->MouseY,PTime),
								  1,PTime,PNum);		
	}
	else
	{
		switch(STATUS)
		{
			case	KEY_DRAG:
				HandleKeyDrag(aev,Window,IntuiMsg,
								  SelectEnvKey(aev,IntuiMsg->MouseX,IntuiMsg->MouseY,PTime),		
								  0,PTime,PNum);		

			case	KEY_CREATE:
				CreateEnvKey(aev,Window,IntuiMsg,PTime,PNum);
				break;
	
				break;
			case	KEY_DELETE:
				DeleteEnvKey(aev,
								 SelectEnvKey(aev,IntuiMsg->MouseX,IntuiMsg->MouseY,PTime),
								 Window,PTime,PNum);
				break;
		}
	
	}
}



/***********************************************************
*
* ScaleEnvelope
*
*	Scaling_Factor=width of super-envelope
***********************************************************/
void ScaleEnvelope(struct AudEnvDisp *aev,ULONG Scaling_Factor)
{
	struct AEDKey *AEDNode,*AEDNode2;
	struct MinList *AEDHead;
	ULONG	 Total_Time;

	aev->SuperEnvWidth=Scaling_Factor;
	AEDHead = &aev->AEDKeys;	
	AEDNode = AEDHead->mlh_Head;
	AEDNode2 = AEDHead->mlh_TailPred;

	Total_Time = AEDNode2->Time-AEDNode->Time;
	aev->HScale = (Total_Time*256)/Scaling_Factor;
	
	aev->MinVal = (AEDNode->Time*256)/aev->HScale;
	aev->MaxVal = (AEDNode2->Time*256)/aev->HScale;

	for(AEDNode=AEDHead->mlh_Head;AEDNode->mln_Succ;AEDNode=AEDNode->mln_Succ)
	{
		AEDNode->Scaled_Time = (AEDNode->Time*256)/aev->HScale;
	}

}	


/*************************************************************************
*
*	SetKeyInPLTime
*
*************************************************************************/
void	SetKeyInPLTime(struct AudEnvDisp *aev,
						   struct PanelLine *PLine)
{
	struct AEDKey *SelNode;
	ULONG	Temp;

	SelNode=aev->SELECTED_KEY;
	if(SelNode)
	{
		Temp= *PLine->Param;
		if(Temp>PLine->PropEnd)
		{
			*PLine->Param=PLine->PropEnd-4;
			Temp= *PLine->Param;
			AdjKeyTimeStr(aev,aev->SELECTED_KEY,PLine,aev->PWindow);
		}
		else	
		{
			if(Temp<PLine->PropStart)
			{
				*PLine->Param=PLine->PropStart+4;
				Temp= *PLine->Param;
				AdjKeyTimeStr(aev,aev->SELECTED_KEY,PLine,aev->PWindow);
			}
		}

		DUMPHEXIL("Time PLine->Param=",(ULONG)*PLine->Param,"\\");

		SelNode->Time=Temp;
		SelNode->Scaled_Time=(SelNode->Time*256)/aev->HScale;
	}
}


/*************************************************************************
*
*	SetKeyInPLValue
*
*************************************************************************/
void	SetKeyInPLValue(struct AudEnvDisp *aev,
							 struct PanelLine *PLine)
{
struct AEDKey *SelNode;

	UWORD Temp; 

	SelNode=aev->SELECTED_KEY;
	if(SelNode)
	{
		Temp = *PLine->Param;
		DUMPHEXIW("Value PLine->Param=",(UWORD)Temp,"\\");
		SelNode->Value = (100-Temp)*655;
		SelNode->Scaled_Val = SelNode->Value/1307;
	}
}


/**************************************************************************
*
*
*
*
**************************************************************************/
ULONG	__asm	*EnvPLGadUserFun(REG(a0) struct PanelLine *PLine,
									  REG(a1) struct IntuiMessage *IntuiMsg,
									  REG(a2) struct AudEnvDisp *Obj) 
{
	DUMPMSG	("EnvPLGadUserFun");

	if(PLine->Type==PNL_EZNUM)
	{
		SetKeyInPLValue(Obj,PLine);
	}	
	else
		if(PLine->Type==PNL_EZTIME)
			{
			SetKeyInPLTime(Obj,PLine);
			}
	DUMPHEXIL("EnvPLGadUserFun aev=",(ULONG)Obj,"\\");
	if(Obj)
		RedrawAudioevn(Obj);
	return(0);
}




#define AREASIZE 100
//***********************************************************************
// 
//	Audio Envelope panel experiment. 
//
//***********************************************************************
UWORD	AudEnvPanel(struct EditWindow *Edit,
						struct PanelLine *PLine,
						LONG Time_In,LONG Time_Out,
						LONG FadeIn,LONG FadeOut,
						struct AudioEnv *AETagTable)
{
	WORD H = PNL_Y1,ID,A,B,X1=0,Y1=0,KeyMoveY,Lines=0;
	struct Gadget *ThisG=0;
	struct Gadget *Envelope;
	struct Window *Window=0;
	struct AudEnvDisp *aev;
	struct RastPort *RP;
	struct AEDKey *NewAEDNode, *AEDNode, *TestKey;
	struct MinList *AEDHead;
	struct PanelLine	*EnvAction, *CurrPL, *KeepPL, *EnvTime, *EnvValue, *UseEnvCheck;
	struct EnvPLPtr *AudEnvPan;


	BOOL Going = TRUE;
	UWORD Success = PAN_CANCEL;
	struct IntuiMessage *IntuiMsg;
	struct StringInfo *si;
	ULONG Y=0;
	UWORD Mx,My;
	struct RastPort DMRP={0};				//The double buffer rastport for audioenv.	
	struct BitMap *DMBM;

	KeepPL=PLine;


	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL; LastString=NULL;
	Wide=FALSE;

	for(Start = PLine; PLine->Type && !Wide; PLine++ )
	{
		if ((PPOS_WIDER & PLine->Align) || (PPOS_HALF2 & PLine->Align))
			Wide=TRUE;

	}

	ClipNW.Flags = STD_FLAGS;		// Default window flags

	for( PLine=Start; PLine->Type; PLine++ )
	{
		DUMPHEXIL("Panel Line  ",(ULONG)PLine,"\\");

		if(PLine->Type != PNL_SKIP)
		{
			if (PPOS_HALF2 & PLine->Align)
				X1 = PNL_WIDTH;

			// Call the gadget's create function

			if(PLine->Create)
			{
				DUMPMSG("BEFORE PLINE CREATE");
				Y1=PLine->Create(X1,H,PLine,&ThisG);
				DUMPMSG("AFTER PLINE CREATE");
			}
			if(PPOS_WIDER & PLine->Align)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
				else
					H += Y1;					// Was no left half
				X1 = 0;
				Y = 0;
			}
			if(PLine->Flags)
			{
				if(PLine->Flags&PL_IN)
					In=PLine->StrGadg;
				else if(PLine->Flags&PL_OUT)
					Out=PLine->StrGadg;
				else if(PLine->Flags&PL_DEL)
					Del=PLine->StrGadg;
				else if(PLine->Flags&PL_LEN)
					Len=PLine->StrGadg;
				if(PLine->Flags&PL_SMREF)		// Somebody wants smart refresh
					ClipNW.Flags = REC_FLAGS;
			}
			Lines++;
		}
	}

	DUMPMSG	("DONE WITH HARD PART?");

	if(X1>0) H += MAX(Y,Y1);  // last gad...
	if(Wide) X1=PNL_WIDTH;


	ClipNW.Width = PNL_WIDTH + (Wide ? PNL_WIDTH:0);
	ClipNW.Height = H;
	ClipNW.Screen = EditScreen;
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = EditTop->Window->TopEdge; // MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
	ClipNW.FirstGadget = NULL;

	DUMPHEXIL("ClipNW.Flags     ",(ULONG)ClipNW.Flags,"\\");
	DUMPHEXIW("ClipNW.LeftEdge  ",(WORD)ClipNW.LeftEdge,"\\");
	DUMPHEXIW("ClipNW.TopEdge   ",(WORD)ClipNW.TopEdge,"\\");
	DUMPHEXIW("ClipNW.Width     ",(WORD)ClipNW.Width,"\\");
	DUMPHEXIW("ClipNW.Height    ",(WORD)ClipNW.Height,"\\");
	DUMPHEXIW("ClipNW.Type      ",(UWORD)ClipNW.Type,"\\");
	DUMPHEXIL("ClipNW.Screen    ",(LONG)ClipNW.Screen,"\\");

	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	
	DUMPMSG	("Before open window");

	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		DUMPMSG	("AFTER OPEN WINDOW");

		SoftSpriteOff();				// Shut off for the duration -- faster, and less flash

		RP = Window->RPort;

		//Initalize and setup the double buffer for envelope displays.
		DMRP.Mask = RP->Mask;
		DMRP.TmpRas = RP->TmpRas;
		DMRP.AreaInfo = RP->AreaInfo;
		DMRP.AreaPtrn = RP->AreaPtrn;
		InitRastPort(&DMRP);
		DMRP.BitMap=AllocBitMap(484+20,50+20,RP->BitMap->Depth,BMF_DISPLAYABLE,NULL);;

		// Go and get aev struct allocated and initilized
		aev = NewEnvGad(RP,&DMRP,25-4,50-4,484+6,50+8,EV_GAD01);
		aev->PWindow = Window;
		DUMPHEXIL("Just allocated aev=",(LONG)aev,"\\");

		ThisG->NextGadget = &aev->EnvDispGadget;
		
		ClipNW.Flags = STD_FLAGS;
		SetDrMd(RP,JAM2);
		AddGList(Window,FirstG,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		SetFont(RP,DarkFont);
		H = PNL_Y1;

		//NewList(&aev.AEDKeys);
		//DUMPHEXIL("&aev->AEDKeys=",(LONG)&aev->AEDKeys,"\\");

		//Find the popup panel line.
		for( PLine=KeepPL; PLine->Type; PLine++ )
		{
			DUMPHEXIB("",PLine->Type,"\\");
			if(PLine->Type==0x0D)
				EnvAction=PLine;					//Keep the POPUP panelline pointer
			
			if(PLine->Type==PNL_EZTIME)
				EnvTime=PLine;						//Keep the panelline pointer
			
			if(PLine->Type==PNL_EZNUM)
				EnvValue=PLine;					//Keep the panelline pointer

			if(PLine->PLID==PLID_USEAUDENV)
				UseEnvCheck=PLine;

		}

		aev->InPoint=Time_In;
		aev->OutPoint=Time_Out;
		aev->FadeIn=FadeIn;
		aev->FadeOut=FadeOut;
		aev->AETagTable=AETagTable;

		TagtoKL(aev,AETagTable);
/*
		// Build Test list. 		
		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			AddTail(&aev->AEDKeys,NewAEDNode);	
			//DUMPHEXIL("&aev.AEDKeys=",(LONG)&aev.AEDKeys,"  ");
			//DUMPHEXIL("NewAEDNode=",(LONG)NewAEDNode,"\\");
			NewAEDNode->Time = 4204;
			NewAEDNode->Scaled_Time = 0;
			NewAEDNode->Value = 32400;
			NewAEDNode->Scaled_Val = 32400/1307;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = TimeLocked;

		}


		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			AddTail(&aev->AEDKeys,NewAEDNode);	
			//DUMPHEXIL("&aev.AEDKeys=",(LONG)&aev.AEDKeys,"  ");
			//DUMPHEXIL("NewAEDNode=",(LONG)NewAEDNode,"\\");
			NewAEDNode->Time = 4804;
			NewAEDNode->Scaled_Time = 0;
			NewAEDNode->Value = 35*1307;
			NewAEDNode->Scaled_Val = 35;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = Deleteable;

		}


		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			AddTail(&aev->AEDKeys,NewAEDNode);	
			//DUMPHEXIL("&aev.AEDKeys=",(LONG)&aev.AEDKeys,"  ");
			//DUMPHEXIL("NewAEDNode=",(LONG)NewAEDNode,"\\");
			NewAEDNode->Time = 6604;
			NewAEDNode->Scaled_Time = (6604<<8)/1583;
			NewAEDNode->Value = 60000;
			NewAEDNode->Scaled_Val = 60000/1307;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = Deleteable;
		}


		if(NewAEDNode=AllocMem(sizeof(struct AEDKey),MEMF_PUBLIC|MEMF_CLEAR))
		{
			AddTail(&aev->AEDKeys,NewAEDNode);	
			//DUMPHEXIL("&aev.AEDKeys=",(LONG)&aev.AEDKeys,"  ");
			//DUMPHEXIL("NewAEDNode=",(LONG)NewAEDNode,"\\");
			NewAEDNode->Time = 7204;
			NewAEDNode->Scaled_Time = 0;
			NewAEDNode->Value = 32000;
			NewAEDNode->Scaled_Val = 32000/1307;
			NewAEDNode->Act = AEDKey_act;
			NewAEDNode->Att = TimeLocked;
		}
		*/

		ScaleEnvelope(aev,485);

		//aev->MinVal=(aev->InPoint*256)/aev->HScale;
		//aev->MaxVal=(aev->OutPoint*256)/aev->HScale;

		//
		NewBorderBox(aev->RP,aev->X-4,aev->Y-4,aev->X+aev->W-1,aev->Y+aev->H-3,BOX_REV);	//box for aud env test.
		RedrawAudioevn(aev);


		//setup string gadgets.

		EnvTime->UserFun = EnvPLGadUserFun;
		EnvTime->UserObj = aev;

		EnvValue->UserFun = EnvPLGadUserFun;
		EnvValue->UserObj = aev;



		DUMPMSG	("AFTER BOARDER BOX");

		PLine = Start;
		X1 = 0;
		Y = 0;
		while (PLine->Type)
		{
			if(PLine->Type != PNL_SKIP)
			{
				PLine->Win = Window;

				if (PPOS_HALF2 & PLine->Align)
					X1 = PNL_WIDTH;

				// Call the gadget's draw function
				if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,Window);

				if(PLine->Flags & PL_ACTIVATE)
				{
					si = (struct StringInfo *) PLine->StrGadg->SpecialInfo;
					si->BufferPos = strlen(si->Buffer);		// Move cursor past end
					ActivateGadget(PLine->StrGadg,Window,NULL);
				}

				if(PPOS_WIDER & PLine->Align)
				{
					X1 = PNL_WIDTH;
					Y = Y1;
				}
				else
				{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
				else
					H += Y1;					// Was no left half
					X1 = 0;
					Y = 0;
				}
			}
			PLine++;
		}

		SoftSpriteOn();

		DUMPMSG	("ENTERING EVENT HANDLER");


		// handle window events
		goto GetEm;
		while (Going)
		{
			WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) 
			{
				//DUMPHEXIL("IntuiMsg: ",IntuiMsg->Class," \\");
				switch(IntuiMsg->Class) 
				{

				case IDCMP_GADGETDOWN:
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					if(ID&EV_GAD)
					{
						//DUMPMSG	("EV_GADDOWN");
						HandleEnvGad(aev,Window,IntuiMsg,
										 EnvAction->PropStart+1,EnvTime,EnvValue); 
						IntuiMsg=NULL;	//HandleEnvGad replys to IntuiMsg.
					}
					else
					if(LastString)
					{
						if(PLine = (struct PanelLine *)LastString->UserData)
						{
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								//Y=FixTimeStr(PLine,Window,FALSE);
								Y=FixTimeStr(PLine,Window,TRUE);
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strcpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer);
						}
						LastString=NULL;
					}
					if(!(PLine = (struct PanelLine *)ThisG->UserData)) break;
					if(ID==STRING_ID)	LastString=ThisG;
					if(PLine->Handle) PLine->Handle(PLine,IntuiMsg,Window);
					break;


				case IDCMP_GADGETUP:
//					DUMPMSG	("GADGETUP");

					if (Down)
					{
						Down = NULL;
						ModifyIDCMP(Window,WinFlags);
					}
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;

					if(LastString && LastString!=ThisG)
					{
						if(PLine = (struct PanelLine *)LastString->UserData)
						{
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								//FixTimeStr(PLine,Window,FALSE);
								FixTimeStr(PLine,Window,TRUE);
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->PropEnd);
						}
						LastString=NULL;
					}

					PLine = (struct PanelLine *)ThisG->UserData;

					if(PLine && PLine->Handle)
					{
						DUMPHEXIL("PLine->Handle ",(ULONG)PLine->Handle,"\\");
						PLine->Handle(PLine,IntuiMsg,Window);

						DoGenButtons(PLine,Window,&Success,&Going);

						if (PLine->Flags & PL_GENBUTT)
						{
							switch ((ULONG)PLine->Param)
							{
							case GB_REORG:		// Reorg drive
								Going = FALSE;				// Exit panel
								Success = PAN_EASY;		// Re-open panel again
								break;
							}
						}

					}
					break;

				case IDCMP_MOUSEMOVE:
//						DUMPSTR("&");
										
						//KeyMoveY=IntuiMsg->MouseY-aev->Y;
						//if (KeyMoveY>49) KeyMoveY=49;
						//if (KeyMoveY<1) KeyMoveY=1;
						//TestKey->Scaled_Val=KeyMoveY;

						//DUMPHEXIW("KeyMoveY: ",KeyMoveY," ");
						//DUMPHEXIW("Mouse X: ",IntuiMsg->MouseX," ");
						//DUMPHEXIW("Mouse Y: ",IntuiMsg->MouseY,"\\");


				case IDCMP_MOUSEBUTTONS:
					if(Down)
					{
                  PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,Window);
					}
               else
						// handle right button here.
						// need to determine if mouse moves are needed.
						if(IntuiMsg->Code==MENUDOWN)		//also watch for MENUUP!
						{
							//See if it's one of those envlope gadgets
							Mx = IntuiMsg->MouseX; 
							My = IntuiMsg->MouseY;
							if ((Mx>aev->X)&(Mx<(aev->X+aev->W))&
								(My>aev->Y)&(My<(aev->Y+aev->H)))
							{
								DUMPSTR("got press in env gad.");
								HandleEnvGad(aev,Window,IntuiMsg,1,EnvTime,EnvValue);
								IntuiMsg=NULL;  //HandleEnvGad replys to IntuiMsg.

							}
						};

					DUMPSTR("*");
					break;

				case IDCMP_INTUITICKS:
					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						ModifyIDCMP(Window,WinFlags);
						EZGad=NULL;
						break;
					}

					// Handle ticks to EZ gadgets
					TickEZLenPL((struct PanelLine *)EZGad->UserData,Window,EZJump(Ticks++));
					break;

				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					if(A<0x80)
					{
						B = IntuiMsg->Qualifier;
						DUMPHEXIB("Key Code: ",A,"\\");
						switch(A)
						{
							case	RAW_IN:
								if(In)	ActivateGadget(In,Window,NULL);
								break;
							case	RAW_OUT:
								if(Out)	ActivateGadget(Out,Window,NULL);
								break;
							case	RAW_LEN:
								if(Len)	ActivateGadget(Len,Window,NULL);
								break;
							case	RAW_DEL:
								if(Del)	ActivateGadget(Del,Window,NULL);
								break;
							case	RAWKEY_PAD_ENTER:
							case	RAWKEY_RETURN:
								Going = FALSE;
								Success=TRUE;
								break;
							case	RAWKEY_HELP:
								break;
							case	RAWKEY_ESC:
								Going = FALSE;
								break;
						}
					}
					break;
				}
				if(IntuiMsg) 	
					ReplyMsg((struct Message *)IntuiMsg);
			}
		}
		// end of event loop

		CloseWindow(Window);
		WaitBlit();

		// update modified parameters
		PLine = Start;
		while (PLine->Type)
		{
			switch(PLine->Type) {
			case PNL_IN_TYPE:
			case PNL_OUT_TYPE:
				if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
				else *(PLine->Param) = 0;
				break;
			}
			PLine++;
		}
	}
	DUMPMSG	("After OW cond.");


	for( PLine=Start; PLine->Type; PLine++ )
	{
		if(PLine && PLine->Destroy && (PLine->Type!=PNL_SKIP) )
			PLine->Destroy(PLine);
	}

	// Free the double buffer bitmap
	FreeBitMap(DMRP.BitMap);


	if(Success==PAN_CONTINUE)
	{
		KLtoTag(aev,AETagTable);
		if(*UseEnvCheck->Param)
			AETagTable->Flags=1;		//Use tagtable
	}

	//free display list.
	AEDHead=&aev->AEDKeys;

	while(AEDNode=RemHead(AEDHead)) 
	{ 
		DUMPHEXIL("Freeing AEDNode: ",(LONG)AEDNode,"\\");
		FreeMem(AEDNode,sizeof(struct AEDKey));	
	}

	// Free the Envelope structures
	FreeMem(aev,sizeof(struct AudEnvDisp));

	return(Success);
}



/**********************************/
/*** Quick-Tune panel & support ***/
/**********************************/

static void TimeHilite(struct RastPort *rp, int which, BOOL state);

#define	QWINH		16						/* Quick window height */
#define	QXBASE	0
#define	QAPART	145
#define	TCLEN		88
#define	QLBL		35
#define	QZwidth	(TCLEN+16)


struct ExtNewWindow quick_nw = {
	32 + GRID_LEFT,28,	/* window XY origin relative to TopLeft of screen */
	640,QWINH,				/* window width and height */
	1,0,						/* detail and block pens */

	/* IDCMP flags */
	IDCMP_RAWKEY | IDCMP_REFRESHWINDOW | IDCMP_MOUSEBUTTONS | IDCMP_GADGETDOWN | IDCMP_GADGETUP,
	/* other window flags */
	/* WFLG_BACKDROP | */
	WFLG_SIMPLE_REFRESH | WFLG_BORDERLESS | WFLG_RMBTRAP | WFLG_NW_EXTENDED,

	NULL,	/* first gadget in gadget list */
	NULL,	/* custom CHECKMARK imagery */
	NULL,	/* window title */
	NULL,	/* custom screen pointer */
	NULL,	/* custom bitmap */
	5,5,	/* minimum width and height */
	656,400,	/* maximum width and height */
	CUSTOMSCREEN,	/* destination screen type */
	&nw_ti[0]
};


UWORD QuickPanel(
	struct EditWindow *Edit,
	struct PanelLine *Panel,
	struct FastGadget *FG,
	LONG smpte)
{
	struct Window *win;
	struct RastPort *rp;
	struct PanelLine *pl,*PLs[4];
	struct EditWindow *edwin;
	BOOL Going=TRUE,IDchange,audpts=FALSE;
	WORD	newID,curID,lastID=0;
	UWORD	success=0;
	char	*labels[] = {"  In","Out","  In","Out"};
	int	i;
	ULONG	waitsigs,topsig,botsig,signals;
	LONG	adder;
	UBYTE	itemcount=0;

	struct IntuiMessage *IntuiMsg;
	ULONG	IMclass;
	UWORD	IMcode,IMqual;

	quick_nw.Screen = EditScreen;

	if (win = OpenWindow((struct NewWindow *)&quick_nw))
	{
		rp = win->RPort;

		SetDrMd(rp,JAM2);
		SetFont(rp,TCFont);
		rp->Mask = 0x07;

		SetRast(rp,1);			// Clear entire window

		PLs[0] = PLs[1] = PLs[2] = PLs[3] = NULL;

		for(pl=Panel; pl->Type; pl++)
		{
			if(pl->Type != PNL_SKIP)
			{
				itemcount++;

				pl->Win = win;

				if (PL_IN & pl->Flags)
				{
					if (PL_AUDIO & pl->Flags)
						PLs[2] = pl;
					else
						PLs[0] = pl;
				}
				else if (PL_OUT & pl->Flags)
				{
					if (PL_AUDIO & pl->Flags)
						PLs[3] = pl;
					else
						PLs[1] = pl;
				}
			}
		}

		curID = -1;					// None highlighted yet

		SetFont(rp,TCDarkFont);

		for (i=0; i<4; i++)
		{
			if (PLs[i])
				DispQuickTime(win,i,*(PLs[i]->Param),labels[i],FALSE);
		}

		// Setup RCB structure to just show time in quick window
		MyRCB->RenderFn = &QuickRenderFunc;						// Use my special renderer
		MyRCB->FG = FG;
		MyRCB->win = win;
		MyRCB->Flags = 0;

		topsig = botsig = 0;
		if (EditTop && EditTop->Window)
			topsig = (1<<EditTop->Window->UserPort->mp_SigBit);
		if (EditBottom && EditBottom->Window)
			botsig = (1<<EditBottom->Window->UserPort->mp_SigBit);

		waitsigs = topsig | botsig;

		// handle window events
		goto GetEm;
		while (Going)
		{
			DUMPMSG	("Wait...");
			signals = Wait(waitsigs);
GetEm:
			for (i=0; i<=1; i++)
			{
				if (i==0)
				{
					if (signals & topsig)
						edwin = EditTop;
					else
						continue;
				}
				else
				{
					if (signals & botsig)
						edwin = EditBottom;
					else
						continue;
				}

				// Steal messages meant for top/bottom windows
				while (IntuiMsg = (struct IntuiMessage *)GetMsg(edwin->Window->UserPort))
				{
					DUMPMSG	("(msg)");
					IMclass = IntuiMsg->Class;
					IMcode  = IntuiMsg->Code;
					IMqual  = IntuiMsg->Qualifier;
					ReplyMsg((struct Message *)IntuiMsg);		// Best to reply quickly

					IDchange = FALSE;
					adder = 0;

					switch(IMclass)
					{
					case IDCMP_GADGETUP:
						DUMPMSG	("GADGETUP");
						newID = -1;							// Change to "none"
						IDchange = TRUE;
						break;
					case IDCMP_GADGETDOWN:
						DUMPMSG	("GADGETDOWN");
						newID = 0;							// Must be left button over some gadget
						IDchange = TRUE;
						break;
					case IDCMP_MOUSEBUTTONS:
						DUMPMSG	("MOUSEBUTTON");

						if (IMcode==SELECTDOWN)
							newID = 0;						// Select "in" point
						else if (IMcode==MENUDOWN)
							newID = 1;						// Select "out" point
						else
							newID = -1;						// "none"

						IDchange = TRUE;
						break;
					case IDCMP_RAWKEY:
						DUMPHEXIB("Key Code: ",IMcode,"\\");
						switch (IMcode)
						{
							case RAW_KEYUP+RAWKEY_CTRL:		// Ctrl up
								Going = FALSE;
								success = PAN_CONTINUE;
								break;
							case RAWKEY_LEFT:
								adder = -4;
								newID = lastID;
								IDchange = TRUE;
								break;
							case RAWKEY_RIGHT:
								adder = 4;
								newID = lastID;
								IDchange = TRUE;
								break;
							case RAWKEY_SPACE:
								audpts = !audpts;		// Change to/from audio in/out points
								break;

//							case RAWKEY_ESC:
//								Going = FALSE;
//								success = PAN_CANCEL;
//								break;
						}
						break;
					}


					if (IDchange)
					{
						if (newID>=0)
						{
							// Wants audio in/out points?
//							if (IMqual & (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
							if (audpts)
								newID |= 2;

							if (PLs[newID] == NULL)
								newID ^= 2;					// Use other pair if this pair is disabled

							lastID = newID;				// Remember this for arrow keys
						}

						if (newID != curID)				// Changing current point?
						{
							// Remove highlight, if any
							if (curID != -1)
							{
								TimeHilite(rp,curID,FALSE);
								DispQuickTime(win,curID,*(PLs[curID]->Param),labels[curID],FALSE);
							}

							// Add new highlight, if any
							if (newID != -1)
							{
								TimeHilite(rp,newID,TRUE);
								DispQuickTime(win,newID,*(PLs[newID]->Param),labels[newID],TRUE);
							}
							curID = newID;
						}

						// Begin jogging if button pressed...
						if (curID != -1)
						{
							MyRCB->pline = pl = PLs[curID];

							if ((itemcount == 4) && (IMqual & IEQUALIFIER_LALT))
								pl->Flags |= PL_PARTNER;
							else
								pl->Flags &= ~((ULONG)PL_PARTNER);

							if (IMqual & IEQUALIFIER_LSHIFT)
							{
								pl->Flags |= PL_SHADOW;

								// Always make positive shadow values!
								if (curID & 1)		// For out point, shadow = this - other
								{
									pl->ShadowOffset = *pl->Param
									- *((struct PanelLine *)(pl->Param2))->Param;
								}
								else					// For in point, shadow = other - this
								{
									pl->ShadowOffset = *((struct PanelLine *)(pl->Param2))->Param
									- *pl->Param;		// Difference
								}

								DUMPSDECL("Shadow=",(LONG)pl->ShadowOffset,"\\");
							}
							else
								pl->Flags &= ~((ULONG)PL_SHADOW);

							MyRCB->Frame = Frms2Flds((ULONG)(*pl->Param - smpte));
							if (curID & 1)										// Out points
							{
								if (pl->Flags & PL_SHADOW)
								{
									MyRCB->Min = PLs[curID-1]->PropStart+pl->ShadowOffset;	// Min w/shadow
									DUMPSDECL("Min=",(LONG)MyRCB->Min,"\\");
								}
								else
									MyRCB->Min = *PLs[curID-1]->Param;		// Min= in point
								MyRCB->Max = pl->PropEnd;						// Max= clip max
							}
							else
							{
								MyRCB->Min = pl->PropStart;		// Min= clip min
								if (pl->Flags & PL_SHADOW)
								{
									MyRCB->Max = PLs[curID+1]->PropEnd-pl->ShadowOffset;		// Max w/shadow
									DUMPSDECL("Max=",(LONG)MyRCB->Max,"\\");
								}
								else
									MyRCB->Max = *PLs[curID+1]->Param;		// Max= out point
							}
							MyRCB->Min = Frms2Flds(MyRCB->Min - smpte);
							MyRCB->Max = Frms2Flds(MyRCB->Max - smpte);

							if (adder)
							{
								MyRCB->Frame += adder;
								DUMPUDECL("Frm ",(LONG)MyRCB->Frame," ");
								DUMPUDECL("Min ",(LONG)MyRCB->Min," ");
								DUMPUDECL("Max ",(LONG)MyRCB->Max,"\\");
								if((MyRCB->Frame <= MyRCB->Max)
								&& (MyRCB->Frame >= MyRCB->Min))
								{
									DHD_Jump(MyRCB,FALSE);			// Jump, stay noisy
//									MyRCB->Frame = Frms2Flds((ULONG)(*(PLs[curID]->Param) - smpte));
								}
							}
							else
							{
								DUMPMSG("Beginning test jog...");
								DHD_Jog(MyRCB);
								DUMPMSG("Done, let's leave");
							}
						}

						DUMPHEXIW("Qualifiers=",(LONG)IMqual,"\\");
						if (!(IMqual & IEQUALIFIER_CONTROL))
						{
							Going = FALSE;
							success = PAN_CONTINUE;
							DUMPMSG("Must have missed!!!");
						}
					}
				}
			}
		}

		MyRCB->RenderFn = &RenderFunc;			// Restore normal RCB renderer

		CloseWindow(win);
//		WaitBlit();
	}

	return(success);
}

void DispQuickTime(struct Window *win, int which, ULONG acctime, char *label, BOOL state)
{
	LONG					x,xend;
	static char	time[12]="00:00:00:00";

	DUMPUDECL("DAT ",(LONG)acctime," )\\");

	x = QXBASE + (which * QAPART) + 10;
	xend = x + QLBL + TCLEN;

	LongToTime((ULONG *)&acctime,time);	// Was provided to me in frames

	DUMPMSG(time);

	if (time)
	{
		if (win)
		{
			struct RastPort		*rp = win->RPort;

			SetAPen(rp,PAL_DGRAY);

			if (label)
			{
				SetFont(rp,DarkFont);
				Move(rp,x,rp->Font->tf_Baseline + 4 );
				SafeColorText(rp,label,strlen(label));
			}

			if (state)
				SetFont(rp,TCFont);
			else
				SetFont(rp,TCDarkFont);

			Move(rp,x+QLBL,rp->Font->tf_Baseline + 4 );
			SafeColorText(rp,time,11);

//			if (rp->cp_x <= xend)			// Clear out rest of ProgTime field
//			{
//				if (state)
//					SetAPen(rp,PAL_DYELLOW);
//				else
//					SetAPen(rp,PAL_DGRAY);
//				RectFill(rp,rp->cp_x,3,xend,13 /* QWINH */);
//			}
		}
	}
}

static void TimeHilite(struct RastPort *rp, int which, BOOL state)
{
	WORD	left,top,w,h;

	left = QXBASE+QLBL+3+which*QAPART;
	top = 0;
	w = QZwidth;
	h = QWINH;

	if (state)
		NewBorderBox(rp,left,top,left+w,top+h,BOX_REV_BORDER);
	else
	{
		SetAPen(rp,PAL_DGRAY);
		RectFill(rp,left,top,left+w,top+h);
	}
}


@


2.146
log
@fixed problem with keys not draging in time. hardcoded action in keyadjust.
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.145 1996/11/18 18:40:35 Holt Exp Holt $
d3 3
@


2.145
log
@added code to validate keys after in/out points are moved.
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.144 1996/07/29 10:29:31 Holt Exp Holt $
d3 3
d453 1
a453 1
#define SERDEBUG	1
a4369 3
			case	KEY_CREATE:
				CreateEnvKey(aev,Window,IntuiMsg,PTime,PNum);
				break;
d4375 4
d4960 2
a4961 1
								HandleEnvGad(aev,Window,IntuiMsg,2,EnvTime,EnvValue);
@


2.144
log
@added part of the audioenv panel.
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.143 1995/12/26 18:19:59 Holt Exp Holt $
d3 3
d450 1
a450 1
//#define SERDEBUG	1
d504 2
d529 3
d1464 1
d1467 11
d3178 2
d3183 2
d3469 1
a3469 1
ErrExit:
d3481 1590
d5483 2
@


2.143
log
@changed several fixtimestr calls to get back cframe aligned times
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.142 1995/10/28 02:02:12 Flick Exp Holt $
d3 3
d2368 3
a2370 1
			if(!(ccd.ClipDisp=InitClipDisplay(16,ccd.TimePL->PropGadg->TopEdge+ccd.TimePL->PropGadg->Height+20,ccd.Window->Width-32,24,ccd.Tmin,ccd.Tmax,ccd.Window)))
d2406 2
d2409 1
@


2.142
log
@No longer clear PlayFG when entering FlyPanel, added misc INTUITICKS debugging
@
text
@d1 5
a5 2
/* $Id: Panel.c,v 2.141 1995/10/17 16:59:57 Flick Exp Flick $
* $Log: Panel.c,v $
d818 2
a819 1
								Y=FixTimeStr(PLine,Window,FALSE);
d893 2
a894 1
								Y=FixTimeStr(PLine,Window,FALSE);
d3234 2
a3235 1
								Y=FixTimeStr(PLine,Window,FALSE);
d3271 2
a3272 1
								FixTimeStr(PLine,Window,FALSE);
@


2.141
log
@Left/Right arrow keys not timeout and go quiet, up/down keys cleaned up lots, go quiet
work on single sliders now, too.  "Cutting clip..." reads "Processing clips" for non-destr.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.140 1995/10/12 16:37:18 Flick Exp Flick $
d3 4
d569 1
a569 1
	PlayFG=NULL;
d959 1
a959 1
//					DUMPMSG	("-tick-");
d981 1
d987 5
a991 1
					if( !(PLine=(struct PanelLine *)EZGad->UserData) ) break;
d996 1
a996 1
						DUMPMSG("shuttle...");
d999 1
d1021 4
a1024 2
						if(Adder>0) MyRCB->Flags = 0;
						else  MyRCB->Flags = DHD_PLAY_REV;
@


2.140
log
@FlyPanel/RAWKEY_LEFT&RIGHT would only Flyer jog if PL_DUAL (changed to PL_FLYER)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.139 1995/10/09 23:31:04 Flick Exp Flick $
d3 3
d560 1
a560 1
	ULONG Y=0,d,*V;
d957 9
d1196 4
d1236 4
d1258 2
a1259 4
								if(LastTime->Flags & PL_IN) V=LastTime->Param;
								else V=LastTime->Param2;
								if(LastTime->Flags&PL_AUDIO)
									*V = *AHiTime;
d1261 1
a1261 1
									*V = *HiTime;
d1265 6
a1270 1
									if(DualFlyer)
d1274 1
a1274 1
										DHD_Jump(MyRCB,FALSE);
d1282 1
d1285 6
a1290 1
									if(DualFlyer)
d1303 1
d1316 2
a1317 4
								if(LastTime->Flags & PL_IN) V=LastTime->Param;
								else V=LastTime->Param2;
								if(LastTime->Flags&PL_AUDIO)
									*V = *ALoTime;
d1319 1
a1319 1
									*V = *LoTime;
d1323 6
a1328 1
									if(DualFlyer)
d1332 1
a1332 1
										DHD_Jump(MyRCB,FALSE);
d1340 1
d1343 6
a1348 1
									if(DualFlyer)
d1361 1
d2118 1
a2118 1
	ULONG Y=0,t,d,*V,ClipFlags;
d2644 9
d2725 4
d2759 4
d2780 1
d2786 1
a2786 1
									DHD_Jump(MyRCB,FALSE);
d2789 1
d2799 1
a2799 1

d2819 1
a2819 1
									DHD_Jump(MyRCB,FALSE);
d2822 1
d2832 1
a2832 1

d2964 4
a2967 1
				sprintf(pstr,"              Cutting clips on drive %s",FlyDrive);
@


2.139
log
@Fixed quick adjust shadow math (always positive!)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.138 1995/10/09 16:37:59 Flick Exp Flick $
d3 3
d1046 1
a1046 1
//					DUMPHEXIL("LastTime=",(LONG)LastTime,"\\");
d1086 1
a1086 1
//						DUMPHEXIB("Key Code: ",A,"\\");
d1144 1
a1144 1
//								DUMPHEXIL("LastTime=",(LONG)LastTime,"\\");
d1175 2
a1176 2
//								DUMPHEXIL("(flags=",(LONG)LastTime->Flags,")\\");
								if(LastTime->Flags&PL_DUAL)
d1179 3
d1215 1
a1215 1
								if(LastTime->Flags&PL_DUAL)
@


2.138
log
@Removed unnecessary usage of popup.h
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.137 1995/10/06 18:50:52 Flick Exp Flick $
d3 3
d3621 12
a3632 3
								pl->ShadowOffset =
								  *((struct PanelLine *)(pl->Param2))->Param
								- *pl->Param;		// Difference
d3634 1
a3634 1
//								DUMPSDECL("Shadow=",(LONG)pl->ShadowOffset,"\\");
d3644 2
a3645 2
									MyRCB->Min = PLs[curID-1]->PropStart-pl->ShadowOffset;	// Min w/shadow
//									DUMPSDECL("Min=",(LONG)MyRCB->Min,"\\");
d3657 1
a3657 1
//									DUMPSDECL("Max=",(LONG)MyRCB->Max,"\\");
@


2.137
log
@LiveFlyer changed to DualFlyer to allow FlyPanel to shuttle on single sliders too
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.136 1995/10/05 18:46:03 Flick Exp Flick $
d3 3
a413 1
#include <edit:popup/popup.h>
@


2.136
log
@Record panel now uses all new Flyer_ functions (no more ES!)
Now warns instead of crashing when proc/cutting non-existent clip in project
Fixed bug with skipping "cut?" requester in cutting room
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.135 1995/10/05 03:48:03 Flick Exp Flick $
d3 5
d546 1
a546 1
	BOOL Going = TRUE, LiveFlyer = FALSE, LoudFlyer = FALSE;
d604 3
d654 1
a654 1
				LiveFlyer = TRUE;
d660 1
a660 1
				LiveFlyer = TRUE;
d753 1
a753 1
		if( LiveFlyer )
d964 2
a965 1
					if( LiveFlyer && (PLine->Flags&PL_DUAL) )
d967 1
a967 1
//						DUMPMSG("tik...");
d1035 1
a1035 1
					if(!LiveFlyer) break;
d1236 1
a1236 1
									if(LiveFlyer)
d1250 1
a1250 1
									if(LiveFlyer)
d1284 1
a1284 1
									if(LiveFlyer)
d1298 1
a1298 1
									if(LiveFlyer)
@


2.135
log
@Fixed bad quick tune + shadow bug on outpoint (miscomputed min value -- would fall of the Earth)
Quick tune shadow feature would refuse to work with audio-only and video-only clips -- fixed
Cut/proc panels right arrow key would cause hit after clicking on new sub-clip in bar
Removed unused Qual[] array of video qualities, //'d lots of extra debugging to reduce data size
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.134 1995/10/03 18:10:46 Flick Exp Flick $
d3 6
a1555 1
								DHD_Abort(0);
d1561 2
a1587 1
						DHD_Abort(0);
d1591 3
d1675 1
a1675 1
									DHD_Pause(Paused);
d1684 2
a1685 1
								else {
d1692 2
a1693 2
									DHD_ClearFlyerStatus();
									DHD_Record(ClipName,0,0,0xDEADBABE);
d1701 2
a1702 1
							if (!Recording) {	// Just un-render if not recording
d1709 1
a1709 1
								DHD_Pause(Paused);
d1721 1
a1721 1
								DHD_Pause(Paused);
d1802 1
a1802 1
							if (DHD_CheckFlyerStatus(NULL, (ULONG *)DropPL->Param)==FERR_DROPPEDFLDS)
d1810 1
a1810 1
							err = DHD_CheckRecord();
d1825 2
a1826 2
											DHD_ClearFlyerStatus();
											DHD_Record(ClipName,0,0,0xDEADBABE);
d1863 1
a1863 1
										DUMPSDECL	("Default: DHD_CheckRecord=",(LONG)err,"\\");
a1905 1
						DHD_Abort(0);
d1909 3
d1945 1
a1945 1
								DHD_Pause(Paused);
d1968 2
a1969 2
							DHD_ClearFlyerStatus();
							DHD_Record(ClipName,0,0,0xDEADBABE);
d2081 2
a2082 2
//		DUMPMSG("Object to work with is called...");
//		DUMPMSG(SrcName);
d2245 9
d2863 1
a2863 1
	if ((!destructive) || (*MPtr[0] == NULL) || (BoolRequest(EditTop->Window,MPtr[0])))
@


2.134
log
@Quick adjust now uses TCDarkFont (removed RectFill's)
ReOrg from drive info panel now exits panel when donw
Made 2 versions of verif.req. on starting clip cutting (based on raw or existing clip)
Raw clip warning skipped if disabled in prefs
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.133 1995/10/02 15:47:29 Flick Exp Flick $
d3 6
d499 1
a499 1
UBYTE	*Qual[] = {" D2 ","Beta SP"," Hi-8 ","S-VHS","VHS","Recognizable",""};
d503 1
a503 1
struct PanelLine QualPL={ PNL_POPUP,PPOS_LEFT,"Video Quality",0,0,(LONG *)Qual,0,QUAL_NUM };
d773 1
a773 1
					DUMPMSG	("GADGETDOWN");
d779 2
a780 2
						DUMPSTR("LastString: ");
						DUMPMSG(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
d783 1
a783 1
							DUMPHEXIL("LastPLine=",(LONG)PLine,"\\");
d792 1
a792 1
									DUMPUDECL("Jumping1 to ",(LONG)MyRCB->Frame,"\\");
d800 1
a800 1
									DUMPUDECL("Jumping2 to ",(LONG)MyRCB->Frame,"\\");
d815 4
a818 4
								DUMPSTR("strncpy");
								DUMPHEXIL("( ",(LONG)PLine->Param," , ");
								DUMPSTR(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
								DUMPUDECL(" , ",(LONG)PLine->PropEnd,")\\ ");
d825 1
a825 1
					DUMPHEXIL("PLine=",(LONG)PLine,"\\");
d845 1
a845 1
					DUMPMSG	("GADGETUP");
d853 2
a854 2
						DUMPSTR("LastString: ");
						DUMPMSG(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
d857 1
a857 1
							DUMPHEXIL("LastPLine=",(LONG)PLine,"\\");
d867 1
a867 1
									DUMPUDECL("Jumping3 to ",(LONG)MyRCB->Frame,"\\");
d877 1
a877 1
									DUMPUDECL("Jumping4 to ",(LONG)MyRCB->Frame,"\\");
d891 4
a894 4
								DUMPSTR("strncpy");
								DUMPHEXIL("( ",(LONG)PLine->Param," , ");
								DUMPSTR(((struct StringInfo *)LastString->SpecialInfo)->Buffer);
								DUMPUDECL(" , ",(LONG)PLine->PropEnd,")\\ ");
d930 1
a930 1
					DUMPMSG	("-tick-");
d1011 1
a1011 1
					DUMPMSG	("MOUSEBUTTON");
d1023 1
a1023 1
					DUMPHEXIL("LastTime=",(LONG)LastTime,"\\");
d1063 1
a1063 1
						DUMPHEXIB("Key Code: ",A,"\\");
d1121 1
a1121 1
								DUMPHEXIL("LastTime=",(LONG)LastTime,"\\");
d1126 1
a1126 1
									DUMPMSG("Abort Play");
d1152 1
a1152 1
								DUMPHEXIL("(flags=",(LONG)LastTime->Flags,")\\");
d1170 1
a1170 1
									DUMPMSG("Abort Play");
d1206 1
a1206 1
									DUMPMSG("Abort Play");
d1254 1
a1254 1
									DUMPMSG("Abort Play");
d1497 1
a1497 1
			DUMPMSG("AudBars OK!!!");
d1501 1
a1501 1
			DUMPMSG("AudBars FAILED!!!");
d1512 1
a1512 1
			DUMPSTR("Set Name: "); DUMPMSG(ClipName);
d1964 1
a1964 1
					DUMPMSG("IDCMP_REFRESHWINDOW");
d2068 2
a2069 2
		DUMPMSG("Object to work with is called...");
		DUMPMSG(SrcName);
d2235 2
a2236 2
		DUMPSTR("Non-Destructive cutting on clip: ");
		DUMPMSG(ClipName);
d2249 3
a2251 2
		DUMPSTR("Destructive cutting on clip: ");
		DUMPMSG(ClipName);
d2653 1
a2653 1
									d=(PLine->Flags&PL_CFRAME) ? 2:1;
d2827 3
a2829 2
	DUMPSTR("Processing to path:");
	DUMPMSG(ClipPath);
d3544 1
a3545 1
//							if (IMqual & (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
d3582 1
a3582 1
							if ((itemcount == 4) && (IMqual & IEQUALIFIER_LSHIFT))
d3588 2
d3598 4
a3601 1
									MyRCB->Min = PLs[curID-1]->PropStart+pl->ShadowOffset;	// Min w/shadow
d3610 1
d3612 2
@


2.133
log
@Cutting room panel: doesn't put up "destroys original" req if came from rec panel
If user cancels this req, cleans up properly now and drops back into cutting panel.
Added Dest Drive popup in processing panel.
Quick tune now support shadow function, hotkeys shuffled around again, uses beveled hilite
box now, ready to use new TCDarkFont (when fixed), added arrow keys (???)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.132 1995/09/28 10:15:07 Flick Exp Flick $
d3 7
d384 1
d461 1
d2823 11
a2833 3
	if ((!destructive)
	|| (FromRawClip)
	|| (BoolRequest(EditTop->Window,"This will destroy the original clip!")))
d3162 12
d3326 1
a3326 1
#define	TCLEN		86
d3418 1
a3418 1
		SetFont(rp,DarkFont);
a3551 1
//								SetFont(rp,TCFont);
a3558 1
//								SetFont(rp,YellowFont);
d3678 1
a3678 1
				SetFont(rp,DarkFont);
d3683 8
a3690 8
			if (rp->cp_x <= xend)			// Clear out rest of ProgTime field
			{
				if (state)
					SetAPen(rp,PAL_DYELLOW);
				else
					SetAPen(rp,PAL_DGRAY);
				RectFill(rp,rp->cp_x,3,xend,13 /* QWINH */);
			}
@


2.132
log
@Now uses RawKeyCodes.h, cutting/proc panels now work correctly within subdirs, subclip name
string was being activated too early on panel open, looks better now, quick tune panel now
supports arrow keys and ganging points together w/ SPACE bar, fixed deadlock when releasing
ALT while jogging.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.131 1995/09/25 13:42:57 Flick Exp Flick $
d3 6
d434 1
a434 1
extern struct TextFont *DarkFont,*YellowFont;
d1981 2
a1982 1
		REG(a1) struct PanelLine *PLine,
d2024 1
a2024 1
	BOOL Going,ListOpen=FALSE;
d2027 1
a2027 1
	struct PanelLine *partsPL;
d2049 3
a2051 1
		SrcName = ((struct ExtFastGadget *)CurFG)->FileName;
d2070 2
d2138 4
a2151 4
//	if(ContCan=CreateContCancel(X1,H,&ThisG,0))
//		H += (UWORD)(PNL_YADD + ContCan->Height);
//	else goto rErrExit;

d2335 1
a2335 1
		MyRCB->FG = CurFG;
d2794 1
a2794 1
	DUMPUDECL("(Include code would have been ",partsPL->PropStart,")\\");
d2796 4
a2799 1
	if((Success == PAN_CONTINUE) && (ccd.ClipDisp))		// Do it?
d2801 16
a2816 1
	if ((!destructive) || (BoolRequest(EditTop->Window,"This will destroy the original clip!")))
a2818 1
//		ok = ClipDisplayNameCheck(ccd.ClipDisp,FlyDrive,EditTop->Window);
a2833 1
//			error = CutClipDownload(ccd.ClipDisp,FlyDrive,ClipFlags);
a2849 1
//					ClipDisplayIcons(ccd.ClipDisp,FlyDrive);
a2872 1
//						RemoveClipsDone(ccd.ClipDisp,FlyDrive,EditTop->Window);
d2908 6
d2915 1
d3299 1
a3299 1
#define	QZwidth	(QLBL+TCLEN+10)
d3335 1
a3335 1
	BOOL Going=TRUE,IDchange,ganged=FALSE;
d3342 1
d3355 1
a3355 1
		SetFont(rp,DarkFont);
d3366 2
d3475 1
a3475 2
							case RAW_KEYUP+RAWKEY_RALT:		// Right-ALT up
//							case RAW_KEYUP+RAWKEY_LAMIGA:		// Left Amiga up
d3490 1
a3490 1
								ganged = !ganged;		// Change A/V ganged mode
d3492 1
d3507 2
a3508 2
							if (IMqual & (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
//							if (IMqual & IEQUALIFIER_LALT)
d3523 1
a3523 1
								SetFont(rp,DarkFont);
d3531 1
a3531 1
								SetFont(rp,YellowFont);
d3540 1
a3540 1
							MyRCB->pline = PLs[curID];
d3542 12
a3553 4
//							if (IMqual & IEQUALIFIER_RCOMMAND)
//							if (IMqual & IEQUALIFIER_LSHIFT)
							if (ganged)
								MyRCB->pline->Flags |= PL_PARTNER;
d3555 1
a3555 1
								MyRCB->pline->Flags &= ~((ULONG)PL_PARTNER);
d3557 1
a3557 1
							MyRCB->Frame = Frms2Flds((ULONG)(*(PLs[curID]->Param) - smpte));
d3560 5
a3564 2
								MyRCB->Min = *PLs[curID-1]->Param;		// Min= in point
								MyRCB->Max = PLs[curID]->PropEnd;		// Max= clip max
d3568 5
a3572 2
								MyRCB->Min = PLs[curID]->PropStart;		// Min= clip min
								MyRCB->Max = *PLs[curID+1]->Param;		// Max= out point
d3599 1
a3599 1
						if (!(IMqual & IEQUALIFIER_RALT))
d3643 2
a3644 1
				Move(rp,x,rp->Font->tf_Baseline + 3 );
d3648 6
a3653 1
			Move(rp,x+QLBL,rp->Font->tf_Baseline + 3 );
d3672 1
a3672 1
	left = QXBASE+which*QAPART;
d3678 1
a3678 1
		SetAPen(rp,PAL_DYELLOW);
d3680 1
d3682 2
a3683 1
	RectFill(rp,left,top,left+w,top+h);
@


2.131
log
@Added Dropped line to RawRec panel, added Quick tune panel & support fn's
Cutting/Proc panels: fixed drive name bug, activates name string when new name built
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.130 1995/09/19 12:35:19 Flick Exp Flick $
d3 4
d387 1
d410 6
d485 1
a485 1
char ClipName[CLIP_PATH_MAX],ClipName2[CLIP_PATH_MAX];
d1045 2
a1046 2
							case	RAW_SPACE:
							case	RAW_TAB:
d1099 1
a1099 1
							case	RAW_LEFT:
d1144 1
a1144 1
							case RAW_RIGHT:
d1180 1
a1180 1
							case RAW_UP:
d1228 1
a1228 1
							case RAW_DOWN:
d1278 1
a1278 1
					if ((A == RAW_ENTER)||(A == RAW_RETURN))
d1283 1
a1283 1
					else if(A == RAW_HELP)
d1301 1
a1301 1
					else if((A == RAW_ESCAPE)) Going = FALSE;
d1414 1
a1414 1
			if (PLine->PLID == 1)
d1870 1
a1870 1
					if(Paused && A!=RAW_SPACE)
d1886 1
a1886 1
						if(A==RAW_SPACE) break;
d1890 2
a1891 2
						case RAW_ENTER:
						case RAW_RETURN:
d1896 1
a1896 1
						case RAW_HELP:
d1898 1
a1898 1
						case RAW_ESCAPE:
d1902 1
a1902 1
						case RAW_SPACE:
d2044 3
d2054 4
d2065 3
a2249 5
				// Activate name string gadget
				si = (struct StringInfo *) ccd.String->SpecialInfo;
				si->BufferPos = strlen(si->Buffer);		// Move cursor past end
				ActivateGadget(ccd.String,ccd.Window,NULL);

d2312 5
d2586 1
a2586 1
							case	RAW_CUT:
d2589 1
a2589 1
							case	RAW_LEFT:
d2620 1
a2620 1
							case RAW_RIGHT:
d2649 1
a2649 1
							case RAW_UP:
d2681 1
a2681 1
							case RAW_DOWN:
d2740 1
a2740 1
							case RAWKEY_PADPLUS:	// ditto
d2745 1
a2745 1
							case RAWKEY_PADMINUS:	// ditto
d2756 4
a2759 4
					else if( (A==(RAW_KEYUP|RAW_LEFT))
							|| (A==(RAW_KEYUP|RAW_RIGHT))
							||	(A==(RAW_KEYUP|RAW_DOWN))
							|| (A==(RAW_KEYUP|RAW_UP)) )	// key-up
d2764 1
a2764 1
					if ((A == RAW_ENTER)||(A == RAW_RETURN))
d2770 1
a2770 1
					else if((A == RAW_ESCAPE)) Going = FALSE;
d2790 2
a2791 1
		ok = ClipDisplayNameCheck(ccd.ClipDisp,FlyDrive,EditTop->Window);
d2806 2
a2807 1
			error = CutClipDownload(ccd.ClipDisp,FlyDrive,ClipFlags);
d2823 2
a2824 1
					ClipDisplayIcons(ccd.ClipDisp,FlyDrive);
d2847 2
a2848 1
						RemoveClipsDone(ccd.ClipDisp,FlyDrive,EditTop->Window);
d2878 3
a2880 3
			strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
			strncat(ClipName,TEMP_CLIP_NAME,CLIP_PATH_MAX);
			CrDeleteFile(ClipName);
d3191 2
a3192 2
							case	RAW_ENTER:
							case	RAW_RETURN:
d3196 1
a3196 1
							case	RAW_HELP:
d3210 1
a3210 1
//							case	RAW_F9:  // Inert on panels without Quick/fine tune button
d3216 1
a3216 1
							case	RAW_ESCAPE:
d3303 2
a3304 2
	BOOL Going=TRUE,IDchange;
	WORD	newID,curID;
d3309 1
d3400 1
a3400 1
				// Steal messages meant for project window
d3410 1
d3438 1
a3438 1
						if (IMcode == 0xE5)		// Right-ALT up
d3440 19
a3458 7
							Going = FALSE;
							success = PAN_CONTINUE;
							break;
						}
//						switch (IntuiMsg->Code)
//						{
//							case RAW_ESCAPE:
d3462 1
a3462 1
//						}
d3473 2
a3474 1
								newID += 2;
d3478 2
d3482 2
a3483 2
//						if ((newID != curID) && (PLs[newID]))		// Changing current point?
//						{
d3500 1
a3500 1
//						}
d3506 8
d3528 27
a3554 3
							DUMPMSG("Beginning test jog...");
							DHD_Jog(MyRCB);
							DUMPMSG("Done, let's leave");
d3607 1
a3607 1
				RectFill(rp,rp->cp_x,0,xend,QWINH);
@


2.130
log
@Changed panels to use less hard-coded buttons (i.e. Continue/Cancel), moved almost all to
GenButtons that can have custom options (like, uh, text label!)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.129 1995/09/13 12:33:09 Flick Exp Flick $
d3 4
d417 1
a417 1
extern struct TextFont *DarkFont;
d473 1
a473 2
static char FlyD[21],
	*DropErr[] = {"ERROR: Flyer dropped fields while recording.","Drive may be too slow for this quality mode."};
d507 1
a507 1
	LONG F;
d915 1
a915 1
					if(!EZJump(Ticks++)) break;  // skip ticks
d917 1
d921 2
a948 1
						break;
a949 6
//					if( (F=*(PLine->Param)) || (Adder>0))
					if( ((F=*(PLine->Param))>=PLine->PropStart) || (Adder>0))  // negative #s
						F += Adder*EZJump(Ticks++);
					else break;
					if(Adder<0)
						*(PLine->Param) = (F>=PLine->PropStart ? F:PLine->PropStart);
d951 16
a966 4
						*(PLine->Param) = (F<=PLine->PropEnd ? F:PLine->PropEnd);
					UpdatePanProp(PLine,Window);
					UpdatePanStr(PLine,Window);
					UpdateAllDiff(RP,Start,Window);
d1352 1
a1352 1
	struct PanelLine *PLine=EasyPanelPL,*LenPL=NULL,
d1402 4
d1650 1
d1756 9
d1782 1
d1923 1
d2011 1
d2014 1
a2014 1
	char *FlyDrive;
d2028 4
a2031 3
	FlyDrive = FlyerDrives[CurFlyDrive];
	if(*FlyDrive==AUDIO_BYTE)
		FlyDrive+=2; // Skip speaker symbol char and space
d2033 8
a2040 6
#if 0
	// First, determine if we are supposed to act as a clip-processing or cutting-room panel
	strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
	strncat(ClipName,TEMP_CLIP_NAME,CLIP_PATH_MAX);
	if(stricmp(((struct ExtFastGadget *)CurFG)->FileName,ClipName)) // Not TEMP clip
		process = TRUE;
d2042 6
a2047 2
		process = FALSE;			// Destructive cut-up
#endif
a2126 16
//	// Also add a "Record Panel" button for cutting-room panel only (if came from rec panel)
//	if (destructive && SrcName)
//	{
//		RecGadget = FindGadget(&Gadget1,ID_REC_PANEL);
//		if (!(RecGadget = AllocOneGadget(RecGadget)))
//			goto rErrExit;
//		ThisG->NextGadget = RecGadget;
//		ThisG = RecGadget;
//		ThisG->LeftEdge = (ClipNW.Width - ThisG->Width)>>1;
//		ThisG->TopEdge = ContCan->TopEdge;
//		ThisG->NextGadget = NULL;
//		ThisG->UserData = NULL;
//	}

//	LastGad = ThisG;

d2138 1
a2138 16
	// Lookup name of FastGadget, unless one is provided
	if (SrcName==NULL)
		SrcName = ((struct ExtFastGadget *)CurFG)->FileName;

	strncpy(ClipName,SrcName,CLIP_PATH_MAX);		// Now make copy

#if 0
	if (!destructive)
		strncpy(ClipName,((struct ExtFastGadget *)CurFG)->FileName,CLIP_PATH_MAX);
	else
	{
		// Make the "xxx:LastClipMade...uncut" name
		strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
		strncat(ClipName,TEMP_CLIP_NAME,CLIP_PATH_MAX);
	}
#endif
d2194 5
a2198 5
		for(Y=0; Y<=20 && ClipName[Y]!=':'; Y++)
			FlyD[Y] = ClipName[Y];
		FlyD[Y] = ClipName[Y++];
		FlyD[Y] = 0;
		FlyDrive = FlyD;
d2228 6
d2438 2
d2453 2
d2489 8
d2766 1
a2766 1
	if (BoolRequest(EditTop->Window,"This will destroy the original clip!"))
d2794 2
d2798 2
d2801 1
a2872 6
//	// Only want to free up to record panel gadget (if it exists)
//	if (LastGad)
//		LastGad->NextGadget = NULL;	// Don't try to free Clips gadget(s)
//	if (RecGadget)
//		RecGadget->NextGadget = NULL;
//	if (ContCan) FreeGadgets(ContCan);
d2889 1
d2891 1
a2891 1
	LONG F;
d2986 7
d3125 3
a3127 2
					if(!EZJump(Ticks++)) break;  // skip ticks
					if( !(PLine=(struct PanelLine *)EZGad->UserData) ) break;
d3129 15
a3143 10
					if( ((F=*(PLine->Param))>=PLine->PropStart) || (Adder>0))  // negative #s
						F += Adder*EZJump(Ticks++);
					else break;
					if(Adder<0)
						*(PLine->Param) = (F>=PLine->PropStart ? F:PLine->PropStart);
					else
						*(PLine->Param) = (F<=PLine->PropEnd ? F:PLine->PropEnd);
					UpdatePanProp(PLine,Window);
					UpdatePanStr(PLine,Window);
					UpdateAllDiff(RP,Start,Window);
d3228 325
@


2.129
log
@Ancillary functions moved to new PanelHelp.c to reduce code bulge
Added 3-color audio meters with clip and peak hold.  Support for Switcher fix
on ES_Jump by adding DHD_Jump "quiet" option.
Lots of new stuff for CutClipPanel: new calling args to be used both destr. and
non-destructively, support "include" popup, verification requester on "continue"
for destructive version, lots of fixes on icon slider, new logic when adding a
new clip (fills all space, Left/Right ALT options).
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.128 1995/08/18 17:01:29 Flick Exp Flick $
d3 9
d421 1
d433 2
a434 2
#define REC_FLAGS		SMART_REFRESH+BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED
#define STD_FLAGS		SIMPLE_REFRESH+BORDERLESS+ACTIVATE+NOCAREREFRESH+RMBTRAP+WFLG_NW_EXTENDED
d495 2
a496 1
	struct Gadget *ThisG=0,*ContCan;
d518 2
d600 1
a600 1
				if(PLine->Flags&PL_SMREF)
a601 2
				else
					ClipNW.Flags = STD_FLAGS;
d617 6
a622 4
	if(Wide) X1=PNL_WIDTH;
	if(ContCan=CreateContCancel(X1,H,&ThisG,XPMode))
		H += (UWORD)(PNL_YADD + ContCan->Height);
	else goto ErrExit;
d645 1
a645 1
		RefreshGList(ContCan,Window,NULL,-1);
d666 1
d873 15
a887 16
						if (PLine->Flags & PL_GENBUTT)
						{
							switch ((ULONG)PLine->Param)
							{
							case GB_PROCESS:		// Process clip
								Going = FALSE;
								Success = PAN_PROCESS;
								break;
							case GB_CUT:			// Cut clip
								Going = FALSE;
								Success = PAN_CUTUP;
								break;
							}
						}
//						if(PLine->Flags&PL_AVAIL)
//						{
d889 3
a891 30
//							Success = PAN_PROCESS;
//						}
					}
					else switch (ID)
					{
						case ID_DARK_CONTINUE:
							DUMPMSG	("CONTINUE");
							Success = PAN_CONTINUE;
						case ID_REQ_DARK_CANCEL:
							Going = FALSE;			//Success was initialized to FALSE
							break;
						case ID_FINE_TUNE:
							Going = FALSE;
							Success = PAN_EXPERT;
							break;
						case ID_QUICK_TUNE:
							Going = FALSE;
							Success = PAN_EASY;
							break;

					}
					break;

				case IDCMP_MOUSEMOVE:
					if(Down)
					{
						PLine = (struct PanelLine *)Down->UserData;
						if(PLine && PLine->Handle)
							PLine->Handle(PLine,IntuiMsg,Window);
					}
d958 9
d969 8
d1260 2
a1261 1
					} else if(A == RAW_HELP)
d1263 15
a1277 3
						Going = FALSE;			//Success was initialized to FALSE
						if(XPMode) Success = PAN_EXPERT;
						else Success=TRUE;
d1310 1
a1310 1
	if (ContCan) FreeGadgets(ContCan);
d1335 2
a1336 1
	struct Gadget *ThisG=0,*ContCan,*Record,*Pause;
d1341 1
a1341 1
	struct PanelLine *PLine=RawRecPL,*LenPL=NULL,
d1397 1
a1397 1
	ClipNW.Height = H+PNL_YADD+24;
d1404 1
a1404 1
	if( !(ContCan=CreateNewClipGads((struct NewWindow *)&ClipNW,F,&ThisG)) )
d1406 1
a1406 2
	Record=ContCan;
	while(Record->NextGadget && (Record->GadgetID != ID_VCR_REC) )
d1408 4
a1411 3
		Record=Record->NextGadget;
		if(Record->GadgetID == ID_VCR_PAUSE)
			Pause=Record;
d1413 1
d1431 1
a1431 1
		RefreshGList(ContCan,Window,NULL,-1);
d1481 1
d1551 38
a1588 1
						break;
d1672 24
a1695 24
						case ID_DARK_CONTINUE:  // called with NO_CUTTING_ROOM def'd
							if( RecordedAlready && !AudioOnly ) DHD_MakeClipIcon(ClipName);
							Success = PAN_CONTINUE;
							Going = FALSE;
							break;
						case ID_REQ_DARK_CANCEL:
							Going = FALSE;
							CrDeleteFile(ClipName);
							break;
						case ID_MARK_PANEL: // called without NO_CUTTING_ROOM def'd
							Going = FALSE;			//Success was initialized to FALSE
							Success = PAN_EXPERT;
							break;
						case ID_REORG:
							DUMPMSG	("Re-Organize");
							if(FlyerDriveCount>0)		// Don't reorg if no drives
							{
								tempdrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
								if (MaybeDoReorg(Window,tempdrive))
								{
									CTRL_SetDrive(FlyPL,IntuiMsg,NULL);
									UpdateAllDiff(RP,Start,Window);
								}

d1711 1
a1711 1
							}
d1716 1
d1923 1
a1923 1
	if (ContCan) FreeGadgets(ContCan);
d1964 8
d1977 2
a1978 3
	struct Gadget *ThisG=NULL,*RecGadget=NULL,*LastGad=NULL,*ContCan,*Clips,*Comm,
		CDisp = { NULL,0,0,20,20,GFLG_GADGHNONE,RELVERIFY,BOOLGADGET,NULL,NULL,NULL,NULL,NULL,CD_ID,NULL};

d1995 2
d2017 1
a2017 1
	for( Start = PLine; PLine->Type; PLine++ )
d2019 4
a2022 2
		if (PPOS_HALF2 & PLine->Align)
			X1 = PNL_WIDTH;
d2024 2
a2025 2
		// Call the gadget's create function
		if(PLine->Create)		Y1=PLine->Create(X1,H,PLine,&ThisG);
d2027 1
a2027 18
		if(PPOS_WIDER & PLine->Align)
		{
			X1 = PNL_WIDTH;
			Y = Y1;
		}
		else
		{
			if (Y>0)
				H += MAX(Y,Y1);		// Don't forget left half
			else
				H += Y1;					// Was no left half
			X1 = 0;
			Y = 0;
		}

		if(PLine->Flags)
		{
			if(PLine->Flags&PL_DUAL)
d2029 2
a2030 3
				ccd.TimePL = PLine;
				In=ccd.TimePL->StrGadg;
				Out=ccd.TimePL->StrGadg->NextGadget;
d2032 1
a2032 1
			else if(PLine->Flags&PL_DEL)
d2034 6
a2039 2
				ccd.String=PLine->StrGadg;
				ccd.StrPL = PLine;
d2041 2
a2042 6
			else if(PLine->Flags&PL_LEN)
				ccd.LenPL=PLine;
			else if(PLine->Flags&PL_PLAY)
				partsPL = PLine;
//				Strip=(ULONG *)&PLine->Param;
			else if(PLine->Flags&PL_AUDIO)
d2044 26
a2069 2
				ccd.FramePL=PLine;
				ccd.Frame=ccd.FramePL->StrGadg;
d2071 1
a2071 5
			else if(PLine->Flags&PL_AVAIL)
			{
				ccd.CommPL=PLine;
				Comm=PLine->StrGadg;
			}
a2072 1
		Lines++;
d2081 3
a2083 3
	if(ContCan=CreateContCancel(X1,H,&ThisG,0))
		H += (UWORD)(PNL_YADD + ContCan->Height);
	else goto rErrExit;
d2092 13
a2104 15
	// Also add a "Record Panel" button for cutting-room panel only (if came from rec panel)
	if (destructive && SrcName)
	{
		RecGadget = FindGadget(&Gadget1,ID_REC_PANEL);
		if (!(RecGadget = AllocOneGadget(RecGadget)))
			goto rErrExit;
		ThisG->NextGadget = RecGadget;
		ThisG = RecGadget;
		ThisG->LeftEdge = (ClipNW.Width - ThisG->Width)>>1;
		ThisG->TopEdge = ContCan->TopEdge;
		ThisG->NextGadget = NULL;
		ThisG->UserData = NULL;
	}

	LastGad = ThisG;
d2106 1
d2108 1
d2230 9
a2238 6
			ccd.FramePL->Param = &ccd.cl->icon;
			ccd.FramePL->PropEnd = ccd.cl->out;
			ccd.FramePL->PropStart = ccd.cl->in;
//			ccd.FramePL->G2 =(struct Gadget *) (ccd.cl->in-ccd.Tmin);
			AHiTime = &ccd.FramePL->PropEnd;
			ALoTime = &ccd.FramePL->PropStart;
d2251 1
a2251 1
		RefreshGList(ContCan,ccd.Window,NULL,-1);
a2253 1
		PLine = Start;
d2257 1
a2257 1
		while (PLine->Type)
d2259 4
a2262 2
			if (PPOS_HALF2 & PLine->Align)
				X1 = PNL_WIDTH;
d2264 2
a2265 2
			// Call the gadget's draw function
			PLine->Win = ccd.Window;
d2267 1
a2267 1
			if(PLine->Draw)	Y1=PLine->Draw(X1,H,PLine,ccd.Window);
d2269 5
a2273 9
			if(PPOS_WIDER & PLine->Align)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				if (Y>0)
					H += MAX(Y,Y1);		// Don't forget left half
d2275 8
a2282 3
					H += Y1;					// Was no left half
				X1 = 0;
				Y = 0;
a2283 1
			PLine++;
d2392 14
a2407 1
						break;
d2411 14
a2424 14
						case ID_DARK_CONTINUE:
							DUMPMSG	("CONTINUE");
							Success = PAN_CONTINUE;
						case ID_REQ_DARK_CANCEL:
							Playing=FALSE;
							Going = FALSE;			//Success was initialized to FALSE
//							DHD_Abort(0);
							break;
						case ID_REC_PANEL:
							Playing=FALSE;
							Going = FALSE;			//Success was initialized to FALSE
							Success = PAN_EASY;
//							DHD_Abort(0);
							break;
d2481 10
d2563 2
a2564 3
								ccd.FramePL->PropEnd = ccd.cl->out;
								ccd.FramePL->PropStart = ccd.cl->in;
								if(ccd.cl->in==ccd.cl->out)
d2566 7
a2572 2
									ccd.FramePL->PropEnd += 2;
									ccd.cl->icon=ccd.cl->in;
d2574 1
d2593 2
a2594 3
								ccd.FramePL->PropEnd = ccd.cl->out;
								ccd.FramePL->PropStart = ccd.cl->in;
								if(ccd.cl->in==ccd.cl->out)
d2596 7
a2602 2
									ccd.FramePL->PropEnd += 2;
									ccd.cl->icon=ccd.cl->in;
d2628 2
a2629 1
								if(ccd.cl->in==ccd.cl->out)
d2631 5
a2635 2
									ccd.FramePL->PropEnd += 2;
									ccd.cl->icon=ccd.cl->in;
d2660 2
a2661 1
								if(ccd.cl->in==ccd.cl->out)
d2663 5
a2667 2
									ccd.FramePL->PropEnd += 2;
									ccd.cl->icon=ccd.cl->in;
d2683 2
a2684 1
								if(ccd.cl->in==ccd.cl->out)
d2686 5
a2690 2
									ccd.FramePL->PropEnd += 2;
									ccd.cl->icon=ccd.cl->in;
d2846 3
a2848 3
	// Only want to free up to record panel gadget (if it exists)
	if (LastGad)
		LastGad->NextGadget = NULL;	// Don't try to free Clips gadget(s)
d2851 1
a2851 1
	if (ContCan) FreeGadgets(ContCan);
d2861 2
a2862 1
	struct Gadget *ThisG=0,*ContCan;
d2879 2
d2915 1
a2915 1
				if(PLine->Flags&PL_SMREF)
a2916 2
				else
					ClipNW.Flags = STD_FLAGS;
d2924 3
a2926 3
	if(ContCan=CreateContCancel(X1,H,&ThisG,XPMode))
		H += (UWORD)(PNL_YADD + ContCan->Height);
	else goto ErrExit;
d2946 1
a2946 1
		RefreshGList(ContCan,Window,NULL,-1);
d2986 2
a2987 1
		while (Going) {
d3058 1
a3058 1
						DoGenButtons(PLine,Window);
d3060 17
a3076 17
					else switch (ID)
					{
						case ID_DARK_CONTINUE:
							DUMPMSG	("CONTINUE");
							Success = PAN_CONTINUE;
						case ID_REQ_DARK_CANCEL:
							Going = FALSE;			//Success was initialized to FALSE
							break;
						case ID_FINE_TUNE:
							Going = FALSE;
							Success = PAN_EXPERT;
							break;
						case ID_QUICK_TUNE:
							Going = FALSE;
							Success = PAN_EASY;
							break;
					}
d3080 1
d3137 12
a3148 10
								if(XPMode==TUNE_FINE) Success = PAN_EXPERT;
								else if(XPMode==TUNE_QUICK) Success = PAN_EASY;
								else Success = PAN_CONTINUE;
								Going = FALSE;
								break;
							case	RAW_F9:  // Inert on panels without Quick/fine tune button
								if(XPMode==TUNE_FINE) Success = PAN_EXPERT;
								else if(XPMode==TUNE_QUICK) Success = PAN_EASY;
								else break;
								Going = FALSE;
d3150 6
d3190 2
a3191 1
	if (ContCan) FreeGadgets(ContCan);
@


2.128
log
@Lotsa changes to FlyPanel: left/right arrow keys would break if you touched any
other gadgets except for duoslide stuff.  They now also stop a play if in prog.
Duoslider knob would "miss" the first grab after playing clip
In/Out point strings work much better -- (used to clobber wrong points, or
could not be highlighted, or would lose tag values on exit: unless you were
nice and hit RETURN after making changed)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.127 1995/08/16 10:57:32 Flick Exp Flick $
d3 8
d377 3
a382 2
DrawBGFunc *DrawBG();
void __asm RenderFunc( REG(a0) struct RenderCallBack *);
a386 6
// *** Static prototypes ***
static int ClipDisplayNameCheck(struct ClipDisplay	*cd,char *FlyDrive, struct Window *win);
static void RemoveClipsDone(struct ClipDisplay *cd,char *FlyDrive, struct Window *win);
static void ChangeActiveClip(struct CutClipData *ccd, struct NewClip *newcl);
static void RemoveActiveClip(struct CutClipData *ccd);

a388 1
//#define NO_CUTTING_ROOM
d391 4
a394 2
//#define SERDEBUG	1
#include <serialdebug.h>
a399 1
extern struct st_PopupRender PopUp;
d404 1
a404 1
extern struct TextFont *EditFont,*DarkFont;
a412 1
extern BOOL UseDropFrame;
d421 1
d424 1
a424 1
#define STD_FLAGS		SIMPLE_REFRESH+BORDERLESS+ACTIVATE+NOCAREREFRESH+WFLG_NW_EXTENDED
d444 1
a444 1
struct PanelLine *CurPLine,*Start,*LastTime,*temp,*ALastTime;
d446 1
a446 1
LONG	InOrOut=0,ft,Adder;
a447 1
struct RenderCallBack StudlyRCB={RenderFunc,NULL,0,0,0,0,NULL,NULL}, *MyRCB=&StudlyRCB;
a448 9
UWORD	CandyStripe[] = {  // striped fill pattern
  0xe3e3,  0xf1f1,  0xf8f8,  0x7c7c,
  0x3e3e,  0x1f1f,  0x8f8f,  0xc7c7
};

UWORD	BCandyStripe[] = {  // striped fill pattern
  0xc7c7,  0x8f8f,  0x1f1f,  0x3e3e,
  0x7c7c,  0xf8f8,  0xf1f1,  0xe3e3
};
a449 1
WORD	Rect[21];
a450 38
struct ClipCrUD {
	ULONG	FORM;		// FORM
	ULONG	fSize;	// FORMSize
	ULONG	CrUD;		// CrUD
	ULONG	Type;		// TYPE
	ULONG	cSize;	// 8
	ULONG	Clip;		// CLIP
	ULONG	ClipEnd;		// NULL
	ULONG	LIBS;		// LIBS
	ULONG	lSize;	// 0x18
	ULONG	lOff;		// 0xFFFFFCD0
	UWORD	lHuh;		// 0x0010
	UBYTE	lName[18]; // "effects.library"
	ULONG	TAGS;		// TAGS
	ULONG	tSize;	// COMMENT_MAX + 12
	ULONG	CommentTag; // TAG_CommentList
	ULONG	ctSize;	// COMMENT_MAX
	UBYTE	Comment[COMMENT_MAX];
/*
	ULONG	tDuration;
	ULONG	Dur;
	ULONG	tRecFields;
	ULONG	Fields;
*/
	ULONG	TagsEnd; // NULL
};

#define ID_CLIP  0x434C4950
#define ID_STIL  0x5354494C

struct ClipCrUD MyCrUD = { 0x464F524D,0,0x43725544,0x54595045,8,
		ID_CLIP,0,
		0x4C494253,0x18,0xFFFFFCD0,0x0010,"effects.library",
		0x54414753,COMMENT_MAX + 12,
		TAG_CommentList,COMMENT_MAX,"",
//		TAG_Duration,180,TAG_RecFields,4,
		NULL};

d455 1
a455 1
//struct PanelLine QualPL={ PNL_POPUP,PNL_LEFT,"Video Quality",0,(LONG *)Qual,0,QUAL_NUM };
d457 3
a459 3
struct PanelLine QualPL={ PNL_POPUP,PNL_LEFT,"Video Quality",0,0,(LONG *)Qual,0,QUAL_NUM };
static char str[100],*Mes[]={"Patience please...     ",str};
static char ClipName[120],FlyD[21],
d461 2
a462 812

//*******************************************************************
//      Panel Specific Popup f'ns .. use global CurPLine

// AAR -- frzl 
char *NameFn(void *frzl, int Entries)
{
	char **PopUpNames=(char **)(CurPLine->Param);
	if (Entries < 0) Entries = 0;
	else if (Entries > ((CurPLine->PropEnd)-1)) Entries = (CurPLine->PropEnd)-1;
	return(PopUpNames[Entries]);
}

VOID RedrawPopText(struct Window *Window)
{
	char *C;
	struct Gadget *Gadget;

	if (Gadget = CurPLine->G1 ) {
		C = NameFn(NULL,( (int)CurPLine->PropStart ));
		SetFont(Window->RPort,EditFont);
		AnyPopupText(Gadget,C,Window,20);
	}
}

VOID HandlePopUp(struct Window *Window,struct IntuiMessage *IntuiMsg, struct PanelLine *PLine)
{
	PopUpID ID;
	struct Gadget *Gadget;
	WORD A,X,Y;

	CurPLine=PLine;
	PUCDefaultRender(&PopUp);
	PopUp.drawBG = (DrawBGFunc *)DrawBG;
	Gadget = CurPLine->G1;
	X = Gadget->LeftEdge + (Gadget->Width >> 1);
	Y = Gadget->TopEdge + (Gadget->Height >> 1);
	ID = PUCCreate((NameFunc *)NameFn,NULL,&PopUp);
	PUCSetNumItems(ID,CurPLine->PropEnd);
	PUCSetCurItem(ID,CurPLine->PropStart);

	Window->Flags |= WFLG_REPORTMOUSE;
	A = PUCActivate(ID,Window,X,Y,IntuiMsg->MouseX,IntuiMsg->MouseY);
	Window->Flags &= ~WFLG_REPORTMOUSE;
	PUCDestroy(ID);
	if (A >= 0)
	{
		if (A != ( (int)CurPLine->PropStart ))
		{
			CurPLine->PropStart = A;
		}
		RedrawPopText(Window);
	}
}

void DumpClip(struct NewClip *cl)
{
	DUMPSTR("Clip: ");
	DUMPSTR(cl->Name);
	DUMPUDECL("    In ",cl->in,"  ");
	DUMPUDECL(" Out",cl->out,"    Comment\\");
	DUMPMSG(cl->Comment);
}


void	__inline DHD_Pause(ULONG PauseOn)
{
	DUMPUDECL("DHD_Pause( ",PauseOn,"); \\ ");
	ESparams1.Data1 =(LONG) PauseOn;
	SendSwitcherReply(ES_Pause,&ESparams1);
	return;
}

void	__inline DHD_StartClipList(char *Name,ULONG Destruct)
{
	DUMPUDECL("DHD_StartClipList( ",Destruct,"); \\ ");
	ESparams2.Data1 =(LONG)Name ;
	ESparams2.Data2 =(LONG)Destruct ;
	SendSwitcherReply(ES_StartClipCutList,&ESparams2);
	return;
}

ULONG	__inline DHD_EndClipList(ULONG DoIt)
{
	ULONG	err;

	DisplayWaitSprite();
	DUMPUDECL("DHD_EndClipList( ",DoIt,") \\ ");
	ESparams1.Data1 =(LONG)DoIt ;
	err = (ULONG)SendSwitcherReply(ES_EndClipCutList,&ESparams1);
	DisplayNormalSprite();

	if (err)
	{
		DUMPHEXIL("EndClipList failed!  Error = ",err,"\\");
	}

	return(err);
}

// NOTA BENE!!!  Assumes clip in/out relative to raw clip start==0
ULONG	__inline DHD_AddClip(struct NewClip	*cl,char *FlyDrive,ULONG Flags)
{
	ULONG	err;

	strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
	strncat(ClipName,cl->Name,CLIP_PATH_MAX);

//	DUMPHEXIL("DHD_AddClip( ",(LONG)cl,") \\ ");
	ESparams4.Data1 =(LONG)ClipName ;
	ESparams4.Data2 =(LONG)cl->in<<1 ;
	ESparams4.Data3 =(LONG) (cl->out - cl->in + 2)<<1;
	ESparams4.Data4 =(LONG)Flags ;
	err = (ULONG)SendSwitcherReply(ES_AddClipCut,&ESparams4);

	if (err)
	{
		DUMPHEXIL("AddClip failed!  Error = ",err,"\\");
	}

	return(err);
}

// NOTA BENE!!!  Assumes clip in/out relative to raw clip start==0
ULONG	DHD_ClipIcon(struct NewClip	*cl, char *FlyDrive)
{
	ULONG	x=FALSE,f=0;	//assume error

	strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
	strncat(ClipName,cl->Name,CLIP_PATH_MAX);

	f=cl->icon - cl->in;

	// If we get a bogus icon field, just take the first field
	if (f >= (cl->out - cl->in))
		f = 0;

	DUMPSTR("DHD_ClipIcon( ");
	DUMPSTR(ClipName);
	DUMPUDECL(", ",f," )\\");

	if(cl->in==cl->out)
	{
		f=0;
		MyCrUD.Clip = ID_STIL;
	}
 	else
	{
//		MyCrUD.Dur = MyCrUD.Fields = (cl->out - cl->in + 2)<<1;
		MyCrUD.Clip = ID_CLIP;
	}
	CopyMem(cl->Comment,&(MyCrUD.Comment[0]),COMMENT_MAX);
	MyCrUD.fSize = sizeof(struct ClipCrUD)-8;
	ESparams4.Data1=(LONG)ClipName;
	ESparams4.Data2=(LONG)&MyCrUD;
	ESparams4.Data3=(LONG)sizeof(struct ClipCrUD);
	ESparams4.Data4=(LONG)(f&~1)<<1;
	x=(ULONG)SendSwitcherReply(ES_MakeClipIcon,&ESparams4);
//	ESparams1.Data1=(LONG)ClipName;
//	SendSwitcherReply(ES_AppendIcon,&ESparams1);
	return(x);
}

static char *mes[3] = {"File already exists"," Please enter new name for"};
BOOL GetNewName(struct Window *win,char *name, char *FlyDrive)
{
	BPTR L;
	strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
	strncat(ClipName,name,CLIP_PATH_MAX);
	while((L=Lock(ClipName,ACCESS_READ)))
	{
		UnLock(L);
		if(SimpleRequest(win,mes,2,REQ_STRING|REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,name))
		{
			strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
			strncat(ClipName,name,CLIP_PATH_MAX);
		}
		else return(FALSE);
	}
	return(TRUE);
}

static int ClipDisplayNameCheck(struct ClipDisplay	*cd,char *FlyDrive, struct Window *win)
{
	struct NewClip	*cl,*cl2,*ncl,*ncl2;
	char *MPtr[3];

	// First check to see that new sub-clip names do not exist on the drive already
	cl=(struct NewClip *)cd->Clips.mlh_Head;
	while(cl && (ncl=(struct NewClip *)cl->Node.mln_Succ) )
	{
		if(!GetNewName(win,cl->Name,FlyDrive))
			return(0);		// "Cancel"
		cl=ncl;
	}

	// Now check for duplicates in the name list
	cl=(struct NewClip *)cd->Clips.mlh_Head;
	while(cl && (ncl=(struct NewClip *)cl->Node.mln_Succ) )
	{
		cl2=ncl;
		while(cl2 && (ncl2=(struct NewClip *)cl2->Node.mln_Succ) )
		{
			if(stricmp(cl->Name,cl2->Name)==0)			// Found a duplication?
			{
				sprintf(str,"New clip name %s",cl->Name);
				MPtr[0] = str;
				MPtr[1] = "used more than once.  Fix and try again";
				SimpleRequest(win,MPtr,2,REQ_CENTER|REQ_H_CENTER,NULL);
				return(-1);		// "ReOpen"
			}

			cl2=ncl2;
		}
		cl=ncl;
	}

	return(1);		// "Okay"
}


//===================================================================================
// RemoveClipsDone
//		Deletes any clip definitions that seem to have been made already
//===================================================================================
static void RemoveClipsDone(struct ClipDisplay *cd,char *FlyDrive, struct Window *win)
{
	struct NewClip	*cl,*ncl;
	BPTR L;

	DUMPMSG("RCD called");

	cl=(struct NewClip *)cd->Clips.mlh_Head;
	while (cl && (ncl=(struct NewClip *)cl->Node.mln_Succ) )
	{
		strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
		strncat(ClipName,cl->Name,CLIP_PATH_MAX);
		DUMPSTR(ClipName);
		DUMPSTR(" -- ");

		if (L=Lock(ClipName,ACCESS_READ))
		{
			UnLock(L);
			DUMPMSG(" must have been successful");

			KillClip(cd,cl);
		}
		else
			DUMPMSG(" missing");

		cl=ncl;
	}
}


ULONG CutClipDownload(struct ClipDisplay	*cd,char *FlyDrive,ULONG Flags)
{
	ULONG	error = FERR_OKAY;
	char *MPtr[3],Line3[32];

	struct NewClip	*cl,*ncl;
	cl=(struct NewClip *)cd->Clips.mlh_Head;
	DisplayWaitSprite();

	while(cl && (ncl=(struct NewClip *)cl->Node.mln_Succ) )
	{
		cl->in -= cd->MinVal;
		if(cl->out>cd->MaxVal) cl->out=cd->MaxVal;
		cl->out -= cd->MinVal;
		error = DHD_AddClip(cl,FlyDrive,Flags);
		if (error != FERR_OKAY)
		{
			DisplayNormalSprite();

			MPtr[0] = "Unable to cut clip";
			strncpy(str,cl->Name,100);
			MPtr[1] = str;
			sprintf(Line3,"Internal error %d",error);
			MPtr[2] = Line3;

			// Put up internal error requester, check proceed or cancel
			if ((BOOL)SimpleRequest(EditTop->Window,MPtr,3,
			REQ_OK_CANCEL | REQ_CENTER | REQ_H_CENTER,NULL))
			{
				error = FERR_OKAY;			// User chose to ignore
				DisplayWaitSprite();
			}
			else
				break;							// User cancelled
		}
//		cl->in -= cd->MinVal;
//		cl->out -= cd->MinVal;
		cl=ncl;
	}
	DisplayNormalSprite();

	return(error);
}


void ClipDisplayIcons(struct ClipDisplay	*cd,char *FlyDrive)
{
	struct NewClip	*cl,*ncl;
	cl=(struct NewClip *)cd->Clips.mlh_Head;
	DisplayWaitSprite();
	while(cl && (ncl=(struct NewClip *)cl->Node.mln_Succ) )
	{
		cl->in -= cd->MinVal;
		if(cl->out>cd->MaxVal) cl->out=cd->MaxVal;
		cl->out -= cd->MinVal;
		if(cl->icon>cd->MaxVal) cl->icon=cd->MaxVal;
		cl->icon -= cd->MinVal;
		DHD_ClipIcon(cl,FlyDrive);
//		cl->in -= cd->MinVal;
//		cl->out -= cd->MinVal;
//		cl->icon -= cd->MinVal;
		cl=ncl;
	}
	DisplayNormalSprite();
}

struct ClipDisplay *InitClipDisplay(int x,int y,int w,int h,int min,int max, struct Window *Win)
{
	struct ClipDisplay	*cd;
	if(cd=SafeAllocMem(sizeof(struct ClipDisplay),MEMF_CLEAR) )
	{
		cd->X=x+2; //+Win->LeftEdge;
		cd->Y=y+2; //+Win->TopEdge;
		cd->W=w-4;
		cd->H=h-4;
		cd->MinVal=min;
		if((cd->MaxVal=max) && (max>min) ) // max =0 for un-initialized display
			cd->Scale=(cd->W*0xFFFF)/(max-min) ;  // Fixed Point Fraction...
		NewList((struct List *)&(cd->Clips));
		cd->RP = Win->RPort;
	}
	return(cd);
}

void FreeClipDisplay(struct ClipDisplay	*cd)
{
	struct NewClip	*cl,*ncl;
	cl=(struct NewClip *)cd->Clips.mlh_Head;
	while(ncl=(struct NewClip *)cl->Node.mln_Succ)
	{
		Remove((struct Node *)cl);
		FreeMem(cl,sizeof(struct NewClip)+CLIP_NAME_MAX+COMMENT_MAX+1);
		cl=ncl;
	}
	FreeMem(cd,sizeof(struct ClipDisplay));
}

struct NewClip	*GetClip(struct ClipDisplay	*cd,int val)
{
	struct NewClip	*cl,	*ret=NULL;
	if( (val<=cd->MaxVal) && (val>=cd->MinVal) )
	{
		cl=(struct NewClip *)cd->Clips.mlh_Head;
		while(cl->Node.mln_Succ && (val>=cl->in) )
		{
			if(val <= cl->out) ret=cl;
			cl=(struct NewClip *)cl->Node.mln_Succ;
		}
	}
	return(ret);
}

struct NewClip	*NextClip(struct ClipDisplay	*cd,int val)
{
	struct NewClip	*cl;
	if( (val<=cd->MaxVal) && (val>=cd->MinVal) )
	{
		cl=(struct NewClip *)cd->Clips.mlh_Head;
		while(cl && cl->Node.mln_Succ )
		{
			if(val>cl->in)
				cl=(struct NewClip *)cl->Node.mln_Succ;
			else return(cl);
		}
	}
	return(NULL);
}

void	InsertClip(struct ClipDisplay	*cd,struct NewClip	*cl)
{
	struct NewClip	*ncl;
	ncl=(struct NewClip *)cd->Clips.mlh_Head;
	while(ncl->Node.mln_Succ && (cl->in>=ncl->in) )
		ncl=(struct NewClip *)ncl->Node.mln_Succ;
	ncl=(struct NewClip *)ncl->Node.mln_Pred;
	Insert((struct List *)(&cd->Clips),(struct Node *)cl,(struct Node *)ncl);
}

struct NewClip	*AddClip(struct ClipDisplay	*cd,int in, int out,int type, char *name)
{
	struct NewClip	*cl=NULL;
	int t1,t2;
	if(cd->MaxVal>0) // display already has first clip at least
	{
		if( in>(cd->MaxVal) ) return(NULL);
		if( in<cd->MinVal ) in=cd->MinVal;
		if( out>cd->MaxVal ) out=cd->MaxVal ;
		if(in==out) out=in + FRAME_QUANT;
		if( cl=GetClip(cd,in) )
		{
			if(cl->out < (cd->MaxVal+FRAME_QUANT) )
				t1 = cl->out + FRAME_QUANT;
			else return(NULL); // ERROR Condition: clip past end
		}
		else t1=in;           // duoooh!!!

		if(out<t1) t2=t1 + FRAME_QUANT;
		else if( cl && (cl=(struct NewClip *)cl->Node.mln_Succ) && cl->Node.mln_Succ)
		{
			if(cl->in > out) t2=out;
			else t2=cl->in - FRAME_QUANT;
		}
		else if( cl=GetClip(cd,out) )
		{
			t2=cl->in - FRAME_QUANT;
		}
		else t2=out;

		if( (t2>t1) && (cl=SafeAllocMem(sizeof(struct NewClip)+CLIP_NAME_MAX+COMMENT_MAX+1,MEMF_CLEAR)) )
		{
			cl->in = t1;
			cl->out = t2;
			cl->icon = (cl->out + cl->in)/2;
			cl->type = type;
			cl->Name = (UBYTE *)( (ULONG)cl+sizeof(struct NewClip) );
			cl->Comment = (UBYTE *)(cl->Name+CLIP_NAME_MAX );
			strncpy(cl->Name,name,CLIP_NAME_MAX-1);

			DUMPSTR("AddClip: ");
			DUMPUDECL(cl->Name,cl->in," , ");
			DUMPUDECL(" ",cl->out," \\");

		}
		else return(cl);
	}
	else // first clip in has to set MaxVal!
	{
		cd->MinVal = in;
		if(cd->MaxVal = out)	cd->Scale=(cd->W*0xFFFF)/(cd->MaxVal-cd->MinVal) ;  // Fixed Point Fraction...
		if(cl=SafeAllocMem(sizeof(struct NewClip)+CLIP_NAME_MAX+COMMENT_MAX+1,MEMF_CLEAR))
		{
			cl->in=cd->MinVal;
			cl->out=out;  // When 1st clip is added it has to be nameless and empty
			cl->type = CLIP_EMPTY;
			cl->Name = (UBYTE *)( (ULONG)cl+sizeof(struct NewClip) );
			cl->Comment = (UBYTE *)(cl->Name+CLIP_NAME_MAX );
		}
		else return(cl);
	}
	InsertClip(cd,cl);
	return(cl);
}

struct NewClip	*KillClip(struct ClipDisplay	*cd,struct NewClip	*cl)
{
	struct NewClip	*ncl;
	if(cl==NULL) 	return(cl);
	if(ncl=(struct NewClip *)cl->Node.mln_Pred)
	{
		Remove((struct Node *)cl);
		FreeMem(cl,sizeof(struct NewClip)+CLIP_NAME_MAX+COMMENT_MAX+1);
	}
	if(ncl->Node.mln_Pred) return(ncl);
	else if( (ncl=(struct NewClip	*)ncl->Node.mln_Succ) && ncl->Node.mln_Succ)
		return(ncl);
	else return(NULL);
}

// Change clip's in and/or out val.s
BOOL SetClip(struct ClipDisplay	*cd, struct NewClip	*cl,ULONG in, ULONG out)
{
	struct NewClip	*tcl;
	ULONG t1,t2;
	in &=~1;    // only even frame #s
	out = (out+1)&~1; // round up
	if(out>cd->MaxVal) out=cd->MaxVal;
	if(in<cd->MinVal) in=cd->MinVal;
	if( cl->in <= in ) // move in-point in
	{
		if( cl->out > in ) t1=in;
		else t1=cl->out; // - STILL_QUANT; // cl->in; NOT // can't move in past old out.. need 2 calls or more code
	}
	else if( (tcl=(struct NewClip *)cl->Node.mln_Pred) && tcl->Node.mln_Pred )
	{
		if(in >= tcl->out + FRAME_QUANT ) t1=in;
		else t1=tcl->out + FRAME_QUANT;
	}
	else t1=in;

	if( cl->out >= out ) // move out-point in
	{
		if( t1 <= out ) t2=out;
		else t2=t1; // + FRAME_QUANT; // can't move out past new in..
	}
	else if( (tcl=(struct NewClip *)cl->Node.mln_Succ) && tcl->Node.mln_Succ )
	{
		if(out <= tcl->in - FRAME_QUANT ) t2=out;
		else t2 = tcl->in - FRAME_QUANT;
	}
	else t2=out;

	if( (cl->in!=t1) || (cl->out!=t2) ) // did anything change??
	{
		cl->in = t1;
		cl->out = t2;
		return(TRUE);  // doesn't fail on illegal moves (i.e. out!=t2)
	}
	return(FALSE);
}

// Set slider after change in time string, use 0 (LOOKS LIKE THIS IS USED BY NO ONE!)
__inline void UpdateClipSlider(struct ClipDisplay *cd,struct Gadget *Prop,struct Window *Window,ULONG Val)
{
		struct PropInfo *pi= ((struct PropInfo *)Prop->SpecialInfo);
//		Val=(Val*MAXPOT)/(cd->MaxVal - cd->MinVal);
		Val = SafeCalcNewPot(Prop, Val, cd->MinVal, cd->MaxVal);
		NewModifyProp(Prop,Window,NULL,pi->Flags,Val&0xFFFF,pi->VertPot,pi->HorizBody,pi->VertBody,1);
}

// Set time string after change in slider
void UpdateTime(struct Gadget *Time,struct Window *Window,ULONG Val)
{
	ULONG	A;
	A = RemoveGadget(Window,Time);
	LongToTime((ULONG *)&Val,((struct StringInfo *)Time->SpecialInfo)->Buffer);
	AddGadget(Window,Time,A);
	RefreshGList(Time,Window,NULL,1);
}

//*******************************************************************
// Correct time string (i.e. :32 ->1:02), fill *Param with frame #
// converts HH:MM:SS:FF to LONG # of FRAMEs,,
// if Even is true, number is rounded down to colorframe even
ULONG FixTimeStr(struct PanelLine *PLine, struct Window *Window, BOOL Even)
{
	ULONG oldpos,a,*L,F=0,M=0,S=0,H=0;
	ULONG	argcount,*ndx,arg,args[5] = {0,0,0,0,0};
	char c,*ptr;
	struct Gadget *ThisG;

	if( (PLine->Type==PNL_DUOSLIDE) && (PLine->Flags&PL_OUT) )
	{
		L=(ULONG *)PLine->Param2;
		ThisG=PLine->G4;
	}
	else {
		L=(ULONG *)PLine->Param;
		ThisG=PLine->StrGadg;
	}

	if( !ThisG ) return(0);

	oldpos = RemoveGadget(Window,ThisG);

	ptr = ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
	ndx = args;
	argcount = arg = 0;
	while (c = *ptr)
	{
		ptr++;
		if ((c >= '0') && (c <= '9'))
		{
			arg *= 10;
			arg += (c - '0');
		}
		if (((*ptr)==NULL) || (c == ':') || (c == ';') || (c == ' ') || (c == '.'))
		{
			*ndx++ = arg;
			argcount++;
			if (argcount > 4) break;
			arg = 0;
		}
	}

	if (argcount == 1)
		*L = args[0];
	else if (argcount == 2)
		*L = args[0]*30 + args[1];
	else if (argcount == 3)
		*L = args[0]*1800 + args[1]*30 + args[2];
	else if (argcount >= 4)
		*L = args[0]*108000 + args[1]*1800 + args[2]*30 + args[3];

	if(Even) (*L) &= 0xFFFFFFFE;
	a=*L;
	if (UseDropFrame) *L=PickUpFrames(*L);
	if(ThisG->Width != PLENSTRING_W)
	{
		F = a;
		H = F/108000;
		F	%= 108000;
		M = F / 1800;  // 60 secs/min * 30 frames/secs
		F %= 1800;
		S = F / 30;
		F %= 30;
		sprintf(((struct StringInfo *)ThisG->SpecialInfo)->Buffer,"%02ld:%02ld:%02ld:%02ld",H,M,S,F);
	}
	else
	{
		F = a;
		S = F / 30;
		F %= 30;
		sprintf(((struct StringInfo *)ThisG->SpecialInfo)->Buffer,"%02ld:%02ld",S,F);
	}

	AddGadget(Window,ThisG,oldpos);
	RefreshGList(ThisG,Window,NULL,1);
	return(*L);
}

/*  __inline void	Box(struct RastPort *RP,UWORD	x,UWORD y,UWORD	w,UWORD h)
{
	Rect[0] = x;		Rect[1] = y;
	Rect[2] = x + w;		Rect[3] = Rect[1];
	Rect[4] = Rect[2];			Rect[5] = y + h;
	Rect[6] = Rect[0];			Rect[7] = Rect[5];
	Rect[8] = Rect[0];			Rect[9] = Rect[3];
	Move(RP,Rect[0],Rect[1]);
	PolyDraw(RP,5,Rect);
}
 */

__inline void	BoxClip(struct ClipDisplay	*cd,UWORD	x1,UWORD x2)
{
	Rect[0] = cd->X + x1;		Rect[1] = cd->Y;
	Rect[2] = cd->X + x2;		Rect[5] = cd->Y + cd->H;
	Rect[4] = Rect[2];
	Rect[6] = Rect[0];
	Rect[8] = Rect[0];
	Rect[7] = Rect[5];
	Rect[9] = (Rect[3] = Rect[1]);

	Rect[10] = Rect[0] + 1;
	Rect[18] = (Rect[16] = Rect[10]);
	Rect[11] = Rect[1] + 1;
	Rect[19] = (Rect[13] = Rect[11]);
	Rect[14] = (Rect[12] = Rect[2] - 1);
	Rect[17] = (Rect[15] = Rect[5] - 1);
	Move(cd->RP,Rect[0],Rect[1]);
	PolyDraw(cd->RP,10,Rect);
}


void DrawClip(struct ClipDisplay *cd,struct NewClip *cl)
{
	UWORD	x1,x2;
	BYTE	APen=cd->RP->FgPen,BPen=cd->RP->BgPen,Dr=cd->RP->DrawMode;
	x1 = ((cl->in - cd->MinVal)*cd->Scale)/0xFFFF ;
	x2 = ((cl->out - cd->MinVal)*cd->Scale)/0xFFFF ;
	if(x1<0) x1=0;
	if(x2<0) x2=2;
	if(x2>=cd->W) x2=cd->W;
	if(x1>=cd->W) x1=cd->W-2;
	if(x2<=x1) x2=x1+2;
	switch(cl->type)
	{
		case CLIP_EMPTY:
//			SetAfPt(cd->RP,BCandyStripe,3);  // Nice stripes
			SetAPen(cd->RP,PAL_DGRAY);
			SetBPen(cd->RP,PAL_LGRAY);
			SetDrMd(cd->RP,JAM2);
			RectFill(cd->RP,cd->X + x1, cd->Y, cd->X + x2, cd->Y + cd->H);
//			SetAfPt(cd->RP,NULL,0);					// Clear pattern
			SetAPen(cd->RP,APen); // restore pens
			SetBPen(cd->RP,BPen); // restore pens
			SetDrMd(cd->RP,Dr); // restore pens
			break;
		case CLIP_ACTIVE:
			SetDrMd(cd->RP,JAM2);
			SetAPen(cd->RP,PAL_LYELLOW);
			RectFill(cd->RP,cd->X + x1, cd->Y, cd->X + x2, cd->Y + cd->H);
			SetAPen(cd->RP,PAL_BLACK);
			BoxClip(cd,x1,x2);
//			SetAfPt(cd->RP,NULL,0);					// Clear pattern
			SetAPen(cd->RP,APen); // restore pens
			SetBPen(cd->RP,BPen); // restore pens
			SetDrMd(cd->RP,Dr); // restore pens
			break;
		case CLIP_LOCKED:
			SetAfPt(cd->RP,CandyStripe,3);  // Nice stripes
			SetAPen(cd->RP,PAL_LBLACK);
			SetBPen(cd->RP,PAL_DYELLOW);
			SetDrMd(cd->RP,JAM2);
			RectFill(cd->RP,cd->X + x1, cd->Y, cd->X + x2, cd->Y + cd->H);
//			SetAPen(cd->RP,PAL_BLACK);
			BoxClip(cd,x1,x2);
			SetAfPt(cd->RP,NULL,0);					// Clear pattern
			SetAPen(cd->RP,APen); // restore pens
			SetBPen(cd->RP,BPen); // restore pens
			SetDrMd(cd->RP,Dr); // restore pens
			break;
	}
}

void	DrawClipDisplay(struct ClipDisplay	*cd)
{
	struct NewClip	*cl,*ncl;
	BYTE	APen=cd->RP->FgPen,BPen=cd->RP->BgPen,Dr=cd->RP->DrawMode;

	NewBorderBox(cd->RP,cd->X-2,cd->Y-2,cd->X+cd->W+2,cd->Y+cd->H+2,BOX_REV);
	SetAfPt(cd->RP,BCandyStripe,3);  // Nice stripes
			SetAPen(cd->RP,PAL_DGRAY);
			SetBPen(cd->RP,PAL_LGRAY);
			SetDrMd(cd->RP,JAM2);

	RectFill(cd->RP,cd->X , cd->Y, cd->X + cd->W, cd->Y + cd->H);
	SetAfPt(cd->RP,NULL,0);					// Clear pattern
			SetAPen(cd->RP,APen); // restore pens
			SetBPen(cd->RP,BPen); // restore pens
			SetDrMd(cd->RP,Dr); // restore pens

	cl=(struct NewClip *)cd->Clips.mlh_Head;
	while(ncl=(struct NewClip *)cl->Node.mln_Succ)
	{
		if (cl->type != CLIP_ACTIVE)
			DrawClip(cd,cl);			// Draw all the inactive ones
		cl=ncl;
	}

	cl=(struct NewClip *)cd->Clips.mlh_Head;
	while(ncl=(struct NewClip *)cl->Node.mln_Succ)
	{
		if (cl->type == CLIP_ACTIVE)
		{
			DrawClip(cd,cl);			// Just draw active one
			break;
		}
		cl=ncl;
	}
}

/*
struct BarGraph *InitBarGraph(int x,int y,int w,int h,int max, struct Window *Win)
{
	struct BarGraph	*bg;
	if(!max) return(NULL);
	if(bg=SafeAllocMem(sizeof(struct BarGraph),MEMF_CLEAR) )
	{
		bg->X=x+2; //+Win->LeftEdge;
		bg->Y=y+2; //+Win->TopEdge;
		bg->W=w-4;
		bg->H=h-4;
		bg->MaxVal=max;
		bg->Val=0;
		bg->RP = Win->RPort;
		bg->Scale=(bg->W*0xFFFF)/max ;  // Fixed Point Fraction...
		NewBorderBox(bg->RP,bg->X-2,bg->Y-2,bg->X+bg->W+2,bg->Y+bg->H+2,BOX_REV);
		SetAPen(bg->RP,PAL_DGRAY);
		RectFill(bg->RP,bg->X , bg->Y, bg->X + bg->W, bg->Y + bg->H);
	}
	return(bg);
}

void FreeBarGraph(struct BarGraph *bg)
{
	if(bg) FreeMem(bg,sizeof(struct BarGraph));
}

void UpdateBarGraph(struct BarGraph *bg, UWORD Val)
{
	UWORD x;
	if(Val==bg->Val) return;
	if(Val>bg->MaxVal)
	{
		if(bg->MaxVal==bg->Val) return;
		else Val=bg->MaxVal;
	}
	bg->Val=Val;
	SetAPen(bg->RP,PAL_DGRAY);
	RectFill(bg->RP,bg->X , bg->Y, bg->X + bg->W, bg->Y + bg->H);
	x=(bg->Val*bg->Scale)/0xFFFF;
	if(bg->Val==bg->MaxVal) SetAPen(bg->RP,PAL_LYELLOW);
	else SetAPen(bg->RP,PAL_DYELLOW);
	RectFill(bg->RP,bg->X , bg->Y, bg->X + x, bg->Y + bg->H);
}
*/

struct AudIndicator *InitAudIndicator(int x,int y,int w,int h,int max,UBYTE *Clipping, struct Window *Win)
{
	struct AudIndicator	*aInd;
	DUMPHEXIL("Indictor Clipping",(LONG)Clipping,"  ");
	if(!Clipping || !max) return(NULL);
	DUMPUDECL(" Making AudIndicator: ",sizeof(struct AudIndicator)," Bytes ");
	if(aInd=SafeAllocMem(sizeof(struct AudIndicator),MEMF_CLEAR) )
	{
		DUMPMSG(" Allocation OK ");
		aInd->X=x+2; //+Win->LeftEdge;
		aInd->Y=y+2; //+Win->TopEdge;
		aInd->W=w-4;
		aInd->H=h-4;
		aInd->ClipX=aInd->X + (aInd->W*14);
		aInd->Clip=Clipping;
		aInd->MaxVal=max;
		aInd->RP = Win->RPort;
		aInd->Clip1Lit = aInd->Clip2Lit = FALSE;
		NewBorderBox(aInd->RP,aInd->X-2,aInd->Y-2,aInd->X+aInd->W+2,aInd->Y+aInd->H+2,BOX_REV);
		NewBorderBox(aInd->RP,aInd->ClipX-2,aInd->Y-2,aInd->ClipX+aInd->W+2,aInd->Y+aInd->H+2,BOX_REV);
		SetAPen(aInd->RP,PAL_DGRAY);
		RectFill(aInd->RP,aInd->X , aInd->Y, aInd->X + aInd->W, aInd->Y + aInd->H);
		RectFill(aInd->RP,aInd->ClipX , aInd->Y, aInd->ClipX + aInd->W, aInd->Y + aInd->H);
	}
	return(aInd);
}

void FreeAudIndicator(struct AudIndicator *aInd)
{
	if(aInd) FreeMem(aInd,sizeof(struct AudIndicator));
}
a463 254
void UpdateAudIndicator(struct AudIndicator *aInd, UWORD Val)
{
	BOOL	newstate;

	if (Val>0)
		newstate = TRUE;
	else
		newstate = FALSE;

	if (newstate != aInd->Clip1Lit)		// Need to re-render?
	{
		SetAPen(aInd->RP,newstate ? PAL_DYELLOW : PAL_DGRAY);
		RectFill(aInd->RP,aInd->X , aInd->Y, aInd->X + aInd->W, aInd->Y + aInd->H);
		aInd->Clip1Lit = newstate;
	}

//	if(Val>aInd->MaxVal)				// Make 2nd LED "sticky"
//		*(aInd->Clip)=1;
//	if(!*(aInd->Clip))

	if (Val>1)							// Make 2nd LED "live"
		newstate = TRUE;
	else
		newstate = FALSE;

	if (newstate != aInd->Clip2Lit)		// Need to re-render?
	{
		SetAPen(aInd->RP,newstate ? PAL_LYELLOW : PAL_DGRAY);
		RectFill(aInd->RP,aInd->ClipX , aInd->Y, aInd->ClipX + aInd->W, aInd->Y + aInd->H);
		aInd->Clip2Lit = newstate;
	}
}


//*******************************************************************
// recalculates difference and prints it if changed, returns 0 if props need update
LONG UpdateDiff(struct RastPort *RP,struct PanelLine *PLine,struct Window *Window)
{
	LONG A,X,Y;
	char ch[32];

	A = *(PLine->Param) - *(PLine->Param2);
	if (A < 0)
	{
		A = 0;
		*(PLine->Param) = *(PLine->Param2) ;
	}
	A += (ULONG)PLine->G5;
	if (A != PLine->PropEnd) {
		PLine->PropEnd = A;
		ch[0] = 0;
		LongToTime((ULONG *)&PLine->PropEnd,&ch[strlen(ch)]);
		SetDrMd(RP,JAM2);
		SetAPen(RP,SCREEN_PEN);
		X=PLine->PropStart>>16;
		Y=PLine->PropStart&0xFFFF;
		RectFill(RP,X+80,Y,X+96,Y+TEXT_HEIGHT);
		Move(RP,X,Y+TEXT_BASE-1);
		SafeColorText(RP,ch,11);
	}
	return(A);
}

//*******************************************************************
// checks all PNL_DIFF PLines for change
VOID UpdateAllDiff(struct RastPort *RP,struct PanelLine *PLine,struct Window *Window)
{
	LONG FixProp=1;
	if(PLine==NULL) PLine=Start;
	while(PLine && PLine->Type)
	{
		if (PLine->Type == PNL_DIFF)
		FixProp *= UpdateDiff(RP,PLine,Window);
		else if ( (FixProp==0) && (PLine->Type==PNL_TIME) )
		{
			UpdatePanProp(PLine,Window);
			UpdatePanStr(PLine,Window);
		}
		PLine++;
	}
}

//*******************************************************************
// checks all PNL_FXTIME PLines for change
VOID UpdateFXTime(struct RastPort *RP,struct PanelLine *PLine,LONG t,struct Window *Window)
{
	if(t)
	{
		while (PLine->Type)
		{
			if (PLine->Type == PNL_FXTIME)
			{
				*PLine->Param=t;
				*PLine->Param2=0;
				UpdateDiff(RP,PLine,Window);
			}
			PLine++;
		}
	}
}

// Set FXSpeed button ot given SMFV, return framecount
LONG UpdateFXSpeed(struct PanelLine *PLine,LONG t,struct Window *Window)
{
	struct Gadget **PPGadg;
	UWORD	A;
	if( (PLine->Type == PNL_FXSPEED) && PLine->Param2[t] )
	{
		*PLine->Param=t;
		PPGadg = &PLine->G1;
		for (A=0;A<4;A++)
		{
			if (*PPGadg)
			{
				if(A!=t)	(*PPGadg++)->Flags &= (~GFLG_SELECTED);
				else (*PPGadg++)->Flags |= GFLG_SELECTED;
			}
		}
		if( (t==3) && (temp=(struct PanelLine *)PLine->PropStart))
			PLine->Param2[3]=*(temp->Param);
		RefreshGList(PLine->G1,Window,0,4);
		return(PLine->Param2[t]); // value to set time to
	}
	return(0);
}

//*******************************************************************
VOID AddPanelG(struct Gadget **First,struct Gadget **This,struct Gadget **New)
{
	if (!(*First)) *First = *This = *New;
	else
	{
		if(*This) (*This)->NextGadget = *New;
		*This = *New;
	}
}

//*******************************************************************
// goes from *(PLine->Param) to StrGadg

#define ENDFUDGE	12
VOID UpdatePanStr(struct PanelLine *PLine,struct Window *Window)
{
	struct Gadget *ThisG, *ThatG;
	LONG A,B;

	if( !(ThisG=PLine->StrGadg) ) return;
	A = RemoveGadget(Window,ThisG);
	switch(PLine->Type)
	{
		case PNL_TIME:		case PNL_EZTIME:
			LongToTime((ULONG *)PLine->Param,((struct StringInfo *)ThisG->SpecialInfo)->Buffer);
			break;
		case PNL_DUOSLIDE:
			LongToTime((ULONG *)PLine->Param,((struct StringInfo *)ThisG->SpecialInfo)->Buffer);
			if( !(ThatG=PLine->G4) ) break;
			B = RemoveGadget(Window,ThatG);
			LongToTime((ULONG *)PLine->Param2,((struct StringInfo *)ThatG->SpecialInfo)->Buffer);
			AddGadget(Window,ThatG,B);
			break;
		case PNL_EZLEN:
			LongToLen((ULONG *)PLine->Param,((struct StringInfo *)ThisG->SpecialInfo)->Buffer);
			break;
		case PNL_EZNUM:
		case PNL_NUMSLIDER:
			stcl_d( ((struct StringInfo *)ThisG->SpecialInfo)->Buffer,*PLine->Param);
			break;
	}
	AddGadget(Window,ThisG,A);
	RefreshGList(ThisG,Window,NULL,1);
}

//*******************************************************************
// goes from prop position to *(PLine->Param)
VOID UpdateParam(struct PanelLine *PLine,struct Window *Window)
{
	LONG A;

	A = PLine->PropEnd-PLine->PropStart;
	A = (((struct PropInfo *)PLine->PropGadg->SpecialInfo)->HorizPot * A)
		 / MAXPOT;
	A += PLine->PropStart;
	*(PLine->Param) = A;
	UpdatePanStr(PLine,Window);
}

//*******************************************************************
// goes from *(PLine->Param) to prop position between PropStart/PropEnd
VOID UpdatePanProp(struct PanelLine *PLine,struct Window *Window)
{
	LONG A=0;

	if (PLine->Param)
		A = *(PLine->Param);
	else
		return;

	if (PLine->PropEnd == PLine->PropStart)
		return;

	if (PLine->PropGadg)
	{
		struct PropInfo *pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);

		if (A > PLine->PropEnd)
			A = PLine->PropEnd;
		else if (A < PLine->PropStart)
			A = PLine->PropStart;

		if( (A!=*(PLine->Param)) )  // If bounds exceeded
		{
			*(PLine->Param)=A;
			UpdatePanStr(PLine,Window);
		}

//		A -= PLine->PropStart;
//		A += (LONG)PLine->G2;
//		A=(A*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
		A = SafeCalcNewPot(PLine->PropGadg, A+(LONG)PLine->G2, PLine->PropStart, PLine->PropEnd);

		NewModifyProp(PLine->PropGadg,Window,NULL,
				pi->Flags,A&0xFFFF,pi->VertPot,pi->HorizBody,pi->VertBody,1);
	}

	if (PLine->Param2)
		A = *(PLine->Param2);
	else
		return;

	if( (PLine->Type==PNL_DUOSLIDE) )
	{
		if(PLine->G5)
		{
			struct PropInfo *pi= ((struct PropInfo *)PLine->G5->SpecialInfo);

			if (A > PLine->PropEnd)
				A = PLine->PropEnd;
			else if (A < *PLine->Param)
				A = *PLine->Param+2;

			if( (A!=*(PLine->Param2)) )  // If bounds exceeded
			{
				*(PLine->Param2)=A;
				UpdatePanStr(PLine,Window);
			}
//			A -= PLine->PropStart;
//			A += (LONG)PLine->G2;
//			A=(A*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
			A = SafeCalcNewPot(PLine->G5, A+(LONG)PLine->G2, PLine->PropStart, PLine->PropEnd);
			NewModifyProp(PLine->G5,Window,NULL,
					pi->Flags,A&0xFFFF,pi->VertPot,pi->HorizBody,pi->VertBody,1);
		}
	}
}
a464 40
struct Gadget *CreateContCancel(UWORD	X1,UWORD	H, struct Gadget **ThisG,UWORD Tune)
{
	struct Gadget *NewG,*con=NULL,*can=NULL;
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_REQ_DARK_CANCEL))))
	{
		NewG->LeftEdge = X1 + PNL_WIDTH - NewG->Width - 8;
		NewG->TopEdge = H + PNL_YADD - 8;
		NewG->NextGadget = NULL;
		can=NewG;
		AddPanelG(&FirstG,ThisG,&NewG);
	} else return(can);
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_DARK_CONTINUE))))
	{
		NewG->LeftEdge = 8;
		NewG->TopEdge = H + PNL_YADD - 8;
		NewG->NextGadget = NULL;
		con=NewG;
		AddPanelG(&FirstG,ThisG,&NewG);
	} else
	{
		FreeGadgets(*ThisG);
		return((struct Gadget *)NULL);
	}
	if(Tune)
	{
		if ((NewG = AllocOneGadget(FindGadget(&Gadget1,(Tune&TUNE_QUICK ? ID_QUICK_TUNE:ID_FINE_TUNE) ))) )
		{
			NewG->LeftEdge = con->LeftEdge + con->Width;
			NewG->LeftEdge += (can->LeftEdge - NewG->LeftEdge - NewG->Width)>>1 ;
			NewG->TopEdge = H + PNL_YADD - 9;
			NewG->NextGadget = NULL;
			AddPanelG(&FirstG,ThisG,&NewG);
		} else
		{
			FreeGadgets(*ThisG);
			return((struct Gadget *)NULL);
		}
	}
	return( can );
}
d484 1
a484 1
	WORD H = PNL_Y1,ID,A,qual,X1=0,Y1=0,Lines=0;
d503 2
a504 1
		if(PLine->Width>0) Wide=TRUE;
d507 2
d513 9
a521 2
			if(PLine->Create) Y1=PLine->Create(X1,H,PLine,&ThisG);
			if(PLine->Width>0)
d528 11
a538 1
				H += MAX(Y,Y1);
d542 1
d617 1
d620 1
d623 2
d661 8
a668 2
				if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,Window);
				if(PLine->Width>0)
d675 4
a678 1
					H += MAX(Y,Y1);
d687 2
d785 3
a787 1
							PlayPL->UserFun(PlayPL,(APTR) 0);
d856 1
d858 2
a859 1
						if(PLine->Flags&PL_AVAIL)
d861 11
a871 2
							Going = FALSE;
							Success = PAN_PROCESS;
d873 5
d899 9
d909 3
a911 2
//					DUMPMSG	("-tick-");
					if(PlayPL && PlayFG)
d913 3
a915 5
						Y=DHD_CheckRecord();
						DUMPSDECL	("ChkPly: ",(LONG)Y,"\\");
						if( Y!=FERR_BUSY )
						{   // Check for play over
							PlayPL->UserFun(PlayPL,0);
d919 1
d978 2
d995 2
d998 11
d1022 1
a1022 1
								if(PlayPL)
d1024 5
a1028 2
									if(!PlayFG)
										PlayPL->UserFun(PlayPL,(APTR) CurFG);
d1030 4
a1033 1
										PlayPL->UserFun(PlayPL,(APTR) 0);
d1081 3
a1083 1
									PlayPL->UserFun(PlayPL,(APTR) 0);
d1111 1
a1111 1
									DHD_Jump(MyRCB);
d1125 3
a1127 1
									PlayPL->UserFun(PlayPL,(APTR) 0);
d1147 1
a1147 1
									DHD_Jump(MyRCB);
d1161 3
a1163 1
									PlayPL->UserFun(PlayPL,(APTR) 0);
d1179 1
a1179 1
										DHD_Jump(MyRCB);
d1209 3
a1211 1
									PlayPL->UserFun(PlayPL,(APTR) 0);
d1227 1
a1227 1
										DHD_Jump(MyRCB);
d1287 1
d1306 2
a1307 2
#define INSTR_ID	ID_BOOL+719
#define OUTSTR_ID	ID_BOOL+720
d1309 1
a1309 1
#define OUT_ID		ID_BOOL+722
d1311 1
a1311 257
#define JUMP_SIZE	30


static void RenderSlide(
	struct RenderCallBack *Call,
	long *frame,
	struct Gadget *pgad,
	struct Gadget *sgad )
{
	struct PanelLine *PLine;
	struct PropInfo *pi;
	ULONG	A;
//	ULONG scaled_ps,scaled_pe,scaled_fr;
	UWORD Val;

#ifdef SERDEBUG
	sprintf(str,"RS: Frame=%lx\n",*frame);
	DUMPSTR(str);
#endif

	if( (!Call) || (!(PLine = Call->pline)))
		return;

	if(pgad)
	{
		pi= ((struct PropInfo *)pgad->SpecialInfo);
//		A=((*frame-PLine->PropStart - (LONG)PLine->G2)*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
//		A=((*frame-PLine->PropStart)*MAXPOT)/(PLine->PropEnd - PLine->PropStart);

//		/* Scale all frame numbers down so that 16 bit math will not break */
//		scaled_ps = PLine->PropStart;
//		scaled_pe = PLine->PropEnd;
//		scaled_fr = (ULONG)*frame;
//		while ((scaled_pe - scaled_ps) > 0xFFFF)
//		{
//			scaled_ps >>= 1;
//			scaled_pe >>= 1;
//			scaled_fr >>= 1;
//		}
//
//		A=((scaled_fr-scaled_ps)*MAXPOT)/(scaled_pe - scaled_ps);
//		Val = A&0xFFFF;
		Val = SafeCalcNewPot(pgad, (ULONG)*frame, PLine->PropStart, PLine->PropEnd);

#ifdef SERDEBUG
//	sprintf(str,"RS: NewPot=%lx\n",Val);
//	DUMPSTR(str);
#endif

		if((Call->Flags&DHD_MOUSE_UPDATE))
		{
			A=Val* (pgad->Width - ((struct Image *)pgad->GadgetRender)->Width);
			A = (A/MAXPOT) + pgad->LeftEdge + Call->win->LeftEdge;
			Call->MouseX = (A&0xFFFF) + (((struct Image *)pgad->GadgetRender)->Width>>1);
		}
		NewModifyProp(pgad,Call->win,NULL,pi->Flags,Val,pi->VertPot,pi->HorizBody,pi->VertBody,1);
	}

	if(sgad)
	{
		A = RemoveGadget(Call->win,sgad);
		LongToTime((ULONG *)frame,((struct StringInfo *)sgad->SpecialInfo)->Buffer);
		AddGadget(Call->win,sgad,A);
		RefreshGList(sgad,Call->win,NULL,1);
	}
}

/* ***************  from Panel.h

struct RenderCallBack {
	void __asm (*RenderFn)(register __a0 APTR);
	struct FastGadget *FG;
	ULONG	Frame;  // Starting at 0, not SMPTE
	ULONG	Min;
	ULONG	Max;
	ULONG	Flags;
	struct Window *win;
	struct PanelLine *pline;
	WORD	MouseY;		//initially same as sc_MouseY
	WORD	MouseX;		//initially same as sc_MouseX
	WORD	VelocityNumerator;
	UWORD	VelocityDenominator;
};

************** */



void __saveds __asm RenderFunc(REG(a0) struct RenderCallBack *Call)
{
	struct PanelLine *PLine,*PartPL;
	if(!Call) return;

	if(PLine = Call->pline)
	{
#ifdef SERDEBUG
		sprintf(str,"RCB: Frame=%x   Min=%d   Max=%d\n",MyRCB->Frame,MyRCB->Min,MyRCB->Max);
		DUMPSTR(str);
		sprintf(str,"PLine: Param=%d   PropStart=%d   PropEnd=%d   G2=%d\n",*PLine->Param,PLine->PropStart,PLine->PropEnd,(LONG)PLine->G2);
		DUMPSTR(str);
#endif

		if( (PLine->Type==PNL_DUOSLIDE) && (PLine->Flags&PL_OUT) )
		{
			*PLine->Param2 = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart - (LONG)PLine->G2); // even frame #s
//			*PLine->Param2 = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart ); // even frame #s
			if (PLine->Flags & PL_SHADOW)
			{
				// Calc/render shadowed in-point based on out-point
				*PLine->Param = *PLine->Param2 - PLine->ShadowOffset;
				RenderSlide(Call,PLine->Param,PLine->PropGadg,PLine->StrGadg);
			}
			RenderSlide(Call,PLine->Param2,PLine->G5,PLine->G4);
		}
		else
		{
			*PLine->Param = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart - (LONG)PLine->G2); // even frame #s
//			*PLine->Param = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart ); // even frame #s
			if( (PLine->Type==PNL_DUOSLIDE) && (PLine->Flags & PL_SHADOW) )
			{
				// Calc/render shadowed out-point based on in-point
				*PLine->Param2 = *PLine->Param + PLine->ShadowOffset;
				RenderSlide(Call,PLine->Param2,PLine->G5,PLine->G4);
			}
			RenderSlide(Call,PLine->Param,PLine->PropGadg,PLine->StrGadg);
		}

		if( (PLine->Flags&PL_PARTNER) && (PartPL=PLine->Partners) )
		{
			Call->pline = PartPL;
			if( (PartPL->Type==PNL_DUOSLIDE) && (PartPL->Flags&PL_OUT) )
			{
//				*PartPL->Param2 = EVEN(1+(Call->Frame>>1)); // even frame #s
				*PartPL->Param2 = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart - (LONG)PLine->G2); // even frame #s
				if (PLine->Flags & PL_SHADOW)
				{
					// Calc/render shadowed in-point based on out-point
					*PartPL->Param = *PartPL->Param2 - PLine->ShadowOffset;
					RenderSlide(Call,PartPL->Param,PartPL->PropGadg,PartPL->StrGadg);
				}
				RenderSlide(Call,PartPL->Param2,PartPL->G5,PartPL->G4);
			}
			else
			{
				*PartPL->Param = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart - (LONG)PLine->G2); // even frame #s
//				*PartPL->Param = EVEN(1+(Call->Frame>>1)); // even frame #s
				if( (PartPL->Type==PNL_DUOSLIDE) && (PLine->Flags & PL_SHADOW) )
				{
					// Calc/render shadowed out-point based on in-point
					*PartPL->Param2 = *PartPL->Param + PLine->ShadowOffset;
					RenderSlide(Call,PartPL->Param2,PartPL->G5,PartPL->G4);
				}
				RenderSlide(Call,PartPL->Param,PartPL->PropGadg,PartPL->StrGadg);
			}
			Call->pline = PLine;
		}

		UpdateAllDiff(Call->win->RPort,NULL,Call->win);
	}
}

// Set global variables (side effects!!) return 1 for out, 0 for in point
ULONG	SetHiLo(struct PanelLine *PLine)
{
	ULONG	retval,*hi,*lo;

	DUMPMSG("* SetHiLo *");

	if(PLine->Flags&PL_OUT) // Adjusting Out Point
	{
		if (PLine->Flags & PL_SHADOW)
		{
			hi = &PLine->PropEnd;				// Slider max
			lo = &PLine->PropStart;				// Slider min (+ offset)
			PLine->ShadowOffset = *PLine->Param2 - *PLine->Param;		// Difference

			MyRCB->Max = (*hi - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*lo + PLine->ShadowOffset - PLine->PropStart + (LONG)PLine->G2)<<1;
		}
		else
		{
			hi = &PLine->PropEnd;				// Slider max
			lo = PLine->Param;					// In-point knob
			MyRCB->Max = (*hi - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*lo - PLine->PropStart + (LONG)PLine->G2)<<1;
		}

		retval = 1;
	}
	else if(PLine->Flags&PL_IN) // Adjusting In Point
	{
		if (PLine->Flags & PL_SHADOW)
		{
			hi = &PLine->PropEnd;				// Slider max (- offset)
			lo = &PLine->PropStart;				// Slider min
			PLine->ShadowOffset = *PLine->Param2 - *PLine->Param;		// Difference

			MyRCB->Max = (*hi - PLine->ShadowOffset - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*lo - PLine->PropStart + (LONG)PLine->G2)<<1;
		}
		else
		{
			hi = PLine->Param2;					// Out-point knob
			lo = &PLine->PropStart;				// Slider min
			MyRCB->Max = (*hi - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*lo - PLine->PropStart + (LONG)PLine->G2)<<1;
		}
		retval = 0;
	}
	else return(0);


	if(PLine->Flags&PL_AUDIO)
	{
		AHiTime=hi;
		ALoTime=lo;
	}
	else
	{
		HiTime=hi;
		LoTime=lo;
	}

	return(retval);
}

struct Gadget *CreateNewClipGads(struct NewWindow *NW, UWORD Y1, struct Gadget **ThisG)
{
	struct Gadget *Gadget, *Ret=NULL;
	UWORD Y;
#ifdef NO_CUTTING_ROOM
	Gadget = FindGadget(&Gadget1,ID_DARK_CONTINUE);
#else
	Gadget = FindGadget(&Gadget1,ID_MARK_PANEL);
#endif
	if ((Gadget = AllocOneGadget(Gadget)))
	{
		AddPanelG(&FirstG,ThisG,&Gadget);
		(*ThisG)->TopEdge = Y = NW->Height - 8 - (*ThisG)->Height;
		(*ThisG)->LeftEdge = (NW->Width - (*ThisG)->Width)>>1;
		(*ThisG)->NextGadget = NULL;
		(*ThisG)->UserData = NULL;
		Ret = *ThisG;
	}
	else return(NULL);


#ifndef NO_CUTTING_ROOM
	if ((Gadget = AllocOneGadget(FindGadget(&Gadget1,ID_REQ_DARK_CANCEL))))
	{
		(*ThisG)->NextGadget = Gadget;
		(*ThisG)= Gadget;
		(*ThisG)->UserData = NULL;
		(*ThisG)->LeftEdge = NW->Width - (*ThisG)->Width - 8;
		(*ThisG)->TopEdge = Y;
		(*ThisG)->NextGadget = NULL;
	}
a1312 61
	if ((Gadget = AllocOneGadget(FindGadget(&Gadget1,ID_DARK_CONTINUE))))
	{
		(*ThisG)->NextGadget = Gadget;
		(*ThisG)= Gadget;
		(*ThisG)->UserData = NULL;
		(*ThisG)->LeftEdge = 8;
		(*ThisG)->TopEdge = Y;
		(*ThisG)->NextGadget = NULL;
	}
#endif
	if(Y1)
	{
		Gadget = FindGadget(&Gadget1,ID_REORG);
		if ((Gadget = AllocOneGadget(Gadget)))
		{
			(*ThisG)->NextGadget = Gadget;
			(*ThisG) = Gadget;
			(*ThisG)->LeftEdge = (NW->Width - (*ThisG)->Width - (PNL_X1<<1) +2 );
			(*ThisG)->TopEdge = Y1;
			(*ThisG)->NextGadget = NULL;
			(*ThisG)->UserData = NULL;
		}
	}

		Gadget = FindGadget(&Gadget1,ID_VCR_PAUSE);
	if ((Gadget = AllocOneGadget(Gadget)))
	{
		(*ThisG)->NextGadget = Gadget;
		(*ThisG) = Gadget;
		(*ThisG)->Activation |= GACT_TOGGLESELECT;
		(*ThisG)->LeftEdge = (NW->Width>>1)-(4*Gadget->Width) - 8;
		(*ThisG)->TopEdge = Y - 24 - Gadget->Height;
		(*ThisG)->NextGadget = NULL;
		(*ThisG)->UserData = NULL;
	}

		Gadget = FindGadget(&Gadget1,ID_VCR_REC);
	if ((Gadget = AllocOneGadget(Gadget)))
	{
		(*ThisG)->NextGadget = Gadget;
		(*ThisG) = Gadget;
		(*ThisG)->Activation |= GACT_TOGGLESELECT;
		(*ThisG)->LeftEdge = (NW->Width>>1)-(3*Gadget->Width) - 8;
		(*ThisG)->TopEdge = Y - 24 - Gadget->Height;
		(*ThisG)->NextGadget = NULL;
		(*ThisG)->UserData = NULL;
	}

	Gadget = FindGadget(&Gadget1,ID_REQ_STOP);
	if ((Gadget = AllocOneGadget(Gadget)))
	{
		(*ThisG)->NextGadget = Gadget;
		Gadget->LeftEdge = (NW->Width>>1) -(2*((*ThisG)->Width)) - 8;
		Gadget->TopEdge = (*ThisG)->TopEdge;
		Gadget->Activation |= GACT_IMMEDIATE;
		Gadget->NextGadget = NULL;
		Gadget->UserData = NULL;
		(*ThisG) = Gadget;
	}
	return(Ret);
}
a1313 23
UWORD DrawPanel(struct PanelLine *PLine)
{
	UWORD	X1=0,Y=0,Y1,H=PNL_Y1;
	struct Window *win=PLine->Win;
	while (PLine->Type)
	{
		if(PLine->Type != PNL_SKIP)
		{
			if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,win);
			if(PLine->Width>0)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				H += MAX(Y,Y1);
				X1 = 0;
				Y = 0;
			}
		}
		PLine++;
	}
a1314 2
	return(H);
}
d1323 1
a1323 1
	UWORD Success = PAN_CANCEL,audlev;
d1328 1
a1328 1
	char *FlyDrive,*t,*tempdrive;
d1330 2
a1331 1
	struct AudIndicator *AudBarR=NULL,*AudBarL=NULL;
d1338 1
a1338 1
	t=(char *)&audlev;
d1345 6
a1350 3
			if(PLine->Create)
				Y1=PLine->Create(X1,H,PLine,&ThisG);
			if(PLine->Width>0)
d1357 4
a1360 1
				H += MAX(Y,Y1);
d1400 2
d1415 14
a1428 7
		/* Fixed these to display level 1 and level 2 clipping -- JMF */
		if( F && (AudBarL = InitAudIndicator(20,Record->TopEdge-20,16,8,1,&LClipping,Window))
		 && (AudBarR = InitAudIndicator(20+(Window->Width>>1),Record->TopEdge-20,16,8,1,&RClipping,Window)) )
		{
			audlev=GetRecSense();
			UpdateAudIndicator(AudBarL,t[0]);
			UpdateAudIndicator(AudBarR,t[1]);
d1449 1
d1498 1
a1498 1
								CTRL_SetDrive(FlyPL,NULL);
d1634 1
a1634 5
								if(*tempdrive==AUDIO_BYTE)
									tempdrive+=2; // Skip speaker symbol char and space

								sprintf(str,"If I reorganize %s, it may take a while... ",tempdrive);
								if(BoolRequest(Window,str))
d1636 1
a1636 7
									sprintf(str,"Reorganizing Flyer drive %s",tempdrive);
									OpenNoticeWindow(Window,Mes,2,FALSE);
									DisplayWaitSprite();
									DHD_Reorganize(tempdrive);
									DisplayNormalSprite();
									CloseNoticeWindow();
									CTRL_SetDrive(FlyPL,NULL);
d1639 16
d1659 8
d1701 1
a1701 1
											CTRL_SetDrive(FlyPL,NULL);
d1711 1
a1711 1
										sprintf(str,"Recording stopped, Flyer drive %s full.",((char **)FlyPL->Param)[FlyPL->PropStart]);
d1716 1
a1716 1
										ContinueRequest(Window,str);
d1742 2
a1743 2
										sprintf(str,"Recording stopped: Internal Flyer Error # %d.",err);
										ContinueRequest(Window,str);
d1754 16
a1769 4
						if(FlyerBase) audlev=GetRecSense();
						else audlev=((IntuiMsg->Micros>>3)&0x0707);
						UpdateAudIndicator(AudBarL,t[0]);
						UpdateAudIndicator(AudBarR,t[1]);
d1867 4
a1870 2
	if(AudBarL) FreeAudIndicator(AudBarL);
	if(AudBarR) FreeAudIndicator(AudBarR);
d1878 5
a1882 18
struct CutClipData {
	struct NewClip			*cl;			// Current sub-clip
	struct ClipDisplay	*ClipDisp;
	struct PanelLine		*TimePL;
	struct PanelLine		*StrPL;
	struct PanelLine		*LenPL;
	struct PanelLine		*FramePL;
	struct PanelLine		*CommPL;
	struct RastPort		*RP;
	struct Window			*Window;
	ULONG						Tmin,Tmax;
	struct Gadget			*Frame;
	struct Gadget			*String;
	ULONG						clipnum;
};


UWORD __asm CutClipPanel(REG(a0) struct EditWindow *Edit )
d1900 2
a1901 2
		"   n   Select next clip",
		"   p   Select previous clip",
d1911 1
a1911 1
	struct	ClipInfo	*ci;
d1915 1
a1915 1
	BOOL Going,process,ListOpen=FALSE;
d1917 2
a1918 1
	struct PanelLine *PLine = MarkClipPL;
d1920 2
a1921 1
	ULONG Y=0,t,d,*V,*Strip,ClipFlags;
d1925 1
a1925 1
	int	ok;
d1932 2
d1938 1
d1946 1
d1953 7
a1959 2
		if(PLine->Create) Y1=PLine->Create(X1,H,PLine,&ThisG);
		if(PLine->Width>0)
d1966 4
a1969 1
			H += MAX(Y,Y1);
d1990 2
a1991 1
				Strip=(ULONG *)&PLine->Param;
d2023 2
a2024 2
	// Also add a "Record Panel" button for cutting-room panel only
	if (!process)
d2047 1
d2050 8
a2057 1
	if (process)
d2065 1
d2070 25
a2094 2
		if(ci->Flags&CIF_HASVIDEO)
			*Strip |= 1;
d2096 15
a2110 5
			*Strip &= ~1;
		if(ci->Flags&CIF_HASAUDIO)
			*Strip |= 2;
		else
			*Strip &= ~2;
d2113 1
a2113 1
	if (process)
d2127 4
a2130 1
	else {
d2139 2
d2146 2
d2149 2
a2150 1
			sprintf(ClipName,"NewClip.%d",1+ccd.clipnum++);
d2164 1
a2164 1
			ccd.FramePL->G2 =(struct Gadget *) (ccd.cl->in-ccd.Tmin);
d2188 4
d2193 4
a2196 2
			if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,ccd.Window);
			if(PLine->Width>0)
d2203 4
a2206 1
				H += MAX(Y,Y1);
d2213 2
d2239 5
a2243 2
						if(PLine->Handle) PLine->Handle(PLine,IntuiMsg,ccd.Window);
						if( PLine==ccd.TimePL )
d2245 1
d2247 1
a2247 13
							if(ccd.cl)
							{
								UpdateTime(ccd.Frame,ccd.Window,ccd.cl->icon);
								ccd.FramePL->PropEnd = ccd.cl->out;
								ccd.FramePL->PropStart = ccd.cl->in;
								if(ccd.cl->in==ccd.cl->out)
								{
									ccd.FramePL->PropEnd += 2;
									ccd.cl->icon=ccd.cl->in;
								}
								ccd.FramePL->G2 =(struct Gadget *) (ccd.FramePL->PropStart-ccd.Tmin);
								UpdatePanProp(ccd.FramePL,ccd.Window);
							}
d2262 39
a2300 1
						if(PLine==ccd.StrPL)
d2302 2
d2305 1
a2305 1
						if((PLine->Flags == PL_GENBUTT) && (((ULONG)PLine->Param) == 1))
d2307 13
a2319 2
							DUMPMSG	("DEL!");
							RemoveActiveClip(&ccd);			// Do all necessary
d2349 33
a2381 5
									sprintf(ClipName,"NewClip.%d",1+ccd.clipnum++);
									tcl=AddClip(ccd.ClipDisp,t,t+30,CLIP_ACTIVE,ClipName);
									if( (ncl=(struct NewClip *)tcl->Node.mln_Succ) && ncl->Node.mln_Succ )
										tcl->out = ncl->in-FRAME_QUANT;
									else tcl->out=ccd.ClipDisp->MaxVal;
d2415 1
d2466 1
a2466 1
								DHD_Jump(MyRCB);
d2491 1
a2491 1
								DHD_Jump(MyRCB);
d2511 1
a2511 1
									DHD_Jump(MyRCB);
d2539 1
a2539 1
									DHD_Jump(MyRCB);
d2568 1
a2568 1
								DHD_Jump(MyRCB);
d2576 1
d2581 1
a2581 8
								// Find next sub-clip
								ncl = (struct NewClip *)ccd.cl->Node.mln_Succ;
								// If hit end of list, go back to beginning
								if ((ncl==0) || (ncl->Node.mln_Succ==0))
									ncl = (struct NewClip *)ccd.ClipDisp->Clips.mlh_Head;

								if (ncl)
									ChangeActiveClip(&ccd,ncl);		// Highlight next
d2586 1
a2586 8
								// Find prev sub-clip
								ncl = (struct NewClip *)ccd.cl->Node.mln_Pred;
								// If hit front of list, go to end
								if ((ncl==0) || (ncl->Node.mln_Pred==0))
									ncl = (struct NewClip *)ccd.ClipDisp->Clips.mlh_TailPred;

								if (ncl)
									ChangeActiveClip(&ccd,ncl);		// Highlight next
d2602 1
d2621 4
d2627 2
d2634 2
a2635 1
		if (ok && (*Strip))
d2638 2
a2639 1
			if((*Strip&1))
d2641 2
a2642 1
			if((*Strip&2))
d2648 2
a2649 2
				sprintf(str,"              Cutting clips on drive %s",FlyDrive);
				OpenNoticeWindow(EditTop->Window,Mes,2,FALSE);
d2664 1
a2664 1
					if (!process)			// (Destructive)
d2687 2
a2688 2
					sprintf(str,"Internal error %ld",error);
					MPtr[1] = str;
d2690 1
a2690 1
					if (process)
d2707 1
a2707 1
		if(!process)
d2714 1
a2738 225
static void ChangeActiveClip(struct CutClipData *ccd, struct NewClip *newcl)
{
	struct NewClip *cl,*oldcl;
	WORD	order;
	BOOL	goingrvs;

	if (newcl == ccd->cl)			// Do nothing if to me again
		return;

	oldcl = cl = ccd->cl;

	cl->type=CLIP_LOCKED;
	newcl->type=CLIP_ACTIVE;
	ccd->cl = cl= newcl;
	InOrOut=1;

	DUMPUDECL("Clip: ",(LONG)cl," \\  ");
	DUMPUDECL("In: ",(LONG)cl->in,"  ");
	DUMPUDECL("Out: ",(LONG)cl->out,"  ");

	DrawClipDisplay(ccd->ClipDisp);			// Draw all clips in the bar

	// Point Length and In/Out stuff at new clip
	ccd->LenPL->Param2	= ccd->TimePL->Param		= &cl->in;
	ccd->LenPL->Param		= ccd->TimePL->Param2	= &cl->out;
	DUMPUDECL("In: ",(LONG)*(ccd->TimePL->Param),"  ");
	DUMPUDECL("Out: ",(LONG)*(ccd->TimePL->Param2),"\\");
//	TimePL->PropStart = Tmin;
//	TimePL->PropEnd =  Tmax;
//	TimePL->G2 =0;

//	if( (ncl=(struct NewClip *)cl->Node.mln_Pred) && ncl->Node.mln_Pred )
//	{
//		DUMPSTR("Previous ");
//		DumpClip(ncl);
////		TimePL->PropStart = ncl->out;
////		TimePL->G2 =(struct Gadget *) (ncl->out-Tmin);
//	}
//	if( (ncl=(struct NewClip *)cl->Node.mln_Succ) && ncl->Node.mln_Succ )
//	{
//		DUMPSTR("Next ");
//		DumpClip(ncl);
////		TimePL->PropEnd = ncl->in;
//	}

	UpdateAllDiff(ccd->RP,Start,ccd->Window);

	HiTime=&ccd->TimePL->PropEnd;
	LoTime=&ccd->TimePL->PropStart;
	MyRCB->Max = (*HiTime - ccd->Tmin)<<1;			// Converting frms to flds?
	MyRCB->Min = (*LoTime - ccd->Tmin)<<1;			// ditto?
	MyRCB->pline = ccd->TimePL;
	DUMPUDECL("Param ",*ccd->TimePL->Param,"	");
	DUMPUDECL("Start ",ccd->TimePL->PropStart,"	");
	DUMPUDECL("End ",ccd->TimePL->PropEnd,"\\");
	DUMPUDECL("Limits ",*LoTime,",	");
	DUMPUDECL(" to ",*HiTime,"\\");


// We need to move each knob on the duoslide to a new location.  To prevent the first
// one we move from clobbering the 2nd (and then leaving a pot-hole when the 2nd is
// moved), we must update them in the proper order.  We determine this by comparing
// the old/new in-points.

	goingrvs = (newcl->in < oldcl->in);
	if (!goingrvs)
	{
		MyRCB->Frame = (ULONG)(*ccd->TimePL->Param2 - ccd->TimePL->PropStart)<<1;
		ccd->TimePL->Flags |= PL_OUT;
		ccd->TimePL->Flags &= ~PL_IN;
		DHD_Jump(MyRCB);				// Re-render out-point knob
	}
	MyRCB->Frame = (ULONG)(*ccd->TimePL->Param - ccd->TimePL->PropStart)<<1;
	ccd->TimePL->Flags &= ~PL_OUT;
	ccd->TimePL->Flags |= PL_IN;
	DHD_Jump(MyRCB);				// Re-render in-point knob

	if (goingrvs)
	{
		MyRCB->Frame = (ULONG)(*ccd->TimePL->Param2 - ccd->TimePL->PropStart)<<1;
		ccd->TimePL->Flags |= PL_OUT;
		ccd->TimePL->Flags &= ~PL_IN;
		DHD_Jump(MyRCB);				// Re-render out-point knob
	}

	UpdateTime(ccd->Frame,ccd->Window,cl->icon);
	ccd->FramePL->Param = &cl->icon;
	ccd->FramePL->PropStart = cl->in;
	ccd->FramePL->PropEnd = cl->out;
	if(cl->in==cl->out)
	{
		ccd->FramePL->PropEnd += 2;
		cl->icon=cl->in;
	}
	ccd->FramePL->G2 =(struct Gadget *) (ccd->FramePL->PropStart - ccd->Tmin);
	UpdatePanProp(ccd->FramePL,ccd->Window);

	order = RemoveGadget(ccd->Window,ccd->String);
	strncpy(((struct StringInfo *)ccd->String->SpecialInfo)->Buffer,cl->Name,CLIP_NAME_MAX-1);
	ccd->StrPL->Param = (LONG *) cl->Name;
	AddGadget(ccd->Window,ccd->String,order);
	RefreshGList(ccd->String,ccd->Window,NULL,1);

	order = RemoveGadget(ccd->Window,ccd->CommPL->StrGadg);
	strncpy(((struct StringInfo *)ccd->CommPL->StrGadg->SpecialInfo)->Buffer,cl->Comment,COMMENT_MAX-1);
	ccd->CommPL->Param = (LONG *) cl->Comment;
	AddGadget(ccd->Window,ccd->CommPL->StrGadg,order);
	RefreshGList(ccd->CommPL->StrGadg,ccd->Window,NULL,1);
}


// GEEZ, THIS HAS GOT A LOT OF REDUNDANT CODE w/ FUNCTION "CHANGEACTIVECLIP()"
// HAVE ONE USE THE OTHER SOON!!!
static void RemoveActiveClip(struct CutClipData *ccd)
{
	WORD	order;
	ULONG	oldinpt;
	struct NewClip	*ncl;
	BOOL	goingrvs;

	if(ccd->cl)
	{
		if( ((ncl=(struct NewClip *)ccd->cl->Node.mln_Pred) && ncl->Node.mln_Pred)
		|| ((ncl=(struct NewClip *)ccd->cl->Node.mln_Succ) && ncl->Node.mln_Succ) )
		{
			oldinpt = ccd->cl->in;			// Will need this for later rendering test

			if (ccd->cl=KillClip(ccd->ClipDisp,ccd->cl))
				ccd->cl->type=CLIP_ACTIVE;

//Don't ever back clipnum down, since we can't guarantee we deleted the highest #'d one.
//Could cause duplicate temp clip names!
//			ccd->clipnum--;

			DrawClipDisplay(ccd->ClipDisp);
			if(ccd->cl)
			{
				// Point Length and In/Out stuff at new clip
				ccd->LenPL->Param2	= ccd->TimePL->Param		= &ccd->cl->in;
				ccd->LenPL->Param		= ccd->TimePL->Param2	= &ccd->cl->out;
				ccd->TimePL->PropStart = ccd->Tmin;
				ccd->TimePL->PropEnd =  ccd->Tmax;
				ccd->TimePL->G2 =0;

//				if( (ncl=(struct NewClip *)ccd->cl->Node.mln_Pred) && ncl->Node.mln_Pred )
//				{
//					DUMPSTR("Previous ");
//					DumpClip(ncl);
////					ccd->TimePL->PropStart = ncl->out;
////					ccd->TimePL->G2 =(struct Gadget *) (ncl->out-ccd->Tmin);
//				}
//				if( (ncl=(struct NewClip *)ccd->cl->Node.mln_Succ) && ncl->Node.mln_Succ )
//				{
//					DUMPSTR("Next ");
//					DumpClip(ncl);
////					ccd->TimePL->PropEnd = ncl->in;
//				}

				UpdateAllDiff(ccd->RP,Start,ccd->Window);

				HiTime=&ccd->TimePL->PropEnd;
				LoTime=&ccd->TimePL->PropStart;
				MyRCB->Max = (*HiTime - ccd->Tmin)<<1;
				MyRCB->Min = (*LoTime - ccd->Tmin)<<1;
				MyRCB->pline = ccd->TimePL;
				DUMPUDECL("Param ",*ccd->TimePL->Param,"	");
				DUMPUDECL("Start ",ccd->TimePL->PropStart,"	");
				DUMPUDECL("End ",ccd->TimePL->PropEnd,"\\");
				DUMPUDECL("Limits ",*LoTime,",	");
				DUMPUDECL(" to ",*HiTime,"\\");

// We need to move each knob on the duoslide to a new location.  To prevent the first
// one we move from clobbering the 2nd (and then leaving a pot-hole when the 2nd is
// moved), we must update them in the proper order.  We determine this by comparing
// the old/new in-points.

				goingrvs = (ccd->cl->in < oldinpt);
				if (!goingrvs)
				{
					MyRCB->Frame = (ULONG)(*ccd->TimePL->Param2 - ccd->Tmin)<<1;
					ccd->TimePL->Flags |= PL_OUT;
					ccd->TimePL->Flags &= ~PL_IN;
					DHD_Jump(MyRCB);		// Render out-point knob
				}

				MyRCB->Frame = (ULONG)(*ccd->TimePL->Param - ccd->Tmin)<<1;
				ccd->TimePL->Flags &= ~PL_OUT;
				ccd->TimePL->Flags |= PL_IN;
				DHD_Jump(MyRCB);			// Render in-point knob

				if (goingrvs)
				{
					MyRCB->Frame = (ULONG)(*ccd->TimePL->Param2 - ccd->Tmin)<<1;
					ccd->TimePL->Flags |= PL_OUT;
					ccd->TimePL->Flags &= ~PL_IN;
					DHD_Jump(MyRCB);		// Render out-point knob
				}

				UpdateTime(ccd->Frame,ccd->Window,ccd->cl->icon);
				ccd->FramePL->Param = &ccd->cl->icon;
				ccd->FramePL->PropStart = ccd->cl->in;
				ccd->FramePL->PropEnd = ccd->cl->out;
				if(ccd->cl->in==ccd->cl->out)
				{
					ccd->FramePL->PropEnd += 2;
					ccd->cl->icon=ccd->cl->in;
				}
				ccd->FramePL->G2 =(struct Gadget *) (ccd->FramePL->PropStart-ccd->Tmin);
				UpdatePanProp(ccd->FramePL,ccd->Window);

				order = RemoveGadget(ccd->Window,ccd->String);
				strncpy(((struct StringInfo *)ccd->String->SpecialInfo)->Buffer,ccd->cl->Name,CLIP_NAME_MAX-1);
				ccd->StrPL->Param = (LONG *) ccd->cl->Name;
				AddGadget(ccd->Window,ccd->String,order);
				RefreshGList(ccd->String,ccd->Window,NULL,1);

				order = RemoveGadget(ccd->Window,ccd->CommPL->StrGadg);
				strncpy(((struct StringInfo *)ccd->CommPL->StrGadg->SpecialInfo)->Buffer,ccd->cl->Comment,COMMENT_MAX-1);
				ccd->CommPL->Param = (LONG *) ccd->cl->Comment;
				AddGadget(ccd->Window,ccd->CommPL->StrGadg,order);
				RefreshGList(ccd->CommPL->StrGadg,ccd->Window,NULL,1);
			}
		}
	}
}
d2756 5
a2760 1
		if(PLine->Width>0) Wide=TRUE;
d2765 7
a2771 2
			if(PLine->Create) Y1=PLine->Create(X1,H,PLine,&ThisG);
			if(PLine->Width>0)
d2778 4
a2781 1
				H += MAX(Y,Y1);
d2820 2
d2839 5
d2845 2
a2846 1
				if(PLine->Width>0)
d2853 4
a2856 1
					H += MAX(Y,Y1);
d2863 3
d2934 1
d2936 1
d2938 3
d3036 1
a3036 1
				}
@


2.127
log
@Added support for SHADOW function
Fixed some knob trashing on "remove" in cutting panels, fixed 'S' still function
Added duplicate name test before cutting clips (now may re-enter panel to fix)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.126 1995/08/09 17:57:22 Flick Exp Flick $
d3 5
d1046 3
a1048 2
	ULONG X,A = 0,B = 0,Z[5] = {0,0,0,0,0},*P,a,*L,F=0,M=0,S=0,H=0;
	char c,*T;
d1060 1
d1062 32
a1093 20
	X = RemoveGadget(Window,ThisG);
	T = ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
	P = Z;
	while (c = *T) {
		T++;
		if ((c >= '0') && (c <= '9')) {
			B *= 10;
			B += (c - '0');
		}
		if ((!(*T)) || (c == ':') || (c == ';') || (c == ' ') || (c == '.')) {
			*P++ = B;
			A++;
			if (A > 4) break;
			B = 0;
		}
	}
	if (A == 1) *L = Z[0];
	else if (A == 2) *L = Z[0]*30 + Z[1];
	else if (A == 3) *L = Z[0]*1800 + Z[1]*30 + Z[2];
	else if (A >= 4) *L = Z[0]*108000 + Z[1]*1800 + Z[2]*30 + Z[3];
d1096 1
a1096 1
	if(UseDropFrame) *L=PickUpFrames(*L);
d1115 2
a1116 1
	AddGadget(Window,ThisG,X);
d1634 1
a1634 1
	WORD H = PNL_Y1,ID,A,B,X1=0,Y1=0,Lines=0;
d1650 1
d1652 1
d1654 2
d1733 1
d1829 8
a1836 5
		while (Going) {
				WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
				switch(IntuiMsg->Class) {
d1838 1
a1838 1
//					DUMPMSG	("GADGETDOWN");
d1841 2
a1842 1
					if(LastString)
d1848 1
d1857 2
a1858 1
									DHD_Jump(MyRCB);
d1865 2
a1866 1
									DHD_Jump(MyRCB);
d1872 4
a1875 2
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
d1890 1
d1900 1
a1900 1
							break;
d1908 1
a1908 1
//					DUMPMSG	("GADGETUP");
d1920 1
d1923 1
a1923 1
								FixTimeStr(PLine,Window,FALSE);
d1927 1
a1927 1
									MyRCB->Frame = (ULONG)(*PLine->Param - *SMPTime)<<1;
d1930 2
a1931 1
									DHD_Jump(MyRCB);
d1937 1
a1937 1
									MyRCB->Frame = (ULONG)(*PLine->Param - *SMPTime)<<1;
d1940 2
a1941 1
									DHD_Jump(MyRCB);
d1967 1
d2060 1
a2060 1
//					DUMPMSG	("MOUSEMOVE");
d2063 2
d2088 1
a2088 1
						B = IntuiMsg->Qualifier;
d2141 1
d2143 8
a2150 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d2152 1
a2152 1
								else if(B & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
d2156 6
a2161 2
								if(LastTime->Flags & PL_IN) V=LastTime->Param;
								else V=LastTime->Param2;
d2165 2
a2166 2
								if(PLine->Flags&PL_AUDIO)
									*V = (Y>=*ALoTime+d ? Y-d:*ALoTime);
d2168 4
a2171 2
									*V = (Y>=*LoTime+d ? Y-d:*LoTime);
								if(PLine->Flags&PL_DUAL)
d2185 8
a2192 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d2194 1
a2194 1
								else if(B & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
d2197 1
a2197 1
									d=(PLine->Flags&PL_CFRAME) ? 2:1;
d2201 1
a2201 1
								if(PLine->Flags&PL_AUDIO)
d2205 1
a2205 1
								if(PLine->Flags&PL_DUAL)
d2219 7
d2233 1
a2233 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d2247 1
a2247 1
								else if(B & IEQUALIFIER_CONTROL )
d2265 7
d2279 1
a2279 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d2293 1
a2293 1
								else if(B & IEQUALIFIER_CONTROL )
@


2.126
log
@Reworked CutClipPanel, make it use a shared structure to make it easier to add
features to such as: N & P hotkeys to navigate thru subclips
Fixed bugs where knobs trashed each other for subclips
Selected subclip is now always rendered last, so it's fully visible
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.125 1995/07/27 18:11:03 Flick Exp Flick $
d3 6
d372 1
d374 2
d683 1
a683 1
BOOL ClipDisplayNameCheck(struct ClipDisplay	*cd,char *FlyDrive, struct Window *win)
d685 4
a688 1
	struct NewClip	*cl,*ncl;
d693 22
a714 1
			return(FALSE);
d717 2
a718 1
	return(TRUE);
d1777 1
d1782 4
a1785 2
			if(OutPL==InPL) HiTime = OutPL->Param2;
			else HiTime = OutPL->Param;
d1801 1
d1957 1
d1985 3
a1987 1
						if( (PLine->Flags&PL_FLYER) && !(PLine->Flags&PL_AUDIO) )
d1989 10
a1998 7
							MyRCB->Max = (*HiTime - *SMPTime)<<1;
							MyRCB->Min = (*LoTime - *SMPTime)<<1;
						}
						else if(PLine->Flags&PL_AUDIO)
						{
							MyRCB->Max = (*AHiTime - *SMPTime)<<1;
							MyRCB->Min = (*ALoTime - *SMPTime)<<1;
d2021 1
d2249 1
a2249 1
				}
d2384 1
d2393 1
d2398 6
d2410 6
d2418 1
d2426 6
d2438 6
d2456 4
d2462 1
a2462 1
		if(PLine->Flags&PL_AUDIO)
d2464 6
a2469 4
			AHiTime=&PLine->PropEnd;
			ALoTime=PLine->Param;
			MyRCB->Max = (*AHiTime - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*ALoTime - PLine->PropStart + (LONG)PLine->G2)<<1;
d2473 4
a2476 4
			HiTime=&PLine->PropEnd;
			LoTime=PLine->Param;
			MyRCB->Max = (*HiTime - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*LoTime - PLine->PropStart + (LONG)PLine->G2)<<1;
d2478 2
a2479 1
		return(1);
d2483 1
a2483 1
		if(PLine->Flags&PL_AUDIO)
d2485 6
a2490 4
			AHiTime=PLine->Param2;
			ALoTime=&PLine->PropStart;
			MyRCB->Max = (*AHiTime - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*ALoTime - PLine->PropStart + (LONG)PLine->G2)<<1;
d2494 4
a2497 4
			HiTime=PLine->Param2;
			LoTime=&PLine->PropStart;
			MyRCB->Max = (*HiTime - PLine->PropStart + (LONG)PLine->G2)<<1;
			MyRCB->Min = (*LoTime - PLine->PropStart + (LONG)PLine->G2)<<1;
d2499 14
a2512 1
		return(0);
d2514 2
a2515 1
	return(0);
d3154 2
d3198 1
a3198 1
	struct CutClipData	ccd;
d3203 1
a3203 2
	struct Gadget *ThisG=NULL,*RecGadget=NULL,*LastGad=NULL,
		*ContCan,*Clips,*Comm,
d3214 2
d3219 1
a3219 1
	ccd.Window=0;
d3231 1
a3231 1
		process = FALSE;
d3235 1
d3329 1
a3648 1
								*V = *HiTime;
d3651 1
d3659 1
a3676 1
								*V = *LoTime;
d3679 1
d3687 1
d3700 6
a3705 1
							case 0x21:			// S -- make still
d3710 1
d3718 1
d3720 3
a3722 1
							case 0x36:			// N -- next clip
d3732 3
a3734 1
							case 0x19:			// P -- prev clip
d3745 1
a3745 1
							case RAW_HELP:
d3750 1
a3750 1
							}
d3752 4
a3755 2
					else if(	(A==(0x80|RAW_LEFT)) || (A==(0x80|RAW_RIGHT))
								||	(A==(0x80|RAW_DOWN)) || (A==(0x80|RAW_UP)) )	// key-up
d3776 1
a3776 1
	if(ccd.ClipDisp)
d3778 6
a3783 3
		if (*Strip
		&& (Success != PAN_CANCEL)
		&& ClipDisplayNameCheck(ccd.ClipDisp,FlyDrive,EditTop->Window))
d3797 1
d3801 1
d3804 1
d3810 1
a3810 1
					if (!process)
d3817 1
a3817 1
					else
d3830 1
a3830 1
				else if (error != FERR_OKAY)
d3851 8
a3858 1
		FreeClipDisplay(ccd.ClipDisp);
d3861 2
a3862 7
	// If destructive clip cutting was performed, destroy original
	if(!process)
	{
		strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
		strncat(ClipName,TEMP_CLIP_NAME,CLIP_PATH_MAX);
		CrDeleteFile(ClipName);
	}
d3960 1
d3995 2
d4000 1
d4002 1
d4009 2
d4013 5
a4017 1
			ccd->clipnum--;
d4021 3
a4023 4
				ccd->TimePL->Param = &ccd->cl->in;
				ccd->TimePL->Param2 = &ccd->cl->out;
				ccd->LenPL->Param = ccd->TimePL->Param2;
				ccd->LenPL->Param2 = ccd->TimePL->Param;
d4027 15
a4041 13
				if( (ncl=(struct NewClip *)ccd->cl->Node.mln_Pred) && ncl->Node.mln_Pred )
				{
					DUMPSTR("Previous ");
					DumpClip(ncl);
//					ccd->TimePL->PropStart = ncl->out;
//					ccd->TimePL->G2 =(struct Gadget *) (ncl->out-ccd->Tmin);
				}
				if( (ncl=(struct NewClip *)ccd->cl->Node.mln_Succ) && ncl->Node.mln_Succ )
				{
					DUMPSTR("Next ");
					DumpClip(ncl);
//					ccd->TimePL->PropEnd = ncl->in;
				}
d4054 15
a4068 4
				MyRCB->Frame = (ULONG)(*ccd->TimePL->Param2 - ccd->Tmin)<<1;
				ccd->TimePL->Flags |= PL_OUT;
				ccd->TimePL->Flags &= ~PL_IN;
				DHD_Jump(MyRCB);
d4072 9
a4080 1
				DHD_Jump(MyRCB);
d4084 1
a4085 1
				ccd->FramePL->PropStart = ccd->cl->in;
@


2.125
log
@Added support for DELETE button in markclips/clip proc panels
Fixed destr. cutting room to not reopen if partially cut/tossed original
@
text
@d1 6
a6 2
/* $Id: panel.c,v 2.124 1995/07/14 16:03:41 Flick Exp Flick $
* $Log: panel.c,v $
d366 6
d982 1
a982 1
// Set slider after change in time string, use 0
d986 2
a987 1
		Val=(Val*MAXPOT)/(cd->MaxVal - cd->MinVal);
d1100 1
a1100 1
void	DrawClip(struct ClipDisplay	*cd,struct NewClip	*cl)
d1171 13
a1183 1
		DrawClip(cd,cl);
d1335 4
a1338 2
	while(PLine && PLine->Type) {
		if (PLine->Type == PNL_DIFF) FixProp*=UpdateDiff(RP,PLine,Window);
d1458 9
a1466 4
	if(PLine->Param) A = *(PLine->Param);
	else return;
	if(PLine->PropEnd == PLine->PropStart) return;
	if(PLine->PropGadg)
d1469 6
a1474 2
		if (A > PLine->PropEnd) A = PLine->PropEnd;
		else if (A < PLine->PropStart) A = PLine->PropStart;
d1480 6
a1485 3
		A -= PLine->PropStart;
		A += (LONG)PLine->G2;
		A=(A*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
d1489 6
a1494 2
	if(PLine->Param2) A = *(PLine->Param2);
	else return;
d1500 6
a1505 2
			if (A > PLine->PropEnd) A = PLine->PropEnd;
			else if (A < *PLine->Param) A = *PLine->Param+2;
d1511 4
a1514 3
			A -= PLine->PropStart;
			A += (LONG)PLine->G2;
			A=(A*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
d2258 2
a2259 1
	ULONG A,scaled_ps,scaled_pe,scaled_fr;
d2267 3
a2269 1
	if( !Call || !(PLine = Call->pline) ) return;
d2276 14
a2289 12
		/* Scale all frame numbers down so that 16 bit math will not break */
		scaled_ps = PLine->PropStart;
		scaled_pe = PLine->PropEnd;
		scaled_fr = (ULONG)*frame;
		while ((scaled_pe - scaled_ps) > 0xFFFF) {
			scaled_ps >>= 1;
			scaled_pe >>= 1;
			scaled_fr >>= 1;
		}

		A=((scaled_fr-scaled_ps)*MAXPOT)/(scaled_pe - scaled_ps);
		Val = A&0xFFFF;
d2292 2
a2293 2
	sprintf(str,"RS: NewPot=%lx\n",Val);
	DUMPSTR(str);
d2304 1
d3059 16
d3078 27
a3104 3
	WORD H = PNL_Y1,ID,A,B,X1=0,Y1=0,Lines=0;
	struct ClipDisplay	*ClipDisp=NULL;
	struct NewClip	*cl=NULL,*tcl=NULL,*ncl;
d3107 1
a3107 1
		*ContCan,*Clips,*String,*Frame,*Comm,
a3109 2
	struct Window *Window=0;
	struct RastPort *RP;
d3112 1
a3112 2
	struct PanelLine *PLine = MarkClipPL,*TimePL,*StrPL,
		*LenPL,*FramePL,*CommPL;
d3114 1
a3114 1
	ULONG Y=0,Tmax,Tmin,t,clipnum,d,*V,*Strip,ClipFlags;
d3118 4
d3156 3
a3158 3
				TimePL = PLine;
				In=TimePL->StrGadg;
				Out=TimePL->StrGadg->NextGadget;
d3162 2
a3163 2
				String=PLine->StrGadg;
				StrPL = PLine;
d3166 1
a3166 1
				LenPL=PLine;
d3171 2
a3172 2
				FramePL=PLine;
				Frame=FramePL->StrGadg;
d3176 1
a3176 1
				CommPL=PLine;
d3183 2
a3184 2
	Tmax = TimePL->PropEnd;
	Tmin = TimePL->PropStart;
d3224 1
a3224 1
	clipnum = 0;
d3268 1
a3268 1
	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
d3270 3
a3272 3
		RP = Window->RPort;
		SetDrMd(RP,JAM2);
		if(!ClipDisp)
d3274 1
a3274 1
			if(!(ClipDisp=InitClipDisplay(16,TimePL->PropGadg->TopEdge+TimePL->PropGadg->Height+20,Window->Width-32,24,Tmin,Tmax,Window)))
d3276 2
a3277 2
			sprintf(ClipName,"NewClip.%d",1+clipnum++);
			if(cl=AddClip(ClipDisp,Tmin,Tmax,CLIP_ACTIVE,ClipName))
d3279 28
a3306 21
				StrPL->Param = (LONG *) cl->Name;
				strncpy(((struct StringInfo *)String->SpecialInfo)->Buffer,cl->Name,CLIP_NAME_MAX-1);
				CommPL->Param = (LONG *) cl->Comment;
			}
			TimePL->Param = &cl->in;
			TimePL->Param2 = &cl->out;
			LenPL->Param = TimePL->Param2;
			LenPL->Param2 = TimePL->Param;
			FramePL->Param = &cl->icon;
			FramePL->PropEnd = cl->out;
			FramePL->PropStart = cl->in;
			FramePL->G2 =(struct Gadget *) (cl->in-Tmin);
			AHiTime = &FramePL->PropEnd;
			ALoTime = &FramePL->PropStart;
		}
		else ClipDisp->RP=Window->RPort;
		if(cl) StrPL->Param = (LONG *) cl->Name;
		Clips->LeftEdge = ClipDisp->X;
		Clips->TopEdge = ClipDisp->Y;
		Clips->Width = ClipDisp->W;
		Clips->Height = ClipDisp->H;
a3307 6
		AddGList(Window,FirstG,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		SetFont(RP,DarkFont);
		RefreshGList(ContCan,Window,NULL,-1);
		DrawClipDisplay(ClipDisp);

d3314 2
a3315 2
			PLine->Win = Window;
			if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,Window);
d3330 5
a3334 5
		HiTime = (TimePL->Param2);
		LoTime = &TimePL->PropStart;
		MyRCB->Frame = (ULONG)(*TimePL->Param - Tmin)<<1;
		MyRCB->Max = (*HiTime - Tmin)<<1;
		MyRCB->Min = (*LoTime - Tmin)<<1;
d3336 2
a3337 2
		MyRCB->win = Window;
		MyRCB->pline = TimePL;
d3343 1
a3343 1
				WaitPort(Window->UserPort);
d3345 1
a3345 1
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
d3354 2
a3355 2
						if(PLine->Handle) PLine->Handle(PLine,IntuiMsg,Window);
						if( PLine==TimePL )
d3357 2
a3358 2
							DrawClipDisplay(ClipDisp);
							if(cl)
d3360 4
a3363 4
								UpdateTime(Frame,Window,cl->icon);
								FramePL->PropEnd = cl->out;
								FramePL->PropStart = cl->in;
								if(cl->in==cl->out)
d3365 2
a3366 2
									FramePL->PropEnd += 2;
									cl->icon=cl->in;
d3368 2
a3369 2
								FramePL->G2 =(struct Gadget *) (FramePL->PropStart-Tmin);
								UpdatePanProp(FramePL,Window);
d3384 3
a3386 3
						PLine->Handle(PLine,IntuiMsg,Window);
						if(PLine==StrPL)
							ActivateGadget(Comm,Window,NULL);
d3391 1
a3391 5
							// This is a real hack, that's why it works so well in this program/
							// 'A' must be NULL'd out so that we can use the RAWKEY logic
							//  without any repercussions.  (Sigh)
							A = 0;
							goto glom_onto_cut;
d3412 1
a3412 1
							if(cl)
d3414 2
a3415 1
								t=Tmin + ((IntuiMsg->MouseX - ClipDisp->X)*0xFFFF)/ClipDisp->Scale;
d3418 1
a3418 1
								if( !(tcl=GetClip(ClipDisp,t)) )
d3421 2
a3422 2
									sprintf(ClipName,"NewClip.%d",1+clipnum++);
									tcl=AddClip(ClipDisp,t,t+30,CLIP_ACTIVE,ClipName);
d3425 1
a3425 1
									else tcl->out=ClipDisp->MaxVal;
d3428 1
d3431 2
a3432 77
									cl->type=CLIP_LOCKED;
									tcl->type=CLIP_ACTIVE;
									cl=tcl;
									InOrOut=1;

									DUMPUDECL("Clip: ",(LONG)cl," \\  ");
									DUMPUDECL("In: ",(LONG)cl->in,"  ");
									DUMPUDECL("Out: ",(LONG)cl->out,"  ");

									DrawClipDisplay(ClipDisp);
									TimePL->Param = &cl->in;
									TimePL->Param2 = &cl->out;
									LenPL->Param = TimePL->Param2;
									LenPL->Param2 = TimePL->Param;
									DUMPUDECL("In: ",(LONG)*(TimePL->Param),"  ");
									DUMPUDECL("Out: ",(LONG)*(TimePL->Param2),"\\");
//									TimePL->PropStart = Tmin;
//									TimePL->PropEnd =  Tmax;
//									TimePL->G2 =0;
									if( (ncl=(struct NewClip *)cl->Node.mln_Pred) && ncl->Node.mln_Pred )
									{
										DUMPSTR("Previous ");
										DumpClip(ncl);
//										TimePL->PropStart = ncl->out;
//										TimePL->G2 =(struct Gadget *) (ncl->out-Tmin);
									}
									if( (ncl=(struct NewClip *)cl->Node.mln_Succ) && ncl->Node.mln_Succ )
									{
										DUMPSTR("Next ");
										DumpClip(ncl);
//										TimePL->PropEnd = ncl->in;
									}
									UpdateAllDiff(RP,Start,Window);

									HiTime=&TimePL->PropEnd;
									LoTime=&TimePL->PropStart;
									MyRCB->Max = (*HiTime - Tmin)<<1;
									MyRCB->Min = (*LoTime - Tmin)<<1;
									MyRCB->pline = TimePL;
									DUMPUDECL("Param ",*TimePL->Param,"	");
									DUMPUDECL("Start ",TimePL->PropStart,"	");
									DUMPUDECL("End ",TimePL->PropEnd,"\\");
									DUMPUDECL("Limits ",*LoTime,",	");
									DUMPUDECL(" to ",*HiTime,"\\");
									MyRCB->Frame = (ULONG)(*TimePL->Param2 - TimePL->PropStart)<<1;
									TimePL->Flags |= PL_OUT;
									TimePL->Flags &= ~PL_IN;
									DHD_Jump(MyRCB);
									MyRCB->Frame = (ULONG)(*TimePL->Param - TimePL->PropStart)<<1;
									TimePL->Flags &= ~PL_OUT;
									TimePL->Flags |= PL_IN;
									DHD_Jump(MyRCB);

									UpdateTime(Frame,Window,cl->icon);
									FramePL->Param = &cl->icon;
									FramePL->PropEnd = cl->out;
									FramePL->PropStart = cl->in;
									if(cl->in==cl->out)
									{
										FramePL->PropEnd += 2;
										cl->icon=cl->in;
									}
									FramePL->G2 =(struct Gadget *) (FramePL->PropStart-Tmin);
									UpdatePanProp(FramePL,Window);

									A = RemoveGadget(Window,String);
									strncpy(((struct StringInfo *)String->SpecialInfo)->Buffer,cl->Name,CLIP_NAME_MAX-1);
									StrPL->Param = (LONG *) cl->Name;
									AddGadget(Window,String,A);
									RefreshGList(String,Window,NULL,1);

									A = RemoveGadget(Window,CommPL->StrGadg);
									strncpy(((struct StringInfo *)CommPL->StrGadg->SpecialInfo)->Buffer,cl->Comment,COMMENT_MAX-1);
									CommPL->Param = (LONG *) cl->Comment;
									AddGadget(Window,CommPL->StrGadg,A);
									RefreshGList(CommPL->StrGadg,Window,NULL,1);

d3442 1
a3442 1
						ModifyIDCMP(Window,WinFlags);
d3447 1
a3447 1
					ModifyIDCMP(Window,WinFlags); // turn off ticks
d3449 1
a3449 1
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param) - Tmin)<<1;
d3451 1
a3451 1
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param2) - Tmin)<<1;
d3458 2
a3459 2
					DrawClipDisplay(ClipDisp);
					UpdateAllDiff(RP,Start,Window);
d3466 1
a3466 1
						B = IntuiMsg->Qualifier;
d3472 3
a3474 3
								ActivateGadget(In,Window,NULL);
								TimePL->Flags &= ~PL_OUT;
								TimePL->Flags |= PL_IN;
d3478 3
a3480 3
								ActivateGadget(Out,Window,NULL);
								TimePL->Flags &= ~PL_IN;
								TimePL->Flags |= PL_OUT;
d3483 2
a3484 2
								if(!String) break;
								ActivateGadget(String,Window,NULL);
d3488 1
a3488 1
								ActivateGadget(Comm,Window,NULL);
d3491 1
a3491 79
glom_onto_cut:
								if(cl)
								{
									if( ((ncl=(struct NewClip *)cl->Node.mln_Pred) && ncl->Node.mln_Pred)
									|| ((ncl=(struct NewClip *)cl->Node.mln_Succ) && ncl->Node.mln_Succ) )
									{
										if(cl=KillClip(ClipDisp,cl))
											cl->type=CLIP_ACTIVE;
										clipnum--;
										DrawClipDisplay(ClipDisp);
										if(cl)
										{
											TimePL->Param = &cl->in;
											TimePL->Param2 = &cl->out;
											LenPL->Param = TimePL->Param2;
											LenPL->Param2 = TimePL->Param;
											TimePL->PropStart = Tmin;
											TimePL->PropEnd =  Tmax;
											TimePL->G2 =0;
											if( (ncl=(struct NewClip *)cl->Node.mln_Pred) && ncl->Node.mln_Pred )
											{
												DUMPSTR("Previous ");
												DumpClip(ncl);
//												TimePL->PropStart = ncl->out;
//												TimePL->G2 =(struct Gadget *) (ncl->out-Tmin);
											}
											if( (ncl=(struct NewClip *)cl->Node.mln_Succ) && ncl->Node.mln_Succ )
											{
												DUMPSTR("Next ");
												DumpClip(ncl);
//												TimePL->PropEnd = ncl->in;
											}
											UpdateAllDiff(RP,Start,Window);

											HiTime=&TimePL->PropEnd;
											LoTime=&TimePL->PropStart;
											MyRCB->Max = (*HiTime - Tmin)<<1;
											MyRCB->Min = (*LoTime - Tmin)<<1;
											MyRCB->pline = TimePL;
											DUMPUDECL("Param ",*TimePL->Param,"	");
											DUMPUDECL("Start ",TimePL->PropStart,"	");
											DUMPUDECL("End ",TimePL->PropEnd,"\\");
											DUMPUDECL("Limits ",*LoTime,",	");
											DUMPUDECL(" to ",*HiTime,"\\");
											MyRCB->Frame = (ULONG)(*TimePL->Param2 - Tmin)<<1;
											TimePL->Flags |= PL_OUT;
											TimePL->Flags &= ~PL_IN;
											DHD_Jump(MyRCB);
											MyRCB->Frame = (ULONG)(*TimePL->Param - Tmin)<<1;
											TimePL->Flags &= ~PL_OUT;
											TimePL->Flags |= PL_IN;
											DHD_Jump(MyRCB);

											UpdateTime(Frame,Window,cl->icon);
											FramePL->Param = &cl->icon;
											FramePL->PropEnd = cl->out;
											FramePL->PropStart = cl->in;
											if(cl->in==cl->out)
											{
												FramePL->PropEnd += 2;
												cl->icon=cl->in;
											}
											FramePL->G2 =(struct Gadget *) (FramePL->PropStart-Tmin);
											UpdatePanProp(FramePL,Window);

											A = RemoveGadget(Window,String);
											strncpy(((struct StringInfo *)String->SpecialInfo)->Buffer,cl->Name,CLIP_NAME_MAX-1);
											StrPL->Param = (LONG *) cl->Name;
											AddGadget(Window,String,A);
											RefreshGList(String,Window,NULL,1);

											A = RemoveGadget(Window,CommPL->StrGadg);
											strncpy(((struct StringInfo *)CommPL->StrGadg->SpecialInfo)->Buffer,cl->Comment,COMMENT_MAX-1);
											CommPL->Param = (LONG *) cl->Comment;
											AddGadget(Window,CommPL->StrGadg,A);
											RefreshGList(CommPL->StrGadg,Window,NULL,1);
										}
									}
								}
a3492 1

d3494 1
a3494 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d3496 7
a3502 2
								else if(B & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									d = (TimePL->PropEnd - TimePL->PropStart)/10+1;
d3504 2
a3505 3
									d=(TimePL->Flags&PL_CFRAME) ? 2:1;
								if(TimePL->Flags & PL_IN) V=TimePL->Param;
								else V=TimePL->Param2;
d3507 2
a3508 2
								*V = (Y>=*LoTime+d ? Y-d:*LoTime);
								MyRCB->Frame = (ULONG)(*V - Tmin)<<1;
d3510 3
a3512 3
								FramePL->PropEnd = cl->out;
								FramePL->PropStart = cl->in;
								if(cl->in==cl->out)
d3514 2
a3515 2
									FramePL->PropEnd += 2;
									cl->icon=cl->in;
d3517 1
a3517 1
								UpdateAllDiff(RP,Start,Window);
d3520 1
a3520 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d3522 2
a3523 2
								else if(B & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									d = (TimePL->PropEnd - TimePL->PropStart)/10+1;
d3526 5
a3530 2
								if(TimePL->Flags & PL_IN) V=TimePL->Param;
								else V=TimePL->Param2;
d3532 2
a3533 2
								*V = (Y<=*HiTime-d ? Y+d:*HiTime);
								MyRCB->Frame = (ULONG)(*V - Tmin)<<1;
d3535 3
a3537 3
								FramePL->PropEnd = cl->out;
								FramePL->PropStart = cl->in;
								if(cl->in==cl->out)
d3539 2
a3540 2
									FramePL->PropEnd += 2;
									cl->icon=cl->in;
d3542 1
a3542 1
								UpdateAllDiff(RP,Start,Window);
d3545 4
a3548 2
								if(TimePL->Flags & PL_IN) V=TimePL->Param;
								else V=TimePL->Param2;
d3550 1
a3550 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d3552 2
a3553 1
									MyRCB->Frame = (ULONG)(*V - Tmin)<<1;
d3555 1
a3555 1
									UpdateAllDiff(RP,Start,Window);
d3557 1
a3557 1
								else if(B & IEQUALIFIER_CONTROL )
d3559 2
a3560 1
									MyRCB->Frame = (ULONG)(*V - Tmin)<<1;
d3563 1
a3563 1
									UpdateAllDiff(RP,Start,Window);
d3565 1
a3565 1
								if(cl->in==cl->out)
d3567 2
a3568 2
									FramePL->PropEnd += 2;
									cl->icon=cl->in;
d3572 4
a3575 2
								if(TimePL->Flags & PL_IN) V=TimePL->Param;
								else V=TimePL->Param2;
d3577 1
a3577 1
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
d3579 2
a3580 1
									MyRCB->Frame = (ULONG)(*V - Tmin)<<1;
d3582 1
a3582 1
									UpdateAllDiff(RP,Start,Window);
d3584 1
a3584 1
								else if(B & IEQUALIFIER_CONTROL )
d3586 2
a3587 1
									MyRCB->Frame = (ULONG)(*V - Tmin)<<1;
d3590 6
a3595 1
									UpdateAllDiff(RP,Start,Window);
d3597 9
a3605 1
								if(cl->in==cl->out)
d3607 2
a3608 2
									FramePL->PropEnd += 2;
									cl->icon=cl->in;
d3611 26
d3642 1
a3642 1
						DrawClipDisplay(ClipDisp);
d3656 1
a3656 1
		CloseWindow(Window);
d3661 1
a3661 1
	if(ClipDisp)
d3663 3
a3665 2
		if(*Strip && (Success != PAN_CANCEL)
			&& ClipDisplayNameCheck(ClipDisp,FlyDrive,EditTop->Window))
d3673 1
a3673 1
			error = CutClipDownload(ClipDisp,FlyDrive,ClipFlags);
d3683 1
a3683 1
					ClipDisplayIcons(ClipDisp,FlyDrive);
d3704 1
a3704 1
						RemoveClipsDone(ClipDisp,FlyDrive,EditTop->Window);
d3730 1
a3730 1
		FreeClipDisplay(ClipDisp);
d3758 196
@


2.124
log
@Fixed ReOrg on audio drives, removed spkr symbol from volname in requester
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.123 1995/07/13 13:04:19 Flick Exp Flick $
d3 3
d3142 11
a3152 8
	if(ci->Flags&CIF_HASVIDEO)
		*Strip |= 1;
	else
		*Strip &= ~1;
	if(ci->Flags&CIF_HASAUDIO)
		*Strip |= 2;
	else
		*Strip &= ~2;
d3255 1
d3282 1
a3282 1
//					DUMPMSG	("GADGETUP");
d3289 1
d3293 10
d3474 1
a3554 1

d3722 4
a3725 1
					goto ReOpen;
@


2.123
log
@More debugging to test DHD_CheckRecord use during play (not happening)
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.122 1995/06/20 23:31:37 Flick Exp Flick $
d3 3
d2501 1
a2501 1
	char *FlyDrive,*t;
d2789 5
a2793 1
								sprintf(str,"If I reorganize %s, it may take a while... ",((char **)FlyPL->Param)[FlyPL->PropStart]);
d2796 1
a2796 1
									sprintf(str,"Reorganizing Flyer drive %s",((char **)FlyPL->Param)[FlyPL->PropStart]);
d2799 1
a2799 1
									DHD_Reorganize(((char **)FlyPL->Param)[FlyPL->PropStart]);
@


2.122
log
@Added "height" member to QualPL structure
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.121 1995/06/15 12:37:17 Flick Exp Flick $
d3 3
d1869 3
a1871 1
						if( (Y=DHD_CheckRecord())!=FERR_BUSY )
@


2.121
log
@Icon creation will now succeed even if CutClipPanel gives bogus icon field
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.120 1995/06/13 18:44:07 Flick Exp Flick $
d3 3
d468 1
a468 1
struct PanelLine QualPL={ PNL_POPUP,PNL_LEFT,"Video Quality",0,(LONG *)Qual,0,QUAL_NUM };
d470 1
a470 1
//struct PanelLine QualPL={ PNL_POPUP,PNL_LEFT,"Video Quality",0,0,(LONG *)Qual,0,QUAL_NUM };
@


2.120
log
@Added error checking to cutting room/clip processing
Will take you back to panel if problems occur
@
text
@d1 6
a6 2
/* $Id: Panel.c,v 2.119 1995/04/28 13:32:00 Flick Exp Flick $
* $Log: Panel.c,v $
d602 5
@


2.119
log
@Record raw clip pause button no longer hilites unless recording
Record & Re-org buttons in record panel handle 0 Flyer drives correctly now
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.118 1995/04/28 12:07:10 Flick Exp Flick $
d3 4
d460 1
d462 2
d548 1
a548 1
void	__inline DHD_EndClipList(ULONG DoIt)
d550 2
d555 1
a555 1
	SendSwitcherReply(ES_EndClipCutList,&ESparams1);
d557 7
a563 1
	return;
d567 1
a567 1
void	__inline DHD_AddClip(struct NewClip	*cl,char *FlyDrive,ULONG Flags)
d569 2
d574 1
a574 1
	DUMPHEXIL("DHD_AddClip( ",(LONG)cl,") \\ ");
d579 8
a586 2
	SendSwitcherReply(ES_AddClipCut,&ESparams4);
	return;
d656 36
a691 1
void CutClipDisplay(struct ClipDisplay	*cd,char *FlyDrive,ULONG Flags)
d693 3
d699 1
d705 21
a725 1
		DHD_AddClip(cl,FlyDrive,Flags);
d731 2
d2987 2
a2988 1
	struct Gadget *ThisG=0,*RecGadget,*ContCan,*Clips,*String,*Frame,*Comm,
d2993 2
a2994 2
	BOOL Going = TRUE,Proc=FALSE;
	UWORD Success = PAN_CANCEL;
d2998 1
a2998 1
	ULONG Y=0,Tmax,Tmin,t,clipnum=0,d,*V,*Strip,ClipFlags;
d3000 14
d3080 15
a3094 8
	RecGadget = FindGadget(&Gadget1,ID_REC_PANEL);
	if (!(RecGadget = AllocOneGadget(RecGadget))) goto rErrExit;
	ThisG->NextGadget = RecGadget;
	ThisG = RecGadget;
	ThisG->LeftEdge = (ClipNW.Width - ThisG->Width)>>1;
	ThisG->TopEdge = ContCan->TopEdge;
	ThisG->NextGadget = NULL;
	ThisG->UserData = NULL;
d3096 1
d3100 5
a3104 3
	FlyDrive = FlyerDrives[CurFlyDrive];
	if(*FlyDrive==AUDIO_BYTE)
		FlyDrive+=2; // Skip speaker symbol char and space
d3106 3
a3108 3
	strncpy(ClipName,FlyDrive,CLIP_PATH_MAX);
	strncat(ClipName,TEMP_CLIP_NAME,CLIP_PATH_MAX);
	if(stricmp(((struct ExtFastGadget *)CurFG)->FileName,ClipName)) // Not TEMP clip
d3110 13
a3122 10
		strncpy(ClipName,((struct ExtFastGadget *)CurFG)->FileName,CLIP_PATH_MAX);
		ci=DHD_ClipInfo(ClipName);
		if(ci->Flags&CIF_HASVIDEO)
			*Strip |= 1;
		else
			*Strip &= ~1;
		if(ci->Flags&CIF_HASAUDIO)
			*Strip |= 2;
		else
			*Strip &= ~2;
d3124 2
d3128 1
d3130 2
a3136 1
		Proc=TRUE;
a3138 9
		ci=DHD_ClipInfo(ClipName);
		if(ci->Flags&CIF_HASVIDEO)
			*Strip |= 1;
		else
			*Strip &= ~1;
		if(ci->Flags&CIF_HASAUDIO)
			*Strip |= 2;
		else
			*Strip &= ~2;
d3140 1
d3173 4
a3176 2
		Clips->LeftEdge = ClipDisp->X;	Clips->TopEdge = ClipDisp->Y;
		Clips->Width = ClipDisp->W;	Clips->Height = ClipDisp->H;
d3217 2
a3218 1
		while (Going) {
d3222 2
a3223 1
				switch(IntuiMsg->Class) {
d3620 1
a3620 1
				}
a3631 3
			sprintf(str,"              Cutting clips on drive %s",FlyDrive);
			OpenNoticeWindow(EditTop->Window,Mes,2,FALSE);

d3638 53
a3690 5
			CutClipDisplay(ClipDisp,FlyDrive,ClipFlags);
			DHD_EndClipList(1);
			if(ClipFlags&CAF_VIDEO)
				ClipDisplayIcons(ClipDisp,FlyDrive);
			CloseNoticeWindow();
a3691 2
		else
			DHD_EndClipList(0);
d3694 3
a3696 1
	if(!Proc)
d3702 1
d3709 9
a3717 2
	// Only want to free up to record panel gadget
	RecGadget->NextGadget = NULL;
@


2.118
log
@Fixed long-standing record panel bug (if 1 Flyer drive)
Cleaned up many other dangerous if/for/while instructions that had code
  which was not protected by { }
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.117 1995/04/25 15:09:29 Flick Exp Flick $
d3 5
d374 1
d2590 2
a2591 22
							if(FlyPL)
							{
								FlyDrive = ((char **)FlyPL->Param)[FlyPL->PropStart];
								if(*FlyDrive==AUDIO_BYTE)
								{
									FlyDrive+=2; // Skip speaker symbol char and space
									AudioOnly = TRUE;
								}
								else AudioOnly = FALSE;

								strcpy(ClipName,FlyDrive);
								strcat(ClipName,TEMP_CLIP_NAME);
								DUMPSTR("Set Name: "); DUMPMSG(ClipName);
							}
							WinFlags=Window->IDCMPFlags;
							Recording=TRUE;
							ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
							if(Paused)  // Pause off
							{
								Paused=FALSE;
								DHD_Pause(Paused);
								Record->Flags |= GFLG_SELECTED;
a2592 5
								Pause->Flags &= ~GFLG_SELECTED;
								RefreshGList(Pause,Window,NULL,1);
								TPauseS += IntuiMsg->Seconds - PauseS; // Add this pause duration
								if(IntuiMsg->Seconds == PauseS)
									TPauseM += IntuiMsg->Micros  - PauseM; // to total paused time
d2595 39
a2633 8
								Paused=FALSE;
								*LenPL->Param = 0;
								TPauseS=0; TPauseM=0;
								PauseS=0; PauseM=0;
								RecStartS=IntuiMsg->Seconds;
								RecStartM=IntuiMsg->Micros;
								DHD_Record(ClipName,0,0,0xDEADBABE);
								RecordedAlready=TRUE;
d2639 5
a2643 1
							if(Paused)  // Pause off
d2683 1
a2683 2
							sprintf(str,"If I reorganize %s, it may take a while... ",((char **)FlyPL->Param)[FlyPL->PropStart]);
							if(BoolRequest(Window,str))
d2685 12
a2696 8
								sprintf(str,"Reorganizing Flyer drive %s",((char **)FlyPL->Param)[FlyPL->PropStart]);
								OpenNoticeWindow(Window,Mes,2,FALSE);
								DisplayWaitSprite();
								DHD_Reorganize(((char **)FlyPL->Param)[FlyPL->PropStart]);
								DisplayNormalSprite();
								CloseNoticeWindow();
								CTRL_SetDrive(FlyPL,NULL);
								UpdateAllDiff(RP,Start,Window);
@


2.117
log
@Reworked UpdateAudIndicator to make 2nd clip LED correct level, not be "sticky"
Also improved response time of LED's and reduces pointer flashiness
@
text
@@


2.116
log
@Fixed RenderSlide to handle field #'s above 64K (18 minutes)
@
text
@@


2.115
log
@Fixed Mungwall hit on close clip reqester via ENTER key
@
text
@@


2.114
log
@Non-working attempt at fixing enter on clip panel bug
@
text
@d1 1
a1 1
/* $Id: panel.c,v 2.113 1995/03/16 14:37:16 CACHELIN4000 Exp pfrench $
d3 3
d2819 1
a2819 1
	struct Gadget *ThisG=0,*Gadget,*ContCan,*Clips,*String,*Frame,*Comm,
d2897 4
a2900 4
	Gadget = FindGadget(&Gadget1,ID_REC_PANEL);
	if (!(Gadget = AllocOneGadget(Gadget))) goto rErrExit;
	ThisG->NextGadget = Gadget;
	ThisG = Gadget;
d3465 2
a3466 1
	ThisG->NextGadget = NULL;
@


2.113
log
@*** empty log message ***
@
text
@d1 5
a5 2
/* $Id: Panel.c,v 2.112 1995/03/10 18:37:58 CACHELIN4000 Exp CACHELIN4000 $
* $Log: Panel.c,v $
d1404 1
a1404 1
	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; 
d3414 2
a3415 1
						Success=TRUE;
d3430 1
a3430 1
		if(*Strip && (Success != PAN_CANCEL) 
d3601 1
a3601 1
					if (Down) 
@


2.112
log
@Fix CrUD
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.111 1995/03/09 18:05:18 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1085 1
d1087 1
d1090 1
d2416 6
d2441 1
d2451 1
d2456 1
d2487 1
a2487 1
//					DUMPMSG	("GADGETUP");
d2788 1
@


2.111
log
@Add tags to flyerstill cruds, limit crashiness of icon slider
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.110 1995/03/09 10:19:01 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d408 1
d413 1
d425 2
a426 1
		TAG_Duration,180,TAG_RecFields,4,NULL};
d559 1
a559 1
	else
d561 1
a561 1
		MyCrUD.Dur = MyCrUD.Fields = (cl->out - cl->in + 2)<<1;
a567 1
//	ESparams4.Data2=(LONG)NULL;
a568 1
//	ESparams4.Data3=(LONG)0;
d2682 1
a2682 1
					else // if(AudBarL && AudBarR)
@


2.110
log
@Cutting roiom flyerstill support
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.109 1995/03/07 16:08:17 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d405 4
d419 2
a420 1
		TAG_CommentList,COMMENT_MAX,"",NULL};
d548 10
a557 2
	if(cl->in==cl->out) MyCrUD.Clip = ID_STIL;
	else MyCrUD.Clip = ID_CLIP;
@


2.109
log
@Handle new DroppedFrames error, fix pause->record bug
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.108 1995/03/03 11:45:55 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d405 3
d409 1
a409 1
		0x434C4950,0,  // CLIP
d540 2
d3000 5
d3116 5
d3250 5
d3288 7
d3310 7
d3336 5
d3358 5
@


2.108
log
@Fix clip length rounding on cutting room, pause/stop/rec interaction, etc.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.107 1995/02/28 19:20:29 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d413 2
a414 1
static char ClipName[120],FlyD[21];
d2496 1
d2506 1
d2522 1
d2534 1
a2542 1
							DHD_Pause(Paused);
d2615 4
d2621 10
a2641 2
										sprintf(str,"Recording stopped: Internal Flyer Error # %d.",err);
										ContinueRequest(Window,str);
d2646 2
d2654 1
a2654 1
					else if(AudBarL && AudBarR)
@


2.107
log
@Fix logic bug in pause, gadget highlight, move clip indicator over
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.106 1995/02/27 13:41:57 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d511 1
a511 1
	ESparams4.Data3 =(LONG) (cl->out - cl->in + 4)<<1;
d544 32
d594 1
a2478 7
/*
									if(AudPL && (AudPL->PropEnd-1!=AudPL->PropStart))
									{
										ContinueRequest(Window," Sorry, you may not record video on an audio-only drive. ");
										break;
									}
*/
d2697 1
a2697 5
									if(AudPL && (AudPL->PropEnd-1!=AudPL->PropStart))
									{
										ContinueRequest(Window,"Sorry, I cannot allow you to record Video on an Audio-only Drive.");
										break;
									}
d2699 1
d3322 2
a3323 1
		if(*Strip && (Success != PAN_CANCEL) )
a3326 1
//			ClipFlags=ci->Flags;
a3330 2
			else
				ClipFlags &= ~CAF_VIDEO;
a3332 2
			else
				ClipFlags &= ~CAF_AUDIO;
@


2.106
log
@Change audio bargraph to indicators
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.105 1995/02/26 14:20:52 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d549 1
d567 1
d569 1
d967 1
d1009 1
a1009 1

d1021 1
a1021 1
		aInd->ClipX=aInd->X + 3*aInd->W;
d1050 1
a1050 1
		SetAPen(aInd->RP,PAL_LYELLOW);
d1526 1
a1526 1
								else if(PLine->Flags&PL_AUDIO)
d2363 1
a2363 1
					if(Paused && ( (ID!=ID_VCR_PAUSE) || (ID!=ID_REQ_STOP) || (ID!=ID_VCR_REC)) )
d2388 1
d2465 2
a2466 2
								ThisG->Flags &= ~GFLG_SELECTED;
								RefreshGList(ThisG,Window,NULL,1);
d2500 2
a2501 2
								ThisG->Flags |= GFLG_SELECTED;
								RefreshGList(ThisG,Window,NULL,1);
@


2.105
log
@Allow Stop, Rec to function while record is paused, fix FixTime() for len.s
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.104 1995/02/24 11:13:07 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d330 1
a330 1
extern UBYTE *FlyerDrives[];
d1004 56
d1302 2
a1303 1
// crufty code, god help you.
d1732 8
d2251 1
a2251 1
	struct BarGraph *AudBarR=NULL,*AudBarL=NULL;
d2326 2
a2327 2
		if( F && (AudBarL = InitBarGraph(20,Record->TopEdge-20,((Window->Width-40)>>1)-20,8,3,Window))
		 && (AudBarR = InitBarGraph(20+(Window->Width>>1),Record->TopEdge-20,((Window->Width-40)>>1)-20,8,3,Window)) )
d2330 2
a2331 2
			UpdateBarGraph(AudBarL,t[0]);
			UpdateBarGraph(AudBarR,t[1]);
d2601 2
a2602 2
						UpdateBarGraph(AudBarL,t[0]);
						UpdateBarGraph(AudBarR,t[1]);
d2700 2
a2701 2
	if(AudBarL) FreeBarGraph(AudBarL);
	if(AudBarR) FreeBarGraph(AudBarR);
@


2.104
log
@Fix flags confusion on cutting room, etc.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.103 1995/02/22 10:16:51 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d826 18
a843 9
	F = a;
	H = F/108000;
	F	%= 108000;
	M = F / 1800;  // 60 secs/min * 30 frames/secs
	F %= 1800;
	S = F / 30;
	F %= 30;
	sprintf(((struct StringInfo *)ThisG->SpecialInfo)->Buffer,"%02ld:%02ld:%02ld:%02ld",H,M,S,F);

d2172 1
a2172 1
	struct Gadget *ThisG=0,*ContCan,*Record;
d2236 1
d2238 3
a2240 1

d2288 1
a2288 1
					if(Paused && ID!=ID_VCR_PAUSE)
d2290 1
a2290 29
					PLine = (struct PanelLine *)ThisG->UserData;

/*
					if(LastString)
					{
						PLine = (struct PanelLine *)LastString->UserData;
						if(PLine)
						{
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								FixTimeStr(PLine,Window,FALSE);
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->PropEnd);
						}
						LastString=NULL;
						PLine = (struct PanelLine *)ThisG->UserData;
					}
					if(ID==STRING_ID)	LastString=ThisG;
*/

					if(PLine)
d2310 2
d2350 1
a2350 24
/*
					if(LastString)
					{
						PLine = (struct PanelLine *)LastString->UserData;
						if(PLine)
						{
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								FixTimeStr(PLine,Window,FALSE);
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->PropEnd);
						}
						LastString=NULL;
						PLine = (struct PanelLine *)ThisG->UserData;
					}
*/
@


2.103
log
@Fix cutting room (i hope)!
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.102 1995/02/20 12:32:25 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d296 1
a296 1

d1226 7
a1232 2
//*******************************************************************

d1248 3
a1250 1
	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL; LastString=NULL;
d1374 1
a1374 1
				DUMPSTR(" . ");
d1398 1
a1398 1
		DUMPMSG("Lines Drawn...");
d1428 1
a1428 1
					DUMPMSG	("GADGETDOWN");
d1491 1
a1491 1
					DUMPMSG	("GADGETUP");
d1593 1
a1593 1
						DUMPMSG("tik...");
d1954 1
a1954 1
#ifdef SERDEBUG
d2179 1
a2179 1
	DUMPHEXIL("New Clip Panel @@",(LONG)PLine,"\\");
d2183 1
a2183 1
			DUMPHEXIL("Pline->Create @@",(LONG)PLine->Create,"\\");
d2339 1
a2339 1
					DUMPMSG	("GADGETUP");
d2512 1
a2512 1
							if( (err=DHD_CheckRecord())!=FERR_BUSY )
a2540 1

d2547 3
a2549 2
									default:
										DUMPHEXIL	("Default: DHD_CheckRecord=",(LONG)err,"\\");
a2551 2

//!!!!! WHAT IF RECORD FAILED? DO WE DELETE THE BOGUS CLIP?????
d2726 1
a2726 1
				Strip=&PLine->Param;
d2911 1
a2911 1
					DUMPMSG	("GADGETUP");
d3078 1
a3078 1
							case	RAW_LEN:
d3082 1
a3082 1
							case	RAW_DEL:
d3258 12
a3269 5
			ClipFlags=ci->Flags;
			if(!(*Strip&1))
				ClipFlags &= ~CIF_HASVIDEO;
			if(!(*Strip&2))
				ClipFlags &= ~CIF_HASAUDIO;
d3272 1
a3272 1
			if(ClipFlags&CIF_HASVIDEO)
a3398 1
				DUMPMSG("Message In");
d3427 1
a3427 1
					DUMPMSG	("GADGETUP");
@


2.102
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.101 1995/02/19 16:57:40 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d487 1
d502 1
d510 1
a510 1
	f=cl->icon-cl->in;
d534 1
a534 1
	while(ncl=(struct NewClip *)cl->Node.mln_Succ)
d536 2
d539 2
d551 1
a551 1
	while(ncl=(struct NewClip *)cl->Node.mln_Succ)
d553 3
d557 3
d574 1
a574 1
		cd->MinVal=min;  // Add timecode start later...
d617 1
a617 1
		while(cl->Node.mln_Succ )
d873 4
d1149 1
d1168 1
a1174 18
/*
VOID BoundPanProp(struct PanelLine *PLine,struct Window *Window)
{
	LONG A=0;

  if(!PLine->PropGadg) return;
	if(PLine->Param) A = *(PLine->Param);
	if (A > *AHiTime) A = *AHiTime;
	else if (A < *ALoTime) A = *ALoTime;
	if( (PLine->Param) && (A!=*(PLine->Param)) )  // If bounds exceeded
	{
		*(PLine->Param)=A;
		UpdatePanStr(PLine,Window);
		A -= PLine->PropStart;
		SetPropHorizPot(PLine->PropGadg,Window,A,0,PLine->PropEnd-PLine->PropStart);
	}
}
*/
d1234 1
a1234 1
	BOOL Going = TRUE, LiveFlyer = FALSE, LoudFlyer = FALSE, Playing=FALSE;
a1255 1
				DUMPUDECW(PLine->Label,X1,"\\");
a1536 2
/* 						if( (PLine==PlayPL) )
							Playing=TRUE; */
d1897 1
a1940 4
#ifdef SERDUBUG
	sprintf(str,"RCB: \tFrame= %d \tMin=%d \tMax=%d\n",MyRCB->Frame,MyRCB->Min,MyRCB->Max);
	DUMPSTR(str);
#endif
d1944 6
d1952 2
a1953 1
			*PLine->Param2 = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart); // even frame #s
d1958 2
a1959 1
			*PLine->Param = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart); // even frame #s
d1968 1
a1968 1
				*PartPL->Param2 = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart); // even frame #s
d1973 1
a1973 1
				*PartPL->Param = EVEN( (1+(Call->Frame>>1)) + PLine->PropStart); // even frame #s
d1993 2
a1994 2
			MyRCB->Max = (*AHiTime - PLine->PropStart)<<1;
			MyRCB->Min = (*ALoTime - PLine->PropStart)<<1;
d2000 2
a2001 2
			MyRCB->Max = (*HiTime - PLine->PropStart)<<1;
			MyRCB->Min = (*LoTime - PLine->PropStart)<<1;
d2011 2
a2012 2
			MyRCB->Max = (*AHiTime - PLine->PropStart)<<1;
			MyRCB->Min = (*ALoTime - PLine->PropStart)<<1;
d2018 2
a2019 2
			MyRCB->Max = (*HiTime - PLine->PropStart)<<1;
			MyRCB->Min = (*LoTime - PLine->PropStart)<<1;
d2146 1
a2146 1
#define AUDIO_LEVEL_UPDATE_TIME 3
d2155 1
a2155 1
	struct PanelLine *PLine = (struct PanelLine *)&RawRecPL,*LenPL=NULL,
d2169 1
d2173 1
a2593 2
							Going = FALSE;			//Success was initialized to FALSE
							Success=TRUE;
d2672 1
a2672 1
	struct Gadget *ThisG=0,*Gadget,*ContCan,*Clips,*String,*Frame,
d2679 1
a2679 1
	struct PanelLine *PLine = (struct PanelLine *)&MarkClipPL,*TimePL,*StrPL,
a2686 1
	SMPTime = &smpte_base;
d2725 1
d2727 2
a2734 1
	SMPTime = &TimePL->PropStart;
d2895 1
a2895 1
								FramePL->G2 =(struct Gadget *) (cl->in-Tmin);
d2911 2
d2942 3
a2944 2
									if( (ncl=(struct NewClip *)tcl->Node.mln_Pred) && ncl->Node.mln_Pred )
									tcl->out = ncl->in;
a2956 2
									DUMPUDECL("In: ",(LONG)*(TimePL->Param),"  ");
									DUMPUDECL("Out: ",(LONG)*(TimePL->Param2),"\\");
d2963 5
a2967 2
									TimePL->PropStart = Tmin;
									TimePL->PropEnd =  Tmax;
d2972 2
a2973 1
										TimePL->PropStart = ncl->out;
d2979 1
a2979 1
										TimePL->PropEnd = ncl->in;
d2993 1
a2993 1
									MyRCB->Frame = (ULONG)(*TimePL->Param2 - Tmin)<<1;
d2997 1
a2997 1
									MyRCB->Frame = (ULONG)(*TimePL->Param - Tmin)<<1;
d3006 1
a3006 1
									FramePL->G2 =(struct Gadget *) (cl->in-Tmin);
d3071 2
a3072 2
								if(!Len) break;
								ActivateGadget(Len,Window,NULL);
d3075 2
a3076 2
								if(!Del) break;
								ActivateGadget(Del,Window,NULL);
a3089 1

d3096 1
d3101 2
a3102 1
												TimePL->PropStart = ncl->out;
d3108 1
a3108 1
												TimePL->PropEnd = ncl->in;
d3135 1
a3135 1
											FramePL->G2 =(struct Gadget *) (cl->in-Tmin);
a3231 4
					} else if(A == RAW_HELP)
					{
						Going = FALSE;			//Success was initialized to FALSE
						Success = PAN_EASY;
@


2.101
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.100 1995/02/19 01:49:58 CACHELIN4000 Exp CACHELIN4000 $
d3 3
@


2.100
log
@Add Audio VUs, Cutting Room SMPTE trix
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.99 1995/02/13 14:37:47 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d282 1
d308 1
a308 1
extern struct PanelLine *RawRecPL,*MarkClipPL;
@


2.99
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.98 1995/02/11 17:53:39 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d293 1
a293 1
extern struct FastGadget *CurFG,*FirstFG;
d312 1
d338 1
a338 1
ULONG	Ticks,WinFlags,GadInd,*LoTime=0,*HiTime=0,*ALoTime=0,*AHiTime=0;
d512 2
d543 1
a543 1
struct ClipDisplay *InitClipDisplay(int x,int y,int w,int h,int max, struct Window *Win)
d552 3
a554 3
		cd->MinVal=0;  // Add timecode start later...
		if(cd->MaxVal=max) // max =0 for un-initialized display
			cd->Scale=(cd->W*0xFFFF)/max ;  // Fixed Point Fraction...
a663 1
		if(cd->MaxVal = out)	cd->Scale=(cd->W*0xFFFF)/cd->MaxVal ;  // Fixed Point Fraction...
d665 1
d668 1
a668 1
			cl->in=0;
d741 1
a741 1
		Val=(Val*MAXPOT)/cd->MaxVal;
a742 1
//	SetPropHorizPot(Prop,Window,Val,0,cd->MaxVal);
d849 2
a850 2
	x1 = (cl->in*cd->Scale)/0xFFFF ;
	x2 = (cl->out*cd->Scale)/0xFFFF ;
d954 2
a955 1
	SetAPen(bg->RP,PAL_LYELLOW);
d1232 1
d1330 1
d1387 4
a1390 3
			MyRCB->Frame = (ULONG)(*InPL->Param)<<1;
			MyRCB->Max = (*HiTime)<<1;
			MyRCB->Min = (*LoTime)<<1;
d1423 3
a1425 3
									MyRCB->Frame = (ULONG)Y<<1;
									MyRCB->Max = (*HiTime)<<1;
									MyRCB->Min = (*LoTime)<<1;
d1430 3
a1432 3
									MyRCB->Frame = (ULONG)Y<<1;
									MyRCB->Max = (*AHiTime)<<1;
									MyRCB->Min = (*ALoTime)<<1;
d1460 1
a1460 1
						if(PlayPL && Playing)  // Must stop play to do Jog/Shuttle/Jump mode
d1463 1
a1463 4
							ModifyIDCMP(Window,WinFlags);
							Playing=FALSE;
							PlayPL->UserObj=(APTR)0;  // Call stop... could just do ClosePanel
							PlayPL->UserFun(PlayPL,PlayPL->UserObj);
d1490 3
a1492 3
									MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
									MyRCB->Max = (*HiTime)<<1;
									MyRCB->Min = (*LoTime)<<1;
d1499 3
a1501 3
									MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
									MyRCB->Max = (*AHiTime)<<1;
									MyRCB->Min = (*ALoTime)<<1;
d1528 2
a1529 2
						if( (PLine==PlayPL) )
							Playing=TRUE;
d1558 1
a1558 1
					if(PlayPL && Playing)
d1562 1
a1562 4
							ModifyIDCMP(Window,WinFlags);
							Playing=FALSE;
							PlayPL->UserObj=(APTR)0;  // Call stop... could just do ClosePanel
							PlayPL->UserFun(PlayPL,PlayPL->UserObj);
d1580 1
a1580 1
							MyRCB->Frame = (ULONG)(*(PLine->Param))<<1;
d1582 1
a1582 1
							MyRCB->Frame = (ULONG)(*(PLine->Param2))<<1;
d1585 2
a1586 2
							MyRCB->Max = (*HiTime)<<1;
							MyRCB->Min = (*LoTime)<<1;
d1590 2
a1591 2
							MyRCB->Max = (*AHiTime)<<1;
							MyRCB->Min = (*ALoTime)<<1;
d1620 1
a1620 1
							MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1622 2
a1623 2
							MyRCB->Max = (*HiTime)<<1;
							MyRCB->Min = (*LoTime)<<1;
d1700 1
a1700 1
									MyRCB->Frame = (ULONG)(*V)<<1;
d1727 1
a1727 1
									MyRCB->Frame = (ULONG)(*V)<<1;
d1750 1
a1750 1
										MyRCB->Frame = (ULONG)(*V)<<1;
d1764 1
a1764 1
										MyRCB->Frame = (ULONG)(*V)<<1;
d1789 1
a1789 1
										MyRCB->Frame = (ULONG)(*V)<<1;
d1803 1
a1803 1
										MyRCB->Frame = (ULONG)(*V)<<1;
d1914 1
a1914 1
	ULONG	Frame;
d1942 1
a1942 1
			*PLine->Param2 = EVEN(1+(Call->Frame>>1)); // even frame #s
d1947 1
a1947 1
			*PLine->Param = EVEN(1+(Call->Frame>>1)); // even frame #s
d1955 2
a1956 1
				*PartPL->Param2 = EVEN(1+(Call->Frame>>1)); // even frame #s
d1961 2
a1962 1
				*PartPL->Param = EVEN(1+(Call->Frame>>1)); // even frame #s
d1972 1
a1972 1
// Set global variables (side effects!!) return 1 for oiut, 0 for in point
d1981 2
a1982 2
			MyRCB->Max = (*AHiTime)<<1;
			MyRCB->Min = (*ALoTime)<<1;
d1988 2
a1989 2
			MyRCB->Max = (*HiTime)<<1;
			MyRCB->Min = (*LoTime)<<1;
d1999 2
a2000 2
			MyRCB->Max = (*AHiTime)<<1;
			MyRCB->Min = (*ALoTime)<<1;
d2006 2
a2007 2
			MyRCB->Max = (*HiTime)<<1;
			MyRCB->Min = (*LoTime)<<1;
d2134 1
a2134 1

d2149 1
a2149 1
	struct BarGraph *AudBar;
d2207 1
d2219 2
a2220 2
/*
		if(AudBar = InitBarGraph(20,Record->TopEdge+Record->Height+8,Window->Width-40,8,4,Window))
d2222 3
a2224 3
//			audlev=GetRecSense();
			audlev=0x0102;
//			UpdateBarGraph(AudBar,MAX(t[0],t[1]));
d2226 2
a2227 1
			AudUpdate=25;
d2229 1
a2229 1
 */
a2538 1
/*
d2540 1
a2540 1
					else if(AudBar)
d2542 5
a2546 5
						AudUpdate=25;
						audlev=0x0102;
						audlev=(IntuiMsg->Seconds&0x0707);
//						audlev=GetRecSense();
//						UpdateBarGraph(AudBar,MAX(t[0],t[1]));
a2547 1
*/
d2646 2
a2647 1
/* 	if(AudBar) FreeBarGraph(AudBar); */
d2670 1
a2670 1
	ULONG Y=0,Tmax,t,clipnum=0,d,*V;
d2675 1
d2706 2
d2720 2
a2721 1

d2759 9
d2780 8
d2799 1
a2799 1
			if(!(ClipDisp=InitClipDisplay(16,TimePL->PropGadg->TopEdge+TimePL->PropGadg->Height+20,Window->Width-32,24,Tmax,Window)))
d2802 1
a2802 1
			if(cl=AddClip(ClipDisp,0,Tmax,CLIP_ACTIVE,ClipName))
d2815 1
d2854 3
a2856 3
		MyRCB->Frame = (ULONG)(*TimePL->Param)<<1;
		MyRCB->Max = (*HiTime)<<1;
		MyRCB->Min = (*LoTime)<<1;
d2882 1
d2919 1
a2919 1
								t=((IntuiMsg->MouseX - ClipDisp->X)*0xFFFF)/ClipDisp->Scale;
d2926 3
a2928 1
									tcl=AddClip(ClipDisp,t,t,CLIP_ACTIVE,ClipName);
d2949 1
a2949 1
									TimePL->PropStart = 0;
d2967 2
a2968 2
									MyRCB->Max = (*HiTime)<<1;
									MyRCB->Min = (*LoTime)<<1;
d2975 1
a2975 1
									MyRCB->Frame = (ULONG)(*TimePL->Param2)<<1;
d2979 1
a2979 1
									MyRCB->Frame = (ULONG)(*TimePL->Param)<<1;
d2988 1
d3019 1
a3019 1
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param))<<1;
d3021 1
a3021 1
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param2))<<1;
d3077 1
a3077 1
											TimePL->PropStart = 0;
d3095 2
a3096 2
											MyRCB->Max = (*HiTime)<<1;
											MyRCB->Min = (*LoTime)<<1;
d3103 1
a3103 1
											MyRCB->Frame = (ULONG)(*TimePL->Param2)<<1;
d3107 1
a3107 1
											MyRCB->Frame = (ULONG)(*TimePL->Param)<<1;
d3116 1
a3129 2


d3147 1
a3147 1
								MyRCB->Frame = (ULONG)(*V)<<1;
d3162 1
a3162 1
								MyRCB->Frame = (ULONG)(*V)<<1;
d3172 1
a3172 1
									MyRCB->Frame = (ULONG)(*V)<<1;
d3178 1
a3178 1
									MyRCB->Frame = (ULONG)(*V)<<1;
d3190 1
a3190 1
									MyRCB->Frame = (ULONG)(*V)<<1;
d3196 1
a3196 1
									MyRCB->Frame = (ULONG)(*V)<<1;
d3231 1
a3231 1
		if(Success != PAN_CANCEL)
d3235 6
a3240 1
			CutClipDisplay(ClipDisp,FlyDrive,ci->Flags);
d3242 1
a3242 1
			if(ci->Flags&CIF_HASVIDEO)
@


2.98
log
@Add audio record level support functions, BarGraph struct
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.97 1995/02/03 12:46:46 pfrench Exp CACHELIN4000 $
d3 3
d2213 1
a2213 1

d2218 1
a2218 1
			UpdateBarGraph(AudBar,MAX(t[0],t[1]));
d2222 1
d2532 1
d2540 1
a2540 1
						UpdateBarGraph(AudBar,MAX(t[0],t[1]));
d2542 1
d2641 1
a2641 1
	if(AudBar) FreeBarGraph(AudBar);
@


2.97
log
@Removed direct serial debugging calls
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.96 1995/02/01 17:53:39 CACHELIN4000 Exp pfrench $
d3 3
d909 40
a948 1

a950 1

d1072 1
d2134 1
a2134 1
	UWORD Success = PAN_CANCEL;
d2138 4
a2141 2
	LONG Y=0,F=0,RecStartM=0,RecStartS=0,PauseS=0,PauseM=0,TPauseS=0,TPauseM=0;
	char *FlyDrive;
d2144 1
a2144 1
	DHD_SetupRecord(CurFlySource,0xFFFF,0xFFFF,CurCompMode);
d2148 1
d2209 10
d2477 1
a2477 1
							if( (Y=DHD_CheckRecord())!=FERR_BUSY )
d2479 1
a2479 1
								switch(Y)
d2514 2
a2515 2
										DUMPHEXIL	("Default: DHD_CheckRecord=",(LONG)Y,"\\");
										sprintf(str,"Recording stopped: Internal Flyer Error # %d.",Y);
d2528 9
d2635 2
@


2.96
log
@Fix Pause, CuttingRoom Icons, Process Room
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.95 1995/01/25 18:36:38 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1194 1
a1194 1
				DumpUDecW(PLine->Label,X1,"\\");
d2677 1
a2677 1
		DumpStr("Non-Destructive cutting on clip: ");
@


2.95
log
@Add MOUSEMOVE support to MiniPanel()
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.94 1995/01/24 18:06:37 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d341 2
d348 5
d354 1
a354 1
	ULONG	tSize;	// COMMENT_MAX + 8
d360 6
a365 1
struct ClipCrUD MyCrUD = {0x43725544,0x54595045,8,0x434C4950,0,0x54414753,COMMENT_MAX + 8,TAG_CommentList,COMMENT_MAX,"",NULL};
d371 2
a372 2
static char str[100],*Mes[]={"Just a Moment...     ",str};
static char ClipName[120];
d427 8
d456 1
d460 1
d466 5
a470 2
	DUMPHEXIL("DHD_AddClip( ",cl,") \\ ");
	ESparams4.Data1 =(LONG)cl->Name ;
d480 1
a480 1
	ULONG	x=FALSE;	//assume error
d485 1
d488 1
a488 1
	DUMPSTR(" )");
a489 1
	DisplayWaitSprite();
d491 1
d494 1
d496 2
a497 1
	ESparams4.Data4=(LONG)(cl->icon)<<1;
a498 1
	DisplayNormalSprite();
d506 1
d512 1
d519 1
d525 1
d562 1
a562 1
	if( (val<cd->MaxVal) && (val>cd->MinVal) )
d574 16
d609 1
d612 2
a613 1
			if(cl->out < (cd->MaxVal+FRAME_QUANT) ) t1 = cl->out + FRAME_QUANT;
d618 2
a619 2
		if(out<=t1) t2=t1; // +STILL_QUANT;
		else if( cl && (cl=(struct NewClip *)cl->Node.mln_Succ) )
d624 4
d629 1
d634 1
d639 5
d1163 1
a1163 1
UWORD __asm Panel(REG(a0) struct EditWindow *Edit,REG(a1) struct PanelLine *PLine, REG(d0) UWORD XPMode)
d1191 1
d1477 5
d2003 1
a2003 3

	Gadget = FindGadget(&Gadget1,ID_REORG);
	if ((Gadget = AllocOneGadget(Gadget)))
d2005 10
a2014 6
		(*ThisG)->NextGadget = Gadget;
		(*ThisG) = Gadget;
		(*ThisG)->LeftEdge = (NW->Width - (*ThisG)->Width - (PNL_X1<<1) +2 );
		(*ThisG)->TopEdge = Y1;
		(*ThisG)->NextGadget = NULL;
		(*ThisG)->UserData = NULL;
d2088 1
a2088 1
	BOOL Going = TRUE, Recording=FALSE,RecordedAlready=FALSE,Paused=FALSE;
d2093 1
a2093 1
	LONG Y=0,F,RecStartM=0,RecStartS=0;
d2102 1
a2102 3
	{
		if(PLine->Create) Y1=PLine->Create(X1,H,PLine,&ThisG);
		if(PLine->Width>0)
d2104 24
a2127 18
			X1 = PNL_WIDTH;
			Y = Y1;
		}
		else
		{
			H += MAX(Y,Y1);
			X1 = Y = 0;
		}
		if(PLine->Flags)
		{
			if(PLine->Flags&PL_AVAIL)
				F= H - PIN_H +4 ;   // for aligning Reorganize button
			else if(PLine->Flags&PL_LEN)
				LenPL=PLine;
			else if(PLine->Flags&PL_FLYER)
				FlyPL=PLine;
			else if(PLine->Flags&PL_AUDIO)
				AudPL=PLine;
a2128 2
		Lines++;
	}
d2221 2
a2222 3
							if(Paused) Paused=FALSE;
							else Paused=TRUE;
							DHD_Pause(Paused);
d2232 2
a2233 2
								DHD_MakeClipIcon(ClipName);
								if(Y = (IntuiMsg->Seconds - RecStartS)*30)
d2236 1
a2236 1
									Y += (3*(IntuiMsg->Micros - RecStartM))/100000;
a2246 1

d2250 1
a2250 1
					if(Paused && ID!=ID_VCR_PAUSE)
d2253 1
a2253 1
					if(Recording)
d2259 2
a2260 2
						DHD_MakeClipIcon(ClipName);
						if(Y = (IntuiMsg->Seconds - RecStartS)*30)
d2262 2
a2263 2
						else
							Y += (3*(IntuiMsg->Micros - RecStartM))/100000;
d2300 1
d2307 2
d2314 1
d2316 2
d2325 20
a2344 5
							*LenPL->Param = 0;
							RecStartS=IntuiMsg->Seconds;
							RecStartM=IntuiMsg->Micros;
							DHD_Record(ClipName,0,0,0xDEADBABE);
							RecordedAlready=TRUE;
d2347 1
d2349 23
d2374 1
d2405 1
a2405 1
					if(Recording)
d2412 1
a2412 1
						if(Y = (IntuiMsg->Seconds - RecStartS)*30)
d2415 1
a2415 1
							Y += (3*(IntuiMsg->Micros - RecStartM))/100000;
d2430 2
d2453 1
a2453 1
										DHD_MakeClipIcon(ClipName);
d2469 1
a2469 1
					else ModifyIDCMP(Window,WinFlags);
d2477 1
a2477 1
					if(Recording)
d2485 1
a2485 1
						if(Y = (IntuiMsg->Seconds - RecStartS)*30)
d2488 1
a2488 1
							Y += (3*(IntuiMsg->Micros - RecStartM))/100000;
d2497 1
d2510 1
a2510 1
							if(Paused)
d2513 5
d2519 1
d2564 1
a2564 1
		if(PLine && PLine->Destroy)
d2579 1
a2579 1
	struct Gadget *ThisG=0,*Gadget,*ContCan,*Clips,*String,
d2584 1
a2584 1
	BOOL Going = TRUE;
d2625 1
d2627 2
d2667 1
d2670 18
a2687 2
	ci=DHD_ClipInfo(ClipName);
	DHD_StartClipList(ClipName,CUTCLIP_DESTROY);
d2704 1
a2709 3
//			TimePL->PropEnd = Tmax;
//			TimePL->PropStart = 0;
			cl->icon = (cl->out + cl->in)/2;
d2713 2
a2714 1

a2769 5
						if( PLine==FramePL )
						{
							HiTime = &FramePL->PropEnd;
							LoTime = &FramePL->PropStart;
						}
d2772 1
d2774 8
a2817 1
								DUMPUDECL("t = ",(LONG)t,"\\");
d2820 1
d2822 1
a2822 1
									tcl=AddClip(ClipDisp,t,t+30,CLIP_ACTIVE,ClipName);
d2824 1
d2832 5
a2836 5
									DUMPHEXIL("Clip: ",(LONG)cl," \\  ");
									DUMPHEXIL("In: ",(LONG)cl->in,"  ");
									DUMPHEXIL("Out: ",(LONG)cl->out,"  ");
									DUMPHEXIL("In: ",(LONG)*(TimePL->Param),"  ");
									DUMPHEXIL("Out: ",(LONG)*(TimePL->Param2),"\\");
a2842 2
									UpdateTime(In,Window,cl->in);
									UpdateTime(Out,Window,cl->out);
d2845 4
a2848 1
									if(ncl=(struct NewClip *)cl->Node.mln_Pred)
d2850 1
d2852 3
d2856 1
a2856 1
									UpdatePanProp(TimePL,Window);
d2858 15
d2874 8
a2881 5
									SetHiLo(TimePL);
									tcl->icon = (tcl->out + tcl->in)/2;
									FramePL->Param = &tcl->icon;
									FramePL->PropEnd = tcl->out;
									FramePL->PropStart = tcl->in;
d2956 2
a2957 5
									if(cl=KillClip(ClipDisp,cl))
										cl->type=CLIP_ACTIVE;
									clipnum--;
									DrawClipDisplay(ClipDisp);
									if(cl)
d2959 66
a3024 2
										UpdateTime(In,Window,cl->in);
										UpdateTime(Out,Window,cl->out);
d3127 2
d3133 1
d3139 6
a3144 1

d3146 1
a3146 1
		if(PLine && PLine->Destroy)
d3395 9
a3404 2
								if(XPMode) Success = PAN_EXPERT;
								else Success=TRUE;
@


2.94
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.93 1995/01/24 16:50:57 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d990 1
a990 1
	ULONG A=0;
d1033 1
a1033 1
	ULONG A=0;
d1912 23
d3047 5
a3051 1
					if (Down) Down = NULL;
d3093 9
@


2.93
log
@Add Icon making for CuttingRoom
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.92 1995/01/24 11:20:21 CACHELIN4000 Exp CACHELIN4000 $
d3 3
a2421 1

d2539 2
a2540 1
			*(FramePL->Param) = (cl->out + cl->in)/2;
d2599 1
a2599 3
						if( PLine==TimePL )
							SetHiLo(TimePL);
						else if( PLine==FramePL )
@


2.92
log
@Cutting Room functions, panel support
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.91 1995/01/13 12:56:59 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d331 15
d350 2
a351 1
char str[100],*Mes[]={"Just a Moment...     ",str};
d433 1
a433 1
void	__inline DHD_AddClip(struct NewClip	*cl,ULONG Flags)
d444 34
a477 1
void CutClipDisplay(struct ClipDisplay	*cd,ULONG Flags)
d483 1
a483 1
		DHD_AddClip(cl,Flags);
a485 1
	FreeMem(cd,sizeof(struct ClipDisplay));
d513 1
a513 1
		FreeMem(cl,sizeof(struct NewClip)+CLIP_NAME_MAX);
d567 1
a567 1
		if( (t2>t1) && (cl=SafeAllocMem(sizeof(struct NewClip)+CLIP_NAME_MAX,MEMF_CLEAR)) )
d573 1
d582 1
a582 1
		if(cl=SafeAllocMem(sizeof(struct NewClip)+CLIP_NAME_MAX,MEMF_CLEAR))
d588 1
d603 1
a603 1
		FreeMem(cl,sizeof(struct NewClip)+CLIP_NAME_MAX);
a1981 1
static char ClipName[120];
d2121 1
d2230 2
d2233 2
a2234 1
							Going = FALSE;			//Success was initialized to FALSE
d2335 1
a2335 1
						DHD_MakeClipIcon(ClipName);
d2357 1
d2361 6
d2432 2
a2433 1
	struct PanelLine *PLine = (struct PanelLine *)&MarkClipPL,*TimePL,*StrPL,*LenPL,*FramePL;
d2472 2
d2596 7
d2678 2
a2679 2

									*(FramePL->Param) = (tcl->out + tcl->in)/2;
a2683 1

d2690 6
d2862 1
a2862 1
	if(Success)
d2864 10
a2873 2
		CutClipDisplay(ClipDisp,ci->Flags);
		DHD_EndClipList(1);
a2874 2
	else DHD_EndClipList(0);
	if(ClipDisp) FreeClipDisplay(ClipDisp);
@


2.91
log
@Add support for PL_PARTNER to RCB functions,
update available sizes after record, etc.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.90 1994/12/31 02:11:29 CACHELIN4000 Exp CACHELIN4000 $
d3 4
d257 1
a257 1
#define NO_CUTTING_ROOM
d285 1
d287 1
a287 1

d387 50
d720 3
a722 1
			SetABPenDrMd(cd->RP,PAL_DGRAY,PAL_LGRAY,JAM2);
d725 3
a727 1
			SetABPenDrMd(cd->RP,APen,BPen,Dr); // restore pens
d736 3
a738 1
			SetABPenDrMd(cd->RP,APen,BPen,Dr); // restore pens
d742 3
a744 1
			SetABPenDrMd(cd->RP,PAL_LBLACK,PAL_DYELLOW,JAM2);
d749 3
a751 1
			SetABPenDrMd(cd->RP,APen,BPen,Dr); // restore pens
d763 4
a766 1
	SetABPenDrMd(cd->RP,PAL_DGRAY,PAL_LGRAY,JAM2);
d769 3
a771 1
	SetABPenDrMd(cd->RP,APen,BPen,Dr); // restore pens
d781 4
d885 2
a886 2
	struct Gadget *ThisG;
	LONG A;
d895 7
d935 1
d951 19
d1863 13
d1882 1
a1882 1
		(*ThisG)->LeftEdge = (NW->Width>>1)-(4*Gadget->Width) - 8;
d1892 1
a1892 1
		Gadget->LeftEdge = (NW->Width>>1) -(3*((*ThisG)->Width)) - 8;
d1929 1
a1929 1
char ClipName[120]="Fly0:ClipperGore";
d1936 1
a1936 1
	BOOL Going = TRUE, Recording=FALSE,RecordedAlready=FALSE;
d1939 1
a1939 1
										*FlyPL=NULL,*NamePL=NULL,*AudPL=NULL;
a1969 2
			else if(PLine->Flags&PL_IN)
				NamePL=PLine;
d2004 1
a2004 1
		NewBorderBox(RP,Record->LeftEdge-6,Record->TopEdge-4,
d2012 2
a2013 2
			strncpy(ClipName,FlyDrive,(LONG)NamePL->PropEnd);
			strncat(ClipName,(char *)NamePL->Param,(LONG)NamePL->PropEnd);
d2026 2
d2029 2
d2054 2
d2059 1
a2059 1
						if( (PLine==FlyPL) || (PLine->Type==PNL_POPUP) ) 
d2066 3
d2097 2
d2115 1
d2138 1
a2138 1

d2159 2
a2160 2
								strncpy(ClipName,FlyDrive,(LONG)NamePL->PropEnd);
								strncat(ClipName,(char *)NamePL->Param,(LONG)NamePL->PropEnd);
d2173 1
d2222 1
a2222 2
										sprintf(str,"%s already exists. Record over it?",ClipName);
										if(BoolRequest(Window,str))
d2271 2
d2316 2
a2317 2
								strncpy(ClipName,FlyDrive,(LONG)NamePL->PropEnd);
								strncat(ClipName,(char *)NamePL->Param,(LONG)NamePL->PropEnd);
d2361 1
d2369 1
a2369 1
	struct PanelLine *PLine = (struct PanelLine *)&MarkClipPL,*TimePL,*StrPL,*LenPL;
d2372 1
d2406 2
d2441 8
d2457 1
a2457 1
			if(!(ClipDisp=InitClipDisplay(16,ContCan->TopEdge-ContCan->Height-60,Window->Width-32,24,Tmax,Window)))
d2471 4
d2606 6
d2784 6
@


2.90
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.89 1994/12/28 17:38:30 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1595 34
d1648 2
d1652 1
a1652 4
	ULONG A;
	UWORD Val;
	struct PanelLine *PLine;
	struct PropInfo *pi;
d1657 1
d1663 1
a1663 20
			if(PLine->G5)
			{
				pi= ((struct PropInfo *)PLine->G5->SpecialInfo);
				A=((*PLine->Param2-PLine->PropStart)*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
				Val = A&0xFFFF;
				if((Call->Flags&DHD_MOUSE_UPDATE))
				{
					A=Val* (PLine->G5->Width - ((struct Image *)PLine->G5->GadgetRender)->Width);
					A = (A/MAXPOT) + PLine->G5->LeftEdge + Call->win->LeftEdge;
					Call->MouseX = (A&0xFFFF) + (((struct Image *)PLine->G5->GadgetRender)->Width>>1);
				}
				NewModifyProp(PLine->G5,Call->win,NULL,pi->Flags,Val,pi->VertPot,pi->HorizBody,pi->VertBody,1);
			}
			if(PLine->G4)
			{
				A = RemoveGadget(Call->win,PLine->G4);
				LongToTime((ULONG *)PLine->Param2,((struct StringInfo *)PLine->G4->SpecialInfo)->Buffer);
				AddGadget(Call->win,PLine->G4,A);
				RefreshGList(PLine->G4,Call->win,NULL,1);
			}
d1665 2
a1666 1
		else {
d1668 6
a1673 1
			if(PLine->PropGadg)
d1675 2
a1676 11
				pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
				A=((*PLine->Param-PLine->PropStart)*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
				Val = A&0xFFFF;
				if((Call->Flags&DHD_MOUSE_UPDATE))
				{
					A=Val* (PLine->PropGadg->Width - ((struct Image *)PLine->PropGadg->GadgetRender)->Width);
					A = (A/MAXPOT) + PLine->PropGadg->LeftEdge + Call->win->LeftEdge;
					Call->MouseX = (A&0xFFFF) + (((struct Image *)PLine->PropGadg->GadgetRender)->Width>>1);
				}
				NewModifyProp(PLine->PropGadg,Call->win,NULL,
					pi->Flags,Val,pi->VertPot,pi->HorizBody,pi->VertBody,1);
d1678 1
a1678 2
//	if(!(Call->Flags&DHD_STR_UPDATE))
			if(PLine->StrGadg)
d1680 2
a1681 4
				A = RemoveGadget(Call->win,PLine->StrGadg);
				LongToTime((ULONG *)PLine->Param,((struct StringInfo *)PLine->StrGadg->SpecialInfo)->Buffer);
				AddGadget(Call->win,PLine->StrGadg,A);
				RefreshGList(PLine->StrGadg,Call->win,NULL,1);
d1683 1
d1685 1
d1963 2
a1964 1
								UpdateDiff(RP,LenPL,Window);
@


2.89
log
@Keep Panels from opening above EditTop->TopEdge
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.88 1994/12/24 12:42:26 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1817 1
a1817 2
//	DHD_SetupRecord(CurFlySource+1,0xFFFF,0xFFFF,0);
	DHD_SetupRecord(CurFlySource+1+2,0xFFFF,0xFFFF,CurCompMode); // until Flyer TBC ready
@


2.88
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.87 1994/12/23 16:12:53 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1037 1
a1037 1
	ClipNW.TopEdge = MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
d1855 1
a1855 1
	ClipNW.TopEdge = MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2);
d2279 1
a2279 1
	ClipNW.TopEdge = MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2);
d2690 1
a2690 1
	ClipNW.TopEdge = MIN(PANEL_TOP,(EditScreen->Height - ClipNW.Height)/2) ;
@


2.87
log
@turn off serial debug statements
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.86 1994/12/23 11:38:44 CACHELIN4000 Exp CACHELIN4000 $
d3 3
@


2.86
log
@Use PropEnd for string limits
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.85 1994/12/22 20:48:27 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d244 1
a244 1
#define SERDEBUG	1
@


2.85
log
@Prevent video recording on audio drives
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.84 1994/12/07 00:13:12 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d241 1
a241 1
//#define SERDEBUG	1
d1118 2
d1121 1
d1147 9
a1155 2
							else
								strcpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer);
d1187 2
d1190 1
d1220 9
a1228 2
							else
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->Param2);
d1875 2
a1876 2
			strncpy(ClipName,FlyDrive,(LONG)NamePL->Param2);
			strncat(ClipName,(char *)NamePL->Param,(LONG)NamePL->Param2);
d1907 1
a1907 1
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->Param2);
d1983 1
a1983 1
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->Param2);
d2009 2
a2010 2
								strncpy(ClipName,FlyDrive,(LONG)NamePL->Param2);
								strncat(ClipName,(char *)NamePL->Param,(LONG)NamePL->Param2);
d2164 2
a2165 2
								strncpy(ClipName,FlyDrive,(LONG)NamePL->Param2);
								strncat(ClipName,(char *)NamePL->Param,(LONG)NamePL->Param2);
d2775 1
a2775 1
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->Param2);
@


2.84
log
@Audio drive name bug fixed, rec vavilable updates on drive/compression changes
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.83 1994/12/05 20:05:59 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1850 2
a1851 1
			if(*FlyDrive==AUDIO_BYTE) FlyDrive+=2; // Skip speaker symbol char and space
a1968 10
//						if(PLine==AudPL)
//						{
//							Y=(LONG)PLine->Param;
//							c=Y&0x000000FF;
//							DUMPHEXIB("Toggle Bits: ",c,"\\");
//							F= Y&1 ? FlyPL->PropStart+1 : 0 ;
//							H= Y&2 ? 0xFFFF : 0 ;
//							DHD_SetupRecord(F,H,H,0);
//						}
//						UpdateAllDiff(RP,Start,Window);
a1973 6
//							Y=(LONG)AudPL->Param;
//							if((Y&3)==0)
//							{
//								ContinueRequest(Window,"  You can't record a clip with no Audio or Video!  ");
//								break;
//							}
d1977 9
a1985 1
								if(*FlyDrive==AUDIO_BYTE) FlyDrive+=2; // Skip speaker symbol char and space
a2128 6
//							Y=(LONG)AudPL->Param;
//							if(!(Y&3))
//							{
//								ContinueRequest(Window,"  You can't record a clip with no Audio or Video!  ");
//								break;
//							}
d2132 9
a2140 1
								if(*FlyDrive==AUDIO_BYTE) FlyDrive+=2; // Skip speaker symbol char and space
@


2.83
log
@Use global CurCompMode for retain compression settings
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.82 1994/12/05 19:24:24 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d233 2
d712 1
a712 1
		RectFill(RP,X+80,Y,X+120,Y+TEXT_HEIGHT);
d1847 1
d1889 2
a1890 1
						if(PLine==FlyPL) UpdateAllDiff(RP,Start,Window);
d1974 1
d1989 1
d2142 1
@


2.82
log
@Quash verminous infestation in CutClipPanel(), add NO_CUTTINGROOM define
I got a car today!! Ha Ha.  Paid $800 in sales tax though aieee!
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.81 1994/12/04 22:57:03 CACHELIN4000 Exp CACHELIN4000 $
d3 4
d255 1
a255 1
extern ULONG CurFlyDrive,CurFlySource,CurFlyTracks;
d1775 1
a1775 1
	DHD_SetupRecord(CurFlySource+1+2,0xFFFF,0xFFFF,0); // until Flyer TBC ready
@


2.81
log
@Bring CurClipPanel into modern age, add SetHiLo()
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.80 1994/12/03 18:34:56 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d225 1
d1675 3
d1679 1
a1679 1
//	Gadget = FindGadget(&Gadget1,ID_DARK_CONTINUE);
d1992 1
a1992 1
						case ID_DARK_CONTINUE:
a1993 1
							Success = PAN_EXPERT;
d1997 1
a1997 1
						case ID_MARK_PANEL:
a1999 1
//							Success = PAN_CONTINUE;
@


2.80
log
@Add QuickTune gadget, etc.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.79 1994/11/30 23:24:43 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d7 1
a7 3
*				if(PLine->Flags&PL_SMREF)
*					ClipNW.Flags = REC_FLAGS;
*				else
d1625 42
d1671 2
a1672 2
//	Gadget = FindGadget(&Gadget1,ID_MARK_PANEL);
	Gadget = FindGadget(&Gadget1,ID_DARK_CONTINUE);
d1987 1
d1993 2
a1994 2
//							Success = PAN_EXPERT;
							Success = PAN_CONTINUE;
d2176 1
a2176 1
	struct PanelLine *PLine = (struct PanelLine *)&MarkClipPL,*InPL,*OutPL,*StrPL,*LenPL;
d2178 1
a2178 1
	ULONG Y=0,Tmax,t,clipnum=0;
d2180 1
a2180 1
	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL;
d2199 1
a2199 6
			if(PLine->Flags&PL_IN)
			{
				In=PLine->StrGadg;
				InPL = PLine;
			}
			else if(PLine->Flags&PL_OUT)
d2201 3
a2203 2
				Out=PLine->StrGadg;
				OutPL = PLine;
d2216 1
a2216 1
	Tmax = OutPL->PropEnd;
d2261 6
a2266 8
			InPL->Param = &cl->in;
			OutPL->Param = &cl->out;
			LenPL->Param = OutPL->Param;
			LenPL->Param2 = InPL->Param;
			InPL->PropEnd = cl->out;
			OutPL->PropEnd = Tmax;
			InPL->PropStart = 0;
			OutPL->PropStart = cl->in;
d2301 3
a2303 4
		LastTime=InPL;
		HiTime = (OutPL->Param);
		LoTime = &InPL->PropStart;
		MyRCB->Frame = (ULONG)(*InPL->Param)<<1;
d2308 1
a2308 1
		MyRCB->pline = LastTime;
a2321 15
						if( InPL && OutPL )
						{
							if(PLine==InPL)
							{
								LastTime=PLine;
								HiTime = (OutPL->Param);
								LoTime = &PLine->PropStart;
							}
							else if(PLine==OutPL)
							{
								LastTime=PLine;
								LoTime = (InPL->Param);
								HiTime = &PLine->PropEnd;
							}
						}
d2323 1
a2323 1
						if( (PLine==InPL) || (PLine==OutPL) )
a2327 32
				case IDCMP_INTUITICKS:
					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						ModifyIDCMP(Window,WinFlags);
						EZGad=NULL;
						break;
					}
					if(!EZJump(Ticks++)) break;  // skip ticks
					ModifyIDCMP(Window,WinFlags); // turn off ticks
					MyRCB->pline = LastTime;
					if(MyRCB->pline->Flags&PL_IN)
					{
						MyRCB->Max = *(OutPL->Param) <<1;
						MyRCB->Min = (MyRCB->pline)->PropStart <<1;
					}
					else
					{
						MyRCB->Min = *(InPL->Param) <<1;
						MyRCB->Max = (MyRCB->pline)->PropEnd <<1;
					}
					DUMPUDECL("Hi Time:",MyRCB->Max,"     " );
					DUMPUDECL("Lo Time:",MyRCB->Min,"    \\" );
					MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param))<<1;
					if(Adder>0) MyRCB->Flags = 0;
					else  MyRCB->Flags = DHD_PLAY_REV;
//						DHD_Jog(MyRCB);
					DHD_Shuttle(MyRCB);
					EZGad=NULL;
					DrawClipDisplay(ClipDisp);
					UpdateAllDiff(RP,Start,Window);
					break;

a2336 12
//						if(PLine==InPL)
//						{
//							DrawClipDisplay(ClipDisp);
//							UpdatePanProp(InPL,Window);
//							UpdatePanStr(InPL,Window);
//						}
//						else if(PLine==OutPL)
//						{
//							DrawClipDisplay(ClipDisp);
//							UpdatePanProp(OutPL,Window);
//							UpdatePanStr(OutPL,Window);
//						}
d2377 2
a2378 2
									DUMPHEXIL("In: ",(LONG)*(InPL->Param),"  ");
									DUMPHEXIL("Out: ",(LONG)*(OutPL->Param),"\\");
d2381 4
a2384 4
									InPL->Param = &cl->in;
									OutPL->Param = &cl->out;
									LenPL->Param = OutPL->Param;
									LenPL->Param2 = InPL->Param;
d2387 2
a2388 4
									InPL->PropEnd = cl->out; // Tmax;
									OutPL->PropEnd = Tmax;
									InPL->PropStart = 0;
									OutPL->PropStart = cl->in; // 0;
d2390 1
a2390 1
										InPL->PropStart = ncl->out;
d2392 2
a2393 3
										OutPL->PropEnd = ncl->in;
									UpdatePanProp(InPL,Window);
									UpdatePanProp(OutPL,Window);
d2395 2
a2396 7

									HiTime = (OutPL->Param);
									LoTime = &InPL->PropStart;
									MyRCB->Frame = (ULONG)(*InPL->Param)<<1;
									MyRCB->Max = (*HiTime)<<1;
									MyRCB->Min = (*LoTime)<<1;

d2410 23
d2444 2
a2445 1
								LastTime = InPL;
d2450 2
a2451 1
								LastTime = OutPL;
d2475 2
d2478 2
a2479 4
								if(LastTime==NULL) break;
								Y = *(LastTime->Param) ;
								if( (Y>=30) && (B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) )
									Y -= 30;
d2481 9
a2489 17
								{
									B = (LastTime->PropEnd - LastTime->PropStart)/10+1 ;
									if(Y>B) Y -= B;
									else Y=0;
								}
								else if(Y)
									Y -= 1;

								*(LastTime->Param) = (Y>=(ULONG)LastTime->PropStart ? Y:LastTime->PropStart);

//								if(InOrOut) //if(LastTime == OutPL) // set Out
//									B = SetClip(ClipDisp,cl,cl->in,*(LastTime->Param));
//								else // set In
//									B = SetClip(ClipDisp,cl,*(LastTime->Param),cl->out);

								UpdatePanProp(LastTime,Window);
								UpdatePanStr(LastTime,Window);
a2492 1
								if(LastTime==NULL) break;
d2494 1
a2494 1
									Y = *(LastTime->Param) + 30;
d2496 1
a2496 1
									Y = *(LastTime->Param) + (LastTime->PropEnd - LastTime->PropStart)/10+1;
d2498 7
a2504 4
									Y = *(LastTime->Param) + 1;
								*(LastTime->Param) = (Y<=LastTime->PropEnd ? Y:LastTime->PropEnd);
								UpdatePanProp(LastTime,Window);
								UpdatePanStr(LastTime,Window);
d2508 3
a2510 1
								if(LastTime==NULL) break;
d2513 9
a2521 5
									Y = LastTime->PropEnd;
									*(LastTime->Param) = Y;
									DrawClipDisplay(ClipDisp);
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
d2526 3
a2528 1
								if(LastTime==NULL) break;
d2531 9
a2539 5
									Y = LastTime->PropStart;
									*(LastTime->Param) = Y;
									DrawClipDisplay(ClipDisp);
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
d2543 1
a2543 1
						}
d2545 2
a2546 1
					else if( (A==(0x80|RAW_LEFT)) || (A==(0x80|RAW_RIGHT)) )		// key-up
@


2.79
log
@				if(PLine->Flags&PL_SMREF)
					ClipNW.Flags = REC_FLAGS;
				else
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.78 1994/11/30 11:24:23 CACHELIN4000 Exp CACHELIN4000 $
d3 5
d853 2
a854 1
struct Gadget *CreateContCancel(UWORD	X1,UWORD	H, struct Gadget **ThisG,BOOL Tune)
d879 1
a879 1
		if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_FINE_TUNE))))
d905 1
a905 1
UWORD __asm Panel(REG(a0) struct EditWindow *Edit,REG(a1) struct PanelLine *PLine, REG(d0) BOOL XPMode)
d1208 1
a1208 1
							Going = FALSE;			//Success was initialized to FALSE
d1211 5
d2182 1
a2182 1
	if(ContCan=CreateContCancel(X1,H,&ThisG,FALSE))
d2580 1
a2580 1
UWORD __asm MiniPanel(REG(a0) struct EditWindow *Edit,REG(a1) struct PanelLine *PLine, REG(d0) BOOL XPMode)
d2749 1
a2749 1
							Going = FALSE;			//Success was initialized to FALSE
d2751 4
@


2.78
log
@Skip over Internal flyer sources 'til TBC stuff is ready
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.77 1994/11/18 16:53:19 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d975 4
d1009 1
d2610 4
d2635 1
@


2.77
log
@I don't remember what I changed...
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.76 1994/11/04 16:54:02 CACHELIN4000 Exp CACHELIN4000 $
d3 3
d1701 2
a1702 1
	DHD_SetupRecord(CurFlySource+1,0xFFFF,0xFFFF,0);
d1771 1
d1910 1
d2063 1
@


2.76
log
@PL_PLAY support
@
text
@d1 5
a5 2
/* $Id: Panel.c,v 2.75 94/11/04 00:29:53 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Panel.c,v $
@


2.75
log
@Set InPL=AInPL, OutPL=AOutPL  on Audio only panel ==> Enforcer happy now
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.74 94/11/03 23:02:42 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d207 1
a207 1
// #define SERDEBUG	1
d896 2
a897 2
	struct PanelLine *InPL=NULL,*OutPL=NULL,*AInPL=NULL,*AOutPL=NULL;
	BOOL Going = TRUE, LiveFlyer = FALSE, LoudFlyer = FALSE;
d964 2
a1070 1
				DUMPMSG("Message In");
d1073 1
d1112 1
d1114 10
d1174 3
d1178 1
d1195 11
@


2.74
log
@Add flyer error messages to record panel, remove audio toggle handling trix
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.73 94/11/02 20:21:55 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d204 1
a204 1
#define SERDEBUG	1
d966 2
@


2.73
log
@Prevent recording of clips w/out audio or video
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.72 94/10/31 17:08:37 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d201 1
a201 1
//#define SERDEBUG	1
d1841 9
a1849 7
						if(PLine==AudPL)
						{
							Y=(LONG)PLine->Param;
							F= Y&1 ? FlyPL->PropStart+1 : 0 ;
							H= Y&2 ? 0xFFFF : 0 ;
							DHD_SetupRecord(F,H,H,0);
						}
d1855 6
a1860 6
							Y=(LONG)AudPL->Param;
							if((Y&3)==0)
							{
								ContinueRequest(Window,"  You can't record a clip with no Audio or Video!  ");
								break;
							}
d1943 4
d1958 2
d2007 6
a2012 6
							Y=(LONG)AudPL->Param;
							if(!(Y&3))
							{
								ContinueRequest(Window,"  You can't record a clip with no Audio or Video!  ");
								break;
							}
@


2.72
log
@Fix diff-update bug
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.71 94/10/27 23:16:07 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1850 6
d1996 6
@


2.71
log
@Set new PLine->Win in Panel() calls, change DrawPanel f'n to use PLine->Win
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.70 94/10/25 18:09:51 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d663 1
d665 1
a665 1
		PLine->PropEnd = A + (ULONG)PLine->G5; //(A==0 ? 2:A);
a666 1
//		if (PLine->Label) strcpy(ch,PLine->Label);
a674 1
//		SafeColorText(RP,ch,strlen(ch));
@


2.70
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.69 94/10/24 17:11:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1010 1
d1608 1
a1608 1
UWORD DrawPanel(struct PanelLine *PLine,struct Window *win)
d1611 1
d1709 3
a1711 2
		PLine = Start;
		DrawPanel(Start,Window);
d1883 1
a1883 1
								DHD_SetDrive(FlyPL,NULL);
d1918 1
a1918 1
											DHD_SetDrive(FlyPL,NULL);
d2154 1
d2563 1
@


2.69
log
@Add MiniPanel() for simplified non-flyer panel calls...
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.68 94/10/24 12:20:51 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1914 6
d2489 1
a2489 1
	ULONG Y=0,d,*V;
@


2.68
log
@Break non-DUAL flyer sliders... fix others
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.67 94/10/20 11:56:02 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d2471 256
@


2.67
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.66 94/10/12 20:41:32 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d907 5
d1033 1
a1033 1
				AHiTime = AOutPL->Param;
d1080 1
d1082 4
a1085 43
					if(!(PLine = (struct PanelLine *)ThisG->UserData)) break;
					if( InPL && OutPL )
					{
						if( (PLine==InPL) && (OutPL==InPL) )
						{
							LastTime=PLine;
//							HiTime = (OutPL->Param);
//							LoTime = &PLine->PropStart;
						}
						else if(PLine==InPL)
						{
							LastTime=PLine;
							HiTime = (OutPL->Param);
							LoTime = &PLine->PropStart;
						}
						else if(PLine==OutPL)
						{
							LastTime=PLine;
							LoTime = (InPL->Param);
							HiTime = &PLine->PropEnd;
						}
					}
					if( AInPL && AOutPL )
					{
						if( (PLine==AInPL) && (AOutPL==AInPL) )
						{
							LastTime=PLine;
//							HiTime = (OutPL->Param);
//							LoTime = &PLine->PropStart;
						}
						else if(PLine==AInPL)
						{
							LastTime=PLine;
							AHiTime = (AOutPL->Param);
							ALoTime = &PLine->PropStart;
						}
						else if(PLine==AOutPL)
						{
							LastTime=PLine;
							ALoTime = (AInPL->Param);
							AHiTime = &PLine->PropEnd;
						}
					}
d1159 2
a1160 2

					if( LiveFlyer )
d1164 3
a1166 3
						MyRCB->pline = LastTime;
						if(LastTime->Flags & PL_IN)
							MyRCB->Frame = (ULONG)(*(LastTime->Param))<<1;
d1168 1
a1168 1
							MyRCB->Frame = (ULONG)(*(LastTime->Param2))<<1;
d1284 1
a1284 1
								if(PLine->Flags&PL_FLYER)
d1311 1
a1311 1
								if(PLine->Flags&PL_FLYER)
d1980 2
@


2.66
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.65 94/10/12 17:37:36 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1901 1
a1901 1
								DHD_SetDrive(FlyPL);
d1936 1
a1936 1
											DHD_SetDrive(FlyPL);
@


2.65
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.64 94/10/11 21:38:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
@


2.64
log
@DuoSlide/PL_DUAL implementation
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.63 94/10/10 17:18:20 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d201 4
d210 2
a211 1
	SMART_REFRESH+BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED,	/* other window flags */
d492 1
a492 1
	if(PLine->Type==PNL_DUOSLIDE)
d868 1
a868 1
	ULONG Y=0,d;
d1257 2
a1258 1
									HiTime = OutPL->Param;
d1264 2
a1265 1
									AHiTime = AOutPL->Param;
d1298 5
a1302 3
									d=(PLine->Flags&PL_CFRAME) ? 2:1;
								Y = *(LastTime->Param);
//								*(LastTime->Param) = (Y>=LastTime->PropStart+d ? Y-d:LastTime->PropStart);
d1305 1
a1305 1
									*(LastTime->Param) = (Y>=*ALoTime+d ? Y-d:*ALoTime);
d1307 1
a1307 1
									*(LastTime->Param) = (Y>=*LoTime+d ? Y-d:*LoTime);
d1310 1
a1310 1
									MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1328 3
a1330 1
								Y = *(LastTime->Param);
d1332 1
a1332 1
									*(LastTime->Param) = (Y<=*AHiTime-d ? Y+d:*AHiTime);
d1334 1
a1334 1
									*(LastTime->Param) = (Y<=*HiTime-d ? Y+d:*HiTime);
d1337 1
a1337 1
									MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1349 4
a1352 2
								if(PLine->Flags&PL_AUDIO)
									*(LastTime->Param) = *AHiTime;
d1354 1
a1354 1
									*(LastTime->Param) = *HiTime;
d1360 1
a1360 1
										MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1374 1
a1374 1
										MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1388 4
a1391 2
								if(PLine->Flags&PL_AUDIO)
									*(LastTime->Param) = *ALoTime;
d1393 1
a1393 1
									*(LastTime->Param) = *LoTime;
d1399 1
a1399 1
										MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1413 1
a1413 1
										MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
d1706 1
d1958 2
a1959 1

d1974 1
a1975 2
					A = IntuiMsg->Code;
					if(A>0x80) break;
d2008 1
a2008 1
				case IDCMP_REFRESHWINDOW:
d2019 1
@


2.63
log
@Add record (SPACE) hotkey
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.62 94/10/07 11:39:24 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d476 1
a476 1
// converts HH:MM:SS:FF to LONG # of FRAMEs,, 
d484 10
a493 1
	if( !(ThisG=PLine->StrGadg) ) return(0);
a495 1
	L=(ULONG *)PLine->Param;
d895 5
d999 2
a1000 1
			HiTime = OutPL->Param;
d1031 1
a1031 1
								FixTimeStr(PLine,Window,FALSE);
d1034 1
a1034 1
									MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
d1041 1
a1041 1
									MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
d1062 7
a1068 1
						if(PLine==InPL)
d1083 7
a1089 1
						if(PLine==AInPL)
d1181 4
a1184 1
						MyRCB->Frame = (ULONG)(*(LastTime->Param))<<1;
d1498 1
a1498 2
		*PLine->Param = EVEN(1+(Call->Frame>>1)); // even frame #s
		if(PLine->PropGadg)
d1500 37
a1536 8
			pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
			A=((*PLine->Param-PLine->PropStart)*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
			Val = A&0xFFFF;
			if((Call->Flags&DHD_MOUSE_UPDATE))
			{
				A=Val* (PLine->PropGadg->Width - ((struct Image *)PLine->PropGadg->GadgetRender)->Width);
				A = (A/MAXPOT) + PLine->PropGadg->LeftEdge + Call->win->LeftEdge;
				Call->MouseX = (A&0xFFFF) + (((struct Image *)PLine->PropGadg->GadgetRender)->Width>>1);
a1537 3
			NewModifyProp(PLine->PropGadg,Call->win,NULL,
				pi->Flags,Val,pi->VertPot,pi->HorizBody,pi->VertBody,1);
		}
d1539 7
a1545 6
		if(PLine->StrGadg)
		{
			A = RemoveGadget(Call->win,PLine->StrGadg);
			LongToTime((ULONG *)PLine->Param,((struct StringInfo *)PLine->StrGadg->SpecialInfo)->Buffer);
			AddGadget(Call->win,PLine->StrGadg,A);
			RefreshGList(PLine->StrGadg,Call->win,NULL,1);
@


2.62
log
@let EZgads go negative...
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.61 94/10/06 23:04:11 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
a1791 5
//							if(RecordedAlready)
//							{
//								DHD_InitRecord(0,0);
//							}
//							else RecordedAlready=TRUE;
d1899 1
a1899 1
					if ((A == RAW_ENTER)||(A == RAW_RETURN))
d1901 28
a1928 6
						Going = FALSE;
						Success=TRUE;
					} else if(A == RAW_HELP)
					{
						Going = FALSE;			//Success was initialized to FALSE
						Success=TRUE;
a1929 1
					else if((A == RAW_ESCAPE)) Going = FALSE;
@


2.61
log
@Connect up audio shuttle real good.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.59 94/10/06 10:47:02 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d842 1
a842 1
	struct PanelLine *InPL,*OutPL,*AInPL=NULL,*AOutPL=NULL;
d1167 2
a1168 1
					if( (F=*(PLine->Param)) || (Adder>0))
@


2.60
log
@Connect up audio shuttle real good.
@
text
@d162 1
a162 1
#define SERDEBUG	1
@


2.59
log
@Audio control fixes...
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.58 94/10/05 16:27:45 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d162 1
a162 1
// #define SERDEBUG	1
d897 5
a901 6
				if( (PLine->Flags&PL_FLYER) && InPL && OutPL)
				{
					LiveFlyer = TRUE;
					if( AInPL && AOutPL )
						LoudFlyer = TRUE;
				}
d903 2
a1051 1
					else LiveFlyer=FALSE; // No In/Out to control..
a1066 1
					else LoudFlyer=FALSE; // No In/Out to control..
d1143 1
@


2.58
log
@Fix Comment editing bug in Panel() (Param2 vs PropEnd for str max)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.57 94/10/05 01:04:36 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d869 1
d882 1
d1138 2
a1139 1
					if( LiveFlyer && (PLine->Flags&PL_FLYER) && !(PLine->Flags&PL_AUDIO) )
a1142 2
						MyRCB->Max = (*HiTime)<<1;
						MyRCB->Min = (*LoTime)<<1;
d1144 10
d1210 6
d1225 6
d1246 1
a1246 1
									d=(PLine->Flags&PL_FLYER) ? 2:1;
d1249 5
a1253 1
								*(LastTime->Param) = (Y>=*LoTime+d ? Y-d:*LoTime);
d1273 1
a1273 1
									d=(PLine->Flags&PL_FLYER) ? 2:1;
d1275 4
a1278 1
								*(LastTime->Param) = (Y<=*HiTime-d ? Y+d:*HiTime);
d1293 5
d1300 1
a1300 3
//									*(LastTime->Param) = LastTime->PropEnd;
									*(LastTime->Param) = *HiTime;
									if(PLine->Flags&PL_FLYER)
d1314 1
a1314 2
									*(LastTime->Param) = *LoTime;
									if(PLine->Flags&PL_FLYER)
d1330 5
d1337 1
a1337 2
									*(LastTime->Param) = *LoTime;
									if(PLine->Flags&PL_FLYER)
d1351 1
a1351 2
									*(LastTime->Param) = *LoTime;
									if(PLine->Flags&PL_FLYER)
@


2.57
log
@Add PNL_DIFF add-on (G5) to UpdateDiff()
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.56 94/10/04 17:52:55 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d181 1
d1023 1
a1023 1
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->Param2);
d1540 1
a1540 1
	DHD_SetupRecord(1,0xFFFF,0xFFFF,0);
@


2.56
log
@Fix string/Popup bug on record panel
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.55 94/10/03 18:47:44 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d608 1
a608 1
		PLine->PropEnd = (A==0 ? 2:A);
@


2.55
log
@Un-hilite REC before writing icon, Don't record if record button used to stop
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.54 94/10/02 00:30:17 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1535 1
a1535 1
	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL;
d1614 1
d1632 1
d1689 1
d1707 1
@


2.54
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.53 94/10/02 00:02:42 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
a1640 1

d1644 2
d1648 1
a1648 2
            				DHD_MakeClipIcon(ClipName);

d1671 3
a1673 2
        				DHD_MakeClipIcon(ClipName);

d1680 1
a1738 2
							Record->Flags &= ~GFLG_SELECTED;
							RefreshGList(Record,Window,NULL,1);
a1803 2
            						DHD_MakeClipIcon(ClipName);

d1806 1
d1810 1
a1810 1
						
d1829 3
a1831 2
            		DHD_MakeClipIcon(ClipName);

d1869 1
a1869 1
	DUMPSTR(" OK so far .....   ");
@


2.53
log
@fix PNL_SKIP type bug...
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.52 94/10/01 01:06:10 Kell Exp Locker: CACHELIN4000 $
d3 3
d1352 1
a1352 1
		if(PLine && PLine->Destroy)
@


2.52
log
@Now calls code to make a clip icon after record.
@
text
@d1 5
a5 2
/* $Id: panel.c,v 2.51 1994/09/30 21:56:28 CACHELIN4000 Exp Kell $
* $Log: panel.c,v $
d141 1
a141 1
//#define SERDEBUG	1
d921 1
d924 1
a924 1

a943 1
				PLine++;
d945 3
d973 1
d1487 1
a1487 2
		if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,win);
		if(PLine->Width>0)
d1489 12
a1500 8
			X1 = PNL_WIDTH;
			Y = Y1;
		}
		else
		{
			H += MAX(Y,Y1);
			X1 = 0;
			Y = 0;
d1504 1
@


2.51
log
@*** empty log message ***
@
text
@d1 5
a5 2
/* $Id: Panel.c,v 2.50 94/09/30 11:29:41 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Panel.c,v $
d138 1
a138 1
#define SERDEBUG	1
d1623 2
d1630 2
a1631 1
//             DHD_MakeIcon()
d1654 2
a1655 1
//             DHD_MakeIcon()
d1783 2
d1787 2
a1788 1
//										DHD_MakeIcon();
d1793 3
d1807 2
d1813 2
a1814 1
//             DHD_MakeIcon()
@


2.50
log
@Set Startup record source to 1 (camcorder in)
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.49 94/09/29 23:47:14 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1625 1
d1648 1
d1775 7
d1791 1
d1798 2
@


2.49
log
@Add NoticeWindow, WaitSprite to reorganize f'n
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.48 94/09/29 16:28:18 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1503 1
a1503 1
	LONG Y=0,F,RecTix=0, RecStartM=0,RecStartS=0;
d1507 1
a1507 1
	DHD_SetupRecord(0,0xFFFF,0xFFFF,0);
d1742 1
a1742 2
						RecTix++;
						if((RecStartS==0)&&(RecStartS==0))
d1747 29
a1775 33
						{
							if(Y = (IntuiMsg->Seconds - RecStartS)*30)
								Y += (3*IntuiMsg->Micros)/100000;
							else
								Y += (3*(IntuiMsg->Micros - RecStartM))/100000;
							*LenPL->Param = (Y+1)&0xFFFFFFFE; // even up
							UpdateDiff(RP,LenPL,Window);
							if(FlyPL->PropEnd>1)
								if( (Y=DHD_CheckRecord())!=FERR_BUSY )
								{
									Recording=FALSE;
									ModifyIDCMP(Window,WinFlags);
									Record->Flags &= ~GFLG_SELECTED;
									RefreshGList(Record,Window,NULL,1);
									switch(Y)
									{
										case FERR_EXISTS:
											sprintf(str,"%s already exists. Record over it?",ClipName);
											if(BoolRequest(Window,str))
											{
												CrDeleteFile(ClipName);
												Recording=TRUE;
												ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
												*LenPL->Param = 0;
												RecStartS=IntuiMsg->Seconds;
												RecStartM=IntuiMsg->Micros;
												DHD_Record(ClipName,0,0,0xDEADBABE);
												DHD_SetDrive(FlyPL);
											}
											break;
										default:
											break;
									}
d1777 1
a1777 1
						}
@


2.48
log
@makeservetr
makeserver
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.47 94/09/29 15:52:14 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 1
a3 5
*Revision 2.47  94/09/29  15:52:14  CACHELIN4000
**** empty log message ***
*
*Revision 2.45  94/09/28  18:17:29  CACHELIN4000
**** empty log message ***
a7 3
*Revision 2.43  94/09/28  00:02:01  CACHELIN4000
**** empty log message ***
*
a10 3
*Revision 2.41  94/09/24  15:12:19  CACHELIN4000
**** empty log message ***
*
a128 7
VOID __asm CopyCrut(
	REG(a0) struct BitMap *SrcBM,
	REG(a1) struct BitMap *DstBM,
	REG(d0) WORD DestX,
	REG(d1) WORD DestY,
	REG(d2) WORD Height);

d194 1
a194 1
char str[100];
d1723 3
d1727 2
d1772 1
@


2.47
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.45 94/09/28 18:17:29 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1832 1
a1832 1

@


2.46
log
@*** empty log message ***
@
text
@d174 1
a174 1
	SIMPLE_REFRESH+BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED,	/* other window flags */
d1480 22
d1511 1
a1511 1
	struct PanelLine *PLine = (struct PanelLine *)&RawRecPL,*Avail=0,*LenPL=NULL,
d1538 1
a1538 1
				Avail=PLine;
a1549 1
	if(Avail==(struct PanelLine *)8) Avail=0;
d1560 1
a1560 1
	if( !(ContCan=CreateNewClipGads((struct NewWindow *)&ClipNW,(Avail->PropStart)&0xFFFF,&ThisG)) )
d1576 1
a1576 20
		X1 = 0;
		Y = 0;
		H = PNL_Y1;
		while (PLine->Type)
		{
			if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,Window);
			if(PLine->Width>0)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				H += MAX(Y,Y1);
				X1 = 0;
				Y = 0;
			}
			PLine++;
		}

a1578 1

a1579 1

d1734 1
a1734 1
							sprintf(str,"%s already exists. Record over it?",((char **)FlyPL->Param)[FlyPL->PropStart]);
d1814 3
@


2.45
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.44 94/09/28 14:47:29 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d208 1
a209 3
#ifdef SERDUBUG
char str[100];
#endif
d619 2
a620 1
	while (PLine->Type) {
d764 1
a764 1
	struct Gadget *NewG,*con=NULL,*can;
d1415 9
a1423 8
//		if(!(Call->Flags&DHD_STR_UPDATE))
			if(PLine->StrGadg)
			{
				A = RemoveGadget(Call->win,PLine->StrGadg);
				LongToTime((ULONG *)PLine->Param,((struct StringInfo *)PLine->StrGadg->SpecialInfo)->Buffer);
				AddGadget(Call->win,PLine->StrGadg,A);
				RefreshGList(PLine->StrGadg,Call->win,NULL,1);
			}
d1427 1
a1427 1
struct Gadget *CreateNewClipGads(struct Gadget *ThisG, UWORD W, UWORD Y1)
d1431 2
a1432 1
	Gadget = FindGadget(&Gadget1,ID_MARK_PANEL);
d1435 6
a1440 11
		if(ThisG)
		{
			while(ThisG->NextGadget)
				ThisG=ThisG->NextGadget;
			ThisG->NextGadget =Gadget;
			Gadget->TopEdge = Y =  ThisG->TopEdge;
		}
		ThisG = Gadget;
		Gadget->LeftEdge = (W - ThisG->Width)>>1;
		ThisG->NextGadget = NULL;
		ThisG->UserData = NULL;
d1447 6
a1452 6
		ThisG->NextGadget = Gadget;
		ThisG = Gadget;
		ThisG->LeftEdge = (W - ThisG->Width - (PNL_X1<<1) +2 );
		ThisG->TopEdge = Y1;
		ThisG->NextGadget = NULL;
		ThisG->UserData = NULL;
d1457 7
a1463 7
		ThisG->NextGadget = Gadget;
		ThisG = Ret =Gadget;
		ThisG->Activation |= GACT_TOGGLESELECT;
		ThisG->LeftEdge = (W>>1)-(4*Gadget->Width) - 8;
		ThisG->TopEdge = Y - 24 - Gadget->Height;
		ThisG->NextGadget = NULL;
		ThisG->UserData = NULL;
d1469 3
a1471 3
		ThisG->NextGadget = Gadget;
		Gadget->LeftEdge = (W>>1) -(3*ThisG->Width) - 8;
		Gadget->TopEdge = ThisG->TopEdge;
d1475 1
a1475 1
		ThisG = Gadget;
d1483 1
a1483 1
	WORD H = PNL_Y1,ID,A,B,X1=0,Y1=0,Lines=0;
d1489 2
a1490 1
	struct PanelLine *PLine = (struct PanelLine *)&RawRecPL,*Avail=0,*LenPL=NULL,*FlyPL=NULL,*NamePL=NULL;
d1495 1
a1495 1
	DHD_InitRecord(0,0xc0ded00d);
d1511 1
a1511 2
			X1 = 0;
			Y = 0;
a1517 1
			{
a1518 2
				Len=PLine->StrGadg;
			}
d1523 2
d1533 1
a1533 1
	ClipNW.Height = H;
d1539 1
a1539 4
	if(ContCan=CreateContCancel(X1,H,&ThisG,FALSE))
		H += (UWORD)(PNL_YADD + ContCan->Height);
	else goto rErrExit;
	if( !(Record=CreateNewClipGads(ContCan,ClipNW.Width,Len->TopEdge + 36)) )
d1541 4
a1585 1
		LastTime=NULL;
d1628 12
a1639 9
							DHD_Abort(0);
							ModifyIDCMP(Window,WinFlags);
							Recording=FALSE;
							if(Y = (IntuiMsg->Seconds - RecStartS)*30)
								Y += (3*IntuiMsg->Micros)/100000;  // should add (1000000-RecStartM)
							else
								Y += (3*(IntuiMsg->Micros - RecStartM))/100000;
							*LenPL->Param = (Y+1)&0xFFFFFFFE; // even up
							UpdateTime(Len,Window,*LenPL->Param);
d1651 11
a1661 1

d1686 7
a1725 3
							DHD_Abort(0);
							Record->Flags &= ~GFLG_SELECTED;
							RefreshGList(Record,Window,NULL,1);
a1730 1
//							DHD_Abort(0);
d1734 7
a1740 4
//							DHD_Abort(0);
//						if(ReorgDrive()) ReDoDiffs();
//							*Avail->Param <<= 1;
//							UpdateDiff(RP,Avail,Window);
a1744 1

d1749 5
a1753 1
//						if(!(RecTix&3)) // every 4th tick... too slow
d1760 1
a1760 3

//							DUMPUDECL("Elapsed Frames: ",*LenPL->Param,"\\");
							UpdateTime(Len,Window,*LenPL->Param);
d1768 18
a1787 7
						break;
					}
					else if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						ModifyIDCMP(Window,WinFlags);
						EZGad=NULL;
						break;
a1788 9
					if(!EZJump(Ticks++)) break;  // skip ticks
					if( (F=*(PLine->Param2)) || (Adder>0))
						F += Adder*EZJump(Ticks++);
					else break;
					if(Adder<0)
						*(PLine->Param2) = (F>=PLine->PropStart ? F:PLine->PropStart);
					else
						*(PLine->Param2) = (F<=PLine->PropEnd ? F:PLine->PropEnd);
					UpdatePanStr(PLine,Window);
a1789 2


d1791 1
a1791 2
					A = IntuiMsg->Code;
					if(A<0x80)
d1793 8
a1800 61
						B = IntuiMsg->Qualifier;
						DUMPHEXIB("Key Code: ",A,"\\");
						switch(A)
						{
							case	RAW_LEN:
								if(Len)	ActivateGadget(Len,Window,NULL);
								break;
							case	RAW_LEFT:
								if(LastTime==NULL) break;
								Y = *(LastTime->Param) ;
								if( (Y>=30) && (B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT)) )
									Y -= 30;
								else if(B & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
								{
									B = (LastTime->PropEnd - LastTime->PropStart)/10+1 ;
									if(Y>B) Y -= B;
									else Y=0;
								}
								else if(Y)
									Y -= 1;
								*(LastTime->Param) = (Y>=(ULONG)LastTime->PropStart ? Y:LastTime->PropStart);
								UpdatePanProp(LastTime,Window);
								UpdatePanStr(LastTime,Window);
								UpdateAllDiff(RP,Start,Window);
								break;
							case RAW_RIGHT:
								if(LastTime==NULL) break;
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
									Y = *(LastTime->Param) + 30;
								else if(B & (IEQUALIFIER_LALT | IEQUALIFIER_RALT) )
									Y = *(LastTime->Param) + (LastTime->PropEnd - LastTime->PropStart)/10+1;
								else
									Y = *(LastTime->Param) + 1;
								*(LastTime->Param) = (Y<=LastTime->PropEnd ? Y:LastTime->PropEnd);
								UpdatePanProp(LastTime,Window);
								UpdatePanStr(LastTime,Window);
								UpdateAllDiff(RP,Start,Window);
								break;
							case RAW_UP:
								if(LastTime==NULL) break;
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
								{
									Y = LastTime->PropEnd;
									*(LastTime->Param) = Y;
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
									UpdateAllDiff(RP,Start,Window);
								}
								break;
							case RAW_DOWN:
								if(LastTime==NULL) break;
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
								{
									Y = LastTime->PropStart;
									*(LastTime->Param) = Y;
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
									UpdateAllDiff(RP,Start,Window);
								}
								break;
						}
d1802 2
a1816 4
				if(!Recording && RecordedAlready)
				{
					DHD_InitPlay(ClipName,0xbadb00b1);
				}
@


2.44
log
@Dummied out NewClip MarkClips button
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.43 94/09/28 00:02:01 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1488 1
a1488 1
	BOOL Going = TRUE, Recording=FALSE;
a1513 1

a1534 5

	if(ContCan=CreateContCancel(X1,H,&ThisG,FALSE))
		H += (UWORD)(PNL_YADD + ContCan->Height);
	else goto rErrExit;

d1541 3
a1543 1

a1545 1

a1619 1

d1634 1
a1634 1
								Y += (3*IntuiMsg->Micros)/100000;
a1693 1
//								DeleteClip(ClipName);
d1698 1
a1698 1
//							DHD_InitPlay(ClipName,0);
d1849 1
a1849 1
				}
d1851 3
d1855 1
a1865 1
	DHD_InitPlay(ClipName,0xbadb00b1);
@


2.43
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.42 94/09/27 17:22:10 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1718 2
a1719 1
							Success = PAN_EXPERT;
a1887 1
  char name[CLIP_NAME_MAX]="NewClip.1";
d1968 2
a1969 2
			sprintf(name,"NewClip.%d",1+clipnum++);
			if(cl=AddClip(ClipDisp,0,Tmax,CLIP_ACTIVE,name))
d2138 2
a2139 2
									sprintf(name,"NewClip.%d",1+clipnum++);
									tcl=AddClip(ClipDisp,t,t+30,CLIP_ACTIVE,name);
@


2.42
log
@Record Panel work: Poll CheckRecord, guestimate recorded duration, use PL_LEN
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.41 94/09/24 15:12:19 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1475 1
d1484 1
a1484 1
	struct PanelLine *PLine = (struct PanelLine *)&RawRecPL,*Avail=0,*LenPL=NULL,*FlyPL=NULL;
d1487 1
a1487 1
	char ClipName[64], *FlyDrive;
d1520 2
d1583 2
a1584 2
			strncpy(ClipName,FlyDrive,64);
			strncat(ClipName,"MyNewClip",64);
d1680 6
a1734 1

d1862 2
a1863 1
//	DHD_InitPlay(ClipName,0xbadb00b1);
@


2.41
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.40 94/09/23 10:33:53 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d109 1
d1441 1
a1441 1
		ThisG->LeftEdge = (W - ThisG->Width - (PNL_X1<<1));
d1451 1
d1464 1
d1478 1
a1478 1
	BOOL Going = TRUE;
d1480 1
a1480 1
	struct PanelLine *PLine = (struct PanelLine *)&RawRecPL, *Avail=0;
d1482 2
a1483 1
	LONG Y=0,F;
d1486 1
d1510 2
d1513 3
d1536 1
a1536 1
	if( !(Record=CreateNewClipGads(ContCan,ClipNW.Width,Len->TopEdge-4)) )
d1574 6
d1617 1
d1625 8
d1674 6
d1682 1
a1682 1
//								DeleteClip("MyNewClip");
d1686 2
a1687 2
//							DHD_Record("MyNewClip",StartBlock,MaxBlocks,0xDEADBABE);
//							DHD_InitPlay("MyNewClip",0);
d1690 2
d1697 3
a1699 1
//							DHD_Abort(0);
d1718 26
a1743 1
					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
d1851 1
a1851 1
	DHD_InitPlay(0,0xbadb00b1);
@


2.40
log
@Record Panel, CutCLip Panel work, Audio controls
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.39 94/09/20 23:39:48 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d1478 1
a1478 1
//	DHD_InitRecord(0,0xc0ded00d);
d1604 1
d1646 8
a1653 1
//							DHD_Record(0,StartBlock,MaxBlocks,0xDEADBABE);
a1655 1
//							DHD_Abort(0);
d1788 1
a1788 1
//	DHD_InitPlay(0,0xbadb00b1);
d1888 1
a1888 1
			if(!(ClipDisp=InitClipDisplay(16,ContCan->TopEdge-ContCan->Height-40,Window->Width-32,24,Tmax,Window)))
@


2.39
log
@PNL_SKIP support, etc.
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.38 94/09/13 20:16:48 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d167 1
a167 1
struct PanelLine *CurPLine,*Start,*LastTime,*temp;
d170 1
a170 1
ULONG	Ticks,WinFlags,GadInd,*LoTime=0,*HiTime=0;
a723 3

//	SetPropHorizPot(PLine->PropGadg,Window,A,0,PLine->PropEnd-PLine->PropStart);
//	if (Window) DrawLRKnobRail(Window->RPort,PLine->PropGadg);
d726 1
a726 1

d733 2
a734 2
	if (A > *HiTime) A = *HiTime;
	else if (A < *LoTime) A = *LoTime;
a740 1
//		if (Window) DrawLRKnobRail(Window->RPort,PLine->PropGadg);
d743 1
a743 1

d786 1
a786 1
ULONG EZJump(ULONG t)
d801 2
a802 2
	struct PanelLine *InPL,*OutPL;
	BOOL Going = TRUE, LiveFlyer = FALSE;
d831 9
a839 2
					InPL=PLine;
					In=PLine->StrGadg;      // change In from *Gadget to *PLine
d843 9
a851 2
					OutPL=PLine;
					Out=PLine->StrGadg;
d858 1
d860 3
d941 6
d964 1
a964 1
								if(PLine->Flags&PL_FLYER)
a965 1
//									MyRCB->Flags = DHD_STR_UPDATE;
d970 7
a976 1
//									MyRCB->Flags = 0;
d1008 16
d1027 62
d1097 1
a1097 1
					if( LiveFlyer && (PLine->Flags&PL_FLYER) )
a1143 55
				case IDCMP_GADGETUP:
					DUMPMSG	("GADGETUP");

					if (Down) Down = NULL;
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;

					if(LastString && LastString!=ThisG)
					{
						if(PLine = (struct PanelLine *)LastString->UserData)
							if( (((struct StringInfo *)(LastString->SpecialInfo))->Extension==&TCExt) )
							{
								FixTimeStr(PLine,Window,FALSE);
								if(PLine->Flags&PL_FLYER)
								{
									MyRCB->Flags = DHD_STR_UPDATE;
									MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
									MyRCB->Max = (*HiTime)<<1;
									MyRCB->Min = (*LoTime)<<1;
									DHD_Jump(MyRCB);
									MyRCB->Flags = 0;
								}
							}
							else if(LastString->Activation & GACT_LONGINT)
							{
								stcd_l(((struct StringInfo *)LastString->SpecialInfo)->Buffer,(LONG *)PLine->Param);
								if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
								if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
								UpdatePanStr(PLine,Window);
							}
							else
								strncpy((char *)PLine->Param,((struct StringInfo *)LastString->SpecialInfo)->Buffer,(int)PLine->Param2);
						LastString=NULL;
					}

					PLine = (struct PanelLine *)ThisG->UserData;
					if(PLine && PLine->Handle)
						PLine->Handle(PLine,IntuiMsg,Window);
					else switch (ID)
					{
						case ID_DARK_CONTINUE:
							DUMPMSG	("CONTINUE");
							Success = PAN_CONTINUE;
						case ID_REQ_DARK_CANCEL:
							Going = FALSE;			//Success was initialized to FALSE
							break;
						case ID_FINE_TUNE:
							Going = FALSE;			//Success was initialized to FALSE
							Success = PAN_EXPERT;
							break;
						case ID_BOOL:
							PLine->Param = (long *)( PLine->Param ? 0:1 ) ;  // invert value...
							break;
					}
					break;
d1309 1
a1309 16
/*
		if(FakeIn)
		{
			A = RemoveGadget(Window,FakeIn);
			AddGadget(Window,InPL->PropGadg,A);
			FakeIn->NextGadget=NULL;
			FreeGadgets(FakeIn);
		}
		if(FakeOut)
		{
			A = RemoveGadget(Window,FakeOut);
			AddGadget(Window,OutPL->PropGadg,A);
			FakeOut->NextGadget=NULL;
			FreeGadgets(FakeOut);
		}
*/
a1317 4
			case PNL_TIME:
//				TimeToLong(((struct StringInfo *)PLine->StrGadg->SpecialInfo)->
//					Buffer,(ULONG *)PLine->Param);
			break;
d1408 55
a1463 1

d1466 1
a1466 1
	struct Gadget *ThisG=0,*Gadget,*ContCan,*Record,*Stop,*Play,*Rew,*FFwd,*Pause;
d1473 1
a1473 1
	ULONG Y=0;
d1520 2
a1521 65
	Gadget = FindGadget(&Gadget1,ID_MARK_PANEL);
	if (!(Gadget = AllocOneGadget(Gadget))) goto rErrExit;
	ThisG->NextGadget = Gadget;
	ThisG = Gadget;
	ThisG->LeftEdge = (ClipNW.Width - ThisG->Width)>>1;
	ThisG->TopEdge = ContCan->TopEdge;
	ThisG->NextGadget = NULL;
	ThisG->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_REORG);
	if (!(Gadget = AllocOneGadget(Gadget))) goto rErrExit;
	ThisG->NextGadget = Gadget;
	ThisG = Gadget;
	ThisG->LeftEdge = (ClipNW.Width - ThisG->Width - (PNL_X1<<1));
	ThisG->TopEdge = Len->TopEdge-4;
	ThisG->NextGadget = NULL;
	ThisG->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_REC);
	if (!(Record = AllocOneGadget(Gadget))) goto rErrExit;
	ThisG->NextGadget = Record;
	Record->LeftEdge = (ClipNW.Width>>1)-(4*Record->Width) - 8;
	Record->TopEdge = ContCan->TopEdge - 40 - Record->Height;
	Record->NextGadget = NULL;
	Record->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_REQ_STOP);
	if (!(Stop = AllocOneGadget(Gadget))) goto rErrExit;
	Stop->LeftEdge = (ClipNW.Width>>1) -(3*Record->Width) - 8;
	Stop->TopEdge = Record->TopEdge;
	Record->NextGadget = Stop;
	Stop->NextGadget = NULL;
	Stop->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_REW);
	if (!(Rew = AllocOneGadget(Gadget))) goto rErrExit;
	Rew->LeftEdge = (ClipNW.Width>>1) ; //-(2*Rew->Width);
	Rew->TopEdge = Record->TopEdge;
	Stop->NextGadget = Rew;
	Rew->NextGadget = NULL;
	Rew->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_PAUSE);
	if (!(Pause = AllocOneGadget(Gadget))) goto rErrExit;
	Pause->LeftEdge = (ClipNW.Width>>1) +(Rew->Width);
	Pause->TopEdge = Record->TopEdge;
	Rew->NextGadget = Pause;
	Pause->NextGadget = NULL;
	Pause->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_PLAY);
	if (!(Play = AllocOneGadget(Gadget))) goto rErrExit;
	Play->LeftEdge = (ClipNW.Width>>1) + (2*Rew->Width);
	Play->TopEdge = Record->TopEdge;
	Pause->NextGadget = Play;
	Play->NextGadget = NULL;
	Play->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_FFWD);
	if (!(FFwd = AllocOneGadget(Gadget))) goto rErrExit;
	FFwd->LeftEdge = (ClipNW.Width>>1) +(3*Rew->Width);
	FFwd->TopEdge = Record->TopEdge;
	Play->NextGadget = FFwd;
	FFwd->NextGadget = NULL;
	FFwd->UserData = NULL;
d1569 2
a1570 1
					if(PLine = (struct PanelLine *)ThisG->UserData)
d1572 1
a1572 1
						if( PLine->StrGadg && (PLine->StrGadg==In) )
d1574 1
a1574 2
							InOrOut=0;
							if(Out && (temp=(struct PanelLine *)Out->UserData) )
d1576 1
a1576 2
								HiTime = (temp->Param);
								LoTime = &PLine->PropStart;
d1578 1
a1578 5
						}
						else if( PLine->StrGadg && (PLine->StrGadg==Out) )
						{
							InOrOut=1;
							if(In && (temp=(struct PanelLine *)In->UserData) )
d1580 4
a1583 2
								HiTime = &PLine->PropEnd;
								LoTime = (temp->Param);
d1585 2
d1588 6
a1601 29
						case ID_VCR_PAUSE:
							break;
					}
					break;

				case IDCMP_INTUITICKS:
					if( !EZGad || !(EZGad->Flags&GFLG_SELECTED) )
					{
						ModifyIDCMP(Window,WinFlags);
						EZGad=NULL;
						break;
					}
					if( (Y=*(PLine->Param)) || (Adder>0))
						Y += Adder*EZJump(Ticks++);
					else break;
					if(Adder<0)
						*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
					else
						*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
					UpdatePanProp(PLine,Window);
					UpdatePanStr(PLine,Window);
					UpdateAllDiff(RP,Start,Window);
					break;

				case IDCMP_MOUSEMOVE:
					if (Down) {
//						DrawLRKnobRail(RP,Down);
						UpdateParam((struct PanelLine *)Down->UserData,Window);
//						UpdateAllDiff(RP,Start,Window);
a1604 9
				case IDCMP_MOUSEBUTTONS:
					A = IntuiMsg->Code;
					if( (A==IECODE_RBUTTON))
//						if(B=DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG))
//							*LastTime->Param=B;
					if (Down) Down = NULL;
					PLine = (struct PanelLine *)ThisG->UserData;
					break;

d1612 22
a1640 3
						case ID_VCR_REW:
						case ID_VCR_FFWD:
//							DHD_Jump(0xc0edbabe);
a1646 2
						case ID_VCR_PAUSE:
							break;
d1662 2
a1663 2
							*Avail->Param <<= 1;
							UpdateDiff(RP,Avail,Window);
d1668 20
d1789 1
a1789 2
	struct Gadget *ThisG=0,*Gadget,*ContCan,*Play,*Rew,*FFwd,*Pause,*Clips,
		*String,*FakeIn=NULL,*FakeOut=NULL,
d1794 1
a1794 1
	BOOL Going = TRUE, LiveFlyer = FALSE;
a1836 2
			if( (PLine->Flags&PL_FLYER) && InPL && OutPL)
				LiveFlyer = TRUE;
a1858 1
//	Gadget = FindGadget(&Gadget1,ID_CROUTON_SMALL);
a1866 40
/* 	itxt = AllocIntuiText(PAL_BLACK,PAL_LGRAY,1,4,"Record Panel");
	if(ThisG->GadgetText = itxt)
	{
		ThisG->GadgetText->ITextFont = &TextAttr;
		Y = IntuiTextLength(itxt);
		ThisG->GadgetText->LeftEdge = (ThisG->Width - Y)>>1;
	} */

	Gadget = FindGadget(&Gadget1,ID_VCR_REW);
	if (!(Rew = AllocOneGadget(Gadget))) goto rErrExit;
	Rew->LeftEdge = (ClipNW.Width>>1) ; //-(2*Rew->Width);
	Rew->TopEdge = ContCan->TopEdge - 40 - Rew->Height;
	ThisG->NextGadget = Rew;
	Rew->NextGadget = NULL;
	Rew->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_PAUSE);
	if (!(Pause = AllocOneGadget(Gadget))) goto rErrExit;
	Pause->LeftEdge = (ClipNW.Width>>1) +(Rew->Width);
	Pause->TopEdge = Rew->TopEdge;
	Rew->NextGadget = Pause;
	Pause->NextGadget = NULL;
	Pause->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_PLAY);
	if (!(Play = AllocOneGadget(Gadget))) goto rErrExit;
	Play->LeftEdge = (ClipNW.Width>>1) + (2*Rew->Width);
	Play->TopEdge = Rew->TopEdge;
	Pause->NextGadget = Play;
	Play->NextGadget = NULL;
	Play->UserData = NULL;

	Gadget = FindGadget(&Gadget1,ID_VCR_FFWD);
	if (!(FFwd = AllocOneGadget(Gadget))) goto rErrExit;
	FFwd->LeftEdge = (ClipNW.Width>>1) +(3*Rew->Width);
	FFwd->TopEdge = Rew->TopEdge;
	Play->NextGadget = FFwd;
	FFwd->NextGadget = NULL;
	FFwd->UserData = NULL;

d1868 1
a1868 1
	FFwd->NextGadget = Clips;
d1878 1
a1878 1
			if(!(ClipDisp=InitClipDisplay(16,FFwd->TopEdge-FFwd->Height-32,Window->Width-32,32,Tmax,Window)))
d1927 9
a1935 33
		LastTime=NULL;
		if( LiveFlyer )
		{
			LastTime=InPL;
			HiTime = (OutPL->Param);
			LoTime = &InPL->PropStart;
			MyRCB->Frame = (ULONG)(*InPL->Param)<<1;
			MyRCB->Max = (*HiTime)<<1;
			MyRCB->Min = (*LoTime)<<1;
			MyRCB->FG = CurFG;
			MyRCB->win = Window;
			MyRCB->pline = LastTime;
			if(InPL->PropGadg && (FakeIn=AllocOneGadget(&CDisp)) )
			{
				A = RemoveGadget(Window,InPL->PropGadg);
				FakeIn->LeftEdge = InPL->PropGadg->LeftEdge;
				FakeIn->TopEdge = InPL->PropGadg->TopEdge;
				FakeIn->Width = InPL->PropGadg->Width;
				FakeIn->Height = InPL->PropGadg->Height;
				FakeIn->Activation |= GADGIMMEDIATE;
				FakeIn->UserData = InPL;
				FakeIn->GadgetID = ID_LR_KNOB;
				AddGadget(Window,FakeIn,A);
			}
			if(OutPL->PropGadg && (FakeOut=AllocOneGadget(FakeIn)) )
			{
				FakeOut->LeftEdge = OutPL->PropGadg->LeftEdge;
				FakeOut->TopEdge = OutPL->PropGadg->TopEdge;
				FakeOut->UserData = OutPL;
				A = RemoveGadget(Window,OutPL->PropGadg);
				AddGadget(Window,FakeOut,A);
			}
		}
a1962 1
							//else if(PLine==NULL)  // tick or move
a1967 9
					else switch(ID) // handle VCR Rec/Play button
					{
						case ID_VCR_FFWD:
						case ID_VCR_REW:
						case ID_VCR_PLAY:
						case ID_REQ_STOP:
						case ID_VCR_PAUSE:
						break;
					}
d1978 3
a1980 1
					if( LiveFlyer && (PLine->Flags&PL_FLYER) )
d1982 2
a1983 23
						ModifyIDCMP(Window,WinFlags); // turn off ticks
						MyRCB->pline = LastTime;
						if(MyRCB->pline->Flags&PL_IN)
						{
							MyRCB->Max = *(OutPL->Param) <<1;
							MyRCB->Min = (MyRCB->pline)->PropStart <<1;
						}
						else
						{
							MyRCB->Min = *(InPL->Param) <<1;
							MyRCB->Max = (MyRCB->pline)->PropEnd <<1;
						}
						DUMPUDECL("Hi Time:",MyRCB->Max,"     " );
						DUMPUDECL("Lo Time:",MyRCB->Min,"    \\" );
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param))<<1;
						if(Adder>0) MyRCB->Flags = 0;
						else  MyRCB->Flags = DHD_PLAY_REV;
//						DHD_Jog(MyRCB);
						DHD_Shuttle(MyRCB);
						EZGad=NULL;
						DrawClipDisplay(ClipDisp);
						UpdateAllDiff(RP,Start,Window);
						break;
a1984 5
					if( (Y=*(PLine->Param)) || (Adder>0))
						Y += Adder*EZJump(Ticks++);
					else break;
					if(Adder<0)
						*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
d1986 13
a1998 3
						*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
					UpdatePanProp(PLine,Window);
					UpdatePanStr(PLine,Window);
a2001 17

				case IDCMP_MOUSEMOVE:
					if (Down) {
//						DrawLRKnobRail(RP,Down);
						UpdateParam((struct PanelLine *)Down->UserData,Window);
					}
					break;

				case IDCMP_MOUSEBUTTONS:
					A = IntuiMsg->Code;
//					if( (A==IECODE_RBUTTON))
//						if(B=DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG))
//							*LastTime->Param=B;
					if (Down) Down = NULL;
					PLine = (struct PanelLine *)ThisG->UserData;
					break;

a2026 15
						case ID_VCR_REW:
						case ID_VCR_FFWD:
							Playing=FALSE;
//							DHD_Jump(0xc0edbabe);
							break;
						case ID_REQ_STOP:
							Playing=FALSE;
//							DHD_Abort(0);
							break;
						case ID_VCR_PLAY:
							Playing=TRUE;
							break;
						case ID_VCR_PAUSE:
							Playing=FALSE;
							break;
d2085 7
a2226 14
		if(FakeIn)
		{
			A = RemoveGadget(Window,FakeIn);
			AddGadget(Window,InPL->PropGadg,A);
			FakeIn->NextGadget=NULL;
			FreeGadgets(FakeIn);
		}
		if(FakeOut)
		{
			A = RemoveGadget(Window,FakeOut);
			AddGadget(Window,OutPL->PropGadg,A);
			FakeOut->NextGadget=NULL;
			FreeGadgets(FakeOut);
		}
a2232 1
	FFwd->NextGadget = NULL;
d2238 1
@


2.38
log
@Fixes to CroutonString, RMB Shuttle, update strings without an <enter>
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.37 94/09/12 18:52:12 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d814 1
a814 3
	{
		if(PLine->Create) Y1=PLine->Create(X1,H,PLine,&ThisG);
		if(PLine->Width>0)
d816 7
a822 12
			X1 = PNL_WIDTH;
			Y = Y1;
		}
		else
		{
			H += MAX(Y,Y1);
			X1 = 0;
			Y = 0;
		}
		if(PLine->Flags)
		{
			if(PLine->Flags&PL_IN)
d824 3
a826 2
				InPL=PLine;
				In=PLine->StrGadg;      // change In from *Gadget to *PLine
d828 1
a828 1
			else if(PLine->Flags&PL_OUT)
d830 16
a845 2
				OutPL=PLine;
				Out=PLine->StrGadg;
d847 1
a847 6
			else if(PLine->Flags&PL_DEL)
				Del=PLine->StrGadg;
			else if(PLine->Flags&PL_LEN)
				Len=PLine->StrGadg;
			if( (PLine->Flags&PL_FLYER) && InPL && OutPL)
				LiveFlyer = TRUE;
a848 2
		Lines++;
	}
d888 2
a889 1
		{
d892 5
a896 5
			SetAPen(RP,PAL_BLACK);
			Move(RP,0,H);
			Draw(RP,PNL_X1,H);
			Move(RP,PNL_WIDTH,H);
			Draw(RP,PNL_WIDTH-PNL_X1,H);
d898 13
a910 11
			if(PLine->Draw) Y1=PLine->Draw(X1,H,PLine,Window);
			if(PLine->Width>0)
			{
				X1 = PNL_WIDTH;
				Y = Y1;
			}
			else
			{
				H += MAX(Y,Y1);
				X1 = 0;
				Y = 0;
a911 2
			PLine++;
		}
@


2.37
log
@DHD_Shuttle On Now...  other coolish fixes..
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.36 94/09/12 13:03:05 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d804 1
d990 3
a992 13
						if(MyRCB->pline->Flags&PL_IN)
						{
							MyRCB->Max = *(OutPL->Param) <<1;
							MyRCB->Min = (MyRCB->pline)->PropStart <<1;
						}
						else
						{
							MyRCB->Min = *(InPL->Param) <<1;
							MyRCB->Max = (MyRCB->pline)->PropEnd <<1;
						}
						DUMPUDECL("Hi Time:",MyRCB->Max,"     " );
						DUMPUDECL("Lo Time:",MyRCB->Min,"    \\" );
						MyRCB->Frame = (ULONG)(*(MyRCB->pline->Param))<<1;
a994 1
//						DHD_Jog(MyRCB);
d1000 2
a1001 2
					if( (Y=*(PLine->Param)) || (Adder>0))
						Y += Adder*EZJump(Ticks++);
d1004 1
a1004 1
						*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
d1006 1
a1006 1
						*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
a1011 8
				case IDCMP_MOUSEMOVE:
					if( !EZGad ) break;
					Y=IntuiMsg->MouseX - EZGad->LeftEdge - (EZGad->Width>>1);
					DUMPSDECL("Move: ",Y,"\\");
					Y += *(PLine->Param);
 					*(PLine->Param) = (Y>PLine->PropStart ? (Y<PLine->PropEnd ? Y:PLine->PropEnd):PLine->PropStart);
					break;

d1015 3
a1017 2
					if( (A==IECODE_RBUTTON))
						if( PLine->Flags&PL_FLYER )
a1019 2
							MyRCB->Max = LastTime->PropEnd<<1;
							MyRCB->Min = LastTime->PropStart<<1;
d1021 2
d1025 2
d1028 2
a1029 2
						if(B=DHD_Shuttle(MyRCB))
//							*LastTime->Param=B;
a1030 1
//					PLine = (struct PanelLine *)ThisG->UserData;
d1040 1
a1040 1
					if(LastString)
d1184 16
a1204 1
//									*(LastTime->Param) = LastTime->PropStart;
d1212 20
a1231 2
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
d1327 2
a1328 7

// Velocity = (NormalStep+(SkipStep/FramesPerSkip))/FieldsPerFrame
// Also SkipStep=0 then shuttle is stopped, else Direction = sign(SkipStep)
	UWORD	FieldsPerFrame;	//never zero frame rate, usually 1, 2, 4, 8, 16 ...
	WORD	NormalStep;
	WORD	SkipStep;
	UWORD	FramesPerSkip;	//never zero
@


2.36
log
@Move all PLine member functions to PLine.c to allow compile/link to succeed
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.35 94/09/10 20:10:39 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d115 1
a115 1
//#define SERDEBUG	1
d364 1
a364 1
	out &=~1; // round up
d934 1
a934 1
									MyRCB->Flags = DHD_STR_UPDATE;
d939 1
a939 1
									MyRCB->Flags = 0;
d1001 2
a1002 2
						DHD_Jog(MyRCB);
//						DHD_Shuttle(MyRCB);
d1330 1
a1330 1
		*PLine->Param = EVEN(Call->Frame>>1); // even frame #s
d1345 1
a1345 1
		if(!(Call->Flags&DHD_STR_UPDATE))
@


2.35
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.34 94/09/09 20:49:39 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d112 1
a112 1
// #define SERDEBUG	1
a113 1
#define PANEL_TOP 44
d118 1
a118 1
extern struct StringExtend StrExt;
d156 1
a156 1
struct Gadget *FirstG=0,*Down=0,*EZGad=NULL,*In=NULL,*Out=NULL,*Del=NULL,*Len=NULL;
a158 2
//UBYTE GadIndex[]={0,0,0,0};
//UBYTE *GadIndex=(UBYTE *)&GadInd;
a159 1
char Size[20],Name[120],Dir[120];
a172 1
#define EVEN(x)  (x&0xFFFFFFFE)
d178 3
a180 1

a289 2
#define FRAME_QUANT	2
#define STILL_QUANT 2
a461 9

	if(a!=*L)
	{
		DUMPSTR("{FixTime}	Time Code: ");
		DUMPSTR(((struct StringInfo *)ThisG->SpecialInfo)->Buffer);
		DUMPUDECL(" Frames: ",*L," ");
		DUMPUDECL("Time (Secs/30):",a,"\\");
	}

a652 1
#define MIN_FIELD	0
a735 2289
//  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//	All PLine types have their Create(), Draw(), Handle(), Update(), and Destroy()
//	functions 'round here

UWORD	CreateTimePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	ULONG A;
  UWORD W =(PEZSLIDE_W + PTCSTRING_W + 6);
	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;
	if ((NewG = AllocOneGadget(&StringGadg)))
	{
		PLine->StrGadg = NewG;
		InstallTCHook(NewG);
		NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - W;
		if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
//		NewG->LeftEdge = X1 + PTIME_XOFF;
		NewG->TopEdge = H + PTIME_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->Width = PTCSTRING_W;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		LongToTime((ULONG *)PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->Buffer);
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))
	{
		PLine->PropGadg = NewG;
		NewG->LeftEdge = X1 + PNL_X1;
		NewG->TopEdge = H + PTIME_POFF + 2;
		NewG->Height = 16;
		NewG->Width = PNL_WIDTH - (PNL_X1<<1) ; // PTIME_W+40;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		A = *PLine->Param*MAXPOT;
		A /= PLine->PropEnd - PLine->PropStart;;
		((struct PropInfo *)NewG->SpecialInfo)->HorizPot = A&0xFFFF;
		((struct PropInfo *)NewG->SpecialInfo)->HorizBody = MAXPOT / 7;
		if(PLine->Flags&PL_FLYER)
		{
			A = 2*MAXPOT; // 1 colorFrame
			A /= PLine->PropEnd - PLine->PropStart;
			((struct PropInfo *)NewG->SpecialInfo)->HorizBody = A&0xFFFF; // move by colorframes
		}
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = PLine->StrGadg->LeftEdge+PLine->StrGadg->Width+6;
		NewG->TopEdge = PLine->StrGadg->TopEdge-5;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if(!(PLine->IncGadg && PLine->DecGadg && PLine->PropGadg))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->PropGadg) {
			PLine->PropGadg->NextGadget = NULL;
			FreeGadgets(PLine->PropGadg);
		}
		if (PLine->StrGadg) {
			PLine->StrGadg->NextGadget = NULL;
			FreeGadgets(PLine->StrGadg);
		}
		return(0);
	}
	return(PTIME_H);
}

void DestroyTimePL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

UWORD	DrawTimePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD  A=X1+PNL_X1,B;
	StringBorder(win->RPort,PLine->StrGadg);
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		if (PLine->Align == PNL_CENTER)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->LeftEdge-A-12,FALSE);
			A = (PLine->StrGadg->LeftEdge-12 - LastExtent.te_Width);
		}
		Move(win->RPort,A,H+PTIME_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	LoTime = &PLine->PropStart;
	HiTime = &PLine->PropEnd;
	UpdatePanProp(PLine,win); // init knob before display
	RefreshGList(PLine->StrGadg,win,NULL,4);
	InitLRKnobRail(win->RPort,PLine->PropGadg);
//	DrawLRKnobRail(win->RPort,PLine->PropGadg);
	return(PTIME_H);
}

BOOL	HandleTimePL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	ULONG	Y,A,jump=1;
	if( PLine->Flags&PL_FLYER )
	{
		jump=FRAME_QUANT;
		MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
		MyRCB->Max = (*HiTime)<<1;
		MyRCB->Min = (*LoTime)<<1;
		MyRCB->FG = CurFG;
		MyRCB->win = Window;
		MyRCB->pline = PLine;
		MyRCB->MouseX = IntuiMsg->MouseX;
		MyRCB->MouseY = IntuiMsg->MouseY;
	}
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
	{
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=ThisG; 		// global Down is used by IDCMP_MOUSEMOVE handler.
				if( PLine->Flags&PL_FLYER )
				{
					struct PropInfo *pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
					A=pi->HorizPot*(PLine->PropGadg->Width -
							((struct Image *)PLine->PropGadg->GadgetRender)->Width);
					A /= MAXPOT;
					A += PLine->PropGadg->LeftEdge;
					if(IntuiMsg->MouseX > A+ ((struct Image *)PLine->PropGadg->GadgetRender)->Width)
					{
						Y = *(PLine->Param);
						*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
						UpdatePanProp(PLine,Window);
						UpdatePanStr(PLine,Window);
					}
					else if(IntuiMsg->MouseX < A)
					{
						Y = *(PLine->Param);
						*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
						UpdatePanProp(PLine,Window);
						UpdatePanStr(PLine,Window);
					}
					else  // clicked right on knob
					{
						MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
						DHD_Jog(MyRCB);
					}
				}
				UpdateAllDiff(RP,Start,Window);
				break;
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;   // global EZGad is used by Intuitick handler.
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	}
	else // GADGET_UP
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=NULL;
				if( PLine->Flags&PL_FLYER ) break;
				UpdateParam(PLine,Window);
				BoundPanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)
				{
//					if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
					break;
				}
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
//				if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
				UpdatePanProp(PLine,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)
				{
//					if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
					break;
				}
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
//				if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
				UpdatePanProp(PLine,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case STRING_ID:
				FixTimeStr(PLine,Window,FALSE); // update long & flush bogus values
				UpdatePanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;
		}
	return(TRUE);
}



UWORD	CreateFlyTimePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG,
		FakeProp = { NULL,0,0,20,20,GFLG_GADGHNONE,RELVERIFY|GADGIMMEDIATE,BOOLGADGET,NULL,NULL,NULL,NULL,NULL,ID_LR_KNOB,NULL};
	ULONG A;
  UWORD W =(PEZSLIDE_W + PTCSTRING_W + 6);
	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;
	if ((NewG = AllocOneGadget(&StringGadg)))
	{
		PLine->StrGadg = NewG;
		InstallTCHook(NewG);
		NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - W;
		if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
		NewG->TopEdge = H + PTIME_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->Width = PTCSTRING_W;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		LongToTime((ULONG *)PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->Buffer);
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))
	{
		PLine->PropGadg = NewG;
		NewG->LeftEdge = X1 + PNL_X1;
		NewG->TopEdge = H + PTIME_POFF + 2;
		NewG->Height = 16;
		NewG->Width = PNL_WIDTH - (PNL_X1<<1) ; // PTIME_W+40;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		A = *PLine->Param*MAXPOT;
		A /= PLine->PropEnd - PLine->PropStart;;
		((struct PropInfo *)NewG->SpecialInfo)->HorizPot = 10 + A&0xFFFF;
		A = 2*MAXPOT; // 1 colorFrame
		A /= PLine->PropEnd - PLine->PropStart;
		((struct PropInfo *)NewG->SpecialInfo)->HorizBody = A&0xFFFF; // move by colorframes

		if ((NewG = AllocOneGadget(&FakeProp)))
		{
			PLine->G1 = NewG;
			NewG->LeftEdge = X1 + PNL_X1;
			NewG->TopEdge = H + PTIME_POFF + 2;
			NewG->Height = 16;
			NewG->Width = PNL_WIDTH - (PNL_X1<<1) ; // PTIME_W+40;
			NewG->UserData = PLine;
			NewG->NextGadget = NULL;
			(*ThisG)->NextGadget = NewG;
			*ThisG=NewG;
		}
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = PLine->StrGadg->LeftEdge+PLine->StrGadg->Width+6;
		NewG->TopEdge = PLine->StrGadg->TopEdge-5;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if(!(PLine->IncGadg && PLine->DecGadg && PLine->PropGadg && PLine->G1))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->G1) {
			PLine->G1->NextGadget = NULL;
			FreeGadgets(PLine->G1);
		}
		if (PLine->PropGadg) {
			PLine->PropGadg->NextGadget = NULL;
			FreeGadgets(PLine->PropGadg);
		}
		if (PLine->StrGadg) {
			PLine->StrGadg->NextGadget = NULL;
			FreeGadgets(PLine->StrGadg);
		}
		return(0);
	}
	return(PTIME_H);
}

void DestroyFlyTimePL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
	if (PLine->PropGadg) {
		PLine->PropGadg->NextGadget = NULL;
		FreeGadgets(PLine->PropGadg);
	}

}

UWORD	DrawFlyTimePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD  A=X1+PNL_X1,B;
	StringBorder(win->RPort,PLine->StrGadg);
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		if (PLine->Align == PNL_CENTER)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->LeftEdge-A-12,FALSE);
			A = (PLine->StrGadg->LeftEdge-12 - LastExtent.te_Width);
		}
		Move(win->RPort,A,H+PTIME_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	RefreshGList(PLine->StrGadg,win,NULL,4);
	InitLRKnobRail(win->RPort,PLine->PropGadg);
	UpdatePanProp(PLine,win); // init knob to display
	return(PTIME_H);
}

BOOL	HandleFlyTimePL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	struct PropInfo *pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
	ULONG	Y,A,jump=FRAME_QUANT;
	MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
	MyRCB->Max = (*HiTime)<<1;
	MyRCB->Min = (*LoTime)<<1;
	MyRCB->FG = CurFG;
	MyRCB->win = Window;
	MyRCB->pline = PLine;
	MyRCB->MouseX = IntuiMsg->MouseX;
	MyRCB->MouseY = IntuiMsg->MouseY;
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
	{
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=ThisG; 		// global Down is used by IDCMP_MOUSEMOVE handler.
				A=pi->HorizPot*(PLine->PropGadg->Width -
						((struct Image *)PLine->PropGadg->GadgetRender)->Width);
				A /= MAXPOT;
				A += PLine->PropGadg->LeftEdge;
				if(IntuiMsg->MouseX > A+ ((struct Image *)PLine->PropGadg->GadgetRender)->Width)
				{
					Y = *(PLine->Param);
					*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jump(MyRCB);
				}
				else if(IntuiMsg->MouseX < A)
				{
					Y = *(PLine->Param);
					*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jump(MyRCB);
				}
				else  // clicked right on knob
				{
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jog(MyRCB);
				}
				UpdateAllDiff(RP,Start,Window);
				break;
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;   // global EZGad is used by Intuitick handler.
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	}
	else // GADGET_UP
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=NULL;
				break;

			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)
					break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
				UpdatePanProp(PLine,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)
					break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
				UpdatePanProp(PLine,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case STRING_ID:
				FixTimeStr(PLine,Window,TRUE); // update long & flush bogus values
				MyRCB->Flags = DHD_STR_UPDATE;
				MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
				DHD_Jump(MyRCB);
				MyRCB->Flags = 0;
				UpdatePanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;
		}
	return(TRUE);
}

UWORD	CreateEZTimePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	UWORD W =(PEZSLIDE_W + PTCSTRING_W + 6);
	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;
	if ((NewG = AllocOneGadget(&StringGadg)))
	{
		PLine->StrGadg = NewG;
		InstallTCHook(NewG);
		NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - W;
		if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
		NewG->TopEdge = H + PIN_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->Width = PTCSTRING_W;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		LongToTime((ULONG *)PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->Buffer);
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width+6;
		NewG->TopEdge = (*ThisG)->TopEdge-5;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if(!(PLine->IncGadg && PLine->DecGadg))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->StrGadg) {
			PLine->StrGadg->NextGadget = NULL;
			FreeGadgets(PLine->StrGadg);
		}
		return(0);
	}
	return(PIN_H);
}

void DestroyEZTimePL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

UWORD	DrawEZTimePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD  A=X1+PNL_X1,B;
	StringBorder(win->RPort,PLine->StrGadg);
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		if (PLine->Align == PNL_CENTER)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->LeftEdge-A-12,FALSE);
			A = (PLine->StrGadg->LeftEdge-12 - LastExtent.te_Width);
		}
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	RefreshGList(PLine->StrGadg,win,NULL,3);
	return(PIN_H);
}

BOOL	HandleEZTimePL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	ULONG	Y ,jump=FRAME_QUANT;
//	char *ch;
	LastTime=PLine;
	if( PLine->Flags&PL_FLYER )
	{
		MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
		MyRCB->Max = (*HiTime)<<1;
		MyRCB->Min = (*LoTime)<<1;
		MyRCB->FG = CurFG;
		MyRCB->win = Window;
		MyRCB->pline = PLine;
	}
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
		switch(ID)
		{
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	else // GADGET_UP
		switch(ID)
		{

			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY) break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY) break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case STRING_ID:
//				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
//				L = PLine->Param;
//				TimeToLong(ch,(ULONG *)L);
//				UpdatePanStr(PLine,Window);
				if(PLine->Flags&PL_FLYER)
				{
					FixTimeStr(PLine,Window,TRUE);    // update long & flush bogus values
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jump(MyRCB);
				}
				else FixTimeStr(PLine,Window,FALSE);

				UpdateAllDiff(RP,Start,Window);
				break;
		}
	return(TRUE);
}

UWORD	CreateEZLenPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
  UWORD W =(PEZSLIDE_W + PLENSTRING_W + 6);
	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;

	if ((NewG = AllocOneGadget(&StringGadg)))
	{
		PLine->StrGadg = NewG;
		InstallTCHook(NewG);
//		NewG->LeftEdge = X1 + PTIME_XOFF + 12;
		NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - W;
		if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
		NewG->TopEdge = H + PIN_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->Width = PLENSTRING_W;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		LongToLen((ULONG *)PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->Buffer);
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width+6;
		NewG->TopEdge = (*ThisG)->TopEdge-5;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if(!(PLine->IncGadg && PLine->DecGadg))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->StrGadg) {
			PLine->StrGadg->NextGadget = NULL;
			FreeGadgets(PLine->StrGadg);
		}
		return(0);
	}
	return(PIN_H);
}

void DestroyEZLenPL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

// Could use Handle EZTime!!!
BOOL	HandleEZLenPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	ULONG	Y,*L;
	char *ch;
	LastTime=PLine;
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
		switch(ID)
		{
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	else // GADGET_UP
		switch(ID)
		{
			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if( (Ticks<=EZ_DELAY) && (Y = *(PLine->Param)) )
				{
					Y--;
					*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
				}
				if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks<=EZ_DELAY)
				{
					Y = *(PLine->Param) + 1;
					*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
				}
				if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case STRING_ID:
				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
				L = PLine->Param;
				TimeToLong(ch,(ULONG *)L); // update long & flush bogus values
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
/*
				if(temp=(struct PanelLine *)PLine->Param2)
					if(temp->Param2[3])
					{
						temp->Param2[3] = *L;
						*temp->Param = 3;
					}
*/
				break;
		}
	return(TRUE);
}

UWORD	CreateEZNumPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
  UWORD W =(PEZSLIDE_W + PLENSTRING_W + 6);

	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;
	StringGadg.Activation |= GACT_LONGINT;
	NewG = AllocOneGadget(&StringGadg);
	StringGadg.Activation &= ~GACT_LONGINT;
	if (NewG)
	{
		PLine->StrGadg = NewG;
		NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - W;
		if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
		NewG->TopEdge = H + PIN_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->Width = PNUMSTRING_W;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		((struct StringInfo *)NewG->SpecialInfo)->LongInt=*PLine->Param;
		stcl_d( ((struct StringInfo *)NewG->SpecialInfo)->Buffer,*PLine->Param);
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width+6;
		NewG->TopEdge = (*ThisG)->TopEdge-5;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if(!(PLine->IncGadg && PLine->DecGadg))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->StrGadg) {
			PLine->StrGadg->NextGadget = NULL;
			FreeGadgets(PLine->StrGadg);
		}
		return(0);
	}
	return(PIN_H);
}

void DestroyEZNumPL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

// Could use Handle EZTime!!!
BOOL	HandleEZNumPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	ULONG	Y,*L;
	char *ch;
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
		switch(ID)
		{
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	else // GADGET_UP
		switch(ID)
		{
			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if( (Ticks>EZ_DELAY) || !(Y = *(PLine->Param)) ) break;
				Y--;
				*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)  break;
				Y = *(PLine->Param) + 1;
				*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case STRING_ID:
				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
				L = PLine->Param;
				stcd_l(ch,(LONG *)L); // update long & flush bogus values
				if(*PLine->Param>PLine->PropEnd) *PLine->Param=PLine->PropEnd;
				if(*PLine->Param<PLine->PropStart) *PLine->Param=PLine->PropStart;
				UpdatePanStr(PLine,Window);
//				UpdateAllDiff(RP,Start,Window);
				break;
		}
	return(TRUE);
}

UWORD	CreateSliderPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	ULONG	A;
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))
	{
		PLine->PropGadg = NewG;
		NewG->LeftEdge = X1 + PNL_X1 ; //+32;
		NewG->TopEdge = H + PTEXT_H;
		NewG->Height = 16;
		NewG->Width = PNL_WIDTH - (PNL_X1<<1) - PEZSLIDE_W - 6 ; // PTIME_W+40;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		A = *PLine->Param*MAXPOT;
		A /= PLine->PropEnd - PLine->PropStart;;
		((struct PropInfo *)NewG->SpecialInfo)->HorizPot = A&0xFFFF;
		((struct PropInfo *)NewG->SpecialInfo)->HorizBody = MAXPOT / 7;
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width+6;
		NewG->TopEdge = (*ThisG)->TopEdge-2;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	if(!(PLine->IncGadg && PLine->DecGadg))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->PropGadg) {
			PLine->PropGadg->NextGadget = NULL;
			FreeGadgets(PLine->PropGadg);
		}
		return(0);
	}
	return(PSLIDE_H);
}

void DestroySliderPL(struct PanelLine *PLine)
{
	if (PLine->PropGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->PropGadg);
	}
}

UWORD	DrawSliderPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	if (PLine->Label)
	{
		Move(win->RPort,X1+PNL_X1,H+PTEXT_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,strlen(PLine->Label));
	}
	RefreshGList(PLine->PropGadg,win,NULL,3);
	InitLRKnobRail(win->RPort,PLine->PropGadg);
	return(PSLIDE_H);
}

BOOL	HandleSliderPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	ULONG	Y,jump=1;

	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=ThisG; 		// global Down is used by IDCMP_MOUSEMOVE handler.
				UpdateAllDiff(RP,Start,Window);
				break;
			case ID_LEFT:
				Y = *(PLine->Param);
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
				UpdatePanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;
			case ID_RIGHT:
				Y = *(PLine->Param);
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
				UpdatePanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	else // GADGET_UP
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=NULL;
				if( PLine->Flags&PL_FLYER ) break;
				UpdateParam(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)  break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
				UpdatePanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)  break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
				UpdatePanProp(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;
		}
	return(TRUE);
}

UWORD	CreateFlySliderPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG,
		FakeProp = { NULL,0,0,20,20,GFLG_GADGHNONE,RELVERIFY|GADGIMMEDIATE,BOOLGADGET,NULL,NULL,NULL,NULL,NULL,ID_LR_KNOB,NULL};
	ULONG A;
  UWORD W =(PEZSLIDE_W + PTCSTRING_W + 6);
	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))
	{
		PLine->PropGadg = NewG;
		NewG->LeftEdge = X1 + PNL_X1;
		NewG->TopEdge = H + PTEXT_H ;
		NewG->Height = 16;
		NewG->Width = PNL_WIDTH - (PNL_X1<<1) - PEZSLIDE_W - 6 ; // PTIME_W+40;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		A = *PLine->Param*MAXPOT;
		A /= PLine->PropEnd - PLine->PropStart;;
		((struct PropInfo *)NewG->SpecialInfo)->HorizPot = 10 + A&0xFFFF;
		A = 2*MAXPOT; // 1 colorFrame
		A /= PLine->PropEnd - PLine->PropStart;
		((struct PropInfo *)NewG->SpecialInfo)->HorizBody = A&0xFFFF; // move by colorframes

		if ((NewG = AllocOneGadget(&FakeProp)))
		{
			PLine->G1 = NewG;
			NewG->LeftEdge =	PLine->PropGadg->LeftEdge;
			NewG->TopEdge =		PLine->PropGadg->TopEdge;
			NewG->Height =		PLine->PropGadg->Height;
			NewG->Width =			PLine->PropGadg->Width;
			NewG->UserData = PLine;
			NewG->NextGadget = NULL;
			if(*ThisG) (*ThisG)->NextGadget = NewG;
			else if(!FirstG) FirstG=NewG;
			*ThisG=NewG;
		}
	} else return(0);

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_L))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width+6;
		NewG->TopEdge = (*ThisG)->TopEdge-2;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_EZ_SLIDE_R))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}

	if(!(PLine->IncGadg && PLine->DecGadg && PLine->PropGadg && PLine->G1))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->G1) {
			PLine->G1->NextGadget = NULL;
			FreeGadgets(PLine->G1);
		}
		if (PLine->PropGadg) {
			PLine->PropGadg->NextGadget = NULL;
			FreeGadgets(PLine->PropGadg);
		}
		return(0);
	}
	return(PSLIDE_H);
}

void DestroyFlySliderPL(struct PanelLine *PLine)
{
	if (PLine->G1)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->G1);
	}
	if (PLine->PropGadg) {
		PLine->PropGadg->NextGadget = NULL;
		FreeGadgets(PLine->PropGadg);
	}
}

UWORD	DrawFlySliderPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	if (PLine->Label)
	{
		Move(win->RPort,X1+PNL_X1,H+PTEXT_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,strlen(PLine->Label));
	}
	InitLRKnobRail(win->RPort,PLine->PropGadg);
	RefreshGList(PLine->PropGadg,win,NULL,1);
	return(PSLIDE_H);
}

BOOL	HandleFlySliderPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	UWORD	ID = ThisG->GadgetID;
	struct RastPort *RP=Window->RPort;
	struct PropInfo *pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
	ULONG	Y,A,jump=FRAME_QUANT;
	MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
	MyRCB->Max = (*HiTime)<<1;
	MyRCB->Min = (*LoTime)<<1;
	MyRCB->FG = CurFG;
	MyRCB->win = Window;
	MyRCB->pline = PLine;
	MyRCB->MouseX = IntuiMsg->MouseX;
	MyRCB->MouseY = IntuiMsg->MouseY;
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
	{
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=ThisG; 		// global Down is used by IDCMP_MOUSEMOVE handler.
				A=pi->HorizPot*(PLine->PropGadg->Width -
						((struct Image *)PLine->PropGadg->GadgetRender)->Width);
				A /= MAXPOT;
				A += PLine->PropGadg->LeftEdge;
				if(IntuiMsg->MouseX > A+ ((struct Image *)PLine->PropGadg->GadgetRender)->Width)
				{
					Y = *(PLine->Param);
					*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jump(MyRCB);
				}
				else if(IntuiMsg->MouseX < A)
				{
					Y = *(PLine->Param);
					*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jump(MyRCB);
				}
				else  // clicked right on knob
				{
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jog(MyRCB);
				}
				UpdateAllDiff(RP,Start,Window);
				break;
			case ID_EZ_SLIDE_L:
				EZGad=ThisG;   // global EZGad is used by Intuitick handler.
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder= -1;
				break;
			case ID_EZ_SLIDE_R:
				EZGad=ThisG;
				WinFlags=Window->IDCMPFlags;
				ModifyIDCMP(Window,WinFlags|IDCMP_INTUITICKS);
				Ticks=0;
				Adder=1;
				break;
		}
	}
	else // GADGET_UP
		switch(ID)
		{
			case ID_LR_KNOB:
				Down=NULL;
				break;

			case ID_EZ_SLIDE_L:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)
					break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
				UpdatePanProp(PLine,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;

			case ID_EZ_SLIDE_R:
				EZGad=NULL;
				if(WinFlags) ModifyIDCMP(Window,WinFlags);
				if(Ticks>EZ_DELAY)
					break;
				Y = *(PLine->Param) ;
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
				UpdatePanProp(PLine,Window);
				UpdatePanStr(PLine,Window);
				UpdateAllDiff(RP,Start,Window);
				break;
		}
	return(TRUE);
}

UWORD	CreateEZSliderPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	ULONG	A;
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))
	{
		PLine->PropGadg = NewG;
		NewG->LeftEdge = X1 + PNL_X1 +16;
		NewG->TopEdge = H + PIN_YOFF;
		NewG->Height = 16;
		NewG->Width = PNL_WIDTH - (PNL_X1<<1) - 32 - 6 ; // PTIME_W+40;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		A = *PLine->Param*MAXPOT;
		A /= PLine->PropEnd - PLine->PropStart;;
		((struct PropInfo *)NewG->SpecialInfo)->HorizPot = A&0xFFFF;
		((struct PropInfo *)NewG->SpecialInfo)->HorizBody = MAXPOT / 7;
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	return(PSLIDE_H);
}

void DestroyEZSliderPL(struct PanelLine *PLine)
{
	if (PLine->PropGadg)
	{
		PLine->PropGadg->NextGadget = NULL;
		FreeGadgets(PLine->PropGadg);
	}
}

UWORD	DrawEZSliderPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	char **labs,*L,*R;
	WORD X=PLine->PropGadg->LeftEdge,LX,B=strlen(PLine->Label);
	if (PLine->Label)
	{
		SafeFitText(win->RPort,PLine->Label,12,PNL_WIDTH-32,FALSE);
		LX = LastExtent.te_Width;
		Move(win->RPort,X1+PNL_X1,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,MIN(12,B));
	}
	RefreshGList(PLine->PropGadg,win,NULL,1);
	InitLRKnobRail(win->RPort,PLine->PropGadg);
	if( (labs=(char **)PLine->Param2) && *(L=labs[0]) && *(R=labs[1]) )
	{
		Move(win->RPort,X - 16,PLine->PropGadg->TopEdge +4+ TEXT_BASE-1);
		SafeColorText(win->RPort,L,1);
		Move(win->RPort,X +PLine->PropGadg->Width + 6,PLine->PropGadg->TopEdge +4+ TEXT_BASE-1);
		SafeColorText(win->RPort,R,1);
		X += (PLine->PropGadg->Width>>1);
		SetAPen(win->RPort,PAL_LGRAY);
		Move(win->RPort,X+1,PLine->PropGadg->TopEdge-2);
		Draw(win->RPort,X+1,PLine->PropGadg->TopEdge-10);
		SetAPen(win->RPort,PAL_LBLACK);
		Move(win->RPort,X-1,PLine->PropGadg->TopEdge-2);
		Draw(win->RPort,X-1,PLine->PropGadg->TopEdge-10);
		Draw(win->RPort,X,PLine->PropGadg->TopEdge-10);
	}
	return(PSLIDE_H);
}

BOOL	HandleEZSliderPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	struct RastPort *RP=Window->RPort;
	ULONG	Y,A,jump=1;
	if( PLine->Flags&PL_FLYER )
	{
		jump=FRAME_QUANT;
		MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
		MyRCB->Max = (*HiTime)<<1;
		MyRCB->Min = (*LoTime)<<1;
		MyRCB->FG = CurFG;
		MyRCB->win = Window;
		MyRCB->pline = PLine;
		MyRCB->MouseX = IntuiMsg->MouseX;
		MyRCB->MouseY = IntuiMsg->MouseY;

	}
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
	{
		Down=ThisG; 		// global Down is used by IDCMP_MOUSEMOVE handler.
		if( PLine->Flags&PL_FLYER )
		{
			struct PropInfo *pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
			A=pi->HorizPot*(PLine->PropGadg->Width -
					((struct Image *)PLine->PropGadg->GadgetRender)->Width);
			A /= MAXPOT;
			A += PLine->PropGadg->LeftEdge;

			if(IntuiMsg->MouseX > A+ ((struct Image *)PLine->PropGadg->GadgetRender)->Width)
			{
				Y = *(PLine->Param);
				*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
				UpdatePanProp(PLine,Window);
			}
			else if(IntuiMsg->MouseX < A)
			{
				Y = *(PLine->Param);
				*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
				UpdatePanProp(PLine,Window);
			}
			else  // clicked right on knob
			{
				MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
				DHD_Jog(MyRCB);
			}
		}
		UpdateAllDiff(RP,Start,Window);
	}
	else // GADGET_UP
	{
		Down=NULL;
		if( !PLine->Flags&PL_FLYER )
		{
			UpdateParam(PLine,Window);
			UpdateAllDiff(RP,Start,Window);
		}
	}
	return(TRUE);
}

UWORD	CreateStringPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	UWORD W=PNL_WIDTH;
//	if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
	H += 4;
	if (!(NewG = AllocOneGadget(&StringGadg))) return(0);
	PLine->StrGadg = NewG;
	NewG->Width=100;
//	if(PLine->PropStart) NewG->Width= W - (PNL_X1<<1) -80;
	NewG->LeftEdge = X1 +  W - PNL_X1 - NewG->Width -80;
	if( (PLine->Align==PNL_CENTER) && (100<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
//	NewG->LeftEdge = X1 + (PNL_WIDTH-NewG->Width)>>1;  //(PNL_WIDTH-NewG->Width)>>1;
	NewG->TopEdge =H+PIN_YOFF - 5;
	NewG->UserData = PLine;
	NewG->NextGadget = NULL;
	strncpy( ((struct StringInfo *)NewG->SpecialInfo)->Buffer,(char *)PLine->Param,MAX_STRING_BUFFER);
	AddPanelG(&FirstG,ThisG,&NewG);
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	return(PIN_H);
//	return(PTEXT_H + 4);
}

void DestroyStringPL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->StrGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

UWORD	DrawStringPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD  A=X1+PNL_X1,B,W=PNL_WIDTH;

//	if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		if (PLine->Align == PNL_CENTER)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->LeftEdge-A-12,FALSE);
			A = (PLine->StrGadg->LeftEdge-12 - LastExtent.te_Width);
		}
//		if(PLine->PropStart)
//		{
//			B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->Width-100,FALSE);
//			PLine->StrGadg->Width -= LastExtent.te_Width +4 ;
//			PLine->StrGadg->LeftEdge += LastExtent.te_Width +4 ;
//		}
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-2);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	StringBorder(win->RPort,PLine->StrGadg);
	RefreshGList(PLine->StrGadg,win,NULL,1);
	return(PIN_H);
//	return(PTEXT_H + 4);
}

BOOL	HandleStringPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	if( (IntuiMsg->Class==IDCMP_GADGETUP) && (ThisG->GadgetID==STRING_ID) )
		strncpy((char *)PLine->Param,((struct StringInfo *)ThisG->SpecialInfo)->Buffer,(int)PLine->Param2);
	return(TRUE);
}

UWORD	CreateChoicePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	UWORD	A=4,B,ID=ID_1,ERROR=0;
	struct Gadget *NewG,**PPGadg;
	PPGadg = &PLine->G1;
	if(PLine->Type==PNL_CHOICE5) A=5;
	for (B=0;B<A;B++)
	{
		if ((A == 5) && (B == 3)) ID++;
		if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID))))
		{
			ERROR=1;
			*PPGadg = NULL;
			break;
		}
		*PPGadg = NewG; // fill in G1..G(A)
		PPGadg++;
		NewG->LeftEdge = ((PNL_WIDTH - (A*40)) >> 1)
			+ (B*40); // hard code - last one is 41 wide
		NewG->TopEdge = H + PCHOICE_YOFF;
		NewG->UserData = PLine;
		NewG->Activation = GACT_IMMEDIATE+GACT_TOGGLESELECT;
		if (B == *(PLine->Param)) NewG->Flags |= GFLG_SELECTED;
		AddPanelG(&FirstG,ThisG,&NewG);
		ID++;
	}
	if(ERROR)
	{
		PPGadg = &PLine->G1;
		while( (NewG=*PPGadg++) )
		{
			NewG->NextGadget=NULL;
			FreeGadgets(NewG);
		}
		return(0);
	}
	return(PCHOICE_H);
}

void DestroyChoicePL(struct PanelLine *PLine)
{
	struct Gadget *NewG,**PPGadg;
	UWORD A=( (PLine->Type==PNL_CHOICE5) ? 5:4 );
	PPGadg = &PLine->G1;
	while( (NewG=*PPGadg++) && A-- )
	{
		NewG->NextGadget=NULL;
		FreeGadgets(NewG);
	}
}

UWORD	DrawChoicePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD	A=4;
	if(PLine->Type==PNL_CHOICE5) A=5;
	if (PLine->Label)
	{
		Move(win->RPort,PNL_X1,H+PCHOICE_TOFF+TEXT_BASE);
		SafeColorText(win->RPort,PLine->Label,strlen(PLine->Label));
	}
	RefreshGList(PLine->G1,win,NULL,A);
	return(PCHOICE_H);
}


BOOL	HandleChoicePL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress, **PPGadg;
	UWORD	ID = ThisG->GadgetID,A,N=((PLine->Type==PNL_CHOICE5) ? 5:4);
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
	{
		PPGadg = &PLine->G1;
		for (A=0;A<N;A++)
		{
			if (*PPGadg) (*PPGadg)->Flags &= (~GFLG_SELECTED);
			if (*PPGadg == ThisG) ID=A;
			PPGadg++;
		}
		ThisG->Flags |= GFLG_SELECTED;
		A = ID;
//		if ((PLine->Type == PNL_CHOICE5) && (A >= ID_4)) A--;
		*(PLine->Param) = A;
		RefreshGList(PLine->G1,Window,0,N);
	}
	return(TRUE);
}

UWORD	CreateNumberPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	UWORD W=64;
	H += 4;
	StringGadg.Activation |= GACT_LONGINT;
	NewG = AllocOneGadget(&StringGadg);
	StringGadg.Activation &= ~GACT_LONGINT;
	if (!(NewG))  return(0);
	PLine->StrGadg = NewG;
	NewG->Width=W;
	NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - W;
	if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
			NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
	//NewG->LeftEdge = X1 + (PNL_WIDTH-NewG->Width)>>1;  //(PNL_WIDTH-NewG->Width)>>1;
	NewG->TopEdge =H+PIN_YOFF - 5;
	NewG->UserData = PLine;
	NewG->NextGadget = NULL;
	((struct StringInfo *)NewG->SpecialInfo)->LongInt=*PLine->Param;
	stcl_d( ((struct StringInfo *)NewG->SpecialInfo)->Buffer,*PLine->Param);
	AddPanelG(&FirstG,ThisG,&NewG);
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	return(PIN_H);
//	return(PTEXT_H + 4);
}

void DestroyNumberPL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->StrGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

UWORD	CreatePopupPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
  UWORD W =PPOPUP_W;

	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;
	if (!(NewG = AllocOneGadget( FindGadget(&Gadget1,ID_POPUP_DISP)  ))) return(0);
	PLine->G1 = NewG;
	CurPLine=PLine;
	NewG->LeftEdge = X1 +  PNL_WIDTH - W;
	if( (PLine->Align==PNL_CENTER) && (W<(PNL_WIDTH-PNL_X1)>>1) )
		NewG->LeftEdge = X1 + ((PNL_WIDTH-PNL_X1) >>1);
//	NewG->LeftEdge = X1 + (PNL_WIDTH-NewG->Width)>>1;
	NewG->TopEdge =H + PIN_YOFF - 5;
	NewG->UserData = PLine;
	NewG->NextGadget = NULL;
	AddPanelG(&FirstG,ThisG,&NewG);
	return(PIN_H);
}

void DestroyPopupPL(struct PanelLine *PLine)
{
	if (PLine->G1)
	{
		PLine->G1->NextGadget = NULL;
		FreeGadgets(PLine->G1);
	}
}

UWORD	DrawPopupPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD  A=X1+PNL_X1,B;
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->LeftEdge-A-12,FALSE);
//if(PLine->Align==PNL_CENTER)		A = (PLine->StrGadg->LeftEdge-12 - LastExtent.te_Width);
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	CurPLine=PLine;
	RedrawPopText(win);
	SetFont(win->RPort,DarkFont);
	return(PIN_H);
}

BOOL	HandlePopupPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	if( (IntuiMsg->Class ==  IDCMP_GADGETDOWN) && (ThisG->GadgetID==ID_POPUP_DISP) )
		HandlePopUp(Window,IntuiMsg,PLine);
	return(TRUE);
}

UWORD	CreateTextPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	if (PLine->Label && *PLine->Label) return( PIN_H );
	return(0);
}

UWORD	DrawTextPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD A,B,W=PNL_WIDTH;
	if (PLine->Label && *PLine->Label)
	{
		if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
		B = strlen(PLine->Label);
		if (PLine->Align == PNL_LEFT) A = PNL_X1 + X1;
		else if (PLine->Align == PNL_CENTER)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,W,FALSE);
			A = (W - LastExtent.te_Width) >> 1;
		}
		else if (PLine->Align == PNL_RIGHT)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,W,FALSE);
			A = W - LastExtent.te_Width;
		}
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
		return(PIN_H);
	}
	return(0);
}

UWORD	CreateTogglePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	UWORD A=0,D,ERROR=0,W=PNL_WIDTH;
	struct Gadget *NewG,**PPGadg;

	PPGadg = &PLine->G1;
	if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
	if(PLine->Width>0) PLine->Width = W;
	else  PLine->Width = -W;
	if (!(NewG = AllocOneGadget( FindGadget(&Gadget1,ID_BOOL)  ))) return(0);
	PLine->G1 = NewG;
	if(PLine->PropEnd>0) D=(W/(PLine->PropEnd)) ;
	else D=(W>>1) ;
	NewG->LeftEdge = X1 + A + D - (NewG->Width>>1);
	NewG->TopEdge =H - ((NewG->Height - TEXT_BASE + 1)>>1) + PIN_YOFF;
	NewG->UserData = PLine;
	NewG->NextGadget = NULL;
	NewG->GadgetID = 1; // ID_TOG1;

	if(!(((long)PLine->Param)&0x00000001)) NewG->Flags &= (~GFLG_SELECTED);
	else NewG->Flags |= GFLG_SELECTED;
	AddPanelG(&FirstG,ThisG,&NewG);

	if(PLine->PropEnd<=1) return(PIN_H);
	if ((NewG = AllocOneGadget( NewG )))
	{
		PLine->G2 = NewG;
		NewG->LeftEdge += D;
		NewG->GadgetID = 2; //ID_TOG2;
		NewG->NextGadget = NULL;
		if(!(((long)PLine->Param)&0x00000002)) NewG->Flags &= (~GFLG_SELECTED);
		else NewG->Flags |= GFLG_SELECTED;
		AddPanelG(&FirstG,ThisG,&NewG);
	} else ERROR=1;

	if( !ERROR && (PLine->PropEnd<=2)) return(PIN_H);
	if ( (ERROR==0) && (NewG=AllocOneGadget( NewG )) )
	{
		PLine->G3 = NewG;
		NewG->LeftEdge += D;
		NewG->GadgetID = 4; //ID_TOG3;
		NewG->NextGadget = NULL;
		if(!(((long)PLine->Param)&0x00000004)) NewG->Flags &= (~GFLG_SELECTED);
		else NewG->Flags |= GFLG_SELECTED;
		AddPanelG(&FirstG,ThisG,&NewG);
	} else ERROR=1;

	if( !ERROR && (PLine->PropEnd<=3)) return(PIN_H);
	if ( (ERROR==0) && (NewG=AllocOneGadget( NewG )) )
	{
		PLine->G4 = NewG;
		NewG->LeftEdge += D;
		NewG->GadgetID = 8; //ID_TOG4;
		NewG->NextGadget = NULL;
		if(!(((long)PLine->Param)&0x00000008)) NewG->Flags &= (~GFLG_SELECTED);
		else NewG->Flags |= GFLG_SELECTED;
		AddPanelG(&FirstG,ThisG,&NewG);
	} else ERROR=1;

	if( !ERROR && (PLine->PropEnd<=4)) return(PIN_H);
	if ( (ERROR==0) && (NewG=AllocOneGadget( NewG )) )
	{
		PLine->G5 = NewG;
		PLine->PropEnd=5;
		NewG->LeftEdge += D;
		NewG->GadgetID = 16; //ID_TOG5;
		NewG->NextGadget = NULL;
		if(!(((long)PLine->Param)&0x00000010)) NewG->Flags &= (~GFLG_SELECTED);
		else NewG->Flags |= GFLG_SELECTED;
		AddPanelG(&FirstG,ThisG,&NewG);
	} else ERROR=1;

	if (ERROR && PLine->G1)
	{
		PLine->G5->NextGadget = NULL;
		FreeGadgets(PLine->G1);
	}

	return(PIN_H);
}

void DestroyTogglePL(struct PanelLine *PLine)
{
	struct Gadget *NewG,**PPGadg;
	PPGadg = &PLine->G1;
	NewG=PPGadg[PLine->PropEnd - 1];
	NewG->NextGadget=NULL;
	FreeGadgets(PPGadg[0]);
}

UWORD	DrawTogglePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD A=PNL_X1,B,C,D=PNL_WIDTH>>1,X=X1,Y=H + PIN_YOFF + 6,SW=0,W=PNL_WIDTH,i=PLine->PropEnd;
	int n=1;
	char **msg;
	struct Gadget **PPGadg;
	if(Wide && (PLine->Width<=0) ) W=PNL_WIDTH<<1;
	if (PLine->Label)
	{
		B = strlen(PLine->Label);
		SafeFitText(win->RPort,PLine->Label,B,W,FALSE);
		SW = LastExtent.te_Width;
		Y = H + PIN_YOFF + ((LastExtent.te_Extent.MaxY - LastExtent.te_Extent.MinY)>>1);
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	PPGadg = &PLine->G1;
	if (PLine->Align == PNL_LEFT)
	{
		X=W - (PLine->G1->Width) - PNL_X1;
		if(PLine->PropEnd>0) D=( ((W-SW)/(PLine->PropEnd)) ) ;
		n=-1;
	}
	else
	{
		if(PLine->PropEnd>1)
		{
			D=( ((W-SW)/(PLine->PropEnd+1)) ) ;
			X=A + SW + D - (PLine->G1->Width>>1);
		}
		else
			X = A + ((W - SW - PLine->G1->Width)>>1) + 6;
	}
	if(msg=(char **)PLine->Param2)
		while(*msg && *PPGadg && i )
		{
			B = strlen(*msg);
			C = SafeFitText(win->RPort,*msg,B,D-2,FALSE);
			if(Y==0) Y = H + PIN_YOFF + ((LastExtent.te_Extent.MaxY - LastExtent.te_Extent.MinY)>>1);
			(*PPGadg)->LeftEdge = X;
			(*PPGadg)->TopEdge = Y - ((*PPGadg)->Height>>1);
			A = X - LastExtent.te_Width;
			Move(win->RPort,A-2,H+PIN_YOFF+TEXT_BASE-1);
			SafeColorText(win->RPort,*msg,C);
			msg++;
			PPGadg++;
			i--;
			X+=n*D;
		}
	RefreshGList(PLine->G1,win,0,PLine->PropEnd);
	return(PIN_H);
}

BOOL	HandleTogglePL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	ULONG	Y,T;
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	if( (IntuiMsg->Class==IDCMP_GADGETUP) )
	{
		Y=(ULONG)PLine->Param;
		T=ThisG->GadgetID;
		PLine->Param = (long *) ( Y&T ? (Y&~T) : (Y|T) ); // invert value...
	}
	return(TRUE);
}

UWORD	CreateVCRPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;

	if ((NewG = AllocOneGadget(&StringGadg)))
	{
		PLine->StrGadg = NewG;
		InstallTCHook(NewG);
		NewG->LeftEdge = X1 + PTIME_XOFF;
		NewG->TopEdge = H + PTIME_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->Width = PTCSTRING_W;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		LongToTime((ULONG *)PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->Buffer);
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_VCR_REW))))
	{
		PLine->DecGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width+6;
		NewG->TopEdge = (*ThisG)->TopEdge - 5;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_VCR_PAUSE))))
	{
		PLine->G1 = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_VCR_PLAY))))
	{
		PLine->G2 = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_VCR_FFWD))))
	{
		PLine->IncGadg = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	if(!(PLine->IncGadg && PLine->DecGadg && PLine->G1 && PLine->G2))
	{
		if (PLine->IncGadg) {
			PLine->IncGadg->NextGadget = NULL;
			FreeGadgets(PLine->IncGadg);
		}
		if (PLine->DecGadg) {
			PLine->DecGadg->NextGadget = NULL;
			FreeGadgets(PLine->DecGadg);
		}
		if (PLine->G1) {
			PLine->G1->NextGadget = NULL;
			FreeGadgets(PLine->G1);
		}
		if (PLine->G2) {
			PLine->G2->NextGadget = NULL;
			FreeGadgets(PLine->G2);
		}
		if (PLine->StrGadg) {
			PLine->StrGadg->NextGadget = NULL;
			FreeGadgets(PLine->StrGadg);
		}
		return(0);
	}
	return(PIN_H);
}

UWORD	DrawVCRPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	StringBorder(win->RPort,PLine->StrGadg);
	RefreshGList(PLine->StrGadg,win,0,5);
	return(PIN_H);
}


void DestroyVCRPL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->IncGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

UWORD	CreatePlayPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;

	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_VCR_PLAY))))
	{
		PLine->G1 = NewG;
		NewG->LeftEdge = X1 + PTIME_XOFF;
		NewG->TopEdge = H + PTIME_YOFF;
		NewG->Height = TEXT_HEIGHT;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		if(*ThisG) (*ThisG)->NextGadget = NewG;
		else if(!FirstG) FirstG=NewG;
		*ThisG=NewG;
  } else  return(0);
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_REQ_STOP))))
	{
		PLine->G2 = NewG;
		NewG->LeftEdge = (*ThisG)->LeftEdge+(*ThisG)->Width;
		NewG->TopEdge = (*ThisG)->TopEdge;
		NewG->UserData = PLine;
		NewG->NextGadget = NULL;
		(*ThisG)->NextGadget = NewG;
		*ThisG=NewG;
	}
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	if(!PLine->G2)
	{
		if (PLine->G1) {
			PLine->G1->NextGadget = NULL;
			FreeGadgets(PLine->G1);
		}
		return(0);
	}
	return(PIN_H);
}

UWORD	DrawPlayPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	RefreshGList(PLine->G1,win,0,2);
	return(PIN_H);
}


void DestroyPlayPL(struct PanelLine *PLine)
{
	if (PLine->G1)
	{
		PLine->G2->NextGadget = NULL;
		FreeGadgets(PLine->G1);
	}
}


UWORD	CreateFXSpeedPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG, **PPGadg;
	UWORD B,A=4,ID= ID_S;
	PPGadg = &PLine->G1;
	for (B=0;B<A;B++)
	{
		if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID))))
		{
			*PPGadg = NewG; // fill in G1..G(A)
			PPGadg++;
//			NewG->LeftEdge = ((PNL_WIDTH - (A*40)) >> 1) + (B*40) ; // hard code - last one is 41 wide
			NewG->LeftEdge = PNL_WIDTH - PNL_X1 - (A*40)  + (B*40) ; // hard code - last one is 41 wide
			NewG->TopEdge = H+PIN_YOFF - 5 ; //+ PCHOICE_YOFF;
			NewG->Activation = GACT_IMMEDIATE+GACT_TOGGLESELECT;
			NewG->UserData = PLine;
			NewG->NextGadget = NULL;
			if ((PLine->Param2)[B]==0) NewG->Flags |= GFLG_DISABLED;
			else if (B == *(PLine->Param)) NewG->Flags |= GFLG_SELECTED;

			if(*ThisG) (*ThisG)->NextGadget = NewG;
			else if(!FirstG) FirstG=NewG;
			*ThisG=NewG;
			ID++;
		}
		else
		{
			PPGadg=NULL;
			break;
		}
	}
	if(!PPGadg)
	{
		PPGadg = &PLine->G1;
		while(*PPGadg)
		{
			(*PPGadg)->NextGadget = NULL;
			FreeGadgets(*PPGadg);
		}
		return(0);
	}
	return(PIN_H); //+ PCHOICE_YOFF;
}

void DestroyFXSpeedPL(struct PanelLine *PLine)
{
	(PLine->G4)->NextGadget=NULL;
	FreeGadgets(PLine->G1);
}

UWORD	DrawFXSpeedPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	if (PLine->Label)
	{
		Move(win->RPort,PNL_X1,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,strlen(PLine->Label));
	}
	RefreshGList(PLine->G1,win,0,4);
	return(PIN_H);
}

BOOL	HandleFXSpeedPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress, **PPGadg;
	UWORD	ID = ThisG->GadgetID,A;
	struct PanelLine *temp;
	if(IntuiMsg->Class ==  IDCMP_GADGETDOWN)
	{
		PPGadg = &PLine->G1;
		for (A=0;A<4;A++)
		{
			if (*PPGadg) (*PPGadg)->Flags &= (~GFLG_SELECTED);
			PPGadg++;
		}
		ThisG->Flags |= GFLG_SELECTED;
		A = ID - ID_S ;
		*(PLine->Param) = A;
		if(temp=(struct PanelLine *)PLine->PropStart)
		{
			*temp->Param=PLine->Param2[A];
			if(temp->PropGadg) UpdatePanProp(temp,Window);
			if(temp->StrGadg) UpdatePanStr(temp,Window);
		}
		else UpdateFXTime(Window->RPort,Start,PLine->Param2[A],Window);
		RefreshGList(PLine->G1,Window,0,4);
	}
	return(TRUE);
}

UWORD	CreateInOutPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	UWORD ID=ID_IN_TYPE;
	if(PLine->Type == PNL_OUT_TYPE) ID = ID_OUT_TYPE;
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID))))
	{
		PLine->G1 = NewG;
		NewG->LeftEdge = X1 + ((PNL_WIDTH - NewG->Width) >> 1);
		NewG->TopEdge = H + PIN_YOFF;
		NewG->UserData = PLine;
		if (*(PLine->Param)==1) NewG->Flags |= GFLG_SELECTED;
		else NewG->Flags &= (~GFLG_SELECTED);
		AddPanelG(&FirstG,ThisG,&NewG);
		if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
		else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
		return( PIN_H );
	}
}

void DestroyInOutPL(struct PanelLine *PLine)
{
	PLine->G1->NextGadget = NULL;
	FreeGadgets(PLine->G1);
}

UWORD	DrawInOutPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD A=X1+PNL_X1,B;
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		B = SafeFitText(win->RPort,PLine->Label,B,PLine->G1->LeftEdge-A-12,FALSE);
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	RefreshGList(PLine->G1,win,0,1);
	return( PIN_H );
}

UWORD	CreateDiffPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	PLine->PropEnd =  *(PLine->Param) - *(PLine->Param2);
	return( PIN_H );
}

UWORD	DrawDiffPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD A=X1+PNL_X1,B,C;
	char ch[32];
	if (PLine->Label && *PLine->Label)
	{
		B = strlen(PLine->Label);
		C=SafeFitText(win->RPort,PLine->Label,B,PNL_WIDTH,FALSE);
		if (PLine->Align == PNL_CENTER)
			A = X1 + ((PNL_WIDTH - LastExtent.te_Width) >> 1);
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,C);
		A += LastExtent.te_Width;
	}
	PLine->PropStart = A<<16; // used to redraw text later
	PLine->PropStart += (H+PIN_YOFF);
	LongToTime((ULONG *)&PLine->PropEnd,ch);
	Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
	SafeColorText(win->RPort,ch,11);
	return( PIN_H );
}

UWORD	CreateDividePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	return( 8+PNL_DIV );
}

UWORD	DrawDividePL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD A=PNL_X1,B,C,x=PNL_X1, W=PNL_WIDTH;
	if (PLine->Label && *PLine->Label)
	{
		if(Wide) W=PNL_WIDTH<<1;
		B = strlen(PLine->Label);
		C=SafeFitText(win->RPort,PLine->Label,B,PNL_WIDTH,FALSE);
		if (PLine->Align == PNL_CENTER)
			A = ((W - LastExtent.te_Width) >> 1);
		else
			x += LastExtent.te_Width ;
		NewBorderBox(win->RPort,x,H+4,ClipNW.Width-PNL_X1,H+4+PNL_DIV,BOX_REV);
		Move(win->RPort,A,H+TEXT_BASE-1 + 3);
		SafeColorText(win->RPort,PLine->Label,C);
	}
	else NewBorderBox(win->RPort,x,H+4,ClipNW.Width-PNL_X1,H+4+PNL_DIV,BOX_REV);
	return( 8+PNL_DIV );
}

UWORD	CreateCroutonPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Gadget **ThisG)
{
	struct Gadget *NewG;
	UWORD W=PNL_WIDTH;
	if(!PLine->Param) PLine->Param=(LONG *)GetDefaultBitmap(CR_ERROR);
	if(Wide) W=PNL_WIDTH<<1;
	H=12;
	if (!(NewG = AllocOneGadget(&StringGadg))) return(0);
	PLine->StrGadg = NewG;
	NewG->LeftEdge = PNL_X1 + 80 + 4;
	NewG->Width= W - PNL_X1 - NewG->LeftEdge;
	NewG->TopEdge =H+50 + PNL_Y1 - NewG->Height - 5 ;
	NewG->UserData = PLine;
	NewG->NextGadget = NULL;
	if(PLine->Param2)strncpy( ((struct StringInfo *)NewG->SpecialInfo)->Buffer,(char *)PLine->Param2,MAX_STRING_BUFFER);
	AddPanelG(&FirstG,ThisG,&NewG);
	if(PLine->Width>0) PLine->Width = (*ThisG)->LeftEdge+(*ThisG)->Width - X1;
	else  PLine->Width = -((*ThisG)->LeftEdge+(*ThisG)->Width - X1);
	return(72);
}

UWORD	DrawCroutonPL(UWORD	X1,UWORD	H, struct PanelLine *PLine, struct Window *win)
{
	UWORD  A=80+PNL_X1,B,W=PNL_WIDTH;
	H=12;
	if(PLine->Param)
		CopyCrut((struct BitMap *)PLine->Param,win->RPort->BitMap,
			win->LeftEdge + PNL_X1,	win->TopEdge + PNL_Y1 + H,EditTop->RowSize-2);
	if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
	if (PLine->Label && (B=strlen(PLine->Label)))
	{
		if (PLine->Align == PNL_CENTER)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,W-A-PNL_X1,FALSE);
			A += (W-A-PNL_X1 - LastExtent.te_Width)>>1;
		}
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-2);
		SafeColorText(win->RPort,PLine->Label,B);
	}
	StringBorder(win->RPort,PLine->StrGadg);
	RefreshGList(PLine->StrGadg,win,NULL,1);
	return(72);
}

void DestroyCroutonPL(struct PanelLine *PLine)
{
	if (PLine->StrGadg)
	{
		PLine->StrGadg->NextGadget = NULL;
		FreeGadgets(PLine->StrGadg);
	}
}

BOOL	HandleCroutonPL(struct PanelLine *PLine,struct  IntuiMessage *IntuiMsg,struct Window *Window)
{
	struct Gadget *ThisG= (struct Gadget *)IntuiMsg->IAddress;
	if( (IntuiMsg->Class==IDCMP_GADGETUP) && (ThisG->GadgetID==STRING_ID) )
		if(PLine->Param2)
		{
			strncpy((char *)PLine->Param2,((struct StringInfo *)ThisG->SpecialInfo)->Buffer,(int)PLine->PropEnd);
			PLine->PropStart=1;
		}
	return(TRUE);
}

d799 1
a799 1
	FirstG=0; Down=0; EZGad=NULL; In=NULL; Out=NULL; Del=NULL; Len=NULL;
d923 28
a965 1
						//else if(PLine==NULL)  // tick or move or key
d1049 29
a1277 70
// Return MaxBlocks
ULONG	DHD_InitRecord(ULONG Unit,ULONG Flags)
{
	DUMPUDECL("DHD_Init( ",Unit,",");
	DUMPHEXIL(" ",Flags," ); \\ ");
	SendSwitcherReply(ES_InitRecord,NULL);
	DUMPMSG("InitRecord() Done");
	return((ULONG)1);
}

// Return MaxBlocks
ULONG	DHD_InitPlay(ULONG Unit,ULONG Flags)
{
	DUMPUDECL("DHD_Init( ",Unit,",");
	DUMPHEXIL(" ",Flags," ); \\ ");
	SendSwitcherReply(ES_InitPlay,NULL);
	DUMPMSG("InitPlay() Done");
	return((ULONG)1);
}

void	DHD_Abort(ULONG Unit)
{
	DUMPUDECL("DHD_Abort( ",Unit,"); \\ ");
	SendSwitcherReply(ES_StopSeq,NULL);
	return;
}

void	Main2Blank()
{
	DUMPMSG("Main2Blank");
	SendSwitcherReply(ES_Main2Blank,NULL);
	return;
}

ULONG	DHD_Record(ULONG Unit, ULONG Start, ULONG Stop, ULONG Flags)
{
	DUMPMSG("DHD_Record()");
// THIS IS BOGUS NOW.  IT HAS TO SUPPORT RECORDING VIA A FILENAME.!!!!!!!
	return((ULONG)SendSwitcherReply(ES_Record,NULL));
}

ULONG	DHD_Shuttle(struct RenderCallBack	*rcb)
{
	DUMPMSG("DHD_Shuttle()");
	ESparams1.Data1=(LONG)rcb;
	return((ULONG)SendSwitcherReply(ES_Shuttle,&ESparams1));
}

void	DHD_Jog(struct RenderCallBack	*rcb)
{
	DUMPMSG("DHD_Jog()");
	ESparams1.Data1=(LONG)rcb;
	rcb->Flags |= DHD_MOUSE_UPDATE;
	SendSwitcherReply(ES_Jog,&ESparams1);
	return;
}

void	DHD_Jump(struct RenderCallBack	*rcb)
{
	DUMPMSG("DHD_Jump()");
	ESparams2.Data1=(LONG)rcb->FG;
	ESparams2.Data2=(LONG)rcb->Frame;
	if(rcb->Frame>rcb->Max) rcb->Frame = rcb->Max;
	if(rcb->Frame<rcb->Min) rcb->Frame = rcb->Min;
	rcb->Flags &= ~DHD_MOUSE_UPDATE;
	SendSwitcherReply(ES_Jump,&ESparams2);
	rcb->RenderFn(rcb);
	return;
}

a1314 3
#ifdef SERDUBUG
char str[100];
#endif
a1351 8

//*******************************************************************
struct EditWindow *HandleNewClip(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	DoNewClipPanel(Edit,NULL);
	return(Edit);
}

@


2.34
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.33 94/09/09 19:59:34 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d131 1
a131 1

d156 1
a156 1
ULONG	Ticks,WinFlags,GadInd,LoTime=0,HiTime=0;
d158 1
a158 1
UBYTE *GadIndex=(UBYTE *)&GadInd;
d418 58
d736 2
a737 2
	if (A > HiTime) A = HiTime;
	else if (A < LoTime) A = LoTime;
d869 2
a870 2
	LoTime = PLine->PropStart;
	HiTime = PLine->PropEnd;
d888 2
a889 2
		MyRCB->Max = HiTime<<1;
		MyRCB->Min = LoTime<<1;
d991 1
a991 1
				FixTimeStr(PLine,Window); // update long & flush bogus values
d1148 2
a1149 2
	MyRCB->Max = HiTime<<1;
	MyRCB->Min = LoTime<<1;
d1234 1
a1234 1
				FixTimeStr(PLine,Window); // update long & flush bogus values
d1348 2
a1349 2
		MyRCB->Max = HiTime<<1;
		MyRCB->Min = LoTime<<1;
a1400 1
				FixTimeStr(PLine,Window);    // update long & flush bogus values
d1403 1
d1407 2
d1892 4
a1895 4
			NewG->LeftEdge = X1 + PNL_X1;
			NewG->TopEdge = H + PTIME_POFF + 2;
			NewG->Height = 16;
			NewG->Width = PNL_WIDTH - (PNL_X1<<1) ; // PTIME_W+40;
d1969 1
a1970 1
	InitLRKnobRail(win->RPort,PLine->PropGadg);
d1982 2
a1983 2
	MyRCB->Max = HiTime<<1;
	MyRCB->Min = LoTime<<1;
d2145 2
a2146 2
		MyRCB->Max = HiTime<<1;
		MyRCB->Min = LoTime<<1;
d3029 5
a3033 1
		if(PLine->Param2) strncpy((char *)PLine->Param2,((struct StringInfo *)ThisG->SpecialInfo)->Buffer,(int)PLine->Param2);
d3205 2
a3206 2
			HiTime = *(OutPL->Param);
			LoTime = InPL->PropStart;
d3208 2
a3209 2
			MyRCB->Min = LoTime<<1;
			MyRCB->Max = HiTime<<1;
d3230 2
a3231 2
							HiTime = *(OutPL->Param);
							LoTime = PLine->PropStart;
d3236 2
a3237 2
							LoTime = *(InPL->Param);
							HiTime = PLine->PropEnd;
d3239 1
a3239 1
						//else if(PLine==NULL)  // tick or move
d3353 6
d3362 6
d3383 1
a3383 1
									d=1;
d3385 2
a3386 1
								*(LastTime->Param) = (Y>=LastTime->PropStart+d ? Y-d:LastTime->PropStart);
d3406 1
a3406 1
									d=1;
d3408 1
a3408 1
								*(LastTime->Param) = (Y<=LastTime->PropEnd-d ? Y+d:LastTime->PropEnd);
d3425 2
a3426 2
									Y = LastTime->PropEnd;
									*(LastTime->Param) = Y;
d3444 2
a3445 2
									Y = LastTime->PropStart;
									*(LastTime->Param) = Y;
a3519 111

LONG GetValue(struct FastGadget *FG,ULONG TagID)
{
#ifdef SERDEBUG
	LONG	c=0;
	if(FG) {
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
		c=SendSwitcherReply(ES_GetValue,&ESparams2);
	}
	DUMPHEXIL("ES_GetValue( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID," ) =");
	DUMPSDECL(" ",c,"\\");
	return(c);
#else
	if(FG){
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
	 	return(SendSwitcherReply(ES_GetValue,&ESparams2));
	}
	else return(0);
#endif
}

LONG PutValue(struct FastGadget *FG,ULONG TagID,LONG Value)
{
#ifdef SERDEBUG
	LONG	c;

	if(FG) {
		ESparams3.Data1=(LONG)FG;
		ESparams3.Data2=TagID;
		ESparams3.Data3=Value;
		c=SendSwitcherReply(ES_PutValue,&ESparams3);
	}
	DUMPHEXIL("ES_PutValue( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID,",");
	DUMPSDECL(" ",Value," ) =");
	DUMPSDECL(" ",c,"\\");
	return(c);
#else
	if(FG) {
		ESparams3.Data1=(LONG)FG;
		ESparams3.Data2=TagID;
		ESparams3.Data3=Value;
		return(SendSwitcherReply(ES_PutValue,&ESparams3));
	}
	else return(0);
#endif
}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~````


ULONG CroutonIndex(ULONG Type)
{
	ULONG i;
//	DUMPHEXIL(" Looking for Type: ",(LONG)Type," \\");
	for(i=CR_FXANIM; i<= CR_CRAWL; i++)
	{
//		DUMPUDECL("CRuDTypes[ ",(LONG)i," ] =");
//		DUMPHEXIL(" ",(LONG)CRuDTypes[i]," \\");
		if(Type == CRuDTypes[i]) return(i);
	}
//	DUMPUDECL(" ",(LONG)i,"\\ ");
	return(CR_UNKNOWN);
}

#define VALID_CTYPE(t)		((t<=CR_CRAWL)&&(t>=CR_FXANIM))
//*******************************************************************
struct EditWindow *HandlePanel(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	ULONG type,indx;
	struct FastGadget *FG,*Next;
	char Label[MAX_PANEL_STR]="";
	BOOL BagIt=FALSE;
	PanHandler	PanelFun;

	FG = *(((struct Project *)Edit->Special)->PtrPtr);
	while (FG && !BagIt)
	{
//		DUMPHEXIL("while FG=",(LONG)FG," ");
		Next = FG->NextGadget;
		if (FG->FGDiff.FGNode.Status == EN_SELECTED)
		{
			type=((struct ExtFastGadget *)FG)->ObjectType;
			indx = CroutonIndex(type);
//			DUMPHEXIL("  Type: ",(LONG)type," ");
//			DUMPHEXIL("  # ",(LONG)indx,"\\");
			if(VALID_CTYPE(indx))
			{
				strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
//				DUMPHEXIL("VALID! FG->ObjectType= ",type,"\\");
				CurFG=FG;
//				SendSwitcherReply(ES_StartControl,FG,0,0);
				if( (PanelFun=PanHandlers[indx]) )  // check type for validity 1st!!!
					BagIt = PanelFun(Edit,FG);
//				SendSwitcherReply(ES_StopControl,FG,0,0);
			}
		}
//		else DUMPMSG(" (Not Selected) ");
		FG = Next;
	}
	return(Edit);
}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~` */


d3585 2
d3856 2
a3857 2
								HiTime = *(temp->Param);
								LoTime = PLine->PropStart;
d3865 2
a3866 2
								HiTime = PLine->PropEnd;
								LoTime = *(temp->Param);
d4251 2
a4252 2
			HiTime = *(OutPL->Param);
			LoTime = InPL->PropStart;
d4254 2
a4255 2
			MyRCB->Min = LoTime<<1;
			MyRCB->Max = HiTime<<1;
d4298 2
a4299 2
								HiTime = *(OutPL->Param);
								LoTime = PLine->PropStart;
d4304 2
a4305 2
								LoTime = *(InPL->Param);
								HiTime = PLine->PropEnd;
@


2.33
log
@/inc

@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.32 94/09/09 13:46:38 CACHELIN4000 Exp Locker: CACHELIN4000 $
@


2.32
log
@Gurm
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.31 94/09/06 22:26:50 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
a171 2
#define DHD_PLAY_REV	(1<<31)
#define DHD_STR_UPDATE	(1<<30)
a404 14
/*
// not used... yet??
void UpdateClipSliders(struct ClipDisplay *cd,struct Gadget *InProp,struct Window *Window,ULONG Val)
{
	struct Gadget *OutProp;
	if(!(OutProp=InProp->NextGadget)) return;
	RemoveGList(Window,InProp,2);
	InProp->Width -= Val;
	OutProp->LeftEdge -= Val;
	AddGList(Window,InProp,0,2,NULL);
	RefreshGList(InProp,Window,NULL,2);
}
*/

a930 7
				if(PLine->Flags&PL_FLYER)
				{
					MyRCB->Flags = DHD_STR_UPDATE;
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jump(MyRCB);
					MyRCB->Flags = 0;
				}
d1108 2
a1109 2
					UpdatePanProp(PLine,Window);
					UpdatePanStr(PLine,Window);
d1115 2
a1116 2
					UpdatePanProp(PLine,Window);
					UpdatePanStr(PLine,Window);
a1723 1
//	DrawLRKnobRail(win->RPort,PLine->PropGadg);
d1732 1
a1732 12
	ULONG	Y,A,jump=1;
	if( PLine->Flags&PL_FLYER )
	{
		jump=FRAME_QUANT;
		MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
		MyRCB->Max = HiTime<<1;
		MyRCB->Min = LoTime<<1;
		MyRCB->FG = CurFG;
		MyRCB->win = Window;
		MyRCB->pline = PLine;
		MyRCB->MouseX = IntuiMsg->MouseX;
		MyRCB->MouseY = IntuiMsg->MouseY;
a1733 1
	}
a1738 26
				if( PLine->Flags&PL_FLYER )
				{
					struct PropInfo *pi= ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
					A=pi->HorizPot*(PLine->PropGadg->Width -
							((struct Image *)PLine->PropGadg->GadgetRender)->Width);
					A /= MAXPOT;
					A += PLine->PropGadg->LeftEdge;

					if(IntuiMsg->MouseX > A+ ((struct Image *)PLine->PropGadg->GadgetRender)->Width)
					{
						Y = *(PLine->Param);
						*(PLine->Param) = (Y<PLine->PropEnd-jump ? Y+jump:PLine->PropEnd);
						UpdatePanProp(PLine,Window);
					}
					else if(IntuiMsg->MouseX < A)
					{
						Y = *(PLine->Param);
						*(PLine->Param) = (Y>PLine->PropStart+jump ? Y-jump:PLine->PropStart);
						UpdatePanProp(PLine,Window);
					}
					else  // clicked right on knob
					{
						MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
						DHD_Jog(MyRCB);
					}
				}
d1785 203
d1995 2
a1996 1
				if(Ticks>EZ_DELAY)  break;
d3031 1
a3031 1
	LONG Y=0;
d3205 2
a3206 2
//						DHD_Jog(MyRCB);
						DHD_Shuttle(MyRCB);
d3244 1
a3244 1
//						if(B=DHD_Shuttle(MyRCB))
d3300 1
a3300 1
									Y = *(LastTime->Param) - 30;
d3302 1
a3302 2
									Y = *(LastTime->Param) - (LastTime->PropEnd - LastTime->PropStart)/10+1;
									//Y = *(LastTime->Param) - 300;
d3304 3
a3306 2
									Y = *(LastTime->Param) - 1;
								*(LastTime->Param) = (Y>=LastTime->PropStart ? Y:LastTime->PropStart);
d3313 4
a3316 2
								UpdatePanProp(LastTime,Window);
								UpdatePanStr(LastTime,Window);
d3322 1
a3322 1
									Y = *(LastTime->Param) + 30;
d3324 1
a3324 2
									Y = *(LastTime->Param) + (LastTime->PropEnd - LastTime->PropStart)/10+1;
									// Y = *(LastTime->Param) + 300;
d3326 3
a3328 2
									Y = *(LastTime->Param) + 1;
								*(LastTime->Param) = (Y<=LastTime->PropEnd ? Y:LastTime->PropEnd);
d3335 4
a3338 2
								UpdatePanProp(LastTime,Window);
								UpdatePanStr(LastTime,Window);
d3353 4
a3356 2
									UpdatePanProp(LastTime,Window);
									UpdatePanStr(LastTime,Window);
a3590 1

a3594 3
// Should return new position, or dist. from start.  This will be called
// on RMB Down, and it should watch for RMB up to stop
// use unit to specify whether in/out point
a3601 1
// Use unit to specify whether in/out point
d3606 1
a3610 1
// Use unit to specify whether in/out point
d3616 1
d3680 6
a3685 3
			A=Val* (PLine->PropGadg->Width - ((struct Image *)PLine->PropGadg->GadgetRender)->Width);
			A = (A/MAXPOT) + PLine->PropGadg->LeftEdge + Call->win->LeftEdge;
			Call->MouseX = (A&0xFFFF) + (((struct Image *)PLine->PropGadg->GadgetRender)->Width>>1);
@


2.31
log
@PNL_CROUTON type enhancements
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.30 94/09/05 19:06:38 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
a1204 2


d1870 1
a1870 1
		NewG->TopEdge = H + PTEXT_H;
d1900 1
a1900 1
	WORD X=PLine->PropGadg->LeftEdge;
d1903 4
a1906 2
		Move(win->RPort,X1+PNL_X1,H+PTEXT_YOFF+TEXT_BASE-1);
		SafeColorText(win->RPort,PLine->Label,strlen(PLine->Label));
d1993 1
a1993 1
	if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
d1998 1
a1998 1
	if(PLine->PropStart) NewG->Width= W - (PNL_X1<<1) -80;
d2027 1
a2027 1
	if(Wide && (PLine->Width<=0)) W=PNL_WIDTH<<1;
d2035 6
a2040 6
		if(PLine->PropStart)
		{
			B = SafeFitText(win->RPort,PLine->Label,B,PLine->StrGadg->Width-100,FALSE);
			PLine->StrGadg->Width -= LastExtent.te_Width +4 ;
			PLine->StrGadg->LeftEdge += LastExtent.te_Width +4 ;
		}
d2243 1
a2243 1
	UWORD A,B;
d2246 1
d2251 2
a2252 2
			B = SafeFitText(win->RPort,PLine->Label,B,PNL_WIDTH,FALSE);
			A = (PNL_WIDTH - LastExtent.te_Width) >> 1;
d2256 2
a2257 2
			B = SafeFitText(win->RPort,PLine->Label,B,PNL_WIDTH,FALSE);
			A = PNL_WIDTH - LastExtent.te_Width;
d2700 7
d2788 1
a2791 1
	H=12;
d2875 1
a2875 1

d2950 12
a2964 1
		H = PNL_Y1;
d2967 8
@


2.30
log
@ES_Jump support added { DHD_Jump() }
@
text
@d1 1
a1 1
/* $Id: Panel.c,v 2.29 94/09/04 17:52:56 CACHELIN4000 Exp Locker: CACHELIN4000 $
d3 3
d90 1
a90 1
void __asm RenderFunc(REG(d0) ULONG , REG(a0) struct RenderCallBack *);
d152 1
a152 1
BOOL	Wide=FALSE,UseDropFrame=TRUE,Playing=FALSE;
d401 1
d413 1
d416 1
a416 1
__inline void UpdateTime(struct Gadget *Time,struct Window *Window,ULONG Val)
d425 1
a425 1
__inline void	Box(struct RastPort *RP,UWORD	x,UWORD y,UWORD	w,UWORD h)
d435 1
a436 1

a514 214
__inline void	StringBorder(struct RastPort *RP, struct Gadget *Str)
{
	NewBorderBox(RP,Str->LeftEdge-4,Str->TopEdge-5,
		Str->LeftEdge+Str->Width+3,Str->TopEdge+Str->Height+2,BOX_REV_BORDER);
//		Str->LeftEdge+Str->Width+4-1,Str->TopEdge+Str->Height+4-1,BOX_REV_BORDER);
}

__inline void Divider(struct Window *w, UWORD	Y)
{
	Y -= PNL_DIV>>1;
	NewBorderBox(w->RPort,PNL_X1,Y,w->Width-PNL_X1,Y+PNL_DIV,BOX_REV);
}

#define RAIL_H 20
//*******************************************************************
VOID InitLRKnobRail(struct RastPort *RP,struct Gadget *Prop)
{
	LONG X,Y,X2,Y2;

	X = Prop->LeftEdge;
	X2 = Prop->LeftEdge+Prop->Width-1;
	Y = Prop->TopEdge ;
	if(Prop->Height > RAIL_H) Y+= ((Prop->Height - RAIL_H)>>1);
	else  Y -= ((RAIL_H - Prop->Height)>>1);
	Y2 = Y + RAIL_H - 1;

	SetAPen(RP,PAL_LBLACK);
	Move(RP,X-2,Y+1);
	Draw(RP,X-2,Y2-1);
	Move(RP,X-1,Y);
	Draw(RP,X-1,Y2-2);
	Move(RP,X2+1,Y+1);
	Draw(RP,X2+2,Y+1);
	Move(RP,X,Y);
	Draw(RP,X2,Y);
	Move(RP,X,Y+1);
	Draw(RP,X2,Y+1);

	SetAPen(RP,PAL_LGRAY);
	Move(RP,X-1,Y2-1);
	Draw(RP,X-1,Y2);
	Move(RP,X2+1,Y+2);
	Draw(RP,X2+1,Y2);
	Move(RP,X2+2,Y+1);
	Draw(RP,X2+2,Y2-1);
	Move(RP,X,Y2);
	Draw(RP,X2,Y2);
	Move(RP,X,Y2-1);
	Draw(RP,X2,Y2-1);
}

//*******************************************************************
// Correct time string (i.e. :32 ->1:02), fill *Param with frame #
// converts HH:MM:SS:FF to LONG # of FRAMEs,
ULONG FixTimeStr(struct PanelLine *PLine, struct Window *Window)
{
	ULONG X,A = 0,B = 0,Z[5] = {0,0,0,0,0},*P,a,*L,F=0,M=0,S=0,H=0;
	char c,*T;
	struct Gadget *ThisG;

	if( !(ThisG=PLine->StrGadg) ) return(0);
	X = RemoveGadget(Window,ThisG);
	T = ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
	L=(ULONG *)PLine->Param;
	P = Z;
	while (c = *T) {
		T++;
		if ((c >= '0') && (c <= '9')) {
			B *= 10;
			B += (c - '0');
		}
		if ((!(*T)) || (c == ':') || (c == ';') || (c == ' ') || (c == '.')) {
			*P++ = B;
			A++;
			if (A > 4) break;
			B = 0;
		}
	}
	if (A == 1) *L = Z[0];
	else if (A == 2) *L = Z[0]*30 + Z[1];
	else if (A == 3) *L = Z[0]*1800 + Z[1]*30 + Z[2];
	else if (A >= 4) *L = Z[0]*108000 + Z[1]*1800 + Z[2]*30 + Z[3];
	a=*L;
	if(UseDropFrame) *L=PickUpFrames(*L);
	F = a;
	H = F/108000;
	F	%= 108000;
	M = F / 1800;  // 60 secs/min * 30 frames/secs
	F %= 1800;
	S = F / 30;
	F %= 30;
	sprintf(((struct StringInfo *)ThisG->SpecialInfo)->Buffer,"%02ld:%02ld:%02ld:%02ld",H,M,S,F);

	AddGadget(Window,ThisG,X);
	RefreshGList(ThisG,Window,NULL,1);

	if(a!=*L)
	{
		DUMPSTR("{FixTime}	Time Code: ");
		DUMPSTR(((struct StringInfo *)ThisG->SpecialInfo)->Buffer);
		DUMPUDECL(" Frames: ",*L," ");
		DUMPUDECL("Time (Secs/30):",a,"\\");
	}

	return(*L);
}

//*******************************************************************
// converts HH:MM:SS:FF to LONG # of FRAMEs
VOID TimeToLong(char *T,ULONG *L)
{
	ULONG A = 0,B = 0,Z[5] = {0,0,0,0,0},*P,a;
	char c;
#ifdef SERDEBUG
	char *tt=T;
#endif
	P = Z;
	while (c = *T) {
		T++;
		if ((c >= '0') && (c <= '9')) {
			B *= 10;
			B += (c - '0');
		}
		if ((!(*T)) || (c == ':') || (c == ';') || (c == ' ') || (c == '.')) {
			*P++ = B;
			A++;
			if (A > 4) break;
			B = 0;
		}
	}
	if (A == 1) *L = Z[0];
	else if (A == 2) *L = Z[0]*30 + Z[1];
	else if (A == 3) *L = Z[0]*1800 + Z[1]*30 + Z[2];
	else if (A >= 4) *L = Z[0]*108000 + Z[1]*1800 + Z[2]*30 + Z[3];
	a=*L;
	if(UseDropFrame) *L=PickUpFrames(*L);

	if(a!=*L)
	{
		DUMPSTR("{T2L}		Time Code: ");
		DUMPSTR(tt);
		DUMPUDECL(" Frames: ",*L," ");
		DUMPUDECL("Time (Secs/30):",a,"\\");
	}

}

// Add time to counters to account for longer frame times
// convert from 30 ticks/sec time to drop-frame SMPTE 29.97 fps
// drop 2 frames every minute... except the 10th
//
__inline ULONG DropFrames(ULONG	ticks)
{
	ULONG	mins;
	if(ticks>0)
		if(mins=(18000*(ticks-1)/17981)/1800)
			return( ticks + 2*((mins) - ((mins)/10)) );
	return(ticks);
}

ULONG PickUpFrames(ULONG	ticks)
{
	ULONG	mins;      // return(17981*ticks/18000);
	mins=ticks/1800;  // 60 secs/min * 30 frames/secs
	if(ticks>0)
		return( ticks - (mins*2) // drop 2 frames every minute
					+ 2*(mins/10)				// ... except the 10th
		);
	return(0);
}

//*******************************************************************
// Convert # of frames to SMPTE string -- HH:MM:SS:FF
VOID LongToTime(ULONG *L,char *T)
{
	ULONG F=0,M=0,S=0,H=0,a;
	if(L)
	{
		if(*L&0x80000000) *L=0;  // Watch for pesky signed LONGs, limit max time code
		F = *L;
		if(UseDropFrame) F=DropFrames(*L); // add extra time since frames last longer than 1/30
		a=F;
		H = F/108000;
		F	%= 108000;
		M = F / 1800;  // 60 secs/min * 30 frames/secs
		F %= 1800;
		S = F / 30;
		F %= 30;
	}
	sprintf(T,"%02ld:%02ld:%02ld:%02ld",H,M,S,F);
	DUMPSTR("{L2T}		Time Code: ");
	DUMPSTR(T);
	DUMPUDECL(" Frames: ",*L," ");
	DUMPUDECL("Time (Secs/30):",a,"\\");
}

//*******************************************************************
// Convert # of frames to "SMPTE" length string -- SS:FF
VOID LongToLen(ULONG *L,char *T)
{
	ULONG A=0,C=0;

	if(L)
	{
		if(*L&0x80000000) *L=0;  // Watch for pesky signed LONGs, limit max time code
		A = *L;
		if(UseDropFrame) A=DropFrames(*L);
		C = A / 30;
		A %= 30;
	}
	sprintf(T,"%02ld:%02ld",C,A);
}


a663 2
	//	if (A > HiTime) A = HiTime;
	//	else if (A < LoTime) A = LoTime;
d955 249
d1861 125
d1989 2
d1995 2
a1996 1
	NewG->LeftEdge = X1 +  PNL_WIDTH - PNL_X1 - 100;
d2022 3
a2024 2
	UWORD  A=X1+PNL_X1,B;
	StringBorder(win->RPort,PLine->StrGadg);
d2032 7
a2038 1
		Move(win->RPort,A,H+PIN_YOFF+TEXT_BASE-1);
d2041 1
d2755 17
a2771 2
	if(!PLine->Param) PLine->Param=(LONG *)GetDefaultBitmap(CR_FXANIM);
	return(0);	//return(54);
d2776 36
a2811 4
	if(PLine->Param) CopyCrut((struct BitMap *)PLine->Param,win->RPort->BitMap,
	win->LeftEdge + win->Width - 80 -3,
	win->TopEdge +4,EditTop->RowSize-2);
	return(0);	//return(54);
d2868 1
a2868 2
	struct Gadget *ThisG=0,*ContCan,*FakeIn=NULL,*FakeOut=NULL,
		CDisp = { NULL,0,0,20,20,GFLG_GADGHNONE,RELVERIFY|GADGIMMEDIATE,BOOLGADGET,NULL,NULL,NULL,NULL,NULL,ID_LR_KNOB,NULL};
a2970 18
			CDisp.LeftEdge = InPL->PropGadg->LeftEdge;
			CDisp.TopEdge = InPL->PropGadg->TopEdge;
			CDisp.Width = InPL->PropGadg->Width;
			CDisp.Height = InPL->PropGadg->Height;
			if(InPL->PropGadg && (FakeIn=AllocOneGadget(&CDisp)) )
			{
				A = RemoveGadget(Window,InPL->PropGadg);
				FakeIn->UserData = InPL;
				AddGadget(Window,FakeIn,A);
			}
			if(OutPL->PropGadg && (FakeOut=AllocOneGadget(&CDisp)) )
			{
				FakeOut->LeftEdge = OutPL->PropGadg->LeftEdge;
				FakeOut->TopEdge = OutPL->PropGadg->TopEdge;
				FakeOut->UserData = OutPL;
				A = RemoveGadget(Window,OutPL->PropGadg);
				AddGadget(Window,FakeOut,A);
			}
d3030 2
a3031 1
						DHD_Jog(MyRCB);
d3214 1
d3229 1
d3441 1
a3441 1
	RenderFunc(rcb);
d3471 7
a3477 2
	UWORD	FieldsPerFrame;	//frame rate, usually 1, 2, 4, 8, 16 ...
	WORD	FieldStep;	//direction & speed per frame
d4200 2
a4201 1
						DHD_Jog(MyRCB);
@


2.29
log
@*** empty log message ***
@
text
@d1 1
a1 2
/* $Panel.c$ - Routines for Control Panels
* $Id: Panel.c,v 2.28 94/09/03 17:50:23 CACHELIN4000 Exp Locker: CACHELIN4000 $
a2 3
*Revision 2.28  94/09/03  17:50:23  CACHELIN4000
**** empty log message ***
*
a5 9
*Revision 2.24  1994/09/01  21:14:12  CACHELIN4000
**** empty log message ***
*
*Revision 2.23  94/09/01  20:45:18  CACHELIN4000
**** empty log message ***
*
*Revision 2.22  94/09/01  18:27:58  Kell
**** empty log message ***
*
a11 3
*Revision 2.19  1994/08/31  21:25:40  CACHELIN4000
**** empty log message ***
*
a31 4
*Revision 2.12  94/07/27  20:47:52  CACHELIN4000
**** empty log message ***
*
*
a34 1
*
a37 3
*Revision 2.5  94/06/08  16:17:55  CACHELIN4000
**** empty log message ***
*
a40 3
*Revision 2.3  94/04/26  13:50:54  CACHELIN4000
**** empty log message ***
*
a43 1
*
d97 1
a97 1
#define SERDEBUG	1
d99 1
a99 1

d2105 1
a2105 1
	NewG->GadgetID = ID_TOG1;
d2116 1
a2116 1
		NewG->GadgetID = ID_TOG2;
d2128 1
a2128 1
		NewG->GadgetID = ID_TOG3;
d2140 1
a2140 1
		NewG->GadgetID = ID_TOG4;
d2153 1
a2153 1
		NewG->GadgetID = ID_TOG5;
d2233 1
a2233 1
	ULONG	Y,T,A;
d2235 1
a2235 1
	if( (IntuiMsg->Class==IDCMP_GADGETUP) && (ThisG->GadgetID>=ID_TOG1) && (ThisG->GadgetID<=ID_TOG5) )
a2236 1
		A=ThisG->GadgetID - ID_TOG1;
d2238 1
a2238 1
		T=(1<A);
d2705 3
a2707 3
	ClipNW.LeftEdge = EditTop->Window->LeftEdge + 24;
//		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = (EditScreen->Height - ClipNW.Height)/2;
d3233 4
a3236 2
	ESparams1.Data1=(LONG)rcb;
	SendSwitcherReply(ES_Jog,&ESparams1);
d3266 2
d3373 1
a3373 1
	ClipNW.TopEdge = (EditScreen->Height - ClipNW.Height)/2;
d3773 1
a3773 1
	ClipNW.TopEdge = (EditScreen->Height - ClipNW.Height)/2;
@


2.28
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.27 94/09/02 20:17:18 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d420 4
a423 1
	SetPropHorizPot(Prop,Window,Val,0,cd->MaxVal);
a893 1
  if(!PLine->PropGadg) return;
d895 2
a896 5
//	if (A > PLine->PropEnd) A = PLine->PropEnd;
//	else if (A < PLine->PropStart) A = PLine->PropStart;
	if (A > HiTime) A = HiTime;
	else if (A < LoTime) A = LoTime;
	if( (PLine->Param) && (A!=*(PLine->Param)) )  // If bounds exceeded
d898 17
a914 2
		*(PLine->Param)=A;
		UpdatePanStr(PLine,Window);
a915 3
	A -= PLine->PropStart;
	SetPropHorizPot(PLine->PropGadg,Window,A,0,PLine->PropEnd-PLine->PropStart);
//	if (Window) DrawLRKnobRail(Window->RPort,PLine->PropGadg);
a1153 1
				Y--;
d1290 1
a1290 1
	ULONG	Y ;//,*L;
d1323 1
d1327 3
a1329 3
				if( (Ticks>EZ_DELAY) || !(Y = *(PLine->Param)) ) break;
				Y -= 2;
				*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
d1337 3
a1339 3
				if(Ticks>EZ_DELAY)  break;
				Y = *(PLine->Param) + 2;
				*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
d1832 1
d1843 1
d2734 2
a2735 2
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
d3316 1
a3316 1
			A=((*PLine->Param)*MAXPOT)/(PLine->PropEnd - PLine->PropStart);
d3729 2
a3730 1
	struct Gadget *ThisG=0,*Gadget,*ContCan,*Play,*Rew,*FFwd,*Pause,*Clips,*String,
d3735 1
a3735 1
	BOOL Going = TRUE;
d3778 2
d3887 3
d3911 33
a3943 2
		RefreshGList(ContCan,Window,NULL,-1);
		DrawClipDisplay(ClipDisp);
a3944 1
		LastTime=NULL;
d3957 16
a3972 3
						if( PLine->StrGadg && (PLine->StrGadg==In) )
							InOrOut=0;
						else InOrOut=1;
d3974 2
d3995 26
d4028 1
d4033 1
d4051 1
d4059 12
a4070 8
						if( (PLine==OutPL) || (PLine==InPL) )
						{
							DrawClipDisplay(ClipDisp);
							UpdatePanProp(InPL,Window);
							UpdatePanStr(InPL,Window);
							UpdatePanProp(OutPL,Window);
							UpdatePanStr(OutPL,Window);
						}
d4282 14
@


2.27
log
@MouseX, many fixes for DHD
@
text
@d2 5
a6 2
* $Id: panel.c,v 2.24 1994/09/01 21:14:12 CACHELIN4000 Exp Kell $
* $Log: panel.c,v $
d187 3
a189 2

#define PLAY_DHD_REV	(1<<31)
d420 1
d686 3
a688 2
	if(mins=(18000*(ticks-1)/17981)/1800)
		return( ticks + 2*((mins) - ((mins)/10)) );
d696 2
a697 1
	return( ticks - (mins*2) // drop 2 frames every minute
d699 2
a700 1
	);
d1057 1
a1057 2
	ULONG	Y ;//,*L;
	// char *ch;
d1060 1
a1075 1
				UpdateParam(PLine,Window); // read prop
d1078 24
a1101 2
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jog(MyRCB);
d1126 1
d1135 1
a1135 1
				if( (Ticks>EZ_DELAY) || !(Y = *(PLine->Param)) )
d1141 2
a1142 1
				*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
d1157 2
a1158 2
				Y = *(PLine->Param) + 1;
				*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
d1169 1
d1172 1
d1314 1
a1314 1
				Y--;
d1324 1
a1324 1
				Y = *(PLine->Param) + 1;
d1581 2
a1582 2
	ULONG	Y; // ,*L;
//	char *ch;
d1625 5
a1629 3
//				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
//				L = PLine->Param;
//				TimeToLong(ch,(ULONG *)L); // update long & flush bogus values
d1631 1
a1631 1
				UpdateAllDiff(RP,Start,Window);
a1653 6
		if(PLine->Flags&PL_FLYER)
		{
			A = 2*MAXPOT; // 1 colorFrame
			A /= PLine->PropEnd - PLine->PropStart;
			((struct PropInfo *)NewG->SpecialInfo)->HorizBody = A&0xFFFF; // move by colorframes
		}
a1722 1
// Could use Handle Time!!!
d1728 1
a1728 1
	ULONG	Y;
d1731 1
a1741 3
				DUMPUDECL("SL Hi Time:",MyRCB->Max,"     " );
				DUMPUDECL("SL Lo Time:",MyRCB->Min,"    \\" );

a1746 1
				UpdateParam(PLine,Window);
d1749 23
a1771 2
					MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
					DHD_Jog(MyRCB);
d1776 2
a1777 2
				Y = *(PLine->Param) - 1;
				*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
d1782 2
a1783 2
				Y = *(PLine->Param) + 1;
				*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
d1807 1
d1815 3
a1817 3
				if( (Ticks>EZ_DELAY) || !(Y = *(PLine->Param)) ) break;
				Y--;
				*(PLine->Param) = (Y>=PLine->PropStart ? Y:PLine->PropStart);
d1826 2
a1827 2
				Y = *(PLine->Param) + 1;
				*(PLine->Param) = (Y<=PLine->PropEnd ? Y:PLine->PropEnd);
d2668 1
a2668 1
	ULONG Y=0;
a2721 2
	if(LiveFlyer)
		ClipNW.IDCMPFlags &= ~MOUSEMOVE;  // Castrate ALL prop gads??
d2840 1
a2840 1
						else  MyRCB->Flags = 1<<31;
d2859 5
a2864 11
/*
					if (Down)
					{
						if(In) MyRCB->pline=(struct PanelLine *)In->UserData;
						else if(Out) MyRCB->pline=(struct PanelLine *)Out->UserData;

						if(PLine->Flags&PL_FLYER)
							DHD_Jog(MyRCB);
//						UpdateParam((struct PanelLine *)Down->UserData,Window);
					}
*/
d3047 2
a3048 2
				TimeToLong(((struct StringInfo *)PLine->StrGadg->SpecialInfo)->
					Buffer,(ULONG *)PLine->Param);
d3287 1
a3287 1
	UWORD Val=0xFFFF;
d3296 1
a3296 1
		*PLine->Param = Call->Frame>>1;
d3299 6
a3304 7
			A=(*PLine->Param)*Val;
			A /= (PLine->PropEnd - PLine->PropStart);
			Val=A;
			A *= PLine->PropGadg->Width;
			A /= MAXPOT;
			Call->MouseX = A;
			pi = ((struct PropInfo *)PLine->PropGadg->SpecialInfo);
d3306 1
a3306 1
			pi->Flags,Val,pi->VertPot,pi->HorizBody,pi->VertBody,1);
d3308 8
a3315 7
		if(PLine->StrGadg)
		{
			A = RemoveGadget(Call->win,PLine->StrGadg);
			LongToTime((ULONG *)PLine->Param,((struct StringInfo *)PLine->StrGadg->SpecialInfo)->Buffer);
			AddGadget(Call->win,PLine->StrGadg,A);
			RefreshGList(PLine->StrGadg,Call->win,NULL,1);
		}
@


2.26
log
@*** empty log message ***
@
text
@d639 4
a642 2
	char c,*tt=T;

d1059 2
d1074 1
d1097 2
a1098 8
//				DrawLRKnobRail(RP,ThisG);
				if( PLine->Flags&PL_FLYER )
					*PLine->Param = (MyRCB->Frame>>1)&0xFFFFFFFE;
				else
				{
					UpdateParam(PLine,Window);
					BoundPanProp(PLine,Window);
				}
d1709 3
a1720 1
//				DrawLRKnobRail(RP,ThisG);
a1721 1
				UpdateAllDiff(RP,Start,Window);
d1727 1
d1761 1
a1761 5
//				DrawLRKnobRail(RP,ThisG);
				if( PLine->Flags&PL_FLYER )
					*PLine->Param = (MyRCB->Frame>>1)&0xFFFFFFFE;  // round off to color frame
				else
					UpdateParam(PLine,Window);
a1784 2


d2613 2
a2614 1
	struct Gadget *ThisG=0,*ContCan;
d2657 1
a2657 1
			if(PLine->Flags&PL_FLYER)
d2708 1
a2708 1
		if( PLine->Flags&PL_FLYER )
d2713 1
a2713 1
			MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
d2719 18
d2748 1
a2748 1
					PLine = (struct PanelLine *)ThisG->UserData;
d2797 2
d2853 1
a2853 2
					if((PLine) && (PLine->Handle) )
					{
a2854 2
						break;
					}
d2985 14
a3023 1

a3028 1

d3236 2
d3241 2
d3244 1
d3251 1
a3251 2
//	sprintf(str,"RCB: \tFn= 0x%08x \tFG=0x%08x\n",MyRCB->RenderFn,MyRCB->FG);
//	DUMPSTR(str);
d3254 1
a3254 2
//	sprintf(str,"RCB: \tFlags= 0x%08x \tWin=0x%08x \tPline=0x%08x\n",MyRCB->Flags,MyRCB->win,MyRCB->pline);
//	DUMPSTR(str);
d3257 1
a3259 1
			*PLine->Param = Call->Frame>>1;
d3263 3
a3265 5
/*
			A=2*Val;
			A /= (PLine->PropEnd - PLine->PropStart);
			pi->HorizBody =A;
*/
d3273 1
a3273 1
			LongToTime((ULONG *)&Val,((struct StringInfo *)PLine->StrGadg->SpecialInfo)->Buffer);
@


2.25
log
@Disabled SERDEBUG flag
@
text
@d119 1
a119 1
//#define SERDEBUG	1
d169 1
a169 1
struct RenderCallBack StudlyRCB={RenderFunc,NULL,0,0,666,0,NULL,NULL}, *MyRCB=&StudlyRCB;
d838 1
a838 2
	LONG A, MaxField;
	ULONG field;
d919 1
d951 3
d955 6
a960 1
//		((struct PropInfo *)NewG->SpecialInfo)->Flags |= PROPNEWLOOK;
a1048 1
	LastTime=PLine;
d1064 2
a1065 4
//				DrawLRKnobRail(RP,ThisG);
//				if(PLine->Flags&PL_FLYER)
//					DHD_Jog(MyRCB);  // should start jog on MOUSEMOVE
//				else
d1067 2
a1068 2
					UpdateParam(PLine,Window);
//					UpdateAllDiff(RP,Start,Window);
d1072 1
a1072 1
				EZGad=ThisG;
d1093 7
a1099 2
				UpdateParam(PLine,Window);
				BoundPanProp(PLine,Window);
d1606 1
a1606 1

a1613 1
//		NewG->Width = PTIME_W ; // -20;
d1616 3
d1620 6
a1625 1
//		((struct PropInfo *)NewG->SpecialInfo)->Flags |= PROPNEWLOOK | PROPBORDERLESS;
a1688 1
	UpdatePanProp(PLine,NULL); // init knob before display
d1702 12
a1713 1
	LastTime=PLine;
d1722 5
d1761 4
a1764 1
				UpdateParam(PLine,Window);
d2621 1
d2648 2
d2651 1
d2653 2
d2656 1
d2679 2
d2714 3
d2718 1
a2719 1
			MyRCB->Min = LoTime<<1;
d2722 1
a2722 1
			MyRCB->pline = NULL;
d2735 1
a2735 1
					if( PLine->StrGadg && (PLine->StrGadg==In) )
d2737 1
a2737 2
						InOrOut=0;
						if(Out && (temp=(struct PanelLine *)Out->UserData) )
d2739 2
a2740 1
							HiTime = *(temp->Param);
d2743 1
a2743 5
					}
					else if( PLine->StrGadg && (PLine->StrGadg==Out) )
					{
						InOrOut=1;
						if(In && (temp=(struct PanelLine *)In->UserData) )
d2745 2
a2747 1
							LoTime = *(temp->Param);
d2749 1
d2751 1
d2766 14
a2779 2
						MyRCB->pline = (struct PanelLine *)EZGad->UserData;
						MyRCB->Frame = (ULONG)(*PLine->Param)<<1;
d2798 2
d2809 1
a2809 1
					break;
a2812 9
					if( PLine->Flags&PL_FLYER )
					{
						MyRCB->Frame = (ULONG)(*LastTime->Param)<<1;
						MyRCB->Max = LastTime->PropEnd<<1;
						MyRCB->Min = LastTime->PropStart<<1;
						MyRCB->FG = CurFG;
						MyRCB->win = Window;
						MyRCB->pline = LastTime;
					}
d2815 9
d3210 1
a3210 1
	struct Gadget *gad;
d3214 1
a3214 1

d3217 2
a3218 1
	ULONG A,Val=Call->Frame>>1;
d3220 7
a3226 3

	DUMPMSG("RenderFunc: ------------");

d3231 12
a3242 2
			DUMPMSG("Sliding along");
			SetPropHorizPot(PLine->PropGadg,Call->win,Val,MIN_FIELD>>1,Call->Max>>1);
a3245 1
			DUMPMSG("Doing Time");
@


2.24
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: Panel.c,v 2.23 94/09/01 20:45:18 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Panel.c,v $
d119 1
a119 1
#define SERDEBUG	1
@


2.23
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.22 94/09/01 18:27:58 Kell Exp Locker: CACHELIN4000 $
d4 3
d116 1
a116 1
//#define SERDEBUG	1
d2716 2
a2720 1
						ModifyIDCMP(Window,WinFlags); // turn off ticks
d2757 1
a2757 1
						MyRCB->pline = PLine;
@


2.22
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: panel.c,v 2.21 1994/09/01 15:06:31 CACHELIN4000 Exp Kell $
* $Log: panel.c,v $
d3158 1
d3161 1
@


2.21
log
@fix hit
@
text
@d2 5
a6 2
* $Id: Panel.c,v 2.20 94/08/31 23:07:21 Kell Exp Locker: CACHELIN4000 $
* $Log:	Panel.c,v $
@


2.20
log
@New debugs.  Some changes to just before the mousemove call to DHD_Jog.
@
text
@d2 5
a6 2
* $Id: panel.c,v 2.19 1994/08/31 21:25:40 CACHELIN4000 Exp Kell $
* $Log: panel.c,v $
d940 1
a940 1
		((struct PropInfo *)NewG->SpecialInfo)->Flags |= PROPNEWLOOK;
d1015 1
a1015 1
	UpdatePanProp(PLine,NULL); // init knob before display
d1596 1
a1596 1
		((struct PropInfo *)NewG->SpecialInfo)->Flags |= PROPNEWLOOK | PROPBORDERLESS;
@


2.19
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: Panel.c,v 2.18 94/08/31 18:10:02 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Panel.c,v $
d104 1
a104 1
#define SERDEBUG	1
d2726 3
a2728 1
//						if(Out) MyRCB->pline=(struct PanelLine *)Out->UserData;
d3143 3
d3149 1
d3153 1
@


2.18
log
@Flyer Control Work .. RCB
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.17 94/08/30 17:30:31 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d101 1
a101 1
// #define SERDEBUG	1
d2723 1
d3134 1
a3134 1
void __asm RenderFunc(REG(a0) struct RenderCallBack *Call)
@


2.17
log
@Work on Flyer commands,
Replace GadIndx hack with PLine->Flags kludge.
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.16 94/08/30 10:44:37 Kell Exp Locker: CACHELIN4000 $
d4 4
d519 1
a519 2
#define RAIL_H 7
LONG LRRailColor[] = { 4,4,5,5,5,2,2 };
d527 3
a529 1
	Y = Prop->TopEdge + ((Prop->Height - RAIL_H)>>1);
a531 1
//	SetAPen(RP,4);
d534 1
a534 1
	Draw(RP,X-2,Y+5);
d536 1
a536 1
	Draw(RP,X-1,Y+4);
d539 5
a543 1
//	SetAPen(RP,2);
d545 2
a546 2
	Move(RP,X-1,Y+5);
	Draw(RP,X-1,Y+6);
d548 1
a548 1
	Draw(RP,X2+1,Y+6);
d550 5
a554 33
	Draw(RP,X2+2,Y+5);
}

//*******************************************************************
VOID DrawLRKnobRail(struct RastPort *RP,struct Gadget *Prop)
{
	LONG X,Y,X2,Y2,KnobX,KnobX2,*L;

	Y = Prop->TopEdge + ((Prop->Height - RAIL_H)>>1);
	Y2 = Y + RAIL_H - 1;
	X = Prop->LeftEdge;
	X2 = ((struct Image *)Prop->GadgetRender)->Width; // X2 temp
	KnobX = Prop->Width - X2;
	KnobX = ((((struct PropInfo *)Prop->SpecialInfo)->HorizPot * KnobX)
		/ MAXPOT) + X;
	KnobX2 = KnobX + X2;
	X2 = Prop->LeftEdge + Prop->Width - 1;
	L = LRRailColor;

	Forbid();
	for (; Y <= Y2; Y++) {
		SetAPen(RP,*L++);
		if (X != KnobX) {
			Move(RP,X,Y);
			Draw(RP,KnobX,Y);
		}
		if (X2 != KnobX) {
			Move(RP,KnobX2,Y);
			Draw(RP,X2,Y);
		}
	}
	Permit();
	WaitBlit();
a824 14
			if( PLine->Flags&PL_FLYER )
			{
				field = (ULONG)(*PLine->Param)<<1;
				MaxField=GetValue(CurFG,0x80000000|TAG_RecFields)-ENDFUDGE;
				if(field > MaxField) field=MaxField;
				if(field < MIN_FIELD) field = MIN_FIELD;
				MyRCB->Frame = field;
				MyRCB->Max = MaxField;
				MyRCB->Min = MIN_FIELD;
				MyRCB->FG = CurFG;
				MyRCB->win = Window;
				MyRCB->gad = ThisG;
				DHD_Jump(0,MyRCB);
			}
d871 1
a871 1
	if (Window) DrawLRKnobRail(Window->RPort,PLine->PropGadg);
d888 1
a888 1
		if (Window) DrawLRKnobRail(Window->RPort,PLine->PropGadg);
d931 1
d1009 1
a1009 1
	DrawLRKnobRail(win->RPort,PLine->PropGadg);
d1021 9
d1031 1
d1036 8
a1043 3
				DrawLRKnobRail(RP,ThisG);
				UpdateParam(PLine,Window);
//				UpdateAllDiff(RP,Start,Window);
d1060 1
d1066 1
a1066 1
				DrawLRKnobRail(RP,ThisG);
d1106 5
d1217 9
d1273 5
d1587 1
d1597 1
a1597 1
		NewG->TopEdge = (*ThisG)->TopEdge-3;
d1654 1
a1654 1
	DrawLRKnobRail(win->RPort,PLine->PropGadg);
d1671 1
a1671 1
				DrawLRKnobRail(RP,ThisG);
d1707 1
a1707 1
				DrawLRKnobRail(RP,ThisG);
a2587 1

a2600 14

/*
		if(GadInd)
		{
			if( (A=GadIndex[0]) && (A==Lines) )
				In=PLine->StrGadg;
			if( (A=GadIndex[1]) && (A==Lines) )
				Out=PLine->StrGadg;
			if( (A=GadIndex[2]) && (A==Lines) )
				Del=PLine->StrGadg;
			if( (A=GadIndex[3]) && (A==Lines) )
				Len=PLine->StrGadg;
		}
*/
d2647 9
d2695 10
d2718 5
a2722 4
					if (Down) {
						DrawLRKnobRail(RP,Down);
						UpdateParam((struct PanelLine *)Down->UserData,Window);
//						UpdateAllDiff(RP,Start,Window);
d2728 9
d2739 1
a2739 1
//						if(B=DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG))
d2742 1
a2742 1
					PLine = (struct PanelLine *)ThisG->UserData;
d2805 6
d2825 6
d2841 6
d2858 6
d3068 1
a3068 4
	DUMPUDECL("DHD_Record( ",Unit,",");
	DUMPUDECL(" ",Start ,",");
	DUMPUDECL(" ",Stop,",");
	DUMPHEXIL(" ",Flags ," ); \\ ");
d3077 1
a3077 1
ULONG	DHD_Play(ULONG Unit, struct RenderCallBack	*rcb)
d3079 1
a3079 5
	DUMPUDECL("DHD_Play( ",Unit,",");
	DUMPUDECL(" ",Start ,",");
	DUMPUDECL(" ",Length,",");
	DUMPHEXIL(" ",FG ," ); \\ ");

d3085 1
a3085 1
void	DHD_Jump(ULONG Unit, struct RenderCallBack	*rcb)
d3087 5
a3091 3
	DUMPUDECL("DHD_Jump( ",Unit,",");
	DUMPUDECL(" ",Spot ,",");
	DUMPHEXIL(" ",FG ," ); \\ ");
d3093 4
a3101 2
LONG MaxBlock=0x7ff000,StartBlock=0x7b5000;

d3118 1
a3118 1
	void __asm (*RenderFn)(register __d0 ULONG, register __a0 APTR);
d3130 1
a3130 2

void __asm RenderFunc(REG(d0) ULONG Frame, REG(a0) struct RenderCallBack *Call)
d3132 15
a3146 8
	ULONG A,Val=Frame;
	struct Gadget *Time = (Call->gad)->NextGadget;
	SetPropHorizPot(Call->gad,Call->win,Frame,0,Call->Max);
	A = RemoveGadget(Call->win,Time);
	LongToTime((ULONG *)&Val,((struct StringInfo *)Time->SpecialInfo)->Buffer);
	AddGadget(Call->win,Time,A);
	RefreshGList(Time,Call->win,NULL,1);
}
d3149 1
a3149 2
struct EditWindow *HandleNewClip(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
d3151 1
a3151 1
  DoNewClipPanel(Edit,NULL);
a3194 12

/* 		if(GadInd)
		{
			if(Avail==(struct PanelLine *)8) Avail=PLine;
			if( (A=GadIndex[3]) && (A==Lines) )
			{
				Avail = (struct PanelLine *) 8;  // avail will be next line
				Len=PLine->StrGadg;
			}
		}
*/

d3380 1
a3380 1
						DrawLRKnobRail(RP,Down);
a3589 24

		}


/*
		if(GadInd)
		{
			if( (A=GadIndex[0]) && (A==Lines) )
			{
				In=PLine->StrGadg;
				InPL = PLine;
			}
			if( (A=GadIndex[1]) && (A==Lines) )
			{
				Out=PLine->StrGadg;
				OutPL = PLine;
			}
			if( (A=GadIndex[2]) && (A==Lines) )
			{
				String=PLine->StrGadg;
				StrPL = PLine;
			}
			if( (A=GadIndex[3]) && (A==Lines) )
				LenPL=PLine;
a3590 2
*/

d3770 1
a3770 1
						DrawLRKnobRail(RP,Down);
@


2.16
log
@Changed SendSwitcherReply calls to work with new ESParams structures.
Disabled some obsolete calls for record, shuttle etc.
@
text
@d2 6
a7 2
* $Id: panel.c,v 2.15 1994/08/30 09:45:06 CACHELIN4000 Exp Kell $
* $Log: panel.c,v $
d84 1
a84 1

d117 1
d144 1
a144 1

d159 2
d833 1
a833 1

d837 2
a838 2
	LONG A ; //, MaxField;
//	ULONG field;
d845 1
a845 3

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!!!~~~~~~~~~~~~~~~~~~~~~~~~~`
			if ( (PLine==&ClipPL[CLIP_TIME]) || (PLine==&ClipPL[CLIP_TIME+1]) )
d850 8
a857 2
				if(field < 0) field = 0;
				DHD_Jump(InOrOut,field,(ULONG)CurFG);
a858 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

d2562 1
a2562 1
	BOOL Going = TRUE;
d2585 16
d2612 1
d2719 1
d2722 2
a2723 2
						if(B=DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG))
							*LastTime->Param=B;
a2990 7
ULONG	DHD_Init(ULONG ,ULONG);
ULONG	DHD_Record(ULONG ,ULONG, ULONG, ULONG);
void	DHD_Abort(ULONG);
ULONG	DHD_Play(ULONG,ULONG,ULONG,ULONG);
void	DHD_Jump(ULONG,ULONG,ULONG);
void	Main2Blank();

d3014 1
a3014 1
	SendSwitcherReply(ES_AbortRecord,NULL);
d3039 1
a3039 1
ULONG	DHD_Play(ULONG Unit, ULONG Start, ULONG Length, ULONG FG)
d3046 2
a3047 3
// THIS NEEDS WORK.  NOW HAVE DIFFERENT PARAMETERS!!!!!
//	return( (ULONG)(SendSwitcherReply(ES_Shuttle,FG,Unit,0)>>1) ); // Fields->Frames
	return( (ULONG)(SendSwitcherReply(ES_Shuttle,NULL))); // Fields->Frames
d3051 1
a3051 1
void	DHD_Jump(ULONG Unit, ULONG Spot, ULONG FG)
d3057 2
a3058 3
// THIS NEEDS WORK.  NOW HAVE DIFFERENT PARAMETERS!!!!!
//	SendSwitcherReply(ES_Jog,FG,Unit,Spot);
	SendSwitcherReply(ES_Jog,NULL);
d3078 1
d3080 3
a3082 1
	void __asm (*RenderFn)(REG(d0) ULONG, REG(a0) APTR);
d3085 1
d3089 1
d3126 1
a3126 1
	DHD_InitRecord(0,0xc0ded00d);
d3144 10
a3153 1
		if(GadInd)
d3162 2
d3358 2
a3359 2
						if(B=DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG))
							*LastTime->Param=B;
d3500 1
a3500 1
	DHD_InitPlay(0,0xbadb00b1);
d3539 25
d3584 2
@


2.15
log
@Change ES_Messages to use ESparams struct
@
text
@d2 5
a6 2
* $Id: Panel.c,v 2.14 94/08/27 16:41:14 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Panel.c,v $
d3028 1
a3028 1
	return( (ULONG)(SendSwitcherReply(ES_Shuttle,NULL) ); // Fields->Frames
@


2.14
log
@reverse Continue, Cancel positions
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.13 94/08/24 12:06:31 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d109 4
d2852 5
a2856 1
	if(FG) c=SendSwitcherReply(ES_GetValue,(LONG)FG,TagID,0);
d2862 5
a2866 1
	if(FG) return(SendSwitcherReply(ES_GetValue,(LONG)FG,TagID,0));
d2876 6
a2881 1
	if(FG) c=SendSwitcherReply(ES_PutValue,(LONG)FG,TagID,Value);
d2888 6
a2893 1
	if(FG) return(SendSwitcherReply(ES_PutValue,(LONG)FG,TagID,Value));
d2973 1
a2973 1
	SendSwitcherReply(ES_InitRecord,0,0,0);
d2983 1
a2983 1
	SendSwitcherReply(ES_InitPlay,0,0,0);
d2991 1
a2991 1
	SendSwitcherReply(ES_AbortRecord,0,0,0);
d2998 1
a2998 1
	SendSwitcherReply(ES_Main2Blank,0,0,0);
d3008 3
a3010 1
	return((ULONG)SendSwitcherReply(ES_Record,Start,Stop,0));
d3022 4
a3025 1
	return( (ULONG)(SendSwitcherReply(ES_Shuttle,FG,Unit,0)>>1) ); // Fields->Frames
d3034 4
a3037 1
	SendSwitcherReply(ES_Jog,FG,Unit,Spot);
@


2.13
log
@Add Audio Fine-tune to clip panel
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.12 94/07/27 20:47:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d2489 1
a2489 1
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_DARK_CONTINUE))))
d2494 1
a2494 1
		con=NewG;
d2496 2
a2497 2
	} else return(con);
	if ((NewG = AllocOneGadget(FindGadget(&Gadget1,ID_REQ_DARK_CANCEL))))
d2502 1
a2502 1
		can=NewG;
d2513 2
a2514 2
			NewG->LeftEdge = can->LeftEdge + can->Width;
			NewG->LeftEdge += (con->LeftEdge - NewG->LeftEdge - NewG->Width)>>1 ;
d2524 1
a2524 1
	return( con );
@


2.12
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.11 94/07/22 11:41:18 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d2430 1
a2430 1
		if (PLine->Align == PNL_CENTER) 
d2451 15
a2465 1
	NewBorderBox(win->RPort,PNL_X1,H+4,ClipNW.Width-PNL_X1,H+4+PNL_DIV,BOX_REV);
a3439 1
	struct IntuiText	*itxt;
@


2.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.10 94/07/11 17:58:46 CACHELIN4000 Exp Locker: CACHELIN4000 $
a3 5
*Revision 2.10  94/07/11  17:58:46  CACHELIN4000
**** empty log message ***
*
*Revision 2.9  94/07/06  22:35:58  CACHELIN4000
*unchanged
d3499 2
a3500 1
	itxt = AllocIntuiText(PAL_BLACK,PAL_LGRAY,1,4,"Record Panel");
d3506 1
a3506 1
	}
@


2.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.9 94/07/06 22:35:58 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d97 1
d3428 1
d3496 1
d3504 7
@


2.9
log
@unchanged
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.8 94/07/06 21:49:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d126 1
a126 1
BOOL	Wide=FALSE,UseDropFrame=TRUE;
d651 1
d653 1
a653 1
ULONG DropFrames(ULONG	ticks)
d655 4
a658 5
	ULONG	mins;      // return(17981*ticks/18000);
	mins=ticks/1800;  // 60 secs/min * 30 frames/secs
	return( ticks + (mins*2) // drop 2 frames every minute
					- mins/10				// ... except the 10th
	);
d663 1
a663 1
	ULONG	mins;      // return(18000*ticks/17981);
d666 1
a666 1
					+ mins/10				// ... except the 10th
d689 4
a692 7
	if(a!=*L)
	{
		DUMPSTR("{L2T}		Time Code: ");
		DUMPSTR(T);
		DUMPUDECL(" Frames: ",*L," ");
		DUMPUDECL("Time (Secs/30):",a,"\\");
	}
a901 1

d903 1
a903 1
//	All PLine types have their Create(), Draw(), Handle(), and Destroy()
d1098 1
a1098 4
				FixTimeStr(PLine,Window);
//				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
//				L = PLine->Param;
//				TimeToLong(ch,(ULONG *)L); // update long & flush bogus values
a1099 1
//				UpdatePanStr(PLine,Window);
d1249 1
a1249 1
//				TimeToLong(ch,(ULONG *)L); // update long & flush bogus values
d1251 1
a1251 1
				FixTimeStr(PLine,Window);
d2898 1
a2898 1
//				SendSwitcher(ES_StartControl,FG,0,0);
d2901 1
a2901 1
//				SendSwitcher(ES_StopControl,FG,0,0);
d2929 1
a2929 1
	SendSwitcher(ES_InitRecord,0,0,0);
d2939 1
a2939 1
	SendSwitcher(ES_InitPlay,0,0,0);
d2947 1
a2947 1
	SendSwitcher(ES_AbortRecord,0,0,0);
d2954 1
a2954 1
	SendSwitcher(ES_Main2Blank,0,0,0);
d3334 3
a3336 2
								if(B & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
									Y = *(LastTime->Param) - 30;
d3338 8
a3345 5
									Y = *(LastTime->Param) - (LastTime->PropEnd - LastTime->PropStart)/10+1;
									//Y = *(LastTime->Param) - 300;
								else
									Y = *(LastTime->Param) - 1;
								*(LastTime->Param) = (Y>=LastTime->PropStart ? Y:LastTime->PropStart);
a3355 1
									// Y = *(LastTime->Param) + 300;
d3613 1
d3676 1
d3680 1
d3683 3
d3687 1
d3693 1
d3698 1
a3829 1
									// Y = *(LastTime->Param) + 300;
@


2.8
log
@Record Panel tweaks, drop-frame fix
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.7 94/07/04 18:34:12 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
@


2.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.6 94/06/22 10:45:00 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 1
d120 1
a120 1
BOOL	Wide=FALSE,UseDropFrame=FALSE;
d550 56
d609 2
a610 2
	ULONG A = 0,B = 0,Z[5] = {0,0,0,0,0},*P;
	char c;
d630 11
a640 1
//	if(UseDropFrame) *L=DropFrames(*L);
d643 3
a645 1
// convert from 30 ticks/sec time to drop-frame SMPTE 29.94 fps
d650 2
a651 2
	return( ticks - (mins*2) // drop 2 frames every minute
					+ mins/10				// ... except the 10th
d657 5
a661 1
	return(18000*ticks/17981);
d668 1
a668 1
	ULONG A=0,B=0,C=0,H=0;
d672 17
a688 8
		A = *L;
		if(UseDropFrame) A=DropFrames(*L);
		H = A/108000;
		A	%= 108000;
		B = A / 1800;  // 60 secs/min * 30 frames/secs
		A %= 1800;
		C = A / 30;
		A %= 30;
a689 2
	sprintf(T,"%02ld:%02ld:%02ld:%02ld",H,B,C,A);

d1025 2
a1026 2
	ULONG	Y,*L;
	char *ch;
d1096 4
a1099 4
				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
				L = PLine->Param;
				TimeToLong(ch,(ULONG *)L); // update long & flush bogus values
//				if(temp=(struct PanelLine *)PLine->Param2) UpdateFXSpeed(temp,3,Window);
d1101 1
a1101 1
				UpdatePanStr(PLine,Window);
d1204 2
a1205 2
	ULONG	Y,*L;
	char *ch;
d1249 5
a1253 4
				ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
				L = PLine->Param;
				TimeToLong(ch,(ULONG *)L); // update long & flush bogus values
				UpdatePanStr(PLine,Window);
a3032 657
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~``

	struct Window *Window;
	struct ClipDisplay	*ClipDisp=NULL;
	struct NewClip	*cl=NULL,*tcl=NULL;
	struct Gadget *Gadget,*Cancel=NULL,*Record,*Stop,*Aud1,*String,*Play,*Rew,*FFwd,*Pause,
		*Aud2,*Aud3,*Max,*Start,*qual,*In,*Out,*Down,*InStr,*OutStr,CDisp,*Clips;
	struct RastPort *RP;
	char	*mx_val,*st_val,dur[]="000:00:00:00",*ms[4] , *ms0="Return To Panel",*ms1= " .. Dude?";
	BOOL Going = TRUE, Expert=FALSE,VRec=TRUE,LARec=TRUE,RARec=TRUE;
	WORD ID,A,InNotOut=0,tx,ty;
	ULONG	tIn=0,tOut=512,t; //,LScale=MAXPOT/tOut;

	DHD_InitRecord(0,0xc0ded00d);

	if( IntuiMsg->Qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
		Expert=TRUE;

	ClipNW.Screen = EditScreen;
	ClipNW.Width = 484;
	ClipNW.Height = 332;
	if(Expert)	ClipNW.Height += 64;

	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = (EditScreen->Height - ClipNW.Height)/2;
	ClipNW.FirstGadget = NULL;

//	Gadget = FindGadget(&Gadget1,ID_REQ_DARK_CANCEL);
	Gadget = FindGadget(&Gadget1,ID_DARK_CONTINUE);
	if (!(Cancel = AllocOneGadget(Gadget))) goto ErrExit;
	Cancel->TopEdge = (ClipNW.Height-Cancel->Height-6);
//	Cancel->LeftEdge = (ClipNW.Width-Cancel->Width-6);
	Cancel->LeftEdge = (ClipNW.Width-Cancel->Width)>>1;
	Cancel->NextGadget = &StringGadg;

	StringGadg.TopEdge = 2 + (3*LINE_HEIGHT);
	StrExt.Font = EditFont;
	strbuf[0] = strubuf[0] = 0;
	StrInf.BufferPos = StrInf.DispPos = 0;
	strcat(strbuf,"Clip_1");
	StringGadg.Width = 160;
	StringGadg.LeftEdge = ((ClipNW.Width - StringGadg.Width)>>1);
	if (!(String = AllocOneGadget(&StringGadg))) goto ErrExit;
	Cancel->NextGadget = String;
	if(Expert)
	{
		if (!(Start = AllocOneGadget(&StringGadg))) goto ErrExit;
		String->NextGadget = Start;
		Start->Width=100;
		Start->Height=TEXT_HEIGHT;
		Start->LeftEdge = ((ClipNW.Width-Start->Width)>>1);
		Start->TopEdge = StringGadg.TopEdge + StringGadg.Height + 12 + LSP;
		st_val = ((struct StringInfo *)Start->SpecialInfo)->Buffer;
		stcl_h(st_val,StartBlock);
		Start->GadgetID=ST_ID;

		if (!(Max = AllocOneGadget(&StringGadg))) goto ErrExit;
		Start->NextGadget = Max;
		Max->Width=100;
		Max->Height=TEXT_HEIGHT;
		Max->LeftEdge = ((ClipNW.Width-Max->Width)>>1);
		Max->TopEdge = Start->TopEdge + Start->Height + 4 + LSP;
		mx_val = ((struct StringInfo *)Max->SpecialInfo)->Buffer;
		stcl_h(mx_val,MaxBlock);
		Max->GadgetID=MX_ID;
	}
	else Max=String;

	Gadget = FindGadget(&Gadget1,ID_VCR_REC);
	if (!(Record = AllocOneGadget(Gadget))) goto ErrExit;
	Max->NextGadget = Record;
	Record->LeftEdge = (ClipNW.Width>>1)-(4*Record->Width) - 8;
	Record->TopEdge = Max->TopEdge + Max->Height + 8 + LSP;

	Gadget = FindGadget(&Gadget1,ID_REQ_STOP);
	if (!(Stop = AllocOneGadget(Gadget))) goto ErrExit;
	Stop->LeftEdge = (ClipNW.Width>>1) -(3*Record->Width) - 8;
	Stop->TopEdge = Record->TopEdge;
	Record->NextGadget = Stop;

	Gadget = FindGadget(&Gadget1,ID_VCR_REW);
	if (!(Rew = AllocOneGadget(Gadget))) goto ErrExit;
	Rew->LeftEdge = (ClipNW.Width>>1) -(2*Rew->Width);
	Rew->TopEdge = Record->TopEdge;
	Stop->NextGadget = Rew;

	Gadget = FindGadget(&Gadget1,ID_VCR_PAUSE);
	if (!(Pause = AllocOneGadget(Gadget))) goto ErrExit;
	Pause->LeftEdge = (ClipNW.Width>>1) -(Rew->Width);
	Pause->TopEdge = Record->TopEdge;
	Rew->NextGadget = Pause;

	Gadget = FindGadget(&Gadget1,ID_VCR_PLAY);
	if (!(Play = AllocOneGadget(Gadget))) goto ErrExit;
	Play->LeftEdge = (ClipNW.Width>>1) ;
	Play->TopEdge = Record->TopEdge;
	Pause->NextGadget = Play;

	Gadget = FindGadget(&Gadget1,ID_VCR_FFWD);
	if (!(FFwd = AllocOneGadget(Gadget))) goto ErrExit;
	FFwd->LeftEdge = (ClipNW.Width>>1) +(Rew->Width);
	FFwd->TopEdge = Record->TopEdge;
	Play->NextGadget = FFwd;

	Gadget = FindGadget(Edit->Gadgets,ID_POPUP_DISP);
	if (!(qual = AllocOneGadget(Gadget))) goto ErrExit;
	qual->LeftEdge = ((ClipNW.Width-qual->Width)>>1);
	qual->TopEdge = Record->TopEdge+Record->Height + LSP;
	qual->NextGadget = NULL;
	qual->GadgetID = 0x400+ID_POPUP_DISP;
	QualPL.G1=qual;
	QualPL.PropStart=DEF_QUALITY;
	QualPL.PropEnd=QUAL_NUM;
	CurPLine=&QualPL;
//	Stop->NextGadget = qual;
	FFwd->NextGadget = qual;

	Gadget = FindGadget(&Gadget1,ID_BOOL);
	if (!(Aud1 = AllocOneGadget(Gadget))) goto ErrExit;
	Aud1->LeftEdge =  ClipNW.Width/4 - (Aud1->Width)/2;
	Aud1->TopEdge = qual->TopEdge+qual->Height + LSP;
	Aud1->GadgetID = aud1_ID;
	if(!VRec) Aud1->Flags &= (~GFLG_SELECTED);
	else Aud1->Flags |= GFLG_SELECTED;
	Aud1->NextGadget = NULL;
	qual->NextGadget = Aud1;
	if (!(Aud2 = AllocOneGadget(Gadget))) goto ErrExit;
	Aud2->LeftEdge = Aud1->LeftEdge + ClipNW.Width/4;
	Aud2->TopEdge = Aud1->TopEdge;
	Aud2->GadgetID = aud2_ID;
	if(!LARec) Aud2->Flags &= (~GFLG_SELECTED);
	else Aud2->Flags |= GFLG_SELECTED;
	Aud2->NextGadget = NULL;
	Aud1->NextGadget = Aud2;

	if (!(Aud3 = AllocOneGadget(Gadget))) goto ErrExit;
	Aud3->LeftEdge = Aud2->LeftEdge + ClipNW.Width/4;
	Aud3->TopEdge = Aud1->TopEdge;
	Aud3->GadgetID = aud3_ID;
	if(!RARec) Aud3->Flags &= (~GFLG_SELECTED);
	else Aud3->Flags |= GFLG_SELECTED;
	Aud3->NextGadget = NULL;
	Aud2->NextGadget = Aud3;

// Slider->NextGadget MUST be corresponding Time string gadget
	if (!(In = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))	goto ErrExit;
	In->GadgetID = IN_ID;
	In->LeftEdge = 16;
	In->TopEdge = Aud3->TopEdge + Aud3->Height + (LSP<<1) + TEXT_HEIGHT + LSP + (LSP>>1);
	In->Height = 16;
	In->Width = ClipNW.Width - 32;
//	In->Width = ClipNW.Width - 32 -140;
	((struct PropInfo *)In->SpecialInfo)->HorizBody =  MAXPOT>>4;
	((struct PropInfo *)In->SpecialInfo)->HorizPot = 0;
	Aud3->NextGadget = In;
	In->NextGadget = NULL;

	if (!(InStr = AllocOneGadget(&StringGadg))) goto ErrExit;
	InstallTCHook(InStr);
	InStr->GadgetID = INSTR_ID;
	InStr->LeftEdge = 16 + 40;
	InStr->TopEdge = Aud3->TopEdge + Aud3->Height + (LSP<<1) ;
	InStr->Height = TEXT_HEIGHT;
	InStr->Width = PTCSTRING_W;
	LongToTime(&tIn,((struct StringInfo *)InStr->SpecialInfo)->Buffer);
	InStr->NextGadget = NULL;
	In->NextGadget = InStr;

	if (!(Out = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))	goto ErrExit;
	Out->GadgetID = OUT_ID;
	Out->LeftEdge = In->LeftEdge;
//	Out->LeftEdge = In->LeftEdge+In->Width;
//	Out->TopEdge = In->TopEdge ;//+ In->Height + LSP + 32; // 32=clipdisp H
	Out->TopEdge = In->TopEdge + In->Height + LSP + 32; // 32=clipdisp H
	Out->Height = In->Height;
	Out->Width = In->Width;
//	Out->Width = (ClipNW.Width - 32) - In->Width;
	((struct PropInfo *)Out->SpecialInfo)->HorizBody =  MAXPOT>>4;
	((struct PropInfo *)Out->SpecialInfo)->HorizPot = 0;
	InStr->NextGadget = Out;
	Out->NextGadget = NULL;

	if (!(OutStr = AllocOneGadget(InStr))) goto ErrExit;
	InstallTCHook(OutStr);
	OutStr->LeftEdge = ClipNW.Width - 16 - 40 - InStr->Width;
	OutStr->GadgetID = OUTSTR_ID;
	LongToTime(&tIn,((struct StringInfo *)OutStr->SpecialInfo)->Buffer);
	Out->NextGadget = OutStr;
	OutStr->NextGadget = NULL;

	Clips=&CDisp;
	OutStr->NextGadget = Clips;
	Clips->NextGadget = NULL;
	Clips->GadgetRender = NULL;
	Clips->SelectRender = NULL;
	Clips->GadgetText = NULL;
	Clips->SpecialInfo = NULL;
	Clips->GadgetType = GTYP_BOOLGADGET;
	Clips->Flags=GFLG_GADGHNONE;
	Clips->Activation = GACT_RELVERIFY;
	Clips->GadgetID =	CD_ID;

OpenUp:
	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		RP = Window->RPort;
		SetDrMd(RP,JAM2);
    if(!ClipDisp)
		{
			if(!(ClipDisp=InitClipDisplay(16,In->TopEdge+In->Height+(LSP>>1),Window->Width-32,32,tOut,Window)))
				goto ErrExit;
		}
		else ClipDisp->RP=Window->RPort;

		Clips->LeftEdge = ClipDisp->X;	Clips->TopEdge = ClipDisp->Y;
		Clips->Width = ClipDisp->W;	Clips->Height = ClipDisp->H;

		if (Cancel) AddGList(Window,Cancel,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);

		StringBorder(RP,String);
		StringBorder(RP,InStr);
		StringBorder(RP,OutStr);
		NewBorderBox(RP,Record->LeftEdge-6,Record->TopEdge-4,
				Record->LeftEdge+(Record->Width<<1)+3,Record->TopEdge+Record->Height+3,BOX_REV);

		if(Expert)
		{
			NewBorderBox(RP,30,Start->TopEdge-12,//				Max->LeftEdge+Max->Width+10-1,
				Window->Width - 30,
				Max->TopEdge+Max->Height+11-1,
				BOX_REV);
			StringBorder(RP,Max);
			StringBorder(RP,Start);
		}
		if (Cancel) RefreshGList(Cancel,Window,NULL,-1);
		RedrawPopText(Window);
		DrawClipDisplay(ClipDisp);
//		InitLRKnobRail(RP,In);  // really necessary ???
		InitLRKnobRail(RP,Out);
		DrawLRKnobRail(RP,In);
		DrawLRKnobRail(RP,Out);

		SetFont(RP,DarkFont);
		Move(RP,36,qual->TopEdge+13);
		SafeColorText(RP,"Quality:",8);
		SafeFitText(RP,RecMsg,strlen(RecMsg),ClipNW.Width,FALSE);
		Move(RP,(ClipNW.Width-LastExtent.te_Width)/2,LINE_HEIGHT+TEXT_BASE);
		SafeFitText(RP,RecMsg,strlen(RecMsg),ClipNW.Width,TRUE);
		if(Expert)
		{
			Move(RP,36,Max->TopEdge+8);
			SafeColorText(RP,"End: ",5);
			Move(RP,36,Start->TopEdge+8);
			SafeColorText(RP,"Start: ",7);
		}
		Move(RP,36,Aud1->TopEdge+13);
		SafeColorText(RP,"Video",5);
		Move(RP,12+Aud1->LeftEdge+Aud1->Width,Aud1->TopEdge+13);
		SafeColorText(RP,"Audio L",7);
		Move(RP,12+Aud2->LeftEdge+Aud2->Width,Aud1->TopEdge+13);
		SafeColorText(RP,"Audio R",7);
		Move(RP,InStr->LeftEdge-24,InStr->TopEdge+8);
		SafeColorText(RP,"In",2);
		Move(RP,OutStr->LeftEdge-32,OutStr->TopEdge+8);
		SafeColorText(RP,"Out",3);

		tx= InStr->LeftEdge+InStr->Width+10;
		ty=OutStr->TopEdge+8;
		Move(RP,tx,ty);
		SafeColorText(RP,"Time: ",6);
		t=tOut-tIn;
		LongToTime(&t,dur);
		SafeColorText(RP,dur,11);

		Divider(Window,String->TopEdge - LSP - 4 );
		Divider(Window,InStr->TopEdge - LSP );
		Divider(Window,Cancel->TopEdge - LSP );

		goto GetEm;
		while (Going) {
				WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
				switch(IntuiMsg->Class) {
				case IDCMP_GADGETUP:
					Down=NULL;
					ID = ((struct Gadget *)IntuiMsg->IAddress)->GadgetID;
					DUMPUDECW("Gad Id: ",ID - ID_BOOL,"\\");
					switch(ID)
					{
						case ID_REQ_RECORD:
							DHD_Record(0,StartBlock,MaxBlock,0xc0edbabe);
							break;
						case ID_REQ_STOP:
							if(cl) cl->type=CLIP_LOCKED;
							if(cl=AddClip(ClipDisp,40,162,CLIP_ACTIVE,"BuzClip"))
							{
								DrawClipDisplay(ClipDisp);
								UpdateClipSlider(ClipDisp,In,Window,cl->in);
								DrawLRKnobRail(RP,In);
								UpdateClipSlider(ClipDisp,Out,Window,cl->out);
								DrawLRKnobRail(RP,Out);
								UpdateTime(InStr,Window,cl->in);
								UpdateTime(OutStr,Window,cl->out);

									A = RemoveGadget(Window,String);
									strncpy(((struct StringInfo *)String->SpecialInfo)->Buffer,cl->Name,CLIP_NAME_MAX-1);
									AddGadget(Window,String,A);
									RefreshGList(String,Window,NULL,1);

							}
							DHD_Abort(0);
							break;
						case ID_REQ_DARK_CANCEL:
							DHD_Abort(0);
							Going = FALSE;
							break;
						case ID_DARK_CONTINUE:
							DHD_Abort(0);
							Going = FALSE;
							break;
						case aud1_ID:
							VRec = !(VRec);
							break;
						case aud2_ID:
							LARec = !(LARec);
							break;
						case aud3_ID:
							RARec = !(RARec);
							RemoveGList(Window,Cancel,-1);
							CloseWindow(Window);
							ms[0]=ms0;
							ms[1]=ms1;
							SimpleRequest(EditTop->Window,ms,2,REQ_H_CENTER|REQ_CENTER,&t);
							goto OpenUp;
							break;
						case ST_ID:
							stch_l(st_val,&StartBlock);
							break;
						case MX_ID:
							stch_l(mx_val,&MaxBlock);
							break;

						case STRING_ID:
							if(strcmp(((struct StringInfo *)String->SpecialInfo)->Buffer,cl->Name))
								strncpy(cl->Name,((struct StringInfo *)String->SpecialInfo)->Buffer,CLIP_NAME_MAX-1);
							break;

						case CD_ID:
							if(cl)
							{
								t=((IntuiMsg->MouseX - ClipDisp->X)*0xFFFF)/ClipDisp->Scale;
								t&=~1;
								DUMPUDECW("MouseX= ",(WORD)IntuiMsg->MouseX,"  ");
								DUMPUDECL("t = ",(LONG)t,"\\");
								if( !(tcl=GetClip(ClipDisp,t)) )
									tcl=AddClip(ClipDisp,t,t+STILL_QUANT,CLIP_ACTIVE,"NewClip");
								if(tcl)
								{
									cl->type=CLIP_LOCKED;
									tcl->type=CLIP_ACTIVE;
									cl=tcl;
									InNotOut=0;
									DrawClipDisplay(ClipDisp);
									UpdateClipSlider(ClipDisp,In,Window,cl->in);
									DrawLRKnobRail(RP,In);
									UpdateClipSlider(ClipDisp,Out,Window,cl->out);
									DrawLRKnobRail(RP,Out);
									UpdateTime(InStr,Window,cl->in);
									UpdateTime(OutStr,Window,cl->out);

									A = RemoveGadget(Window,String);
									strncpy(((struct StringInfo *)String->SpecialInfo)->Buffer,cl->Name,CLIP_NAME_MAX-1);
									AddGadget(Window,String,A);
									RefreshGList(String,Window,NULL,1);

									Move(RP,tx,ty);
									SafeColorText(RP,"Time: ",6);
									t=cl->out - cl->in;
									LongToTime(&t,dur);
									SafeColorText(RP,dur,11);
									SafeColorText(RP,"  ",2);

								}
							}
							break;
						case INSTR_ID:
							DUMPSTR("In String Gad Up! ...  ") ;
							InNotOut=1;
							TimeToLong(((struct StringInfo *)InStr->SpecialInfo)->Buffer,&t);
							if( (t!=tIn) && SetClip(ClipDisp,cl,t,cl->out) )
							{
								DUMPSTR((UBYTE *)((struct StringInfo *)InStr->SpecialInfo)->Buffer);
								DUMPUDECL(" = ",(LONG)t,"\\");
								tIn=cl->in;
								A = RemoveGadget(Window,InStr);
								LongToTime((ULONG *)&tIn,((struct StringInfo *)InStr->SpecialInfo)->Buffer);
								DUMPSTR((UBYTE *)((struct StringInfo *)InStr->SpecialInfo)->Buffer);
								DUMPUDECL(" = ",(LONG)tIn,"\\");
								AddGadget(Window,InStr,A);
								UpdateClipSlider(ClipDisp,In,Window,cl->in);
								DrawLRKnobRail(RP,In);
								RefreshGList(InStr,Window,NULL,1);
								DrawClipDisplay(ClipDisp);
									Move(RP,tx,ty);
									SafeColorText(RP,"Time: ",6);
									t=cl->out - cl->in;
									LongToTime(&t,dur);
									SafeColorText(RP,dur,11);
									SafeColorText(RP,"  ",2);
							}
							break;
						case OUTSTR_ID:
							DUMPMSG("Out String Gad Up!") ;
							InNotOut=0;
							TimeToLong(((struct StringInfo *)OutStr->SpecialInfo)->Buffer,&t);
							if( (cl) && (t!=tOut) && SetClip(ClipDisp,cl,cl->in,t) )
							{
								tOut=cl->out;
								A = RemoveGadget(Window,OutStr);
								LongToTime((ULONG *)&tOut,((struct StringInfo *)OutStr->SpecialInfo)->Buffer);
								AddGadget(Window,OutStr,A);
								UpdateClipSlider(ClipDisp,Out,Window,cl->out);
								DrawLRKnobRail(RP,Out);
								RefreshGList(OutStr,Window,NULL,1);
								DrawClipDisplay(ClipDisp);
									Move(RP,tx,ty);
									SafeColorText(RP,"Time: ",6);
									t=cl->out - cl->in;
									LongToTime(&t,dur);
									SafeColorText(RP,dur,11);
									SafeColorText(RP,"  ",2);
							}
							break;
						case IN_ID:
							InNotOut=1;
							t=(((struct PropInfo *)In->SpecialInfo)->HorizPot*ClipDisp->MaxVal)/MAXPOT;
							if(cl)
							{
								if(SetClip(ClipDisp,cl,t,cl->out))  // if changed
								{
									if(t!=cl->in) UpdateClipSlider(ClipDisp,In,Window,cl->in);
									UpdateTime(InStr,Window,cl->in);
									DrawClipDisplay(ClipDisp);
								}
								else if(t!=cl->in) // illegal move
								{
									UpdateClipSlider(ClipDisp,In,Window,cl->in);
									UpdateTime(InStr,Window,cl->in);
									DrawClipDisplay(ClipDisp);
								}

									Move(RP,tx,ty);
									SafeColorText(RP,"Time: ",6);
									t=cl->out - cl->in;
									LongToTime(&t,dur);
									SafeColorText(RP,dur,11);
									SafeColorText(RP,"  ",2);

							}
							DrawLRKnobRail(RP,In);
							break;
						case OUT_ID:
							InNotOut=0;
							t=(((struct PropInfo *)Out->SpecialInfo)->HorizPot*ClipDisp->MaxVal)/MAXPOT;
							if(cl)
							{
								if(SetClip(ClipDisp,cl,cl->in,t))
								{
									if(t!=cl->out) UpdateClipSlider(ClipDisp,Out,Window,cl->out);
									UpdateTime(OutStr,Window,cl->out);
									DrawClipDisplay(ClipDisp);
								}
								else if(t!=cl->out) // illegal move
								{
									UpdateClipSlider(ClipDisp,Out,Window,cl->out);
									UpdateTime(OutStr,Window,cl->out);
									DrawClipDisplay(ClipDisp);
								}

									Move(RP,tx,ty);
									SafeColorText(RP,"Time: ",6);
									t=cl->out - cl->in;
									LongToTime(&t,dur);
									SafeColorText(RP,dur,11);
									SafeColorText(RP,"  ",2);

							}
							DrawLRKnobRail(RP,Out);
							break;
					}
					break;

				case IDCMP_GADGETDOWN:
					Down=((struct Gadget *)IntuiMsg->IAddress);
					ID = Down->GadgetID;
					if (ID == ID_POPUP_DISP + 0x400)
						HandlePopUp(Window,IntuiMsg,&QualPL);
					else if (ID == ID_LR_KNOB)
					{
						DrawLRKnobRail(RP,Down);
					}
					break;

				case IDCMP_MOUSEMOVE:
					if (Down) {
						DrawLRKnobRail(RP,Down);
						t=(((struct PropInfo *)Down->SpecialInfo)->HorizPot*ClipDisp->MaxVal)/MAXPOT;
						if(Down->NextGadget)
							UpdateTime(Down->NextGadget,Window,t);
					}
					break;

				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					switch(A)
					{
						case	RAW_IN:
							ActivateGadget(InStr,Window,NULL);
							break;
						case	RAW_OUT:
							((struct StringInfo *)(OutStr->SpecialInfo))->BufferPos = 6;
							ActivateGadget(OutStr,Window,NULL);
							break;
						case	RAW_CUT:
							if(cl)
							{
								if(cl=KillClip(ClipDisp,cl))
									cl->type=CLIP_ACTIVE;
								DrawClipDisplay(ClipDisp);
								if(cl)
								{
									UpdateClipSlider(ClipDisp,In,Window,cl->in);
									DrawLRKnobRail(RP,In);
									UpdateClipSlider(ClipDisp,Out,Window,cl->out);
									DrawLRKnobRail(RP,Out);
									UpdateTime(InStr,Window,cl->in);
									UpdateTime(OutStr,Window,cl->out);
								}
							}
							break;
						case	RAW_LEFT:
							if(cl)
								if(InNotOut)
								{
                  if(SetClip(ClipDisp,cl,cl->in - JUMP_SIZE,cl->out))
									{
										DrawClipDisplay(ClipDisp);
										UpdateClipSlider(ClipDisp,In,Window,cl->in);
										DrawLRKnobRail(RP,In);
										UpdateClipSlider(ClipDisp,Out,Window,cl->out);
										DrawLRKnobRail(RP,Out);
										UpdateTime(InStr,Window,cl->in);
										UpdateTime(OutStr,Window,cl->out);
									}
								}
								else if(SetClip(ClipDisp,cl,cl->in,cl->out - JUMP_SIZE))
								{
									DrawClipDisplay(ClipDisp);
									UpdateClipSlider(ClipDisp,In,Window,cl->in);
									DrawLRKnobRail(RP,In);
									UpdateClipSlider(ClipDisp,Out,Window,cl->out);
									DrawLRKnobRail(RP,Out);
									UpdateTime(InStr,Window,cl->in);
									UpdateTime(OutStr,Window,cl->out);
								}
							break;
						case	RAW_RIGHT:
							if(cl)
								if(InNotOut)
								{
                  if(SetClip(ClipDisp,cl,cl->in + JUMP_SIZE,cl->out))
									{
										DrawClipDisplay(ClipDisp);
										UpdateClipSlider(ClipDisp,In,Window,cl->in);
										DrawLRKnobRail(RP,In);
										UpdateClipSlider(ClipDisp,Out,Window,cl->out);
										DrawLRKnobRail(RP,Out);
										UpdateTime(InStr,Window,cl->in);
										UpdateTime(OutStr,Window,cl->out);
									}
								}
								else if(SetClip(ClipDisp,cl,cl->in,cl->out + JUMP_SIZE))
								{
									DrawClipDisplay(ClipDisp);
									UpdateClipSlider(ClipDisp,In,Window,cl->in);
									DrawLRKnobRail(RP,In);
									UpdateClipSlider(ClipDisp,Out,Window,cl->out);
									DrawLRKnobRail(RP,Out);
									UpdateTime(InStr,Window,cl->in);
									UpdateTime(OutStr,Window,cl->out);
								}
							break;
						case RAW_ENTER: case RAW_RETURN:
						case RAW_ESCAPE: case RAW_HELP:
							Going = FALSE;
							break;
					}
					break;
				}
				ReplyMsg((struct Message *)IntuiMsg);
				}
		}
		if(ClipDisp) FreeClipDisplay(ClipDisp);
		CloseWindow(Window);
		WaitBlit();
	}
ErrExit:
	if (Cancel) {
		Cancel->NextGadget = NULL;
		FreeGadgets(Cancel);
	}
	if (String) {
		String->NextGadget = NULL;
		FreeGadgets(String);
	}
	if(Expert)
	{
		if (Max) {
			Max->NextGadget = NULL;
			FreeGadgets(Max);
		}
		if (Start) {
			Start->NextGadget = NULL;
			FreeGadgets(Start);
		}
	}
	if (Record) {
		Record->NextGadget = NULL;
		FreeGadgets(Record);
	}
	if (Stop) {
		FFwd->NextGadget = NULL;
		FreeGadgets(Stop);
	}
	if (Aud1) {
		Aud3->NextGadget = NULL;
		FreeGadgets(Aud1);
	}
	if (In) {
		InStr->NextGadget = NULL;
		FreeGadgets(In);
	}
	if (Out) {
		OutStr->NextGadget = NULL;
		FreeGadgets(Out);
	}
	DUMPUDECL("Max Block   = ",MaxBlock,"\\");
	DHD_InitPlay(0,0xbadb00b1);
	DUMPUDECL("Start Block = ",StartBlock,"\\");

~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

d3050 2
d3233 1
a3233 1
						break;
d3235 1
a3235 1
						break;
d3237 1
a3237 1
						break;
d3291 11
d3306 1
d3311 1
d3315 1
a3319 3
						case ID_BOOL:
							PLine->Param = (long *)( PLine->Param ? 0:1 ) ;  // invert value...
							break;
d3410 1
d3610 2
a3611 2
						case ID_VCR_REC:
						break;
a3612 1
						break;
d3645 1
a3645 1
					if( (A==IECODE_RBUTTON))
a3652 2
					DUMPMSG	("GADGETUP");

a3658 1
//						B=0;
a3659 5
//						if(PLine==OutPL)
//							B = SetClip(ClipDisp,cl,cl->in,*(PLine->Param));
//						else if(PLine==InPL) // set In
//							B = SetClip(ClipDisp,cl,*(PLine->Param),cl->out);
//						if(B)
d3663 4
a3666 1
							UpdatePanProp(PLine,Window);
d3672 9
d3686 1
d3691 1
a3691 3
							break;
						case ID_BOOL:
							PLine->Param = (long *)( PLine->Param ? 0:1 ) ;  // invert value...
a3718 2
//									*(InPL->Param) = cl->in;
//									*(OutPL->Param) = cl->out;
a3823 6

//								if(InOrOut) // set Out
//									B = SetClip(ClipDisp,cl,cl->in,*(LastTime->Param));
//								else // set In
//									B = SetClip(ClipDisp,cl,*(LastTime->Param),cl->out);

a3833 4
//									if(InOrOut) // set Out
//										B = SetClip(ClipDisp,cl,cl->in,Y);
//									else // set In
//										B = SetClip(ClipDisp,cl,Y,cl->out);
a3845 4
//									if(InOrOut) // set Out
//										B = SetClip(ClipDisp,cl,cl->in,Y);
//									else // set In
//										B = SetClip(ClipDisp,cl,Y,cl->out);
@


2.6
log
@Remove Control Panel data to Controls.c, left abstract panel code
@
text
@d2 1
a2 1
* $Id: Panel.c,v 2.5 94/06/08 16:17:55 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d73 1
a73 1
#define SERDEBUG	1
d93 1
d119 1
a119 1
BOOL	Wide=FALSE;
a136 22
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`


#ifdef PROTO_PASS
	PanHandler	PanHandlers[50];
#else
PanHandler	PanHandlers[] = {
  DoFXANIMPanel,
  DoFXILBMPanel,
  DoFXALGOPanel,
  DoFXCRPanel,
  DoVIDEOPanel,
  DoAUDIOPanel,
  DoCONTROLPanel,
  NULL,		// DoPROJECTPanel,
  DoFRAMESTOREPanel,
  DoKEYPanel,
  DoSCROLLPanel,
  DoCRAWLPanel,
	NULL } ;
#endif

a137 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */


a208 2
#define CLIP_NAME_MAX	42

d374 1
a374 1
void UpdateClipTime(struct ClipDisplay *cd,struct Gadget *Time,struct Window *Window,ULONG Val)
d383 1
a383 1
void	Box(struct RastPort *RP,UWORD	x,UWORD y,UWORD	w,UWORD h)
d395 1
a395 1
void	BoxClip(struct ClipDisplay	*cd,UWORD	x1,UWORD x2)
d573 16
d595 14
a608 1
	ULONG A,B,C,H;
a609 9
	if(*L&0x80000000) *L=0;  // Watch for pesky signed LONGs, limit max time code
	A = *L;
	H = A/108000;
	A	%= 108000;
	B = A / 1800;  // 60 secs/min * 30 frames/secs
	A %= 1800;
	C = A / 30;
	A %= 30;
	sprintf(T,"%02ld:%02ld:%02ld:%02ld",H,B,C,A);
d616 1
a616 1
	ULONG A,C;
d618 8
a625 4
	if(*L&0x80000000) *L=0;  // Watch for pesky signed LONGs, limit max time code
	A = *L;
	C = A / 30;
	A %= 30;
d1877 3
a1879 2
		if (PLine->Align == PNL_LEFT) A = PNL_X1;
		else
d1881 1
a1881 2
			B = strlen(PLine->Label);
			SafeFitText(win->RPort,PLine->Label,B,PNL_WIDTH,FALSE);
d1884 5
d1890 1
a1890 1
		SafeColorText(win->RPort,PLine->Label,strlen(PLine->Label));
d2741 2
d2925 1
a2925 1
/* ***************
d2951 3
d3258 2
a3259 2
								UpdateClipTime(ClipDisp,InStr,Window,cl->in);
								UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3324 2
a3325 2
									UpdateClipTime(ClipDisp,InStr,Window,cl->in);
									UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3398 1
a3398 1
									UpdateClipTime(ClipDisp,InStr,Window,cl->in);
d3404 1
a3404 1
									UpdateClipTime(ClipDisp,InStr,Window,cl->in);
d3426 1
a3426 1
									UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3432 1
a3432 1
									UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3465 1
a3465 1
							UpdateClipTime(ClipDisp,Down->NextGadget,Window,t);
d3492 2
a3493 2
									UpdateClipTime(ClipDisp,InStr,Window,cl->in);
									UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3508 2
a3509 2
										UpdateClipTime(ClipDisp,InStr,Window,cl->in);
										UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3519 2
a3520 2
									UpdateClipTime(ClipDisp,InStr,Window,cl->in);
									UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3534 2
a3535 2
										UpdateClipTime(ClipDisp,InStr,Window,cl->in);
										UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3545 2
a3546 2
									UpdateClipTime(ClipDisp,InStr,Window,cl->in);
									UpdateClipTime(ClipDisp,OutStr,Window,cl->out);
d3606 3
d3611 855
@


2.5
log
@*** empty log message ***
@
text
@Binary files Panel.c and t:,RCSt1A70d7800 differ
@


2.4
log
@Complete rework...
@
text
@Binary files Panel.c and t:,RCSt1A70d7fb0 differ
@


2.3
log
@*** empty log message ***
@
text
@Binary files Panel.c and t:,RCSt1A70d7d00 differ
@


2.2
log
@Comment out Audio Test code
@
text
@Binary files Panel.c and t:,RCSt1A702ce58 differ
@


2.1
log
@Comment out Audio Test code
@
text
@Binary files Panel.c and t:,RCSt1A702ce58 differ
@


2.0
log
@FirstCheckIn
@
text
@Binary files Panel.c and t:,RCSt1A70ec1a0 differ
@
