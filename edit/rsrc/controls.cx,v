head	2.147;
access;
symbols;
locks; strict;
comment	@*@;


2.147
date	95.02.27.09.33.53;	author CACHELIN4000;	state Exp;
branches;
next	2.146;

2.146
date	95.02.24.16.14.12;	author pfrench;	state Exp;
branches;
next	2.145;

2.145
date	95.02.24.11.48.35;	author CACHELIN4000;	state Exp;
branches;
next	2.144;

2.144
date	95.02.22.10.32.07;	author CACHELIN4000;	state Exp;
branches;
next	2.143;

2.143
date	95.02.21.12.19.54;	author CACHELIN4000;	state Exp;
branches;
next	2.142;

2.142
date	95.02.20.12.28.13;	author CACHELIN4000;	state Exp;
branches;
next	2.141;

2.141
date	95.02.19.16.41.44;	author CACHELIN4000;	state Exp;
branches;
next	2.140;

2.140
date	95.02.19.11.35.29;	author pfrench;	state Exp;
branches;
next	2.139;

2.139
date	95.02.19.11.27.06;	author pfrench;	state Exp;
branches;
next	2.138;

2.138
date	95.02.19.01.03.41;	author CACHELIN4000;	state Exp;
branches;
next	2.137;

2.137
date	95.02.14.10.46.12;	author CACHELIN4000;	state Exp;
branches;
next	2.136;

2.136
date	95.02.14.10.27.50;	author CACHELIN4000;	state Exp;
branches;
next	2.135;

2.135
date	95.02.13.14.38.09;	author CACHELIN4000;	state Exp;
branches;
next	2.134;

2.134
date	95.02.11.17.52.59;	author CACHELIN4000;	state Exp;
branches;
next	2.133;

2.133
date	95.02.10.15.27.46;	author Kell;	state Exp;
branches;
next	2.132;

2.132
date	95.02.01.17.54.31;	author CACHELIN4000;	state Exp;
branches;
next	2.131;

2.131
date	95.01.25.18.34.57;	author CACHELIN4000;	state Exp;
branches;
next	2.130;

2.130
date	95.01.24.18.05.37;	author CACHELIN4000;	state Exp;
branches;
next	2.129;

2.129
date	95.01.24.16.50.04;	author CACHELIN4000;	state Exp;
branches;
next	2.128;

2.128
date	95.01.24.11.19.50;	author CACHELIN4000;	state Exp;
branches;
next	2.127;

2.127
date	95.01.13.14.23.30;	author CACHELIN4000;	state Exp;
branches;
next	2.126;

2.126
date	95.01.12.12.03.52;	author CACHELIN4000;	state Exp;
branches;
next	2.125;

2.125
date	95.01.06.22.16.54;	author CACHELIN4000;	state Exp;
branches;
next	2.124;

2.124
date	95.01.05.17.54.15;	author CACHELIN4000;	state Exp;
branches;
next	2.123;

2.123
date	95.01.04.23.40.23;	author CACHELIN4000;	state Exp;
branches;
next	2.122;

2.122
date	95.01.04.17.36.29;	author CACHELIN4000;	state Exp;
branches;
next	2.121;

2.121
date	95.01.04.11.02.25;	author CACHELIN4000;	state Exp;
branches;
next	2.120;

2.120
date	94.12.31.02.05.06;	author CACHELIN4000;	state Exp;
branches;
next	2.119;

2.119
date	94.12.30.21.22.20;	author CACHELIN4000;	state Exp;
branches;
next	2.118;

2.118
date	94.12.30.13.09.58;	author CACHELIN4000;	state Exp;
branches;
next	2.117;

2.117
date	94.12.28.17.48.48;	author CACHELIN4000;	state Exp;
branches;
next	2.116;

2.116
date	94.12.24.12.33.41;	author CACHELIN4000;	state Exp;
branches;
next	2.115;

2.115
date	94.12.23.17.45.10;	author CACHELIN4000;	state Exp;
branches;
next	2.114;

2.114
date	94.12.23.15.01.55;	author CACHELIN4000;	state Exp;
branches;
next	2.113;

2.113
date	94.12.23.11.36.30;	author CACHELIN4000;	state Exp;
branches;
next	2.112;

2.112
date	94.12.23.10.08.47;	author CACHELIN4000;	state Exp;
branches;
next	2.111;

2.111
date	94.12.22.21.57.59;	author CACHELIN4000;	state Exp;
branches;
next	2.110;

2.110
date	94.12.21.17.33.10;	author CACHELIN4000;	state Exp;
branches;
next	2.109;

2.109
date	94.12.16.21.02.36;	author CACHELIN4000;	state Exp;
branches;
next	2.108;

2.108
date	94.12.15.16.42.59;	author CACHELIN4000;	state Exp;
branches;
next	2.107;

2.107
date	94.12.09.16.42.17;	author CACHELIN4000;	state Exp;
branches;
next	2.106;

2.106
date	94.12.08.16.08.38;	author CACHELIN4000;	state Exp;
branches;
next	2.105;

2.105
date	94.12.07.23.14.31;	author CACHELIN4000;	state Exp;
branches;
next	2.104;

2.104
date	94.12.07.00.12.22;	author CACHELIN4000;	state Exp;
branches;
next	2.103;

2.103
date	94.12.05.20.06.38;	author CACHELIN4000;	state Exp;
branches;
next	2.102;

2.102
date	94.12.05.19.21.30;	author CACHELIN4000;	state Exp;
branches;
next	2.101;

2.101
date	94.12.04.22.55.45;	author CACHELIN4000;	state Exp;
branches;
next	2.100;

2.100
date	94.12.03.18.36.24;	author CACHELIN4000;	state Exp;
branches;
next	2.99;

2.99
date	94.11.18.18.31.19;	author Kell;	state Exp;
branches;
next	2.98;

2.98
date	94.11.18.16.51.52;	author CACHELIN4000;	state Exp;
branches;
next	2.97;

2.97
date	94.11.16.15.13.23;	author CACHELIN4000;	state Exp;
branches;
next	2.96;

2.96
date	94.11.15.21.41.24;	author CACHELIN4000;	state Exp;
branches;
next	2.95;

2.95
date	94.11.10.00.31.47;	author CACHELIN4000;	state Exp;
branches;
next	2.94;

2.94
date	94.11.10.00.10.47;	author CACHELIN4000;	state Exp;
branches;
next	2.93;

2.93
date	94.11.09.18.50.38;	author CACHELIN4000;	state Exp;
branches;
next	2.92;

2.92
date	94.11.09.15.33.40;	author CACHELIN4000;	state Exp;
branches;
next	2.91;

2.91
date	94.11.09.15.05.07;	author CACHELIN4000;	state Exp;
branches;
next	2.90;

2.90
date	94.11.04.17.19.15;	author CACHELIN4000;	state Exp;
branches;
next	2.89;

2.89
date	94.11.04.00.31.17;	author CACHELIN4000;	state Exp;
branches;
next	2.88;

2.88
date	94.11.03.23.11.36;	author CACHELIN4000;	state Exp;
branches;
next	2.87;

2.87
date	94.11.03.11.08.07;	author CACHELIN4000;	state Exp;
branches;
next	2.86;

2.86
date	94.11.02.20.23.11;	author CACHELIN4000;	state Exp;
branches;
next	2.85;

2.85
date	94.11.01.18.57.35;	author CACHELIN4000;	state Exp;
branches;
next	2.84;

2.84
date	94.10.31.17.22.17;	author CACHELIN4000;	state Exp;
branches;
next	2.83;

2.83
date	94.10.28.16.52.01;	author CACHELIN4000;	state Exp;
branches;
next	2.82;

2.82
date	94.10.28.15.25.40;	author CACHELIN4000;	state Exp;
branches;
next	2.81;

2.81
date	94.10.28.11.57.26;	author CACHELIN4000;	state Exp;
branches;
next	2.80;

2.80
date	94.10.27.23.45.14;	author CACHELIN4000;	state Exp;
branches;
next	2.79;

2.79
date	94.10.25.20.01.18;	author CACHELIN4000;	state Exp;
branches;
next	2.78;

2.78
date	94.10.25.18.08.29;	author CACHELIN4000;	state Exp;
branches;
next	2.77;

2.77
date	94.10.24.17.20.32;	author CACHELIN4000;	state Exp;
branches;
next	2.76;

2.76
date	94.10.24.12.21.50;	author CACHELIN4000;	state Exp;
branches;
next	2.75;

2.75
date	94.10.21.23.21.52;	author CACHELIN4000;	state Exp;
branches;
next	2.74;

2.74
date	94.10.20.11.53.44;	author CACHELIN4000;	state Exp;
branches;
next	2.73;

2.73
date	94.10.14.13.39.08;	author CACHELIN4000;	state Exp;
branches;
next	2.72;

2.72
date	94.10.12.18.03.50;	author CACHELIN4000;	state Exp;
branches;
next	2.71;

2.71
date	94.10.12.17.34.59;	author CACHELIN4000;	state Exp;
branches;
next	2.70;

2.70
date	94.10.11.21.40.06;	author CACHELIN4000;	state Exp;
branches;
next	2.69;

2.69
date	94.10.07.11.36.39;	author CACHELIN4000;	state Exp;
branches;
next	2.68;

2.68
date	94.10.07.07.40.26;	author Kell;	state Exp;
branches;
next	2.67;

2.67
date	94.10.07.07.35.35;	author Kell;	state Exp;
branches;
next	2.66;

2.66
date	94.10.06.23.04.57;	author CACHELIN4000;	state Exp;
branches;
next	2.65;

2.65
date	94.10.06.19.15.37;	author CACHELIN4000;	state Exp;
branches;
next	2.64;

2.64
date	94.10.06.09.30.39;	author CACHELIN4000;	state Exp;
branches;
next	2.63;

2.63
date	94.10.06.01.02.19;	author CACHELIN4000;	state Exp;
branches;
next	2.62;

2.62
date	94.10.05.23.34.05;	author Kell;	state Exp;
branches;
next	2.61;

2.61
date	94.10.05.16.29.07;	author CACHELIN4000;	state Exp;
branches;
next	2.60;

2.60
date	94.10.05.05.31.30;	author Kell;	state Exp;
branches;
next	2.59;

2.59
date	94.10.05.02.40.14;	author Kell;	state Exp;
branches;
next	2.58;

2.58
date	94.10.05.01.06.35;	author CACHELIN4000;	state Exp;
branches;
next	2.57;

2.57
date	94.10.04.18.13.53;	author CACHELIN4000;	state Exp;
branches;
next	2.56;

2.56
date	94.10.04.17.54.42;	author CACHELIN4000;	state Exp;
branches;
next	2.55;

2.55
date	94.10.03.21.11.03;	author CACHELIN4000;	state Exp;
branches;
next	2.54;

2.54
date	94.10.03.19.05.00;	author CACHELIN4000;	state Exp;
branches;
next	2.53;

2.53
date	94.10.03.18.49.52;	author CACHELIN4000;	state Exp;
branches;
next	2.52;

2.52
date	94.10.02.00.23.28;	author CACHELIN4000;	state Exp;
branches;
next	2.51;

2.51
date	94.10.02.00.03.19;	author CACHELIN4000;	state Exp;
branches;
next	2.50;

2.50
date	94.10.01.22.58.03;	author CACHELIN4000;	state Exp;
branches;
next	2.49;

2.49
date	94.10.01.14.52.16;	author Kell;	state Exp;
branches;
next	2.48;

2.48
date	94.10.01.13.00.35;	author Kell;	state Exp;
branches;
next	2.47;

2.47
date	94.10.01.01.03.29;	author Kell;	state Exp;
branches;
next	2.46;

2.46
date	94.09.30.21.36.52;	author CACHELIN4000;	state Exp;
branches;
next	2.45;

2.45
date	94.09.30.13.17.47;	author pfrench;	state Exp;
branches;
next	2.44;

2.44
date	94.09.30.11.28.57;	author CACHELIN4000;	state Exp;
branches;
next	2.43;

2.43
date	94.09.29.15.50.57;	author CACHELIN4000;	state Exp;
branches;
next	2.42;

2.42
date	94.09.29.13.51.26;	author CACHELIN4000;	state Exp;
branches;
next	2.41;

2.41
date	94.09.29.12.20.01;	author CACHELIN4000;	state Exp;
branches;
next	2.40;

2.40
date	94.09.28.23.42.13;	author CACHELIN4000;	state Exp;
branches;
next	2.39;

2.39
date	94.09.28.18.17.54;	author CACHELIN4000;	state Exp;
branches;
next	2.38;

2.38
date	94.09.28.14.46.52;	author CACHELIN4000;	state Exp;
branches;
next	2.37;

2.37
date	94.09.28.11.31.49;	author CACHELIN4000;	state Exp;
branches;
next	2.36;

2.36
date	94.09.28.00.09.03;	author CACHELIN4000;	state Exp;
branches;
next	2.35;

2.35
date	94.09.27.23.39.39;	author CACHELIN4000;	state Exp;
branches;
next	2.34;

2.34
date	94.09.27.18.05.24;	author CACHELIN4000;	state Exp;
branches;
next	2.33;

2.33
date	94.09.27.17.19.58;	author CACHELIN4000;	state Exp;
branches;
next	2.32;

2.32
date	94.09.25.16.34.27;	author Kell;	state Exp;
branches;
next	2.31;

2.31
date	94.09.24.15.11.59;	author CACHELIN4000;	state Exp;
branches;
next	2.30;

2.30
date	94.09.23.10.33.05;	author CACHELIN4000;	state Exp;
branches;
next	2.29;

2.29
date	94.09.20.23.40.26;	author CACHELIN4000;	state Exp;
branches;
next	2.28;

2.28
date	94.09.20.23.33.17;	author CACHELIN4000;	state Exp;
branches;
next	2.27;

2.27
date	94.09.14.19.02.51;	author CACHELIN4000;	state Exp;
branches;
next	2.26;

2.26
date	94.09.13.20.19.46;	author CACHELIN4000;	state Exp;
branches;
next	2.25;

2.25
date	94.09.12.18.53.43;	author CACHELIN4000;	state Exp;
branches;
next	2.24;

2.24
date	94.09.12.13.04.22;	author CACHELIN4000;	state Exp;
branches;
next	2.23;

2.23
date	94.09.10.20.11.35;	author CACHELIN4000;	state Exp;
branches;
next	2.22;

2.22
date	94.09.09.20.39.26;	author CACHELIN4000;	state Exp;
branches;
next	2.21;

2.21
date	94.09.09.13.39.41;	author CACHELIN4000;	state Exp;
branches;
next	2.20;

2.20
date	94.09.07.14.43.46;	author CACHELIN4000;	state Exp;
branches;
next	2.19;

2.19
date	94.09.07.14.34.45;	author CACHELIN4000;	state Exp;
branches;
next	2.18;

2.18
date	94.09.06.22.27.41;	author CACHELIN4000;	state Exp;
branches;
next	2.17;

2.17
date	94.09.05.19.07.37;	author CACHELIN4000;	state Exp;
branches;
next	2.16;

2.16
date	94.09.04.17.52.40;	author CACHELIN4000;	state Exp;
branches;
next	2.15;

2.15
date	94.09.03.17.50.55;	author CACHELIN4000;	state Exp;
branches;
next	2.14;

2.14
date	94.09.02.20.18.08;	author CACHELIN4000;	state Exp;
branches;
next	2.13;

2.13
date	94.09.01.21.13.55;	author CACHELIN4000;	state Exp;
branches;
next	2.12;

2.12
date	94.09.01.18.02.45;	author CACHELIN4000;	state Exp;
branches;
next	2.11;

2.11
date	94.09.01.10.41.21;	author CACHELIN4000;	state Exp;
branches;
next	2.10;

2.10
date	94.09.01.03.33.29;	author Kell;	state Exp;
branches;
next	2.9;

2.9
date	94.08.30.17.26.34;	author CACHELIN4000;	state Exp;
branches;
next	2.8;

2.8
date	94.08.30.10.31.42;	author Kell;	state Exp;
branches;
next	2.7;

2.7
date	94.08.30.09.46.00;	author CACHELIN4000;	state Exp;
branches;
next	2.6;

2.6
date	94.08.26.21.48.24;	author Kell;	state Exp;
branches;
next	2.5;

2.5
date	94.08.24.12.07.28;	author CACHELIN4000;	state Exp;
branches;
next	2.4;

2.4
date	94.07.11.17.59.48;	author CACHELIN4000;	state Exp;
branches;
next	2.3;

2.3
date	94.07.07.17.01.58;	author CACHELIN4000;	state Exp;
branches;
next	2.2;

2.2
date	94.07.06.22.35.28;	author CACHELIN4000;	state Exp;
branches;
next	2.1;

2.1
date	94.07.04.18.40.22;	author CACHELIN4000;	state Exp;
branches;
next	2.0;

2.0
date	94.06.21.16.14.06;	author CACHELIN4000;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.147
log
@*** empty log message ***
@
text
@/* $Controls.c$ - Control Panels Themselves
* $Id: Controls.c,v 2.146 1995/02/24 16:14:12 pfrench Exp CACHELIN4000 $
* $Log: Controls.c,v $
*Revision 2.146  1995/02/24  16:14:12  pfrench
*Color names for yellow/cyan transposed
*
*Revision 2.145  1995/02/24  11:48:35  CACHELIN4000
*Fix stuff, add RT to CFX panel, start time/time mode order swap
*
*Revision 2.144  1995/02/22  10:32:07  CACHELIN4000
**** empty log message ***
*
*Revision 2.143  1995/02/21  12:19:54  CACHELIN4000
*Add TimeMode popup to Audio panel
*
*Revision 2.142  1995/02/20  12:28:13  CACHELIN4000
**** empty log message ***
*
*Revision 2.141  1995/02/19  16:41:44  CACHELIN4000
*Separate out PanData.c, PanFunctions.c to  make things link
*
*Revision 2.140  1995/02/19  11:35:29  pfrench
*One more attempt at getting the data to a far section
*
*Revision 2.139  1995/02/19  11:27:06  pfrench
*Cannot have static items that are FAR
*
*Revision 2.138  1995/02/19  01:03:41  CACHELIN4000
**** empty log message ***
*
*Revision 2.137  1995/02/14  10:46:12  CACHELIN4000
**** empty log message ***
*
*Revision 2.136  1995/02/14  10:27:50  CACHELIN4000
*Add Rec Gain controls to RawRec, strip audio/video to Mark Clip
*
*Revision 2.135  1995/02/13  14:38:09  CACHELIN4000
**** empty log message ***
*
*Revision 2.134  1995/02/11  17:52:59  CACHELIN4000
*Add SMPTE, audio record level support
*
*Revision 2.133  1995/02/10  15:27:46  Kell
*ES_RecordSource now doesn't have record audio volume parameters.
*
*Revision 2.132  1995/02/01  17:54:31  CACHELIN4000
*Add Process button, fix cutting room jump from record panel
*
*Revision 2.131  1995/01/25  18:34:57  CACHELIN4000
*Change TBC controls to scaled STEPSLIDE lines
*
*Revision 2.130  1995/01/24  18:05:37  CACHELIN4000
**** empty log message ***
*
*Revision 2.129  1995/01/24  16:50:04  CACHELIN4000
*Re-enable TBC inputs
*
*Revision 2.128  1995/01/24  11:19:50  CACHELIN4000
*TBC panels, some cutting room additions
*
*Revision 2.127  1995/01/13  14:23:30  CACHELIN4000
*Add Partner stuff to video control panel, DHD_Jog,Jump and Shuttle
*Put in Play buttons/crouton button, fix CTRL_Play() to ahndel SWITCHER_MODE,
*Add none to Audio channels again, add audio toggle to EZ video again,  etc.
*
*Revision 2.126  1995/01/12  12:03:52  CACHELIN4000
*Framestore duration EZLEN-> EZTIME
*
*Revision 2.125  1995/01/06  22:16:54  CACHELIN4000
*All Tables ARE even length now!
*
*Revision 2.124  1995/01/05  17:54:15  CACHELIN4000
*Fix available time swap between Extended and Std. modes
*
*Revision 2.123  1995/01/04  23:40:23  CACHELIN4000
*Fix Matte color bugs in DoFXAnimPanel()
*
*Revision 2.122  1995/01/04  17:36:29  CACHELIN4000
*Quantize Audio sliders on Color Frame (add PL_CFRAME flag)
*
*Revision 2.121  1995/01/04  11:02:25  CACHELIN4000
**** empty log message ***
*
*Revision 2.120  1994/12/31  02:05:06  CACHELIN4000
*Fix AUDIO_ONLY avail time again, standardize Source setting, CurFlySource
*
*Revision 2.119  1994/12/30  21:22:20  CACHELIN4000
*Fixed audio duration
*
*Revision 2.118  1994/12/30  13:09:58  CACHELIN4000
*Add Audio only calc to BlocksToFrames(), CTRL_SetSource(), etc.
*
*Revision 2.117  1994/12/28  17:48:48  CACHELIN4000
*add 1 b4 rounding down rcb->frame in DHD_Jog()
*
*Revision 2.116  1994/12/24  12:33:41  CACHELIN4000
*fix bug with AUDIO_ONLY_SOURCE vs CurFlySource (add 1)
*
*Revision 2.115  1994/12/23  17:45:10  CACHELIN4000
*change LENGTH_ADJUST to 0 so short clips have correct out points.. i hope
*
*Revision 2.114  1994/12/23  15:01:55  CACHELIN4000
*Make GetTable() requests use 256byte buffer, instead of 255...
*
*Revision 2.113  1994/12/23  11:36:30  CACHELIN4000
*Use PropEnd for string limits
*
*Revision 2.112  1994/12/23  10:08:47  CACHELIN4000
*Add AUDIO_ONLY_SOURCE define, fix DHD_SetupRecord 'bug' for audio only initialization.
*
*Revision 2.111  1994/12/22  21:57:59  CACHELIN4000
*fixes to Rexx panel
*
*Revision 2.110  1994/12/21  17:33:10  CACHELIN4000
*add recordclip(), fix CTRL_Play, add play line to clip panel
*
*Revision 2.109  1994/12/16  21:02:36  CACHELIN4000
*Add RecordClip Function
*
*Revision 2.108  1994/12/15  16:42:59  CACHELIN4000
**** empty log message ***
*
*Revision 2.107  1994/12/09  16:42:17  CACHELIN4000
*Use AUD_ENABLE flags for channels popup
*
*Revision 2.106  1994/12/08  16:08:38  CACHELIN4000
*Reorganize Audio, video control panels (Yet Again), fix Streeo pan oversight
*Add Start Time to Rexx panel, etc.
*
*Revision 2.105  1994/12/07  23:14:31  CACHELIN4000
*Add Channels popup to XPVidClip, change volume num to slider (Sorry James, SKell said Tim siad to do it)
*
*Revision 2.104  1994/12/07  00:12:22  CACHELIN4000
*Add SortFLyerDrives(), Audio drive tweaks and various cosmetics
*
*Revision 2.103  1994/12/05  20:06:38  CACHELIN4000
*Use global CurCompMode for retain compression settings
*
*Revision 2.102  1994/12/05  19:21:30  CACHELIN4000
*Add Quality popup to record panel.
*
*Revision 2.100  1994/12/03  18:36:24  CACHELIN4000
*Add PanelMode tag check, quicktune gadgets, diff text placement
*
*Revision 2.99  1994/11/18  18:31:19  Kell
*Changed Tag Synchronous to Asynchronous
*
*Revision 2.98  1994/11/18  16:51:52  CACHELIN4000
*Add RexxPanel tags..
*
*Revision 2.97  1994/11/16  15:13:23  CACHELIN4000
*Fix I/O point swap bug, add Rexx panel, make things far static to help linker (?)
*
*Revision 2.96  1994/11/15  21:41:24  CACHELIN4000
*Fix initial clip length bug
*
*Revision 2.95  1994/11/10  00:31:47  CACHELIN4000
*Remove FlyerIn, FlyerY/C sources from popup..
*
*Revision 2.94  1994/11/10  00:10:47  CACHELIN4000
*Implement Audio source channels popup, CTRL_SetPan
*
*Revision 2.93  1994/11/09  18:50:38  CACHELIN4000
*Fix New Audio Balance/Volume system... i hope
*
*Revision 2.92  94/11/09  15:33:40  CACHELIN4000
*More MessinG around...
*
*Revision 2.90  94/11/04  17:19:15  CACHELIN4000
*Remove Rename from fileinfo, fix audio panel, etc.
*
*Revision 2.89  94/11/04  00:31:17  CACHELIN4000
**** empty log message ***
*
*Revision 2.88  94/11/03  23:11:36  CACHELIN4000
*CTRL_Play(), remove record tracks toggle, fix CTRL_SetSource, etc.
*
*Revision 2.87  94/11/03  11:08:07  CACHELIN4000
*Limit Coarse tweak to 0-9, not 0-15
*
*Revision 2.86  94/11/02  20:23:11  CACHELIN4000
*fix Balance/Volume setting, lack of render after DHD_Jog message,
*monaural audio clip support with Pan, even volumes losing 1
*
*Revision 2.85  94/11/01  18:57:35  CACHELIN4000
*Backup Tweak values..
*
*Revision 2.84  94/10/31  17:22:17  CACHELIN4000
*Re-Do Tweak panel, etc.
*
*Revision 2.83  94/10/28  16:52:01  CACHELIN4000
*Add Pedestal preset to Tweak
*
*Revision 2.82  94/10/28  15:25:40  CACHELIN4000
*fix reversed Hack array
*
*Revision 2.81  94/10/28  11:57:26  CACHELIN4000
*Fix Audio Fade bug.
*
*Revision 2.80  94/10/27  23:45:14  CACHELIN4000
*Buffer Tweak panel, re-do VidClip controls to meet new spec, add CTRL_SetBalance
*change PLine User-Function names to start with CTRL_ not DHD_
*
*Revision 2.79  94/10/25  20:01:18  CACHELIN4000
*extend Tweak panel, check flyerbase before finding drives...
*
*Revision 2.78  94/10/25  18:08:29  CACHELIN4000
*Fix Tweak panel to get flyer volumes
*
*Revision 2.77  94/10/24  17:20:32  CACHELIN4000
*Insert MiniPanel call, fix inpoint/outpoint calculations
*
*Revision 2.76  94/10/24  12:21:50  CACHELIN4000
*Update grazer after rename, etc.
*
*Revision 2.75  94/10/21  23:21:52  CACHELIN4000
*Connect SetupPanel to new messages, structure
*
*Revision 2.74  94/10/20  11:53:44  CACHELIN4000
*Switch to new PLine->UserFun for function calls, add setup panel
*
*Revision 2.73  94/10/14  13:39:08  CACHELIN4000
*Add CheckFlyerDrives() to sort Audio drives and add 0xA2 as 1st byte of name
*
*Revision 2.71  94/10/12  17:34:59  CACHELIN4000
*Use DuoSLider for VideoXP, Audio, AudioXP panels
*
*Revision 2.70  94/10/11  21:40:06  CACHELIN4000
*DuoSlide for ClipPL
*
*Revision 2.69  94/10/07  11:36:39  CACHELIN4000
*Fix HAck,RecTest f'ns
*
*Revision 2.66  1994/10/06  23:04:57  CACHELIN4000
*Fix ANIMFX panels
*
*Revision 2.65  94/10/06  19:15:37  CACHELIN4000
*Matte/Border awareness in DoANIMFXPanel() .. left ghost
*
*Revision 2.64  94/10/06  09:30:39  CACHELIN4000
*Audio Duration ->RecFields.. bug fix
*
*Revision 2.63  94/10/06  01:02:19  CACHELIN4000
*Fix RecTest for A/B channel, DHD_Shuttle not updating I/O point bug
*
*Revision 2.62  94/10/05  23:34:05  Kell
*Fix Rec_Test stuff (AC)
*
*Revision 2.61  1994/10/05  16:29:07  CACHELIN4000
*Open all Panels on multi-select...
*
*Revision 2.60  94/10/05  05:31:30  Kell
*Fixed the Get/Put Table comment stuff.
*
*Revision 2.59  1994/10/05  02:40:14  Kell
*PutTable now does correct ES_PutTable command.
*
*Revision 2.58  1994/10/05  01:06:35  CACHELIN4000
*Diff add-ons, ES_Hack, DoTweakPanel, TweakPL, etc.
*
*Revision 2.57  94/10/04  18:13:53  CACHELIN4000
*Remember Drive, Source, Tracks and Name between record panel invocations
*
*Revision 2.53  94/10/03  18:49:52  CACHELIN4000
*Don't make icon for Audio clips, Update dir after record, XPClip volume=0 if audio off
*un-reverse audio volume channel setting
*
*Revision 2.51  94/10/02  00:03:19  CACHELIN4000
*Bullet-proof Clip control panel against missing tags.
*
*Revision 2.49  94/10/01  14:52:16  Kell
*Fixed bugs related to saving / loading comments.
*
*Revision 2.48  1994/10/01  13:00:35  Kell
*Now saves center icon of recorded clip.
*DHD_FlyerClipInfo for getting length of recorded clip, etc.
*
*Revision 2.47  1994/10/01  01:03:29  Kell
*Added DHD_MakeClipIcon. Currently puts up Wait sprite when making icon.
*
*Revision 2.46  1994/09/30  21:36:52  CACHELIN4000
*assure even frame numbers in aduio, video panels
*
*Revision 2.45  94/09/30  13:17:47  pfrench
*Removed doallnewdir from doinfopanel because the grazer
*was traversing the list of selected files.
*
*Revision 2.44  1994/09/30  11:28:57  CACHELIN4000
*Audio InPoints set on EZ Clip Adjust
*
*Revision 2.40  94/09/28  23:42:13  CACHELIN4000
*Add DHD_Reorganize(), rearrange record panel again
*
*Revision 2.38  94/09/28  14:46:52  CACHELIN4000
*BlocksToFrames added
*
*Revision 2.37  94/09/28  11:31:49  CACHELIN4000
*add BuildFlyerList()
*to NewClipPanel
*
*Revision 2.34  94/09/27  18:05:24  CACHELIN4000
*Bag crashy FreeCrouton in DHD_InitRecord
*
*Revision 2.33  94/09/27  17:19:58  CACHELIN4000
*Add POPUP f'ns (SetSource, SetDrive), tweak DHD_ functions for record panel,
*add Drive popup to record panel, FlyerDriveInfo query
*
*Revision 2.32  94/09/25  16:34:27  Kell
*Changes ES_StopSeq to ES_Stop
*
*Revision 2.30  94/09/23  10:33:05  CACHELIN4000
*Record Panel, CutCLip Panel work.
*
*Revision 2.28  94/09/20  23:33:17  CACHELIN4000
*FX Tags work, TAGNames added for EZ debuggery
*
* Copyright (c)1994 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
*********************************************************************/

#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/sghooks.h>
#include <graphics/gfxmacros.h>
#include <graphics/gfxbase.h>
#include <graphics/text.h>

#include <stdio.h>
#include <string.h>
#include <dos.h>
#include <time.h>
#include <editwindow.h>
#include <project.h>
#include <gadgets.h>
#include <prophelp.h>
#include <grazer.h>
#include <edit:popup/popup.h>
#include <editswit.h>
#include <crouton_all.h>
#include <request.h>
#include <tags.h>
#include <panel.h>
#include <flyer.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
#include <proto/diskfont.h>

#ifndef PROTO_PASS
#include <proto.h>
#else
DrawBGFunc *DrawBG();
#include "edit:proto/Pline.p"
#include "edit:proto/PanFunctions.p"
#include "edit:proto/PanData.p"
#endif

//#define SERDEBUG	1
#include <serialdebug.h>

#define CFAR __far

#define CSTATIC

extern struct PanelLine *CurPLine,*Start,*LastTime,*temp;
extern struct Gadget *FirstG,*Down,*EZGad,*In,*Out,*Del,*Len;
extern LONG	InOrOut,ft,Adder;
extern ULONG	Ticks,WinFlags,GadInd;
extern struct FastGadget *CurFG,*SKellFG;
extern char TempCh[],TempC2[],*DTNames[];
extern UBYTE *TempMem;
extern ULONG CRuDTypes[];
extern struct MsgPort *SwitPort;
extern struct EditWindow *EditTop,*EditBottom;
extern struct Library *FlyerBase;
extern struct ESParams1 ESparams1;
extern struct ESParams2 ESparams2;
extern struct ESParams3 ESparams3;
extern struct ESParams4 ESparams4;
extern struct ESParams5 ESparams5;

extern CFAR struct PanelLine ReqString_PL[];
extern CFAR struct PanelLine ReqNum_PL[];
extern CFAR struct PanelLine ReqTime_PL[];
extern CFAR struct PanelLine ReqTell_PL[];
extern CFAR struct PanelLine Setup_PL[];
extern CFAR struct PanelLine Tweak_PL[];
extern CFAR struct PanelLine TBC_PL[];
extern CFAR struct PanelLine XPTBC_PL[];
extern CFAR struct PanelLine Error_PL[];
extern CFAR struct PanelLine RawRec_PL[];
extern CFAR struct PanelLine MarkClip_PL[];
extern CFAR struct PanelLine FileInfo_PL[];
extern CFAR struct PanelLine Rexx_PL[];
extern CFAR struct PanelLine Frame_PL[];
extern CFAR struct PanelLine LumaKey_PL[];
extern CFAR struct PanelLine Trails_PL[];
extern CFAR struct PanelLine CFX_PL[];
extern CFAR struct PanelLine Video_PL[];
extern CFAR struct PanelLine XPVideo_PL[];
extern CFAR struct PanelLine Effect_PL[];
extern CFAR struct PanelLine XPEffect_PL[];
extern CFAR struct PanelLine AnimFX_PL[];
extern CFAR struct PanelLine XPAnimFX_PL[];
extern CFAR struct PanelLine Clip_PL[];
extern CFAR struct PanelLine XPClip_PL[];
extern CFAR struct PanelLine AudClip_PL[];
extern CFAR struct PanelLine XPAudClip_PL[];
extern CFAR struct PanelLine Key_PL[];
extern CFAR struct PanelLine XPKey_PL[];
extern CFAR struct PanelLine Crawl_PL[];
extern CFAR struct PanelLine Scroll_PL[];
/*
extern CFAR struct PanelLine Test_PL[];
extern CFAR struct PanelLine Test_PL3[];
extern CFAR struct PanelLine Test_PL2[];
extern CFAR struct PanelLine XPTest_PL[];
 */

struct PanelLine *ReqStringPL = ReqString_PL;
struct PanelLine *ReqNumPL = ReqNum_PL;
struct PanelLine *ReqTimePL = ReqTime_PL;
struct PanelLine *ReqTellPL = ReqTell_PL;
struct PanelLine *SetupPL = Setup_PL;
struct PanelLine *TweakPL = Tweak_PL;
struct PanelLine *TBCPL = TBC_PL;
struct PanelLine *XPTBCPL = XPTBC_PL;
struct PanelLine *ErrorPL = Error_PL;
struct PanelLine *RawRecPL = RawRec_PL;
struct PanelLine *MarkClipPL = MarkClip_PL;
struct PanelLine *FileInfoPL = FileInfo_PL;
struct PanelLine *RexxPL = Rexx_PL;
struct PanelLine *FramePL = Frame_PL;
struct PanelLine *LumaKeyPL = LumaKey_PL;
struct PanelLine *TrailsPL = Trails_PL;
struct PanelLine *CFXPL = CFX_PL;
struct PanelLine *VideoPL = Video_PL;
struct PanelLine *XPVideoPL = XPVideo_PL;
struct PanelLine *EffectPL = Effect_PL;
struct PanelLine *XPEffectPL = XPEffect_PL;
struct PanelLine *AnimFXPL = AnimFX_PL;
struct PanelLine *XPAnimFXPL = XPAnimFX_PL;
struct PanelLine *ClipPL = Clip_PL;
struct PanelLine *XPClipPL = XPClip_PL;
struct PanelLine *AudClipPL = AudClip_PL;
struct PanelLine *XPAudClipPL = XPAudClip_PL;
struct PanelLine *KeyPL = Key_PL;
struct PanelLine *XPKeyPL = XPKey_PL;
struct PanelLine *CrawlPL = Crawl_PL;
struct PanelLine *ScrollPL = Scroll_PL;
/*
struct PanelLine *TestPL = Test_PL;
struct PanelLine *XPTestPL = XPTest_PL;
struct PanelLine *TestPL2 = Test_PL2;
struct PanelLine *TestPL3 = Test_PL3;
*/

#define SWITCHER_MODE	( (!EditBottom) && (!EditTop || (EditTop->Height!=TOP_LARGE)) )
#define EDITOR_MODE		(!SWITCHER_MODE)



struct	AudioSet	CurAudioSet={0,0,0};
struct FlyAudCtrl AudCtrl = {0,0,0,0,0,0,8,8,128,0,128,0,0,0,0,0,0,0,0,0};
struct FastGadget *PlayFG=NULL;
far static UBYTE CommentBuf[COMMENT_MAX+1];	//The Get/PutTable commands need an EVEN length!!!!!

CFAR CSTATIC char Size[20],Name[MAX_STRING_BUFFER]="Clip.0",Dir[MAX_STRING_BUFFER];
ULONG CurFlyDrive=0,CurFlySource=2,CurFlyTracks=1,CurCompMode=0;
VOID DisplayWaitSprite(VOID);
VOID DisplayNormalSprite(VOID);
#define TWEAK_CHANNELS	3  // 4 when Record_B becomes real again
CFAR struct Hack
		HackA={HKF_PLAY_A,-29,1,14,7,0,0,60},*Hack=&HackA,
		HackB={HKF_PLAY_B,-29,2,2,7,0,0,60},
		HackC={HKF_RECORD_A|HKF_TESTREC,20,3,0,3,0,0,0},
		HackD={HKF_RECORD_B|HKF_TESTREC,20,2,6,3,0,0,0},
		*Hacks[]={&HackA,&HackB,&HackC,&HackD},
		BakHackA={HKF_PLAY_A,-29,1,14,7,0,0,60},
		BakHackB={HKF_PLAY_B,-29,2,2,7,0,0,60},
		BakHackC={HKF_RECORD_A|HKF_TESTREC,20,3,0,3,0,0,0},
		BakHackD={HKF_RECORD_B|HKF_TESTREC,20,2,6,3,0,0,0},
		*BakHacks[]={&BakHackA,&BakHackB,&BakHackC,&BakHackD};

struct SystemPrefs Config={0,0,0,0};
struct TBCctrl		TBC_dat,TBC_bak;

#define QUAL_NUM	3 		// number of entires in Qual array
#define DEF_QUALITY	0 	// default quality
#define COLOR_NUM	10		// number of entires in Colors array
#define DEF_COLOR	2			// default color = Red
#define SCROLL_NUM  2
#define DEF_SCROLL 0
#define CRAWL_NUM	3
#define PNL_NUM	15
#define FLY_SRC_NUM	7



LONG PanType=PAN_EASY,FlyerDriveCount=0;

UBYTE
	FDrive[420], // (20x21)

	*FlyerDrives[]={&FDrive[0],&FDrive[20],&FDrive[40],&FDrive[60],&FDrive[80],
								&FDrive[100],&FDrive[120],&FDrive[140],&FDrive[160],&FDrive[180],
								&FDrive[200],&FDrive[220],&FDrive[240],&FDrive[260],&FDrive[280],
								&FDrive[300],&FDrive[320],&FDrive[340],&FDrive[360],&FDrive[380],&FDrive[400]};

CFAR UBYTE
	*FlyDrives[]={"-NONE-","Test2:"},
	*Colors[] = {"Black","White","Red","Green","Blue","Yellow","Magenta","Cyan","Snow","Special",""},
	*Scrolls[] = {"Scroll Once","Scroll Hold"},
	*Crawls[] = {"Crawl Once","Crawl Repeat","Crawl Hold"},
	*Pnls[] = { "ANIM","ILBM","ALGO","CHROMAFX","VIDEO","AUDIO","CONTROL",
		"PROJECT","FRAMESTORE","KEY","SCROLL","CRAWL","ERROR","RAWREC","SETUP","TWEAK",""},
	*Quals[] = {"Standard Play","Extended Play","Audio Only",""},
	*CutTracks[] = {"Video  ","Audio  ",""},
//	*TimeModes[] = {"Audio In","Delay",""},
	*TimeModes[] = {"Clip","In Point",""},
	*Tracks[] = {" Record Audio ",""},
	*Sources[] = {"Flyer In","Flyer Y/C","Input 1","Input 2","Input 3","Input 4","Main Out",""},

	SrcInd[] = {FLYS_VideoSource_NTSC,FLYS_VideoSource_SVHS,FLYS_VideoSource_VID1,
		FLYS_VideoSource_VID2,FLYS_VideoSource_VID3,FLYS_VideoSource_VID4,FLYS_VideoSource_Main},

//	*Sources[] = {"Input 1","Input 2","Main Out","Audio Only",""},
	*Tweaks[] ={ "Play A","Play B","Record","Record B","Rec. Test"},
	*Channels[] ={ "Stereo (L+R)", "Left Only" , "Right Only", "None"},
//	*Inputs[] ={ "1  ","2  ","3  ","4  "},
	*Inputs[] ={ "4  ","3  ","2  ","1  "},
	*CFX_CModes[] ={ "Chroma","Chroma Strip"},
	*CFX_DModes[] ={ "Filter","Transition"},
	*CFX_Cycles[] ={ "1  ","2  ","3  ","4  "},
	*FlyInputs[] ={ "Input 3","Input 4"},
	*TBCSources[] = {"Composite"," Y/C ","Main Out","Fader",""},
	*TBCTerm[] = {"Comp. ","Gen. ","TBC ","AFade","BFade",""},
	*TBCDecoder[] = {"Mono. In","AGC","Chroma AGC",""},
	*TBCEncoder[] = {"Bypass","Bars","Kill Color","Freeze",""},
	*TBCKeyer[] = {"Fader Out","Channel B",""},
	*TBCKeyModes[] = {"Fader","2 Level","4 Level",""},
	TBC_KeyMode[] = {0,TBCKF_MODE0,TBCKF_MODE0|TBCKF_MODE1},
	*GPI[] ={ "Off" , "Pulse Front", "Pulse Back"};

far char RexxArgs[COMMENT_MAX+1],*Waits[]={"Wait for Return  ",""};
far UBYTE 	TBC_Input[] = {TBCIN_COMP,TBCIN_YC,TBCIN_TMAIN,TBCIN_FADER};

#ifdef PROTO_PASS
	PanHandler	PanHandlers[50];
#else
CFAR PanHandler	PanHandlers[] = {
  DoFXALGOPanel,						// CR_FXANIM
  DoFXILBMPanel,						// CR_FXILBM
  DoFXALGOPanel,						// CR_FXALGO
  DoFXCRPanel,  						// CR_FXCR
  DoVIDEOPanel, 						// CR_VIDEO
  DoAUDIOPanel, 						// CR_AUDIO
  DoCONTROLPanel,						// CR_CONTROL
  NULL,											// CR_PROJECT
  DoFRAMESTOREPanel,				// CR_FRAMESTORE
  DoKEYPanel,       				// CR_KEY
  DoSCROLLPanel,    				// CR_SCROLL
  DoCRAWLPanel,     				// CR_CRAWL
  DoFRAMESTOREPanel,				// CR_VIDEOANIM,
  DoKEYPanel,								// CR_KEYEDANIM,
  DoCONTROLPanel,						// CR_MAIN,
  DoFRAMESTOREPanel,				// CR_STILL,
	DoERRORPanel,     				// CR_ERROR
  NULL,          						// CR_CGBOOK
  NULL,          						// CR_IMAGE
  NULL,          						// CR_LWSCENE
  NULL,          						// CR_LWOBJ
  NULL,          						// CR_LWSURF
  NULL,          						// CR_LWMOT
  NULL,          						// CR_LWENV
  NULL,          						// CR_FONT
  NULL,          						// CR_EPS
  DoRexxPanel ,  						// CR_REXX
  NULL,          						// CR_TEXT
  NULL,          						// CR_UNKNOWN
  DoNewClipPanel ,
  DoSetupPanel ,
  DoTweakPanel ,
	NULL } ;
#endif

//*******************************************************************
struct EditWindow *HandleNewClip(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	DoNewClipPanel(Edit,NULL);
	DUMPMSG(" ...NewClip Handled.");
	return(Edit);
}

//*******************************************************************
BOOL DoStrReqPanel(char *Title, char *buff, int buffsize)
{
	ReqStringPL[0].Label = Title;
	ReqStringPL[2].Param = (LONG *)buff;
	ReqStringPL[2].PropEnd = (LONG)buffsize-1;
	if(PAN_CANCEL==MiniPanel(NULL,ReqStringPL,TUNE_NONE))
		return(FALSE);
	return(TRUE);
}

//*******************************************************************
int DoNumReqPanel(char *Title, int n, int min, int max)
{
	int Num=n;
	ReqNumPL[0].Label = Title;
	ReqNumPL[2].Param = (LONG *)&Num;
	ReqNumPL[2].PropStart = min;
	ReqNumPL[2].PropEnd = max;
	if(PAN_CANCEL==MiniPanel(NULL,ReqNumPL,TUNE_NONE))
		return(n);
	return(Num);
}

//*******************************************************************
BOOL DoTimeReqPanel(char *Title, char *timecode)
{
	ULONG t;
	TimeToLong(timecode,&t);
	ReqTimePL[0].Label = Title;
	ReqTimePL[2].Param = (LONG *)&t;
	ReqTimePL[2].PropStart = 0;
	ReqTimePL[2].PropEnd = 65535<<4; // Big!
	if(PAN_CANCEL==MiniPanel(NULL,ReqTimePL,TUNE_NONE))
		return(FALSE);
	LongToTime(&t,timecode);
	return(TRUE);
}

//*******************************************************************
BOOL DoTellReqPanel(char *Title, char *line1, char *line2, char *line3)
{
	ReqTellPL[0].Label = Title;
	ReqTellPL[2].Label = line1;
	ReqTellPL[3].Label = line2;
	ReqTellPL[4].Label = line3;
	if(PAN_CANCEL==MiniPanel(NULL,ReqTellPL,TUNE_NONE))
		return(FALSE);
	return(TRUE);
}

//*******************************************************************
// This panel should also offer a way to save settings,
// then load them on the fly in the sequence.
BOOL DoTBCPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG bri,con,sat,hue,cphas,hphas,fade,KeyM,
		dbri=0,dcon=63,dsat=63,dhue=0,dcphas=0x3FF,dhphas=870,dfade=127,
		term=0,dec=0,enc=0,key=0,type=PAN_EASY;

	ESparams2.Data1 =(LONG) HACK_TBCO;
	ESparams2.Data2 =(LONG) &TBC_dat;
	SendSwitcherReply(ES_Hack,&ESparams2);

	ESparams2.Data1 =(LONG) HACK_TBCR;
	ESparams2.Data2 =(LONG) &TBC_dat;
	SendSwitcherReply(ES_Hack,&ESparams2);

	bri = TBC_dat.Bright;
	con = TBC_dat.Contrast;
	sat = TBC_dat.Sat;
	hue = TBC_dat.Hue;
	cphas=TBC_dat.Phase;
	hphas=TBC_dat.HorAdj;
	fade = TBC_dat.Fader;

	key=0;
	if(TBC_dat.KeyerFlags&TBCKF_KEYONB)	key|=1<<1;
	if(TBC_dat.KeyerFlags&TBCKF_FADEROUT)	key|=1;
	KeyM=0;
	if(TBC_dat.KeyerFlags&TBCKF_MODE0)
		if(TBC_dat.KeyerFlags&TBCKF_MODE1)
			KeyM=2;
		else
			KeyM=1;

	term=0;
	if(TBC_dat.Term&TBCTF_FADERB)	term|=1<<4;
	if(TBC_dat.Term&TBCTF_FADERA)	term|=1<<3;
	if(TBC_dat.Term&TBCTF_OUT)		term|=1<<2;
	if(TBC_dat.Term&TBCTF_GENIN)	term|=1<<1;
	if(TBC_dat.Term&TBCTF_COMPIN)	term|=1;
	dec=0;
	if(TBC_dat.DecFlags&TBCDF_CHROMAAGC)	dec|=1<<2;
	if(TBC_dat.DecFlags&TBCDF_AGC)				dec|=1<<1;
	if(TBC_dat.DecFlags&TBCDF_MONOCHROME)	dec|=1;
	enc=0;
	if(TBC_dat.EncFlags&TBCEF_KILLCOLOR)	enc|=1<<2;
	if(TBC_dat.EncFlags&TBCEF_BARS)				enc|=1<<1;
	if(TBC_dat.Flags&TBCGF_BYPASS)				enc|=1;
	if(TBC_dat.Flags&TBCGF_FREEZE)				enc|=1<<3;

	CopyMem(&TBC_dat,&TBC_bak,sizeof(struct TBCctrl));

	TBCPL[2].Param	=&hphas;
	TBCPL[2].Param2	=&dhphas;
	TBCPL[2].PropStart	=0;
	TBCPL[2].PropEnd	=909;
	TBCPL[2].UserObj				= (APTR) TBC_HPHZ;
	TBCPL[2].UserFun				= CTRL_TBCSet;

	TBCPL[3].Param	=&cphas;
	TBCPL[3].Param2	=&dcphas;
	TBCPL[3].PropStart	=0;
	TBCPL[3].PropEnd	=0x7FF;
	TBCPL[3].UserObj				= (APTR) TBC_CPHZ;
	TBCPL[3].UserFun				= CTRL_TBCSet;

	TBCPL[4].Param	=&hue;
	TBCPL[4].Param2	=&dhue;
	TBCPL[4].PropStart	=-64;
	TBCPL[4].PropEnd	=63;
	TBCPL[4].UserObj				= (APTR) TBC_HUE;
	TBCPL[4].UserFun				= CTRL_TBCSet;

	TBCPL[5].Param	=&bri;
	TBCPL[5].Param2	=&dbri;
	TBCPL[5].PropStart	=-64;
	TBCPL[5].PropEnd	=63;
	TBCPL[5].UserObj				= (APTR) TBC_BRT;
	TBCPL[5].UserFun				= CTRL_TBCSet;

	dsat=63;
	TBCPL[6].Param	=&sat;
	TBCPL[6].Param2	=&dsat;
	TBCPL[6].PropStart	=0;
	TBCPL[6].PropEnd		=127;
	TBCPL[6].UserObj				= (APTR) TBC_SAT;
	TBCPL[6].UserFun				= CTRL_TBCSet;

	dcon=63;
	TBCPL[7].Param	=&con;
	TBCPL[7].Param2	=&dcon;
	TBCPL[7].PropStart	=0;
	TBCPL[7].PropEnd		=127;
	TBCPL[7].UserObj				= (APTR) TBC_CON;
	TBCPL[7].UserFun				= CTRL_TBCSet;

	TBCPL[8].Param	= &fade;
	TBCPL[8].Param2	= &dfade;
	TBCPL[8].PropStart	=0;
	TBCPL[8].PropEnd		=255;
	TBCPL[8].UserObj				= (APTR) TBC_FAD;
	TBCPL[8].UserFun				= CTRL_TBCSet;

	TBCPL[9].Param	= (long *)TBCSources;
	TBCPL[9].PropStart	=TBC_Input[TBC_dat.InputSel];
	TBCPL[9].PropEnd		=TBCSRC_NUM;
	TBCPL[9].UserObj				= (APTR) TBC_INP;
	TBCPL[9].UserFun				= CTRL_TBCSet;


	XPTBCPL[2].Param	= (long *)TBCSources;
	XPTBCPL[2].PropStart	=TBC_Input[TBC_dat.InputSel];
	XPTBCPL[2].PropEnd		=TBCSRC_NUM;
	XPTBCPL[2].UserObj				= (APTR) TBC_INP;
	XPTBCPL[2].UserFun				= CTRL_TBCSet;

	XPTBCPL[3].Param	= (long *)TBCKeyModes;
	XPTBCPL[3].PropStart	=KeyM;
	XPTBCPL[3].PropEnd		=TBCKEYM_NUM;
	XPTBCPL[3].UserObj				= (APTR) TBC_KEYM;
	XPTBCPL[3].UserFun				= CTRL_TBCSet;

	XPTBCPL[4].Param	= &fade;
	XPTBCPL[4].Param2	= &dfade;
	XPTBCPL[4].PropStart	=0;
	XPTBCPL[4].PropEnd		=255;
	XPTBCPL[4].UserObj				= (APTR) TBC_FAD;
	XPTBCPL[4].UserFun				= CTRL_TBCSet;

	XPTBCPL[6].Param	=(ULONG *)term;
	XPTBCPL[6].Param2	= (long *)TBCTerm;
	XPTBCPL[6].PropStart	=0;
	XPTBCPL[6].PropEnd		=TBCTERM_NUM;
	XPTBCPL[6].UserObj				= (APTR) TBC_TRM;
	XPTBCPL[6].UserFun				= CTRL_TBCSet;

	XPTBCPL[8].Param	=(ULONG *)key;
	XPTBCPL[8].Param2	= (long *)TBCKeyer;
	XPTBCPL[8].PropStart	= 0;
	XPTBCPL[8].PropEnd		= TBCKEY_NUM;
	XPTBCPL[8].UserObj				= (APTR) TBC_KEY;
	XPTBCPL[8].UserFun				= CTRL_TBCSet;

	XPTBCPL[10].Param	=(ULONG *)enc;
	XPTBCPL[10].Param2	= (long *)TBCEncoder;
	XPTBCPL[10].PropStart	=0;
	XPTBCPL[10].PropEnd		=TBCENCOD_NUM;
	XPTBCPL[10].UserObj				= (APTR) TBC_ENC;
	XPTBCPL[10].UserFun				= CTRL_TBCSet;

	XPTBCPL[12].Param	=(ULONG *)dec;
	XPTBCPL[12].Param2	= (long *)TBCDecoder;
	XPTBCPL[12].PropStart	=0;
	XPTBCPL[12].PropEnd		=TBCDECOD_NUM;
	XPTBCPL[12].UserObj				= (APTR) TBC_DEC;
	XPTBCPL[12].UserFun				= CTRL_TBCSet;

	while(type > PAN_CONTINUE)
	{
		switch(type)
		{
			case PAN_EXPERT:
				type = MiniPanel(Edit,XPTBCPL,TUNE_QUICK);
				TBCPL[9].PropStart	=TBC_Input[TBC_dat.InputSel];
				break;
			case PAN_EASY:
				type = MiniPanel(Edit,TBCPL,TUNE_FINE);
				XPTBCPL[2].PropStart	=TBC_Input[TBC_dat.InputSel];
				break;
		}
	}

	if(type==PAN_CANCEL)
	{
		CopyMem(&TBC_bak,&TBC_dat,sizeof(struct TBCctrl));
		ESparams2.Data1 =(LONG) HACK_TBCW;
		ESparams2.Data2 =(LONG) &TBC_dat;
		SendSwitcherReply(ES_Hack,&ESparams2);
		ESparams2.Data1 =(LONG) HACK_TBCC;
		ESparams2.Data2 =(LONG) &TBC_dat;
		SendSwitcherReply(ES_Hack,&ESparams2);
		return(FALSE);
	}
	ESparams1.Data1=(LONG)&Config;
	SendSwitcherReply(ES_SavePrefs,&ESparams1);

	ESparams2.Data1 =(LONG) HACK_TBCC;
	ESparams2.Data2 =(LONG) &TBC_dat;
	SendSwitcherReply(ES_Hack,&ESparams2);

	return(TRUE);
}

//*******************************************************************
BOOL DoTweakPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
//	char *sh[]={"Shift",""};
	int i,type;
	if(FlyerDriveCount==0) BuildFlyerList();
	for(i=0;i<TWEAK_CHANNELS;i++)
	{
		Hack=Hacks[i];
		Hack->hk_Flags |= HKF_READCALIB;
		ESparams2.Data1 =(LONG) HACK_TWEAK;
		ESparams2.Data2 =(LONG) Hack;  // Hack ptr
		SendSwitcherReply(ES_Hack,&ESparams2);
		Hack->hk_Flags &= ~HKF_READCALIB;
		CopyMem(Hack,BakHacks[i],sizeof(struct Hack));
	}
	TweakPL[2].Param = (long *)Tweaks;// Popup
	TweakPL[2].UserFun = CTRL_RecTest;// Popup f'n
	TweakPL[2].PropStart=0;
	Hack=Hacks[TweakPL[2].PropStart];
	TweakPL[2].UserObj=(APTR)Hack;
	TweakPL[2].PropEnd=TWEAK_CHANNELS;

	TweakPL[3].Param = &(Hack->hk_Position) ;// EZ_NUM
	TweakPL[3].UserFun = CTRL_Hack;
	TweakPL[3].UserObj = (APTR)Hack;
	TweakPL[3].PropStart=-910;
	TweakPL[3].PropEnd=910;

	TweakPL[4].Param =  &(Hack->hk_Clock) ;	// EZ_NUM
	TweakPL[4].UserFun =CTRL_Hack;
	TweakPL[4].UserObj =(APTR)Hack;
	TweakPL[4].PropStart=0;
	TweakPL[4].PropEnd=3;

	TweakPL[5].Param = &(Hack->hk_Coarse) ;	// EZ_NUM
	TweakPL[5].UserFun =CTRL_Hack;
	TweakPL[5].UserObj=(APTR)Hack;
	TweakPL[5].PropStart=0;
	TweakPL[5].PropEnd=9;

	TweakPL[6].Param = &(Hack->hk_Fine) ;	// EZ_NUM
	TweakPL[6].UserFun =CTRL_Hack;
	TweakPL[6].UserObj=(APTR)Hack;
	TweakPL[6].PropStart=0;
	TweakPL[6].PropEnd=7;

//	TweakPL[7].Param = &(Hack->hk_Pedestal) ;	// EZ_NUM
//	TweakPL[7].UserFun =CTRL_Hack;
//	TweakPL[7].UserObj=(APTR)Hack;
//	TweakPL[7].PropStart=0;
//	TweakPL[7].PropEnd=255;

//	TweakPL[8].Param=(long *)Hack->hk_Shift;
//	TweakPL[8].Param2=(long *)sh;
//	TweakPL[8].PropEnd=1;

	type=MiniPanel(Edit,TweakPL,TUNE_NONE);
	if(type==PAN_CANCEL)
	{
		for(i=0;i<TWEAK_CHANNELS;i++)
		{
			Hack=Hacks[i];
			CopyMem(BakHacks[i],Hack,sizeof(struct Hack));
			ESparams1.Data1 =(LONG) Hack;  // Hack ptr
			SendSwitcherReply(ES_Hack,&ESparams1);
		}
	}
	DHD_InitPlay("",0);
	return(TRUE);
}


//*******************************************************************
BOOL DoSetupPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG	I=0,M=0,T=0xF,trig=0,type=PanType,oM;

	DUMPMSG("Enter Setup Panel");
	ESparams1.Data1=(LONG)&Config;
	SendSwitcherReply(ES_GetPrefs,&ESparams1);
	DUMPHEXIL(" Got Prefs ",(LONG)&Config,"\\");
	M=(Config.Flags1&(1<<spB_PrvwOLay)) ? 1:0 ;
	oM=M;
	if(Config.Flags1&(1<<spB_FlyerVID3))
		I |= 1;
	if(Config.Flags1&(1<<spB_FlyerVID4))
		I |= 2;

	T=(UBYTE) Config.Termination;
	trig=(UBYTE) Config.GPI;
	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		SetupPL[2].Param =(LONG *)&M;
		SetupPL[2].UserFun=CTRL_SetFace;
		SetupPL[2].Flags=PL_SMREF; // requester with interface change

		SetupPL[4].Param =(LONG *)T;
		SetupPL[4].Param2 =(LONG *)Inputs;
		SetupPL[4].PropEnd =4;
		SetupPL[4].UserFun=CTRL_SetTermination;

		SetupPL[6].Param =(LONG *)GPI;
		SetupPL[6].PropStart =trig;
		SetupPL[6].PropEnd =3;
		SetupPL[6].UserFun=CTRL_SetGPI;

		SetupPL[7].Param = (LONG *)I;
		SetupPL[7].Param2 =(LONG *)FlyInputs;
		SetupPL[7].PropEnd =2;
		SetupPL[7].UserFun=CTRL_SetFlyOut;
		if( !FlyerBase ) SetupPL[7].Type =PNL_SKIP;

		type = MiniPanel(Edit,SetupPL,TUNE_NONE);
	}

	if(type==PAN_CONTINUE)
	{
		Config.GPI = (UBYTE) SetupPL[6].PropStart;
		if((LONG)SetupPL[7].Param&1)
			Config.Flags1 |= (1<<spB_FlyerVID3);
		else Config.Flags1 &= ~(1<<spB_FlyerVID3);
		if((LONG)SetupPL[7].Param&2)
			Config.Flags1 |= (1<<spB_FlyerVID4);
		else Config.Flags1 &= ~(1<<spB_FlyerVID4);
		Config.Termination=(UBYTE)SetupPL[4].Param;
		ESparams1.Data1=(LONG)&Config;
		SendSwitcherReply(ES_SavePrefs,&ESparams1);
		return(TRUE);
	}
	else
	{
		Config.Termination = (UBYTE)T;
		Config.Flags1 = (UBYTE) ( oM!=0 ? (1<<spB_PrvwOLay):0);
		if(I!=(Config.Flags1>>1)&0x3)
		{
			if(I&1) Config.Flags1 |= (1<<spB_FlyerVID3);
			else Config.Flags1 &= ~(1<<spB_FlyerVID3);
			if(I&2) Config.Flags1 |= (1<<spB_FlyerVID4);
			else Config.Flags1 &= ~(1<<spB_FlyerVID4);
		}
		ESparams1.Data1=(LONG)&Config;
		SendSwitcherReply(ES_SetPrefs,&ESparams1);
		return(TRUE);
	}

	return(FALSE);
}

//*******************************************************************
BOOL DoRexxPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	ULONG ow=0,DLay,B,TM=0;
	*RexxArgs=0;
	if(FG)
	{
		ow=GetValue(FG,TAG(Asynchronous));
		DLay=(B=GetValue(FG,TAG(Delay)));
		TM=GetValue(FG,TAG(TimeMode));
		GetTable(FG,TAG_CommandLine,RexxArgs,COMMENT_MAX);
	}
	PutValue(FG,TAG(Asynchronous),0);
	RexxPL[3].Type = PNL_SKIP;

	RexxPL[2].Param = (LONG *)RexxArgs;
	RexxPL[2].PropEnd = COMMENT_MAX;
	RexxPL[2].PropStart = 0; // this changes when string does
	RexxPL[2].G5 = (struct Gadget *)250; // Custom string width

	RexxPL[3].Param = (LONG *)ow;
	RexxPL[3].Param2 = (LONG *)Waits;
	RexxPL[3].PropEnd = 1;

	RexxPL[4].Param = (LONG *)TimeModes;
	RexxPL[4].PropStart = TM;
	RexxPL[4].PropEnd = 2;

	RexxPL[5].Param = &DLay;
	RexxPL[5].PropStart = 0;
	RexxPL[5].PropEnd = 600;
	RexxPL[5].Flags = PL_DEL;

	if(PAN_CANCEL==MiniPanel(Edit,RexxPL,TUNE_NONE))
		return(FALSE);
	if(RexxPL[2].PropStart)
		PutTable(FG,TAG_CommandLine,RexxArgs,COMMENT_MAX);
	if((ULONG)RexxPL[3].Param!=ow)
		PutValue(FG,TAG(Asynchronous),(LONG)RexxPL[3].Param);
	if(DLay!=B)
		PutValue(FG,TAG(Delay),DLay);
	if(RexxPL[4].PropStart!=TM)
		PutValue(FG,TAG(TimeMode),RexxPL[4].PropStart);
	return(TRUE);
}

UBYTE FCM[] = {3,0,1,2};  // convert between wacky FCountMode and gadget
UBYTE notFCM[] = {1,2,3,0};  // S,M,F,V -> 3,0,1,2 .. NotFCM[FCM[x]] == x
#define MAX_DELAY 1800   // !!! arbitrary Delay Limit

// CT_FXALGO
//*******************************************************************
BOOL DoFXALGOPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG B=2,t_In=300,type=PanType,Speed=1,S,SP[4]={45,30,15,9},D=0, Color=0,pmode=0;
	char Label[MAX_PANEL_STR];
	BOOL Matte=FALSE,Border=FALSE;
	if(FG)
	{
		SP[3]=GetValue(FG,TAG(NumFramesVariable));
		if(SP[3]==0)	return(DoFXANIMPanel(Edit,FG));  // Not Variable Speed
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Speed=GetValue(FG,TAG(FCountMode));
		Speed&=0x00000003; // 3,0,1,2 == S,M,F,V
		B=notFCM[Speed];	 // B=gadget button SMFV=0123
	 	SP[0]=GetValue(FG,TAG(NumFramesSlow));
		SP[1]=GetValue(FG,TAG(NumFramesMedium));
		SP[2]=GetValue(FG,TAG(NumFramesFast));
		pmode = GetValue(FG,TAG(PanelMode));
		type = (pmode==1) ? PAN_EXPERT:PAN_EASY ;

		if( (GetValue(FG,TAG(ForceDefaultMatte))==0) && (Color=GetValue(FG,TAG(MatteColor))) )
		{
			Color -= 1; // map 1-9 to 0-8 , or -1 -> -2 for CustomColor
			if(Color>8) Color=8;
			Matte=TRUE;
		}
		else if( GetValue(FG,TAG(AlgoFXborder)) && (Color=GetValue(FG,TAG(BorderColor))) )
		{
			Color -= 1; // map 1-8 to 0-7 , or -1 -> -2 for CustomColor
			if(Color>7) Color=7;
			Border=TRUE;
		}
		t_In=GetValue(FG,TAG(MaxDuration))>>1;
	}
	S=SP[notFCM[Speed]];

	EffectPL[0].Label =Label;
	EffectPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap

	EffectPL[1].Label =""; // Label;

	EffectPL[4].Param =&B;						// SMFV choice
	EffectPL[4].Param2 =SP;						// Array of field counts
	EffectPL[4].PropStart =(LONG)&EffectPL[5];	// PLine (time) to update

	EffectPL[5].Param = &S;	// Time slider
	EffectPL[5].Param2 = (LONG *)&EffectPL[4];	// FXSpeed gadg to set to V
	EffectPL[5].PropStart = 1;
	EffectPL[5].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
	EffectPL[5].Flags = PL_LEN;

// ~~*~~*~~*~~| This fence separates the XP from the EZ, it doesn't do much but they feel better |~~~*~~~*~~~|

	XPEffectPL[0].Label =Label;
	XPEffectPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap

	XPEffectPL[1].Label = ""; //Label;

	XPEffectPL[4].Param =&B;						// SMFV choice
	XPEffectPL[4].Param2 =SP;						// Array of field counts
	XPEffectPL[4].PropStart =(LONG)&XPEffectPL[5];	// PLine (time) to update

	XPEffectPL[5].Param = &S;	// Time slider
	XPEffectPL[5].Param2 = (LONG *)&XPEffectPL[4];	// FXSpeed gadg to set to V
	XPEffectPL[5].PropStart = 1;
	XPEffectPL[5].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
	XPEffectPL[5].Flags = PL_LEN;

	XPEffectPL[6].Type = PNL_SKIP;
	if(Matte)
	{
		XPEffectPL[6].Type = PNL_POPUP;
		XPEffectPL[6].Param = (long *)Colors;		// POPUP
		XPEffectPL[6].PropEnd = COLOR_NUM - 1; // don't include "Special"
		XPEffectPL[6].PropStart = Color<0 ? 0 : Color;
		if((GetValue(FG,TAG(CustomMatteColor))!=0))
		{
			XPEffectPL[6].PropEnd = COLOR_NUM;
			XPEffectPL[6].PropStart = Color<0 ? (COLOR_NUM - 1) : Color;
		}
	}
	else if(Border)
	{
		XPEffectPL[6].Type = PNL_POPUP;
		XPEffectPL[6].Param = (long *)Colors;		// POPUP
		XPEffectPL[6].PropEnd = COLOR_NUM - 2; // don't include "Special"
		XPEffectPL[6].PropStart = Color<0 ? 0 : Color;
		if((GetValue(FG,TAG(CustomBorderColor))!=0))
		{
			XPEffectPL[6].PropEnd = COLOR_NUM -1 ; // should swap ptrs for "Snow" and Special" here
			XPEffectPL[6].PropStart = Color<0 ? (COLOR_NUM - 2) : Color;
		}
	}

	XPEffectPL[7].Param = &D;	// Start Time slider
	XPEffectPL[7].PropStart = 1;
	XPEffectPL[7].PropEnd = t_In;	// (t_In>=330 ? t_In:330);

	while(type > PAN_CONTINUE)
	{
		switch(type)
		{
			case PAN_EXPERT:
				pmode=1;
				type = MiniPanel(Edit,XPEffectPL,TUNE_QUICK);
				break;
			case PAN_EASY:
				pmode=0;
				type = MiniPanel(Edit,EffectPL,TUNE_FINE);
				break;
		}
	}

	if(type==PAN_CONTINUE)
	{
		if(B!=notFCM[Speed])
			PutValue(FG,TAG(FCountMode),FCM[B]); // FCM[3]=2 = variable
		if( B==3 )
			PutValue(FG,TAG(VariableFCount),S<<1);   // Frames -> Fields
		if( Matte && Color!= XPEffectPL[6].PropStart )
		{
			PutValue(FG,TAG(MatteColor), (XPEffectPL[6].PropStart < COLOR_NUM -1) ? XPEffectPL[6].PropStart+1 : -1 );
//			ESparams2.Data1=(LONG)FG;
//			ESparams2.Data2=FGC_BORDER;
//			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		else if( Border && Color!= XPEffectPL[6].PropStart )
		{
			PutValue(FG,TAG(BorderColor), (XPEffectPL[6].PropStart < COLOR_NUM -2) ? XPEffectPL[6].PropStart+1 : -2 );
//			ESparams2.Data1=(LONG)FG;
//			ESparams2.Data2=FGC_BORDER;
//			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=FGC_FCOUNT;
		SendSwitcherReply(ES_FGcommand,&ESparams2);
		PutValue(FG,TAG(PanelMode),pmode);  // ...just following orders.
		return(TRUE);
	}
	return(FALSE);
}

// CT_FXILBM
BOOL DoFXANIMPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG A=0,B=2,t_In=900,type=PanType,Speed=1,S,SP[4]={45,30,15,9},D=0,
			Color=0,pmode=0;
	char Label[MAX_PANEL_STR];
	BOOL Matte=FALSE,Border=FALSE;
	if(FG)
	{
		SP[3]=GetValue(FG,TAG(NumFramesVariable));
//		if(SP[3]!=0)	return(DoFXALGOPanel(Edit,FG));  // Variable Speed
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Speed=GetValue(FG,TAG(FCountMode));
		Speed&=0x00000003; // 3,0,1,2 == S,M,F,V
		B=notFCM[Speed];	 // B=gadget button SMFV=0123
	 	SP[0]=GetValue(FG,TAG(NumFramesSlow));
		SP[1]=GetValue(FG,TAG(NumFramesMedium));
		SP[2]=GetValue(FG,TAG(NumFramesFast));
		Color=GetValue(FG,TAG(MatteColor));
		pmode = GetValue(FG,TAG(PanelMode));
		type = (pmode==1) ? PAN_EXPERT:PAN_EASY ;
		if( (GetValue(FG,TAG(ForceDefaultMatte))==0) && (Color!=0) )
		{
			Color -= 1; // map 1-9 to 0-8 , or -1 -> -2 for CustomColor
			if(Color>8) Color=8;
			Matte=TRUE;
		}
		else if( GetValue(FG,TAG(AlgoFXborder)) && (Color!=0) )
		{
			Color -= 1; // map 1-8 to 0-7 , or -1 -> -2 for CustomColor
			if(Color>7) Color=7;
			Border=TRUE;
		}
	}
	S=SP[notFCM[Speed]];

	AnimFXPL[0].Label =Label;
	AnimFXPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap

	AnimFXPL[1].Label =""; // Label;

	AnimFXPL[4].Param =&B;						// SMFV choice
	AnimFXPL[4].Param2 =SP;						// Array of field counts
	AnimFXPL[4].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME

	AnimFXPL[5].Param = &S;	// Time slider
	AnimFXPL[5].Param2 = &A;

// ~~*~~*~~*~~| This fence separates the XP from the EZ, it doesn't do much but they feel better |~~~*~~~*~~~|

	XPAnimFXPL[0].Label =Label;
	XPAnimFXPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap

	XPAnimFXPL[1].Label = ""; //Label;

	XPAnimFXPL[4].Param =&B;						// SMFV choice
	XPAnimFXPL[4].Param2 =SP;						// Array of field counts
	XPAnimFXPL[4].PropStart = NULL;	// PLine (time) to update

	XPAnimFXPL[5].Param = &S;	// Time slider
	XPAnimFXPL[5].Param2 = &A;

	XPAnimFXPL[6].Type = PNL_SKIP;
	if(Matte)
	{
		XPAnimFXPL[6].Type = PNL_POPUP;
		XPAnimFXPL[6].Param = (long *)Colors;		// POPUP
		XPAnimFXPL[6].PropEnd = COLOR_NUM - 1; // don't include "Special"
		XPAnimFXPL[6].PropStart = Color<0 ? 0 : Color;
		if((GetValue(FG,TAG(CustomMatteColor))!=0))
		{
			XPAnimFXPL[6].PropEnd = COLOR_NUM;
			XPAnimFXPL[6].PropStart = Color<0 ? (COLOR_NUM - 1) : Color;
		}
	}
	else if(Border)
	{
		XPAnimFXPL[6].Type = PNL_POPUP;
		XPAnimFXPL[6].Param = (long *)Colors;		// POPUP
		XPAnimFXPL[6].PropEnd = COLOR_NUM - 2; // don't include "Special"
		XPAnimFXPL[6].PropStart = Color<0 ? 0 : Color;
		if((GetValue(FG,TAG(CustomBorderColor))!=0))
		{
			XPAnimFXPL[6].PropEnd = COLOR_NUM -1 ; // should swap ptrs for "Snow" and Special" here
			XPAnimFXPL[6].PropStart = Color<0 ? (COLOR_NUM - 2) : Color;
		}
	}

	XPAnimFXPL[7].Param = &D;	// Start Time slider
	XPAnimFXPL[7].PropStart = 1;
	XPAnimFXPL[7].PropEnd = t_In;	// (t_In>=330 ? t_In:330);

	while(type > PAN_CONTINUE)
		switch(type)
		{
			case PAN_EXPERT:
				pmode=1;
				type = MiniPanel(Edit,XPAnimFXPL,TUNE_QUICK);
				break;
			case PAN_EASY:
				pmode=0;
				type = MiniPanel(Edit,AnimFXPL,TUNE_FINE);
				break;
		}


	if(type==PAN_CONTINUE)
	{
		if( Matte && Color!= XPAnimFXPL[6].PropStart )
		{
			PutValue(FG,TAG(MatteColor), (XPAnimFXPL[6].PropStart < COLOR_NUM -1) ? XPAnimFXPL[6].PropStart+1 : -1 );
//			ESparams2.Data1=(LONG)FG;
//			ESparams2.Data2=FGC_BG; // really Matte source.. duoooh!
//			ESparams2.Data2=FGC_BORDER;
//			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		else if( Border && Color!= XPAnimFXPL[6].PropStart )
		{
			PutValue(FG,TAG(BorderColor), (XPAnimFXPL[6].PropStart < COLOR_NUM -2) ? XPAnimFXPL[6].PropStart+1 : -1 );
//			ESparams2.Data1=(LONG)FG;
//			ESparams2.Data2=FGC_BORDER;
//			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		if(B!=notFCM[Speed])
		{
			PutValue(FG,TAG(FCountMode),FCM[B]); // FCM[3]=2 = variable
			ESparams2.Data1=(LONG)FG;
			ESparams2.Data2=FGC_FCOUNT;
			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		PutValue(FG,TAG(PanelMode),pmode);  // ...just following orders
		return(TRUE);
	}
	return(FALSE);
}


// CT_FXILBM
BOOL DoFXILBMPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	return(DoFXALGOPanel(Edit,FG));
}

// CT_FXCR
BOOL DoFXCRPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG TBar=0,TBarb=0,B=2,t_In=300,type=PanType,Speed=1,S,SP[4]={45,30,15,9},
		D=0, Cmod=0,Dmod=0, Cyc=0;
	char Label[MAX_PANEL_STR];
	struct TagMess	tagTBar={TAG(TBarPosition),NULL,4,0},
		tagDmod={TAG(DataMode),NULL,4,0},
		tagCmod={TAG(ColorMode),NULL,4,0},
		tagCyc={TAG(CycleMode),NULL,4,0};
	if(FG)
	{
		SP[3]=GetValue(FG,TAG(NumFramesVariable));
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Speed=GetValue(FG,TAG(FCountMode));
		Speed&=0x00000003; // 3,0,1,2 == S,M,F,V
		B=notFCM[Speed];	 // B=gadget button SMFV=0123
	 	SP[0]=GetValue(FG,TAG(NumFramesSlow));
		SP[1]=GetValue(FG,TAG(NumFramesMedium));
		SP[2]=GetValue(FG,TAG(NumFramesFast));
		D = GetValue(FG,TAG(Delay));
		Cyc=GetValue(FG,TAG(CycleMode));
		Cmod=GetValue(FG,TAG(ColorMode));
		Dmod=GetValue(FG,TAG(DataMode));
		TBar=(TBarb=GetValue(FG,TAG(TBarPosition)));
		t_In=GetValue(FG,TAG(MaxDuration))>>1;
	}
	S=SP[notFCM[Speed]];

	CFXPL[0].Label =Label;
	CFXPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap

	CFXPL[1].Label =""; // Label;

	CFXPL[4].Param =&B;						// SMFV choice
	CFXPL[4].Param2 =SP;						// Array of field counts
	CFXPL[4].PropStart =(LONG)&CFXPL[5];	// PLine (time) to update

	CFXPL[5].Param = &S;	// Time slider
	CFXPL[5].Param2 = (LONG *)&CFXPL[4];	// FXSpeed gadg to set to V
	CFXPL[5].PropStart = 1;
	CFXPL[5].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
	CFXPL[5].Flags = PL_LEN;

	CFXPL[6].Param = &D;	// Start Time slider
	CFXPL[6].PropStart = 1;
	CFXPL[6].PropEnd = t_In;	// (t_In>=330 ? t_In:330);

	CFXPL[7].Param = (long *)CFX_Cycles;		// POPUP
	CFXPL[7].PropEnd = 4;
	CFXPL[7].PropStart = Cyc;
	CFXPL[7].UserFun = CTRL_SetTag;
	tagCyc.tm_Val = (ULONG *)&CFXPL[7].PropStart;
	tagCyc.tm_FG = FG;
	CFXPL[7].UserObj = (APTR)&tagCyc;

	CFXPL[8].Param = &TBar;	// Start Time slider
	CFXPL[8].PropStart = 1;
	CFXPL[8].PropEnd = 511;
	CFXPL[8].UserFun = CTRL_SetTag;
	tagTBar.tm_Val = (ULONG *)CFXPL[8].Param;
	tagTBar.tm_FG = FG;
	CFXPL[8].UserObj = (APTR)&tagTBar;

	CFXPL[9].Param = (long *)CFX_CModes;		// POPUP
	CFXPL[9].PropEnd = 2;
	CFXPL[9].PropStart = Cmod;
	CFXPL[9].UserFun = CTRL_SetTag;
	tagCmod.tm_Val = (ULONG *)&CFXPL[9].PropStart;
	tagCmod.tm_FG = FG;
	CFXPL[9].UserObj = (APTR)&tagCmod;

	CFXPL[10].Param = (long *)CFX_DModes;		// POPUP
	CFXPL[10].PropEnd = 2;
	CFXPL[10].PropStart = Dmod;
	CFXPL[10].UserFun = CTRL_SetTag;
	tagDmod.tm_Val = (ULONG *)&CFXPL[10].PropStart;
	tagDmod.tm_FG = FG;
	CFXPL[10].UserObj = (APTR)&tagDmod;

	while(type > PAN_CONTINUE)
	{
		switch(type)
		{
			case PAN_EXPERT:
			case PAN_EASY:
				type = MiniPanel(Edit,CFXPL,TUNE_NONE);
				break;
		}
	}

	if(type==PAN_CONTINUE)
	{
		if(B!=notFCM[Speed])
			PutValue(FG,TAG(FCountMode),FCM[B]); // FCM[3]=2 = variable
		if( B==3 )
			PutValue(FG,TAG(VariableFCount),S<<1);   // Frames -> Fields

		if(CFXPL[7].PropStart != Cyc)
			PutValue(FG,TAG(CycleMode),CFXPL[7].PropStart);
		if(CFXPL[9].PropStart != Cmod)
			PutValue(FG,TAG(ColorMode),CFXPL[9].PropStart);
		if(CFXPL[10].PropStart != Dmod)
			PutValue(FG,TAG(DataMode),CFXPL[10].PropStart);
		if(TBar!=TBarb)
			PutValue(FG,TAG(TBarPosition),TBar);
		PutValue(FG,TAG(Delay),D);

		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=FGC_FCOUNT;
		SendSwitcherReply(ES_FGcommand,&ESparams2);
		return(TRUE);
	}
	else
	{
		PutValue(FG,TAG(CycleMode),Cyc);
		PutValue(FG,TAG(ColorMode),Cmod);
		PutValue(FG,TAG(DataMode),Dmod);
		PutValue(FG,TAG(TBarPosition),TBarb);
	}
	return(FALSE);
}

#define LENGTH_ADJUST		2

// CT_AUDIO
BOOL DoAUDIOPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG FadeIn=0,FadeOut=0,V=0,P=0,V1=0xFFC0,V2=0xFFC0,A=800,B,TM,TMb,
	t_In=36,t_Out=69,type=PanType,Time,S=0,SP[12]={36,69,0,0},AudioOn=1,pmode=0,smpte=0;
	char Label[MAX_PANEL_STR]="", *pan[]={"L","R"};
	struct SMPTEinfo si;

	CommentBuf[0]=0;
	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
// This is a constant value
		Time = A = (GetValue(FG,TAG(RecFields))>>2)<<1 ;
		if(A<2) Time=A=4;
// Stash original values
		SP[2] = GetValue(FG,TAG(Delay));
		SP[3] = GetValue(FG,TAG(AudioStart));
		if(!(SP[4] = GetValue(FG,TAG(AudioDuration)) )) SP[4]=A-SP[3];
		SP[5] = GetValue(FG,TAG(AudioAttack));
		SP[6] = GetValue(FG,TAG(AudioDecay));
		SP[7] = V1 = GetValue(FG,TAG(AudioVolume1));
		SP[8] = V2 = GetValue(FG,TAG(AudioVolume2));
		pmode = GetValue(FG,TAG(PanelMode));
		if(pmode==1) type=PAN_EXPERT;
		TM=(TMb=GetValue(FG,TAG(TimeMode)));
		if(GetTable(FG,TAG_SMPTEtime,(UBYTE *)&si,sizeof(struct SMPTEinfo)))
		{
			smpte = EVEN(SMPTEToLong(&si));
//			smpte = SMPTEToLong(&si);
			DUMPUDECB("SMPTE Start: ",si.SMPTEhours,":");
			DUMPUDECB("",si.SMPTEminutes,":");
			DUMPUDECB("",si.SMPTEseconds,":");
			DUMPUDECB("",si.SMPTEframes,"  = ");
			DUMPUDECL(" ",smpte," frames \\");
		}

		AudioOn = GetValue(FG,TAG(AudioOn));

// These are values that are modified by the panel
		SP[0] = t_In  = ((SP[3]>>2)<<1) + smpte;			 // In Frame
		SP[1] = t_Out = (((SP[3]+SP[4]-4)>>2)<<1) + smpte;  // Out Frame
		FadeIn = SP[5] >>1;
		FadeOut= SP[6] >>1;
		S = SP[2] >>1;
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);

		CurAudioSet.AudioOn=AudioOn;
		if( HAS_STEREO(AudioOn) && IS_STEREO(AudioOn) )
		{
			CurAudioSet.Mode=AMODE_STEREO;
			CurAudioSet.Pan1 = PAN_LEFT;
			CurAudioSet.Pan2 = PAN_RIGHT;
			PutValue(FG,TAG(AudioPan1),CurAudioSet.Pan1);
			PutValue(FG,TAG(AudioPan2),CurAudioSet.Pan2);
		}
		else if( HAS_LEFT(AudioOn) || IS_LEFT(AudioOn) )
		{
			CurAudioSet.Mode=AMODE_LEFT;
			CurAudioSet.Pan1 = 0;
			PutValue(FG,TAG(AudioPan1),CurAudioSet.Pan1);
		}
		else if( HAS_RIGHT(AudioOn) || IS_RIGHT(AudioOn) )
		{
			CurAudioSet.Mode=AMODE_RIGHT;
			CurAudioSet.Pan2 = 0;
			PutValue(FG,TAG(AudioPan2),CurAudioSet.Pan2);
		}
//		else Haven't dealt with pathologic situations
	}
	else strncat(Label,"Canned Laughter",MAX_PANEL_STR);

	DUMPHEXIW("Old Balance: ",CurAudioSet.Balance,"\\");

	CurAudioSet.FG = FG;
	CurAudioSet.V1 = V1;
	CurAudioSet.V2 = V2;

	P=GetBalance(&CurAudioSet);
	V=GetVolume(&CurAudioSet);

	DUMPHEXIW("New Balance: ",CurAudioSet.Balance,"\\");

	AudClipPL[0].Label = Label;
	AudClipPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
	AudClipPL[0].Param = (long *)CommentBuf;
	AudClipPL[0].PropEnd = COMMENT_MAX;
	AudClipPL[0].UserFun=CTRL_Play;
	AudClipPL[0].UserObj=(APTR)FG;
	AudClipPL[0].Flags=PL_PLAY;

	AudClipPL[2].Param =  &t_Out;
	AudClipPL[2].Param2 = &t_In;
	AudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
	AudClipPL[2].PropStart = PANEL_LENGTHX<<16;
	AudClipPL[2].PropStart += 12 + PIN_YOFF;
	AudClipPL[2].UserObj = (APTR)1;

	AudClipPL[3].Param = &t_In;
	AudClipPL[3].Param2 = &t_Out;
	AudClipPL[3].PropStart = smpte;
	AudClipPL[3].PropEnd = smpte + A-LENGTH_ADJUST;  // Min length= 1 colorframe
	AudClipPL[3].Flags = PL_IN | PL_AUD1 | PL_DUAL | PL_CFRAME;

	AudClipPL[5].Param = (LONG *)TimeModes;
	AudClipPL[5].PropStart = TM;
	AudClipPL[5].PropEnd = 2;

	AudClipPL[6].Param = &S;
	AudClipPL[6].PropStart = 0;
	AudClipPL[6].PropEnd = MAX_DELAY;
	AudClipPL[6].Flags = PL_DEL;


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

	XPAudClipPL[0].Label = Label;
	XPAudClipPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
	XPAudClipPL[0].Param = (long *)CommentBuf;
	XPAudClipPL[0].PropEnd = COMMENT_MAX;
	XPAudClipPL[0].UserFun=CTRL_Play;
	XPAudClipPL[0].UserObj=(APTR)FG;
	XPAudClipPL[0].Flags=PL_PLAY;

	XPAudClipPL[2].Param = &t_Out;
	XPAudClipPL[2].Param2 = &t_In;
	XPAudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
	XPAudClipPL[2].PropStart = PANEL_LENGTHX<<16;
	XPAudClipPL[2].PropStart += 12 + PIN_YOFF;
	XPAudClipPL[2].UserObj = (APTR)1; // Flag for custom DIFF positioning

	XPAudClipPL[3].Param = &t_In;
	XPAudClipPL[3].Param2 = &t_Out;
	XPAudClipPL[3].PropStart = smpte;
	XPAudClipPL[3].PropEnd = smpte + A - LENGTH_ADJUST;
	XPAudClipPL[3].Flags = PL_IN | PL_AUD1 | PL_DUAL | PL_CFRAME;

	XPAudClipPL[5].Param = (LONG *)TimeModes;
	XPAudClipPL[5].PropStart = TM;
	XPAudClipPL[5].PropEnd = 2;

	XPAudClipPL[6].Param = &S;
	XPAudClipPL[6].PropStart = 0;
	XPAudClipPL[6].PropEnd = MAX_DELAY;
	XPAudClipPL[6].Flags = PL_DEL;

	XPAudClipPL[7].Param = &CurAudioSet.Volume;
//	XPAudClipPL[7].Param2 = (LONG *)&(XPAudClipPL[11]); // Balance PL
	XPAudClipPL[7].PropStart = 0;
	XPAudClipPL[7].PropEnd = 100;
	XPAudClipPL[7].Flags = PL_AUD1|PL_AUD2;
	XPAudClipPL[7].UserFun=CTRL_SetVolume;
	XPAudClipPL[7].UserObj=(APTR)&CurAudioSet;

//	XPAudClipPL[8].Param =&CurAudioSet.Volume;  // !!! Unnecessary in CTRL_SetBalance???
	XPAudClipPL[8].Param2 = (long *) pan;
//	XPAudClipPL[8].PropStart = CurAudioSet.Balance;
	B=CurAudioSet.Balance;
	XPAudClipPL[8].Param = &B;  // Should move initial value to Param
	XPAudClipPL[8].UserFun= CTRL_SetBalance;
	XPAudClipPL[8].UserObj=(APTR)&CurAudioSet;

	XPAudClipPL[9].Param = &FadeIn;
	XPAudClipPL[9].PropStart = 0;
	XPAudClipPL[9].PropEnd = MAX_AUD_FADE;
	XPAudClipPL[9].Flags = PL_AUD1;  // means Attack on EZLen types

	XPAudClipPL[10].Param = &FadeOut;
	XPAudClipPL[10].PropStart = 0;
	XPAudClipPL[10].PropEnd = MAX_AUD_FADE;
	XPAudClipPL[10].Flags = PL_AUD2;  // means Decay on EZLen types

	XPAudClipPL[11].Param = (LONG *)Channels;
	XPAudClipPL[11].PropStart = CurAudioSet.Mode;
	XPAudClipPL[11].PropEnd = 3;
	XPAudClipPL[11].UserFun=CTRL_SetPan;
	XPAudClipPL[11].UserObj=(APTR)&CurAudioSet;

	XPAudClipPL[12].Flags =  PL_AVAIL;

	while(type > PAN_CONTINUE)
	{
		DUMPUDECL("B4 Type:	",type,"	");
		DUMPUDECL("PanelMode: ",pmode,"\\ ");
		switch(type)
		{
			case PAN_EXPERT:
				pmode=1;
				type = FlyPanel(Edit,XPAudClipPL,TUNE_QUICK);
				TM = XPAudClipPL[5].PropStart;
				break;
			case PAN_EASY:
				pmode=0;
				type = FlyPanel(Edit,AudClipPL,TUNE_FINE);
				TM = AudClipPL[5].PropStart;
				break;
			case PAN_PROCESS:
				DoProcClipPanel(Edit,FG);
				type=PAN_CANCEL;
				break;

		}
		DUMPUDECL("After Type:	",type,"	");
		DUMPUDECL("PanelMode: ",pmode,"\\ ");
	}

	if(type==PAN_CONTINUE) // Set non-real-time adjusted values
	{
		if(t_In!=SP[0])
		{
			PutValue(FG,TAG(AudioStart),(t_In-smpte)<<1);
		 	PutValue(FG,TAG(AudioDuration),(t_Out+2-t_In)<<1);
		}
		else if(t_Out!=SP[1])
		{
		 	PutValue(FG,TAG(AudioDuration),(t_Out+2-t_In)<<1);
		}
		if(TMb != TM)
			PutValue(FG,TAG(TimeMode),TM);
		if( (SP[2]>>1)!=S )
			PutValue(FG,TAG(Delay),S<<1);
		if( (SP[5]>>1)!=FadeIn )
			PutValue(FG,TAG(AudioAttack),FadeIn<<1);
		if( (SP[6]>>1)!=FadeOut )
			PutValue(FG,TAG(AudioDecay),FadeOut<<1);
		if( (AudClipPL[0].PropStart) || (XPAudClipPL[0].PropStart) )
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		PutValue(FG,TAG(PanelMode),pmode);  // ...just following orders
		return(TRUE);
	}
	else if(type==PAN_CANCEL)  // reset real-time adjusted values to old values
	{
		PutValue(FG,TAG(Delay),					SP[2]);
		PutValue(FG,TAG(AudioStart),		SP[3]);
		PutValue(FG,TAG(AudioDuration),	SP[4]);
		PutValue(FG,TAG(AudioAttack),		SP[5]);
		PutValue(FG,TAG(AudioDecay),		SP[6]);
		PutValue(FG,TAG(AudioVolume1),	SP[7]);
		PutValue(FG,TAG(AudioVolume2),	SP[8]);
		PutValue(FG,TAG(AudioOn),AudioOn);
		ESparams1.Data1 =(LONG) FG;
		SendSwitcherReply(ES_ChangeAudio,&ESparams1);
	}
	return(FALSE);
}

// CT_VIDEO
BOOL DoVIDEOPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG B,Vol=0,P,V1=0xFFFF,V2=0x8000,A=800,t_In=36,t_Out=69,A_In,A_Out,AFade_In=0,AFade_Out=0,
		type=PanType,SP[16]={36,69,0,36},AudioOn=1,pmode=0,Relate=0,smpte=0;
	char Label[MAX_PANEL_STR]="",*pan[]={"L","R"}, *aud[]={"Play Audio "};
	BOOL Jam_On=TRUE;
	struct SMPTEinfo si;

	CommentBuf[0]=0;
	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
// This is a constant value
		A = (GetValue(FG,TAG(RecFields))>>1);  // Clip Frame Length
		if(A<2) A=4;
// Stash original values
		SP[3]= GetValue(FG,TAG(ClipStartField));
		if( !(SP[4]= GetValue(FG,TAG(Duration))) ) SP[4]=A-SP[3];
		SP[5]= GetValue(FG,TAG(AudioStart));
		if( !(SP[6]= GetValue(FG,TAG(AudioDuration))) ) SP[6]=A-SP[5];
		SP[9]  = V1 =GetValue(FG,TAG(AudioVolume1));
		SP[10] = V2 =GetValue(FG,TAG(AudioVolume2));
		SP[11] = GetValue(FG,TAG(AudioAttack));
		SP[12] = GetValue(FG,TAG(AudioDecay));
		AudioOn = GetValue(FG,TAG(AudioOn));
		pmode = GetValue(FG,TAG(PanelMode));
		if(pmode==1) type=PAN_EXPERT;
		if(GetTable(FG,TAG_SMPTEtime,(UBYTE *)&si,sizeof(struct SMPTEinfo)))
		{
//			smpte = SMPTEToLong(&si);
			smpte = EVEN(SMPTEToLong(&si));
			DUMPUDECB("SMPTE Start: ",si.SMPTEhours,":");
			DUMPUDECB("",si.SMPTEminutes,":");
			DUMPUDECB("",si.SMPTEseconds,":");
			DUMPUDECB("",si.SMPTEframes,"  = ");
			DUMPUDECL(" ",smpte," frames \\");
		}

// These are values that are modified by the panel
		SP[0] = t_In  = ((SP[3]>>2)<<1) + smpte;			 // In Frame
		SP[1] = t_Out = (( (SP[3]+SP[4]-4)>>2 )<<1) + smpte;  // Out Frame
		if(t_In > t_Out) t_Out = t_In+2;
//		SP[2] = B     =((GetValue(FG,TAG(FadeInVideo)) !=0) ? 0:1); // FadeIn flag
		SP[7]= A_In  = ((SP[5] >> 2)<<1)  + smpte;
		SP[8]= A_Out = (((SP[5]+SP[6]-4)>>2)<<1) + smpte;
    AFade_In = SP[11] >>1;
    AFade_Out= SP[12] >>1;
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);

		CurAudioSet.AudioOn=AudioOn;
		if( HAS_STEREO(AudioOn) && IS_STEREO(AudioOn) )
		{
			CurAudioSet.Mode=AMODE_STEREO;
			CurAudioSet.Pan1 = PAN_LEFT;
			CurAudioSet.Pan2 = PAN_RIGHT;
			PutValue(FG,TAG(AudioPan1),CurAudioSet.Pan1);
			PutValue(FG,TAG(AudioPan2),CurAudioSet.Pan2);
		}
		else if( HAS_LEFT(AudioOn) || IS_LEFT(AudioOn) )
		{
			CurAudioSet.Mode=AMODE_LEFT;
			CurAudioSet.Pan1 = 0;
			PutValue(FG,TAG(AudioPan1),CurAudioSet.Pan1);
		}
		else if( HAS_RIGHT(AudioOn) || IS_RIGHT(AudioOn) )
		{
			CurAudioSet.Mode=AMODE_RIGHT;
			CurAudioSet.Pan2 = 0;
			PutValue(FG,TAG(AudioPan2),CurAudioSet.Pan2);
		}
		else if( !IS_ANYAUDIO(AudioOn) )
		{
			CurAudioSet.Mode= AMODE_NOAUDIO;
		}
	}
	else
	{
		strncat(Label,"Kiki's Shower",MAX_PANEL_STR);
		strcpy(CommentBuf,"No Comment At This Time");
	}

	DUMPHEXIW("Old Balance: ",CurAudioSet.Balance,"\\");
	CurAudioSet.FG = FG;
	CurAudioSet.V1 = V1;
	CurAudioSet.V2 = V2;
	P=GetBalance(&CurAudioSet);
	Vol=GetVolume(&CurAudioSet);
	DUMPHEXIW("New Balance: ",CurAudioSet.Balance,"\\");

	ClipPL[0].Label = "";

	ClipPL[1].Label = Label;
	ClipPL[1].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
	ClipPL[1].Param = (long *)CommentBuf;
	ClipPL[1].PropEnd = COMMENT_MAX ; // max string length
	ClipPL[1].PropStart=0;		// set to non-zero if comment is changed...
//	ClipPL[1].UserFun=CTRL_Play;
	ClipPL[1].UserObj=(APTR)FG;

	ClipPL[2].UserFun=CTRL_Play;
	ClipPL[2].UserObj=(APTR)FG;
	ClipPL[2].Flags=PL_PLAY;

	ClipPL[3].Param = &t_Out; // out
	ClipPL[3].Param2 = &t_In; // in
	ClipPL[3].G5 = (struct Gadget *)2; // diff add-on
	ClipPL[3].PropStart = PANEL_LENGTHX<<16;
	ClipPL[3].PropStart += 12 + PIN_YOFF;
	ClipPL[3].UserObj = (APTR) 1; // Flag for custom DIFF positioning

	ClipPL[5].Param = &t_In;
	ClipPL[5].Param2 = &t_Out;
	ClipPL[5].PropStart = smpte;
	ClipPL[5].PropEnd = smpte+A-LENGTH_ADJUST;
	ClipPL[5].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;

	if(!HAS_ANYAUDIO(AudioOn))
	{
		ClipPL[7].Type = 0;
	}
	else
	{
		ClipPL[7].Param =(LONG *) (IS_ANYAUDIO(AudioOn) ? 1:0);
		ClipPL[7].Param2 = (LONG *)aud;
		ClipPL[7].PropEnd = 1;
		ClipPL[7].UserFun=CTRL_SetAudio;
		ClipPL[7].UserObj=(APTR)&CurAudioSet;
	}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	XPClipPL[0].Label = ""; //Label;

	XPClipPL[1].Label = Label;
	XPClipPL[1].Param2 = (FG ? (long *)FG->Data:(long *)NULL); // icon bitmap
	XPClipPL[1].Param = (long *)CommentBuf;
	XPClipPL[1].PropEnd = COMMENT_MAX ; // max string length
	XPClipPL[1].PropStart=0;		// set to non-zero if comment is changed...
	XPClipPL[1].UserFun=CTRL_Play;
	XPClipPL[1].UserObj=(APTR)FG;

	XPClipPL[2].UserFun=CTRL_Play;
	XPClipPL[2].UserObj=(APTR)FG;
	XPClipPL[2].Flags=PL_PLAY;

	XPClipPL[3].Param = &t_Out;
	XPClipPL[3].Param2 = &t_In;
	XPClipPL[3].G5 = (struct Gadget *)2; // diff
	XPClipPL[3].PropStart = PANEL_LENGTHX<<16;
	XPClipPL[3].PropStart += 12 + PIN_YOFF;
	XPClipPL[3].UserObj = (APTR)1; // Flag for custom DIFF positioning

	XPClipPL[5].Param = &t_In;
	XPClipPL[5].Param2 = &t_Out;
	XPClipPL[5].PropStart = smpte;
	XPClipPL[5].PropEnd = smpte+A-LENGTH_ADJUST;
	XPClipPL[5].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;
	XPClipPL[5].NumParts=0;

	if(!HAS_ANYAUDIO(AudioOn))
	{
		XPClipPL[7].Type = 0;
	}
	else
	{
		XPClipPL[8].Param = &A_In;
		XPClipPL[8].Param2 = &A_Out;
		XPClipPL[8].PropStart = smpte;
		XPClipPL[8].PropEnd = smpte+A-LENGTH_ADJUST;
		XPClipPL[8].Flags = PL_AUDIO | PL_IN | PL_CFRAME | PL_DUAL;
//		XPClipPL[8].UserFun=CTRL_DumpPLine;

		XPClipPL[5].NumParts=1;  // Connect audio slider to video slider
		Relate = PR_MIRROR;
		XPClipPL[5].Relation=&Relate;
		XPClipPL[5].Partners=&(XPClipPL[8]);

		XPClipPL[10].Param = &CurAudioSet.Volume;
//		XPClipPL[10].Param2 = (LONG *)&(XPClipPL[11]); // Balance PL
		XPClipPL[10].PropStart = 0;
		XPClipPL[10].PropEnd = 100;
		XPClipPL[10].Flags =  PL_AUD1|PL_AUD2;
		XPClipPL[10].UserFun=CTRL_SetVolume;
		XPClipPL[10].UserObj=(APTR)&CurAudioSet;

//		XPClipPL[11].Param = &CurAudioSet.Volume; // Overall volume control for "Balance"
		XPClipPL[11].Param2 = (LONG *)pan;
//		XPClipPL[11].PropStart = CurAudioSet.Balance;
		B=CurAudioSet.Balance;
		XPClipPL[11].Param = &B;
		XPClipPL[11].UserFun= CTRL_SetBalance;
		XPClipPL[11].UserObj=(APTR)&CurAudioSet;

		XPClipPL[12].Param = &AFade_In;
		XPClipPL[12].PropStart = 0;
		XPClipPL[12].PropEnd = MAX_AUD_FADE;

		XPClipPL[13].Param = &AFade_Out;
		XPClipPL[13].PropStart = 0;
		XPClipPL[13].PropEnd = MAX_AUD_FADE;

		XPClipPL[14].Param = (LONG *)Channels;
		XPClipPL[14].PropStart = CurAudioSet.Mode;
		XPClipPL[14].PropEnd = 4;
		XPClipPL[14].UserFun=CTRL_SetPan;
		XPClipPL[14].UserObj=(APTR)&CurAudioSet;
	}
	XPClipPL[15].Flags =  PL_AVAIL;

	while(type > PAN_CONTINUE)
	{
		switch(type)
		{
			case PAN_EASY:
				ClipPL[7].Param =(LONG *) (IS_ANYAUDIO(CurAudioSet.AudioOn) ? 1:0);
				type = FlyPanel(Edit,ClipPL,TUNE_FINE);
				pmode=0;
				if(t_In  != SP[0])  // Audio should match Video on easy panel
				{
					A_In = t_In;
					SetAudioInPoint(FG,(A_In-smpte)<<1,(A_Out-smpte)<<1);
				}
				if(t_Out != SP[1])
				{
					A_Out = t_Out;
					SetAudioOutPoint(FG,(A_In-smpte)<<1,(A_Out-smpte)<<1);
				}
				break;
			case PAN_EXPERT:
				pmode=1;
				XPClipPL[14].PropStart = ( IS_ANYAUDIO(CurAudioSet.AudioOn) ? CurAudioSet.Mode:AMODE_NOAUDIO );
				type = FlyPanel(Edit,XPClipPL,TUNE_QUICK);
				break;
			case PAN_PROCESS:
				DoProcClipPanel(Edit,FG);
				type=PAN_CANCEL;
				break;
		}
	}
	if(!(AudioOn&AUD_EXISTS))
		XPClipPL[7].Type = PNL_DIVIDE;


	if(type==PAN_CONTINUE)
	{
		if(AFade_In != SP[11] >>1)
			PutValue(FG,TAG(AudioAttack),		AFade_In<<1);
		if(AFade_Out!= SP[12] >>1)
			PutValue(FG,TAG(AudioDecay),		AFade_Out<<1);
		if( (XPClipPL[1].PropStart) || (ClipPL[1].PropStart) )
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		PutValue(FG,TAG(PanelMode),pmode);  // ...just following orders
	}
	else  // The Jog/Shuttle may have affected these values, so we restore them!!
	{
		PutValue(FG,TAG(FadeInVideo),		SP[2]^1);
		PutValue(FG,TAG(ClipStartField),SP[3]);
		PutValue(FG,TAG(Duration),			SP[4]);
		PutValue(FG,TAG(AudioAttack),		SP[11]);
		PutValue(FG,TAG(AudioDecay),		SP[12]);
		PutValue(FG,TAG(AudioStart),		SP[5]);
		PutValue(FG,TAG(AudioDuration),	SP[6]);
		PutValue(FG,TAG(AudioVolume1),	SP[9]);
		PutValue(FG,TAG(AudioVolume2),	SP[10]);
		PutValue(FG,TAG(AudioOn),AudioOn);
		Jam_On=FALSE;
		ESparams1.Data1 =(LONG) FG;
		SendSwitcherReply(ES_ChangeAudio,&ESparams1);
	}
	//Main2Blank();
	return(Jam_On);
}

// CT_CONTROL
BOOL DoCONTROLPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG A=0,B=1,t_In=1800,t_Out=1,type=PanType,Time=84;
	char Label[MAX_PANEL_STR]="";

	if(FG)
	{
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Time=GetValue(FG,TAG(Duration))>>1; // Fields-->Frames
		t_In=GetValue(FG,TAG(MaxDuration))>>1;
		A=Time;
		B=GetValue(FG,TAG(FadeInVideo));
		B=((B!=0) ? 0:1);
		t_Out=B;
	}
//	if(type==PAN_EASY)
	{
		VideoPL[1].Label =Label;
		VideoPL[3].Param = &Time;	// Time slider
		VideoPL[3].PropStart = 1;
		VideoPL[3].PropEnd = (t_In>=900 ? t_In:1800);
		VideoPL[4].Param = &B;
		VideoPL[3].Flags = PL_LEN;
//		type = MiniPanel(Edit,VideoPL,TUNE_FINE);
	}
//	if(type==PAN_EXPERT)
	{
		XPVideoPL[1].Label =Label;
		XPVideoPL[3].Param = &Time;	// Time slider
		XPVideoPL[3].PropStart = 1;
		XPVideoPL[3].PropEnd = (t_In>=900 ? t_In:1800);
		XPVideoPL[4].Param = &B;
		XPVideoPL[3].Flags = PL_LEN;
//		type = MiniPanel(Edit,XPVideoPL,TUNE_QUICK);
	}

	while(type > PAN_CONTINUE)
		switch(type)
		{
			case PAN_EXPERT:
				type = MiniPanel(Edit,XPVideoPL,TUNE_QUICK);
				break;
			case PAN_EASY:
				type = MiniPanel(Edit,VideoPL,TUNE_FINE);
				break;
		}


	if(type==PAN_CONTINUE)
	{
		if(A!=Time)
			PutValue(FG,TAG(Duration),Time<<1);    // Frames -> Fields
		if(B!=t_Out) PutValue(FG,TAG(FadeInVideo),B^1);
		return(TRUE);
	}
	return(FALSE);
}

// CT_FRAMESTORE
BOOL DoFRAMESTOREPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG A=69,t_In=100,type=PanType,Time=80;
	char Label[MAX_PANEL_STR]="Still: ";

	CommentBuf[0]=0;
	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Time=GetValue(FG,TAG(Duration))>>1; // Fields-->Frames
		t_In=GetValue(FG,TAG(MaxDuration))>>1;
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);

		A=Time;
	}
	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		FramePL[0].Label =Label;
		FramePL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		FramePL[0].Param = (long *)CommentBuf;
		FramePL[0].PropEnd = COMMENT_MAX;

		FramePL[2].Param = &Time;	// Time slider
		FramePL[2].PropStart = 1;
		FramePL[2].PropEnd = (t_In>=900 ? t_In:1800);
		FramePL[2].Flags = PL_LEN | PL_CFRAME;
		type = MiniPanel(Edit, FramePL,TUNE_NONE);
	}
	if(type==PAN_CONTINUE)
	{
		if(A!=Time)
			PutValue(FG,TAG(Duration),Time<<1);    // Frames -> Fields
		if(FramePL[0].PropStart)
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		return(TRUE);
	}
	return(FALSE);
}

// CT_KEY
BOOL DoKEYPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG A=0,B=2,t_In,t_Out,type=PanType,Speed=1,Time=69,DLay=12,FadeIn=15,
		FadeOut=15,pmode=0,TM,TMb;
	char Label[MAX_PANEL_STR]="Graphic Overlay ";

	CommentBuf[0]=0;
	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Time=(A=GetValue(FG,TAG(Duration)));
		DLay=(B=GetValue(FG,TAG(Delay)));
		TM=(TMb=GetValue(FG,TAG(TimeMode)));
		Speed=GetValue(FG,TAG(Speed)); // bit0 =fade in, bit1=fade out
		FadeIn=GetValue(FG,TAG(FadeInDuration));
		FadeOut=GetValue(FG,TAG(FadeOutDuration));
		if(!(Speed&1)) FadeIn=0;
		if(!(Speed&2)) FadeOut=0;
		t_In = FadeIn;
		t_Out = FadeOut;
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		pmode = GetValue(FG,TAG(PanelMode));
		type = (pmode==1) ? PAN_EXPERT:PAN_EASY ;
	}

	KeyPL[0].Label =Label;
	KeyPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
	KeyPL[0].Param = (long *)CommentBuf;
	KeyPL[0].PropEnd = COMMENT_MAX;

	KeyPL[2].Param = &Time;
	KeyPL[2].PropStart = 1;
	KeyPL[2].PropEnd = 3600;
	KeyPL[2].Flags = PL_LEN | PL_CFRAME;

	KeyPL[3].Param = (LONG *)TimeModes;
	KeyPL[3].PropStart = TM;
	KeyPL[3].PropEnd = 2;

	KeyPL[4].Param = &DLay;
	KeyPL[4].PropStart = 1;
	KeyPL[4].PropEnd = 3600;
	KeyPL[4].Flags = PL_DEL;

	XPKeyPL[0].Label =Label;
	XPKeyPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
	XPKeyPL[0].Param = (long *)CommentBuf;
	XPKeyPL[0].PropEnd = COMMENT_MAX;

	XPKeyPL[2].Param = &Time;
	XPKeyPL[2].PropStart = 1;
	XPKeyPL[2].PropEnd = 3600;
	XPKeyPL[2].Flags = PL_LEN | PL_CFRAME;

	XPKeyPL[3].Param = (LONG *)TimeModes;
	XPKeyPL[3].PropStart = TM;
	XPKeyPL[3].PropEnd = 2;

	XPKeyPL[4].Param = &DLay;
	XPKeyPL[4].PropStart = 1;
	XPKeyPL[4].PropEnd = 3600;
	XPKeyPL[4].Flags = PL_DEL;


	XPKeyPL[6].Param = &FadeIn;
	XPKeyPL[6].PropStart = 1;
	XPKeyPL[6].PropEnd = A;
	XPKeyPL[6].Flags = PL_IN;

	XPKeyPL[7].Param = &FadeOut;
	XPKeyPL[7].PropStart = 1;
	XPKeyPL[7].PropEnd = A;
	XPKeyPL[7].Flags = PL_OUT;


	while(type > PAN_CONTINUE)
		switch(type)
		{
			case PAN_EXPERT:
				pmode=1;
				type = MiniPanel(Edit, XPKeyPL,TUNE_QUICK);
				TM=XPKeyPL[4].PropStart;
				break;
			case PAN_EASY:
				pmode=0;
				type = MiniPanel(Edit, KeyPL,TUNE_FINE);
				TM=KeyPL[4].PropStart;
				break;
		}



	if(type==PAN_CONTINUE)
	{
		if(A!=Time)
		{
			PutValue(FG,TAG(Duration),Time);
			ESparams2.Data1=(LONG)FG;
			ESparams2.Data2=FGC_FCOUNT;
			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		if(B!=DLay)
			PutValue(FG,TAG(Delay),DLay);
		if(t_In!=FadeIn)
		{
			Speed|=1;
			PutValue(FG,TAG(FadeInDuration),FadeIn);
		}
		if(t_Out!=FadeOut)
		{
			Speed|=2;
			PutValue(FG,TAG(FadeOutDuration),FadeOut);
		}
		if( (t_Out!=FadeOut) || (t_In!=FadeIn) )
			PutValue(FG,TAG(Speed),Speed);
		if( (KeyPL[0].PropStart) || (XPKeyPL[0].PropStart) )
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		PutValue(FG,TAG(PanelMode),pmode);  // ...just following orders
		if(TMb != TM)
			PutValue(FG,TAG(TimeMode),TM);

		return(TRUE);
	}
	return(FALSE);
}

int SCSpeed[]={1,2,4,6,8}; //  lines/field
int CRSpeed[]={2,4,8,16};  //  pixs/field
#define PAGE_SCROLL		0
#define PAGE_CRAWL		1
// Fix field count for page based on new speed
int NewDuration(int Dur, int OldSpeed, int NewSpeed, UBYTE PType)
{
	int n=0,dist;

	if(OldSpeed==NewSpeed) return(Dur);
	if(PType==PAGE_SCROLL)
	{
		if(OldSpeed) dist=SCSpeed[OldSpeed]*Dur;
		else dist = Dur/2;
		if(NewSpeed) n=dist/SCSpeed[NewSpeed];
		else n=dist*2; // Slowest = 1/2 line/field
	}
	else if(PType==PAGE_CRAWL)
	{
		dist=CRSpeed[OldSpeed]*Dur;
		n=dist/CRSpeed[NewSpeed];
	}
	DUMPSDECL("Duration: Old ",Dur,"   ");
	DUMPSDECL("          New ",n,"\\");
	DUMPSDECL("Speed:    Old ",OldSpeed,"   ");
	DUMPSDECL("          New ",NewSpeed,"\\");
	return(n);
}

// CT_CRAWL
BOOL DoCRAWLPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG type=PanType,A=1,Speed=A,B=84,DLay=B,TM=0,Z=0,S=0,SP[5]={120,90,60,30,0};
	char Label[MAX_PANEL_STR]="CG Crawl ";
	CommentBuf[0]=0;
	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Speed=(A=GetValue(FG,TAG(Speed)));
		SP[A]=(S=GetValue(FG,TAG(Duration)));
		DLay=(B=GetValue(FG,TAG(Delay)));
		TM=GetValue(FG,TAG(TimeMode));
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
	}
	SP[0]=NewDuration(S,A,0,PAGE_CRAWL);
	SP[1]=NewDuration(S,A,1,PAGE_CRAWL);
	SP[2]=NewDuration(S,A,2,PAGE_CRAWL);
	SP[3]=NewDuration(S,A,3,PAGE_CRAWL);
	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		CrawlPL[0].Label =Label;
		CrawlPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		CrawlPL[0].Param = (long *)CommentBuf;
		CrawlPL[0].PropEnd = COMMENT_MAX;

		CrawlPL[2].Param = &A;
		CrawlPL[2].Param2 = SP;
		CrawlPL[2].PropStart = 0;

		CrawlPL[3].Param = &S;
		CrawlPL[3].Param2 = &Z;
		CrawlPL[3].PropEnd = -1;

		CrawlPL[4].Param = (long *)TimeModes;		// POPUP
		CrawlPL[4].PropStart = TM;
		CrawlPL[4].PropEnd = 2;

		CrawlPL[5].Param = &B;
		CrawlPL[5].PropStart = 1;
		CrawlPL[5].PropEnd = 3600;
		CrawlPL[5].Flags = PL_DEL;

		type = MiniPanel(Edit, CrawlPL,TUNE_NONE);
	}
	if( FG && (type==PAN_CONTINUE) )
	{
		if(Speed!=A)
		{
			PutValue(FG,TAG(Speed),A);
			PutValue(FG,TAG(Duration),SP[A]);
		}
		if(DLay!=B) PutValue(FG,TAG(Delay),B);
		if(CrawlPL[0].PropStart)
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		if(CrawlPL[4].PropStart!=TM)
			PutValue(FG,TAG(TimeMode),CrawlPL[4].PropStart);
		return(TRUE);
	}
	return(FALSE);
}

// CT_SCROLL
BOOL DoSCROLLPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG type=PanType,A=1,Speed=A,B=84,DLay=B,C=120,Time=120,F=0,Fb=0,TM,S,SP[6]={120,90,60,30,15,0};
	char Label[MAX_PANEL_STR]="";
	CommentBuf[0]=0;
	if(FG)
	{
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		Speed=(A=GetValue(FG,TAG(Speed)));
		SP[A]=(S=GetValue(FG,TAG(Duration)));
		DLay=(B=GetValue(FG,TAG(Delay)));
		Time=(C=GetValue(FG,TAG(NumFields)));
		F=(Fb=GetValue(FG,TAG(FadeOutDuration)));
		TM=GetValue(FG,TAG(TimeMode));
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
	}
	SP[0]=NewDuration(S,A,0,PAGE_SCROLL);
	SP[1]=NewDuration(S,A,1,PAGE_SCROLL);
	SP[2]=NewDuration(S,A,2,PAGE_SCROLL);
	SP[3]=NewDuration(S,A,3,PAGE_SCROLL);
	SP[4]=NewDuration(S,A,4,PAGE_SCROLL);

	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		ScrollPL[0].Label =Label;
		ScrollPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		ScrollPL[0].Param = (long *)CommentBuf;
		ScrollPL[0].PropEnd = COMMENT_MAX;

		ScrollPL[2].Param = &A;
		ScrollPL[2].Param2 = SP;
		ScrollPL[2].PropStart = 0;

		ScrollPL[3].Param = &A;
		ScrollPL[3].Param2 = SP;
		ScrollPL[3].PropEnd = -1;

		ScrollPL[4].Param = (long *)Scrolls;		// POPUP
		ScrollPL[4].PropStart = DEF_SCROLL;
		ScrollPL[4].PropEnd = SCROLL_NUM;

		ScrollPL[5].Param = (LONG *)TimeModes;
		ScrollPL[5].PropStart = TM;
		ScrollPL[5].PropEnd = 2;

		ScrollPL[6].Param = &B;
		ScrollPL[6].PropStart = 1;
		ScrollPL[6].PropEnd = 36000;
		ScrollPL[6].Flags = PL_DEL;

		ScrollPL[7].Param = &C;
		ScrollPL[7].PropStart = 1;
		ScrollPL[7].PropEnd = 36000;
		ScrollPL[7].Flags = PL_LEN;

		ScrollPL[8].Param = &F;
		ScrollPL[8].PropStart = 1;
		ScrollPL[8].PropEnd = 36000;

		type = MiniPanel(Edit, ScrollPL,TUNE_NONE);
	}
	if( FG && (type==PAN_CONTINUE) )
	{
		if(Speed!=A)
		{
			PutValue(FG,TAG(Speed),A);
			PutValue(FG,TAG(Duration),SP[A]);
		}
		if(DLay!=B) PutValue(FG,TAG(Delay),B);
		if(Time!=C) PutValue(FG,TAG(NumFields),C);
		if(F!=Fb) PutValue(FG,TAG(FadeOutDuration),Fb);
		if(ScrollPL[5].PropStart != TM)
			PutValue(FG,TAG(TimeMode),ScrollPL[5].PropStart);
		if(ScrollPL[0].PropStart)
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		return(TRUE);
	}
	return(FALSE);
}

BOOL DoNewClipPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,F=0,T=0,LG=8,RG=8,NG=8,STOP=0,
		Spot=0,types[16],smpte=0;
	struct FlyerVolInfo *FVI=NULL;
	char *FlyDrive;
	struct SMPTEinfo si;

	if(FlyerBase)
	{
		if(FlyerDriveCount==0) BuildFlyerList();
		if(FlyerDriveCount && (FVI=GetFlyerInfo(FlyerDrives[CurFlyDrive])))
		{
			B=BlocksToFrames(FVI->Largest,0);
			C=BlocksToFrames(FVI->Optimized,0);
			if(B>C) C=B; // Don't let optimized be smaller!!!
		}
	}
	DUMPHEXIL("Welcome to the New Clip Panel @@",(LONG)&RawRecPL[0],"\\");
	DUMPHEXIL(" RawRecPL->Create @@",(LONG)RawRecPL[0].Create,"\\");
	LG=GetRecGain();
	RG=(LG&0xFF00)>>8;
	LG=(LG&0x00FF);
	while(!STOP)
	{
		switch(type)
		{
		case PAN_EASY:
			if(FlyerDriveCount)
			{
				RawRecPL[3].Param = (long *)FlyerDrives;		// POPUP
				RawRecPL[3].PropStart = CurFlyDrive;
				RawRecPL[3].PropEnd = FlyerDriveCount;
				RawRecPL[3].UserFun = CTRL_SetDrive;
				RawRecPL[3].G4 = (struct Gadget *)B;
				RawRecPL[3].G5 = (struct Gadget *)C;
				RawRecPL[3].Flags = PL_FLYER|PL_PARTNER;
				RawRecPL[3].Partners = &(RawRecPL[4]); // Mode->Audio Only popup
			}
			else
			{
				RawRecPL[3].Param = (long *)FlyDrives;		// POPUP
				FlyDrives[0][0]=AUDIO_BYTE;
				RawRecPL[3].PropStart = 0;
				RawRecPL[3].PropEnd = 1;
				RawRecPL[3].Param2 = NULL;
				RawRecPL[3].G4 = (struct Gadget *)B;
				RawRecPL[3].G5 = (struct Gadget *)C;
				RawRecPL[3].Flags = PL_FLYER;
			}

			RawRecPL[4].Param = (long *)Quals;		// POPUP
			RawRecPL[4].PropStart = CurCompMode;
			RawRecPL[4].PropEnd = QUAL_NUM;
			RawRecPL[4].UserFun = CTRL_SetCompression;
			RawRecPL[4].UserObj = (APTR)&RawRecPL[3]; // PLine with Max and opt sizes

			RawRecPL[6].Param = (LONG *)&(RawRecPL[3].G4);  // Diff
			RawRecPL[6].Param2 = &Z;
			RawRecPL[6].G5 = (struct Gadget *)2; // Diff

			RawRecPL[7].Param = (LONG *)&(RawRecPL[3].G5);  // Diff
			RawRecPL[7].Param2 = &Z;
			RawRecPL[7].Flags = PL_AVAIL;

			RawRecPL[9].Param = &T;     // Diff
			RawRecPL[9].Param2 = &Z;
			RawRecPL[9].Flags = PL_LEN;

			RawRecPL[10].Param = (long *)Sources;		// POPUP
			RawRecPL[10].UserFun = CTRL_SetSource;
			RawRecPL[10].UserObj = (APTR)&RawRecPL[3]; // PLine with Max and opt sizes
			RawRecPL[10].PropStart = CurFlySource;
			RawRecPL[10].PropEnd = FLY_SRC_NUM; // 4; //6; (Audio Only moved...)
			RawRecPL[10].Flags = PL_AUDIO;

			RawRecPL[11].Param = (long *)&LG;
			RawRecPL[11].Param2 = (long *)&NG;
			RawRecPL[11].PropStart = 0;
			RawRecPL[11].PropEnd = 15;
			RawRecPL[11].UserFun = CTRL_SetRecGain;
			RawRecPL[11].UserObj = &AudCtrl;
			RawRecPL[11].Flags = PL_IN; // Flag so CTRL_function can set Left vs Right

			RawRecPL[12].Param = (long *)&RG;
			RawRecPL[12].Param2 = (long *)&NG;
			RawRecPL[12].PropStart = 0;
			RawRecPL[12].PropEnd = 15;
			RawRecPL[12].UserFun = CTRL_SetRecGain;
			RawRecPL[12].UserObj = &AudCtrl;

			RawRecPL[13].PropStart = 36+8+PNL_DIV;  // Spacer

			if(SWITCHER_MODE)
			{
//				types[1] = RawRecPL[1].Type;
				types[2] = RawRecPL[2].Type;
				types[5] = RawRecPL[5].Type;
				types[7] = RawRecPL[7].Type;
				types[8] = RawRecPL[8].Type;
				types[11]= RawRecPL[11].Type;
				types[12]= RawRecPL[12].Type;
//				RawRecPL[1].Type  = PNL_SKIP;
				RawRecPL[2].Type  = PNL_SKIP;
				RawRecPL[5].Type  = PNL_SKIP;
				RawRecPL[7].Type  = PNL_SKIP;
				RawRecPL[8].Type  = PNL_SKIP;
				RawRecPL[11].Type = PNL_SKIP;
				RawRecPL[12].Type = PNL_SKIP;
			}
			type = 	NewClipPanel(Edit);
			break;
		case PAN_CONTINUE:
			STOP=1;
			break;
		case PAN_EXPERT:

			FlyDrive = FlyerDrives[CurFlyDrive];
			if(*FlyDrive==AUDIO_BYTE)
				FlyDrive+=2; // Skip speaker symbol char and space
			strncpy(Name,FlyDrive,CLIP_PATH_MAX);
			strncat(Name,TEMP_CLIP_NAME,CLIP_PATH_MAX);
			ESparams2.Data1=(LONG)Name;
			ESparams2.Data2=(LONG)1;

			if(FlyerBase)
				if( !(FG=(struct FastGadget *)SendSwitcherReply(ES_LoadCrouton,&ESparams2)) )
				{
					DUMPSTR("Load Failed On ");
					DUMPMSG(Name);
					STOP=TRUE;
					break;
				}
				else
				{
					CurFG = FG;
					T = (GetValue(FG,TAG(RecFields))>>1);  // Clip Frame Length
					if(GetTable(FG,TAG_SMPTEtime,(UBYTE *)&si,sizeof(struct SMPTEinfo)))
					{
//						smpte = SMPTEToLong(&si);
						smpte = EVEN(SMPTEToLong(&si));
						DUMPUDECB("SMPTE Start: ",si.SMPTEhours,":");
						DUMPUDECB("",si.SMPTEminutes,":");
						DUMPUDECB("",si.SMPTEseconds,":");
						DUMPUDECB("",si.SMPTEframes,"  = ");
						DUMPUDECL(" ",smpte," frames \\");
					}
				}
			ESparams1.Data1=(LONG)FG;
			SendSwitcherReply(ES_PanelClose,&ESparams1);
			SendSwitcherReply(ES_PanelOpen,&ESparams1);

			B=smpte+T;
			Z=smpte;
			*Name=0;
			MarkClipPL[2].Param = (long *)Name;  // Name String
			MarkClipPL[2].PropEnd = CLIP_NAME_MAX;
			MarkClipPL[2].Flags = PL_DEL;

			MarkClipPL[3].Param = &B;  // Diff
			MarkClipPL[3].Param2 = &Z;
			MarkClipPL[3].G5 = (struct Gadget *)2; // Diff
			MarkClipPL[3].Flags = PL_LEN;

			MarkClipPL[4].Param = (long *)CommentBuf;  // Name String
			MarkClipPL[4].PropEnd = COMMENT_MAX;
			MarkClipPL[4].G5 = (struct Gadget *)300; // string gad width
			MarkClipPL[4].Flags = PL_AVAIL;

			MarkClipPL[5].Param = &Z;
			MarkClipPL[5].Param2 = &B;
			MarkClipPL[5].PropStart = smpte;
			MarkClipPL[5].PropEnd = T + smpte;
			MarkClipPL[5].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;

			MarkClipPL[7].PropStart = 32; // Gap for bar

			F=T/2;
			MarkClipPL[8].Param = &F;
			MarkClipPL[8].PropStart = smpte;
			MarkClipPL[8].PropEnd = T + smpte;
			MarkClipPL[8].Flags = PL_IN | PL_FLYER | PL_CFRAME | PL_AUDIO;
// Partnership between these last two is essential

			MarkClipPL[9].Param = (long *)Spot;
			MarkClipPL[9].PropEnd = 2;
			MarkClipPL[9].Param2 =(long *)CutTracks;
			MarkClipPL[9].Flags = PL_PLAY;

			type = CutClipPanel(Edit);
			break;
		case PAN_CANCEL:
		default:
			STOP=2;
			break;
		}
	}
	if(SWITCHER_MODE)
	{
//		RawRecPL[1].Type  =types[1] ;
		RawRecPL[2].Type  =types[2] ;
		RawRecPL[5].Type  =types[5] ;
		RawRecPL[7].Type  =types[7] ;
		RawRecPL[8].Type  =types[8] ;
		RawRecPL[11].Type =types[11];
		RawRecPL[12].Type =types[12];
	}
	DoAllNewDir(Edit);
	if(STOP==1) return(TRUE);
	else return(FALSE);
}


BOOL DoProcClipPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG type=PAN_EASY,B,Z,F=0,T=0,STOP=0, Spot=0, smpte=0;
	char Label[MAX_PANEL_STR]="";
	struct SMPTEinfo si;
	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
		T = (GetValue(FG,TAG(RecFields))>>1);  // Clip Frame Length
		if(T<2) T=4;
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
		if(GetTable(FG,TAG_SMPTEtime,(UBYTE *)&si,sizeof(struct SMPTEinfo)))
		{
			smpte = EVEN(SMPTEToLong(&si));
			DUMPUDECB("SMPTE Start: ",si.SMPTEhours,":");
			DUMPUDECB("",si.SMPTEminutes,":");
			DUMPUDECB("",si.SMPTEseconds,":");
			DUMPUDECB("",si.SMPTEframes,"  = ");
			DUMPUDECL(" ",smpte," frames \\");
		}
	}
	B=smpte+T;
	Z=smpte;
	while(!STOP)
	{
		switch(type)
		{
		case PAN_CONTINUE:
			STOP=1;
			break;
		case PAN_EASY:
		case PAN_EXPERT:
			MarkClipPL[2].Param = (long *)Label;  // Name String
			MarkClipPL[2].PropEnd = CLIP_NAME_MAX;
			MarkClipPL[2].Flags = PL_DEL;

			MarkClipPL[3].Param = &B;  // Diff
			MarkClipPL[3].Param2 = &Z;
			MarkClipPL[3].G5 = (struct Gadget *)2; // Diff
			MarkClipPL[3].Flags = PL_LEN;

			MarkClipPL[4].Param = (long *)CommentBuf;  // Name String
			MarkClipPL[4].PropEnd = COMMENT_MAX;
			MarkClipPL[4].G5 = (struct Gadget *)300; // string gad width
			MarkClipPL[4].Flags = PL_AVAIL;

			MarkClipPL[5].Param = &Z;
			MarkClipPL[5].Param2 = &B;
			MarkClipPL[5].PropStart = smpte;
			MarkClipPL[5].PropEnd = T+ smpte;
			MarkClipPL[5].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;

			MarkClipPL[7].PropStart = 32; // Gap for bar

			F=T/2 + smpte;
			MarkClipPL[8].Param = &F;
			MarkClipPL[8].PropStart = smpte;
			MarkClipPL[8].PropEnd = T + smpte;
			MarkClipPL[8].Flags = PL_IN | PL_FLYER | PL_CFRAME | PL_AUDIO;

			MarkClipPL[9].Param = (long *)Spot;
			MarkClipPL[9].PropEnd = 2;
			MarkClipPL[9].Param2 =(long *)CutTracks;
			MarkClipPL[9].Flags = PL_PLAY;

			type = CutClipPanel(Edit);
			break;
		case PAN_CANCEL:
		default:
			STOP=2;
			break;
		}
	}
	DoAllNewDir(Edit);
	if(STOP==1) return(TRUE);
	else return(FALSE);
}

// CT_ERROR
BOOL DoERRORPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	char Label[MAX_PANEL_STR]="Barney in Bosnia", *Orig="VT_CDII:Gurm/Cucaracha's revenge",
		*CurHome="GigI:StupidStuff/little/LostCrouton";
	LONG type=PAN_EASY;
	if(FG)
	{
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR-1);
	}
	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		ErrorPL[2].Label = Label;
		ErrorPL[4].Label = Orig;
		ErrorPL[5].Label = CurHome;
		type = MiniPanel(Edit, ErrorPL,TUNE_NONE);
	}
	if(type==PAN_CONTINUE)
	{
		return(TRUE);
	}
	return(FALSE);
}

/*
BOOL DoTestPanel(struct EditWindow *Edit)
{
	char Mystr[50]="Aboud's"; //,*ts="Test" ,*LR[]={"L","R"};
	long	D=98,T=450,type=PAN_EXPERT;
	BOOL Jam_On=TRUE;
	struct FastGadget *FG=NULL;
	PanHandler	PanelFun;

	XPTestPL[2].Param = (long *)Mystr;	// STRING
	XPTestPL[2].PropEnd = 50;

	XPTestPL[3].Param = (long *)Pnls;		// POPUP
	XPTestPL[3].PropStart = 6;
	XPTestPL[3].PropEnd = PNL_NUM;

	XPTestPL[4].Param = (long *)&D;			// NUMBER
	XPTestPL[4].PropStart = 0;  // min
	XPTestPL[4].PropEnd = 100;  // max

	XPTestPL[5].Param = (long *)&T;			// PLAY
	XPTestPL[5].UserFun = CTRL_Play;

	while(Jam_On)
	{
		type = MiniPanel(Edit, XPTestPL,TUNE_NONE);
		if(type == PAN_CANCEL) Jam_On=FALSE;
		if(XPTestPL[5].Param)
		{
			if( (PanelFun=PanHandlers[XPTestPL[3].PropStart]) )  // check type for validity 1st!!!
				Jam_On = PanelFun(Edit,FG);
		}
	}
	return(Jam_On);
}
 */


UWORD __asm DoInfoPanel(
	REG(a0) char *Path,
	REG(a1) char *File,
	REG(a2) struct EditWindow *Edit,
  REG(d0) UWORD type )
{
	char *MPtr[5],*c; // ,num[5];
	struct FileInfoBlock *fib;
	BPTR L;
	UWORD result =0;
	WORD i=1;
	ULONG	sz,dec;

//	if(type<=GT_EFFECT) i=0;
//	else  type-=GT_EFFECT;
	if(type<=CR_FXANIM) i=0;
//	if(!SwitPort)
//		DoTBCPanel(Edit,NULL);
	if (L = Lock(Path,ACCESS_READ))
	{
		if (fib = SafeAllocMem(sizeof(struct FileInfoBlock),MEMF_CLEAR))
		{
			if (Examine(L,fib))
			{
				strncpy(Name,fib->fib_FileName,MAX_STRING_BUFFER-1);
				FileInfoPL[2].Param=(LONG *)Name;
				FileInfoPL[2].PropEnd=MAX_STRING_BUFFER;
				FileInfoPL[3].Label = DTNames[type];
				FileInfoPL[4].Label = fib->fib_Comment;
				if (fib->fib_DirEntryType > 0)
				{
					FileInfoPL[3].Label = "";
					strcpy(Size,"Directory");
				}
				else
				{
					sz=fib->fib_Size;
					if( fib->fib_Size < 0)
						sz=(ULONG)((fib->fib_Size&0x7FFFFFFF) + 0x80000000);
					dec=sz;
					if( (sz>>20)>=10 ) // greater than 10M
					{
						sz >>= 20;
						dec = (dec<<12)>>(12+18);
						if(dec)
							sprintf(Size, "Size %d.%d Mb",sz,dec);
						else
							sprintf(Size, "Size %d Mb",sz);
					}
					else if( (sz>>10)>=50 ) // greater than 50K
					{
						sz >>= 10;
						dec = (dec<<22)>>(22+8);
						if(dec)
							sprintf(Size, "Size %d.%d Kb",sz,dec);
						else
							sprintf(Size, "Size %d Kb",sz);
					}
					else
						sprintf(Size, "Size %d bytes",fib->fib_Size);
				}
				FileInfoPL[5].Label = Size;
				if (((ft=getft(Path)) != -1) && (strftime(TempCh,60,"%a, %b %d, %Y %I:%M %p",localtime(&ft))))
					FileInfoPL[6].Label =TempCh;

				FileInfoPL[7].Label = "";
				FileInfoPL[8].Label = ""; // date...

				if( result=(MiniPanel(Edit,FileInfoPL,TUNE_NONE) ? 1:0) )
					if(strnicmp(Name,fib->fib_FileName,MAX_STRING_BUFFER) )
					{
						strncpy(Dir,Path,MAX_STRING_BUFFER);
						c=FilePart(Dir);
						*c=0;
								MPtr[0] = "Renaming";
								MPtr[1] = Path;
								MPtr[2] = " To ";
								MPtr[3] = Dir;
								MPtr[4] = Name;
						strncat(Dir,Name,119);
						if(SimpleRequest(Edit->Window,MPtr,4,REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,NULL))
							if ( !(result+=(Rename(Path,Dir) ? 1:0)) )
							{
								MPtr[0] = "Unable to rename";
								MPtr[1] = Path;
								MPtr[2] = IoErrToText(IoErr());
								SimpleRequest(Edit->Window,MPtr,3,REQ_CENTER|REQ_H_CENTER,NULL);
							}
							else
							{
								DUMPSTR("Rename ");
								DUMPSTR(Path);
								DUMPSTR(" To ");
								DUMPMSG(Dir);
								strncpy(Name,Path,119);
								strncat(Name,".i",119);
								strncat(Dir,".i",119);
								Rename(Name,Dir);
								strncat(Name,"nfo",119);
								strncat(Dir,"nfo",119);
								Rename(Name,Dir);
							}
					}
				*Name=0;
			}
			FreeMem(fib,sizeof(struct FileInfoBlock));
		}
	UnLock(L);
	}
	return(result);
}


ULONG CroutonIndex(ULONG Type)
{
	ULONG i;
//	DUMPHEXIL(" Looking for Type: ",(LONG)Type," \\");
	for(i=CR_FXANIM; i<= CR_UNKNOWN; i++)
	{
//		DUMPUDECL("CRuDTypes[ ",(LONG)i," ] =");
//		DUMPHEXIL(" ",(LONG)CRuDTypes[i]," \\");
		if(Type == CRuDTypes[i]) return(i);
	}
//	DUMPUDECL(" ",(LONG)i,"\\ ");
	return(CR_UNKNOWN);
}

#define VALID_CTYPE(t)		((t<=CR_UNKNOWN)&&(t>=CR_FXANIM))
//#define VALID_CTYPE(t)		((t<=CR_ERROR)&&(t>=CR_FXANIM))
//*******************************************************************
// Could really be called DoFGPanel
struct EditWindow *HandlePanel(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	ULONG type,indx;
	struct FastGadget *FG,*Next;
	BOOL DontStop=TRUE;
	PanHandler	PanelFun;

	FG = *(((struct Project *)Edit->Special)->PtrPtr);

	if( FlyerBase && (IntuiMsg->Qualifier&IEQUALIFIER_CONTROL) && (IntuiMsg->Qualifier&IEQUALIFIER_LSHIFT) )
	{
		DoTweakPanel(Edit,FG);
		return(Edit);
	}
//	else if( FlyerBase && (IntuiMsg->Qualifier&IEQUALIFIER_CONTROL) && (IntuiMsg->Qualifier&IEQUALIFIER_LALT) )
	else if( (IntuiMsg->Qualifier&IEQUALIFIER_CONTROL) && (IntuiMsg->Qualifier&IEQUALIFIER_LALT) )
	{
		DoTBCPanel(Edit,FG);
		return(Edit);
	}

	while (FG && DontStop)
	{
		Next = FG->NextGadget;
		if (FG->FGDiff.FGNode.Status == EN_SELECTED)
		{
			type=((struct ExtFastGadget *)FG)->ObjectType;
			indx = CroutonIndex(type);
			DUMPSTR(DTNames[indx]);
			DUMPHEXIL(" has type ",type,"  ");
			if(VALID_CTYPE(indx))
			{
				DUMPUDECL(" Valid type",indx,"\\");
				CurFG=FG;
				ESparams1.Data1=(LONG)FG;
				SendSwitcherReply(ES_PanelOpen,&ESparams1);
				if(IntuiMsg->Qualifier & IEQUALIFIER_CAPSLOCK)
					PanType=PAN_EXPERT;
				else
					PanType=PAN_EASY;
				if( (PanelFun=PanHandlers[indx]) )
					DontStop = PanelFun(Edit,FG);
				ESparams1.Data1=(LONG)FG;
				SendSwitcherReply(ES_PanelClose,&ESparams1);
			}
		}
		FG = Next;
	}
	return(Edit);
}
@


2.146
log
@Color names for yellow/cyan transposed
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.145 1995/02/24 11:48:35 CACHELIN4000 Exp pfrench $
d4 3
d949 1
a949 1
//		SetupPL[6].UserFun=CTRL_SetGPI; ???
d963 7
@


2.145
log
@Fix stuff, add RT to CFX panel, start time/time mode order swap
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.144 1995/02/22 10:32:07 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d513 1
a513 1
	*Colors[] = {"Black","White","Red","Green","Blue","Cyan","Magenta","Yellow","Snow","Special",""},
@


2.144
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.143 1995/02/21 12:19:54 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d462 1
a462 1
struct FlyAudCtrl AudCtrl = {0,0,0,0,0,0,2,2,128,0,128,0,0,0,0,0,0,0,0,0};
d518 1
a518 1
	*TimeModes[] = {"Start","In Point",""},
d992 1
a992 2

		PutValue(FG,TAG(Asynchronous),0);
a994 1

d1004 8
a1011 8
	RexxPL[4].Param = &DLay;
	RexxPL[4].PropStart = 0;
	RexxPL[4].PropEnd = 600;
	RexxPL[4].Flags = PL_DEL;

	RexxPL[5].Param = (LONG *)TimeModes;
	RexxPL[5].PropStart = TM;
	RexxPL[5].PropEnd = 2;
d1319 1
a1319 1
	LONG TBar=0,B=2,t_In=300,type=PanType,Speed=1,S,SP[4]={45,30,15,9},
d1322 4
d1340 1
a1340 1
		TBar=GetValue(FG,TAG(TBarPosition));
d1367 4
d1375 4
d1383 4
d1391 4
d1420 2
a1421 1
		PutValue(FG,TAG(TBarPosition),TBar);
d1429 7
d1444 1
a1444 1
	LONG FadeIn=0,FadeOut=0,V=0,P=0,V1=0xFFFF,V2=0x4000,A=800,B,TM,TMb,
d1545 8
a1552 8
	AudClipPL[5].Param = &S;
	AudClipPL[5].PropStart = 0;
	AudClipPL[5].PropEnd = MAX_DELAY;
	AudClipPL[5].Flags = PL_DEL;

	AudClipPL[6].Param = (LONG *)TimeModes;
	AudClipPL[6].PropStart = TM;
	AudClipPL[6].PropEnd = 2;
d1578 8
a1585 8
	XPAudClipPL[5].Param = &S;
	XPAudClipPL[5].PropStart = 0;
	XPAudClipPL[5].PropEnd = MAX_DELAY;
	XPAudClipPL[5].Flags = PL_DEL;

	XPAudClipPL[6].Param = (LONG *)TimeModes;
	XPAudClipPL[6].PropStart = TM;
	XPAudClipPL[6].PropEnd = 2;
d1630 1
d1635 1
d2095 8
a2102 8
	KeyPL[3].Param = &DLay;
	KeyPL[3].PropStart = 1;
	KeyPL[3].PropEnd = 3600;
	KeyPL[3].Flags = PL_DEL;

	KeyPL[4].Param = (LONG *)TimeModes;
	KeyPL[4].PropStart = TM;
	KeyPL[4].PropEnd = 2;
d2114 9
a2122 8
	XPKeyPL[3].Param = &DLay;
	XPKeyPL[3].PropStart = 1;
	XPKeyPL[3].PropEnd = 600;
	XPKeyPL[3].Flags = PL_DEL;

	XPKeyPL[4].Param = (LONG *)TimeModes;
	XPKeyPL[4].PropStart = TM;
	XPKeyPL[4].PropEnd = 2;
d2249 8
a2256 8
		CrawlPL[4].Param = &B;
		CrawlPL[4].PropStart = 1;
		CrawlPL[4].PropEnd = 3600;
		CrawlPL[4].Flags = PL_DEL;

		CrawlPL[5].Param = (long *)TimeModes;		// POPUP
		CrawlPL[5].PropStart = TM;
		CrawlPL[5].PropEnd = 2;
d2319 8
a2326 8
		ScrollPL[5].Param = &B;
		ScrollPL[5].PropStart = 1;
		ScrollPL[5].PropEnd = 36000;
		ScrollPL[5].Flags = PL_DEL;

		ScrollPL[6].Param = (LONG *)TimeModes;
		ScrollPL[6].PropStart = TM;
		ScrollPL[6].PropEnd = 2;
d2360 1
a2360 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,F=0,T=0,LG=2,RG=2,NG=2,STOP=0,
@


2.143
log
@Add TimeMode popup to Audio panel
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.142 1995/02/20 12:28:13 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d353 1
a353 1
#define SERDEBUG	1
@


2.142
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.141 1995/02/19 16:41:44 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d350 1
a350 1
//#define SERDEBUG	1
d916 5
a920 1
	I=(Config.Flags1>>1)&0x3;
d939 1
a939 1
		SetupPL[7].Param =(LONG *)I;
d961 4
a964 4
			if(I&1) Config.Flags1 |= spB_FlyerVID3;
			else Config.Flags1 &= ~spB_FlyerVID3;
			if(I&2) Config.Flags1 |= spB_FlyerVID4;
			else Config.Flags1 &= ~spB_FlyerVID4;
d1412 1
a1412 1
	LONG FadeIn=0,FadeOut=0,V=0,P=0,V1=0xFFFF,V2=0x4000,A=800,B,
d1434 1
d1518 5
d1551 3
a1553 5
	XPAudClipPL[6].Param = (LONG *)Channels;
	XPAudClipPL[6].PropStart = CurAudioSet.Mode;
	XPAudClipPL[6].PropEnd = 3;
	XPAudClipPL[6].UserFun=CTRL_SetPan;
	XPAudClipPL[6].UserObj=(APTR)&CurAudioSet;
d1581 5
a1585 1
	XPAudClipPL[11].Flags =  PL_AVAIL;
d1587 2
d1624 2
d2173 4
d2331 1
a2331 2
	if(FlyerDriveCount==0) BuildFlyerList();
	if(FlyerDriveCount && (FVI=GetFlyerInfo(FlyerDrives[CurFlyDrive])))
d2333 7
a2339 3
		B=BlocksToFrames(FVI->Largest,0);
		C=BlocksToFrames(FVI->Optimized,0);
		if(B>C) C=B; // Don't let optimized be smaller!!!
d2341 2
d2713 3
a2715 1
					dec=fib->fib_Size;
@


2.141
log
@Separate out PanData.c, PanFunctions.c to  make things link
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.140 1995/02/19 11:35:29 pfrench Exp CACHELIN4000 $
d4 3
d351 1
d371 31
a401 31
extern struct PanelLine CFAR ReqString_PL[];
extern struct PanelLine CFAR ReqNum_PL[];
extern struct PanelLine CFAR ReqTime_PL[];
extern struct PanelLine CFAR ReqTell_PL[];
extern struct PanelLine CFAR Setup_PL[];
extern struct PanelLine CFAR Tweak_PL[];
extern struct PanelLine CFAR TBC_PL[];
extern struct PanelLine CFAR XPTBC_PL[];
extern struct PanelLine CFAR Error_PL[];
extern struct PanelLine CFAR RawRec_PL[];
extern struct PanelLine CFAR MarkClip_PL[];
extern struct PanelLine CFAR FileInfo_PL[];
extern struct PanelLine CFAR Rexx_PL[];
extern struct PanelLine CFAR Frame_PL[];
extern struct PanelLine CFAR LumaKey_PL[];
extern struct PanelLine CFAR Trails_PL[];
extern struct PanelLine CFAR CFX_PL[];
extern struct PanelLine CFAR Video_PL[];
extern struct PanelLine CFAR XPVideo_PL[];
extern struct PanelLine CFAR Effect_PL[];
extern struct PanelLine CFAR XPEffect_PL[];
extern struct PanelLine CFAR AnimFX_PL[];
extern struct PanelLine CFAR XPAnimFX_PL[];
extern struct PanelLine CFAR Clip_PL[];
extern struct PanelLine CFAR XPClip_PL[];
extern struct PanelLine CFAR AudClip_PL[];
extern struct PanelLine CFAR XPAudClip_PL[];
extern struct PanelLine CFAR Key_PL[];
extern struct PanelLine CFAR XPKey_PL[];
extern struct PanelLine CFAR Crawl_PL[];
extern struct PanelLine CFAR Scroll_PL[];
d403 4
a406 4
extern struct PanelLine CFAR Test_PL[];
extern struct PanelLine CFAR Test_PL3[];
extern struct PanelLine CFAR Test_PL2[];
extern struct PanelLine CFAR XPTest_PL[];
d409 31
a439 31
CFAR struct PanelLine *ReqStringPL = &ReqString_PL[0];
CFAR struct PanelLine *ReqNumPL = &ReqNum_PL[0];
CFAR struct PanelLine *ReqTimePL = &ReqTime_PL[0];
CFAR struct PanelLine *ReqTellPL = &ReqTell_PL[0];
CFAR struct PanelLine *SetupPL = &Setup_PL[0];
CFAR struct PanelLine *TweakPL = &Tweak_PL[0];
CFAR struct PanelLine *TBCPL = &TBC_PL[0];
CFAR struct PanelLine *XPTBCPL = &XPTBC_PL[0];
CFAR struct PanelLine *ErrorPL = &Error_PL[0];
CFAR struct PanelLine *RawRecPL = &RawRec_PL[0];
CFAR struct PanelLine *MarkClipPL = &MarkClip_PL[0];
CFAR struct PanelLine *FileInfoPL = &FileInfo_PL[0];
CFAR struct PanelLine *RexxPL = &Rexx_PL[0];
CFAR struct PanelLine *FramePL = &Frame_PL[0];
CFAR struct PanelLine *LumaKeyPL = &LumaKey_PL[0];
CFAR struct PanelLine *TrailsPL = &Trails_PL[0];
CFAR struct PanelLine *CFXPL = &CFX_PL[0];
CFAR struct PanelLine *VideoPL = &Video_PL[0];
CFAR struct PanelLine *XPVideoPL = &XPVideo_PL[0];
CFAR struct PanelLine *EffectPL = &Effect_PL[0];
CFAR struct PanelLine *XPEffectPL = &XPEffect_PL[0];
CFAR struct PanelLine *AnimFXPL = &AnimFX_PL[0];
CFAR struct PanelLine *XPAnimFXPL = &XPAnimFX_PL[0];
CFAR struct PanelLine *ClipPL = &Clip_PL[0];
CFAR struct PanelLine *XPClipPL = &XPClip_PL[0];
CFAR struct PanelLine *AudClipPL = &AudClip_PL[0];
CFAR struct PanelLine *XPAudClipPL = &XPAudClip_PL[0];
CFAR struct PanelLine *KeyPL = &Key_PL[0];
CFAR struct PanelLine *XPKeyPL = &XPKey_PL[0];
CFAR struct PanelLine *CrawlPL = &Crawl_PL[0];
CFAR struct PanelLine *ScrollPL = &Scroll_PL[0];
d441 4
a444 4
CFAR struct PanelLine *TestPL = &Test_PL[0];
CFAR struct PanelLine *XPTestPL = &XPTest_PL[0];
CFAR struct PanelLine *TestPL2 = &Test_PL2[0];
CFAR struct PanelLine *TestPL3 = &Test_PL3[0];
@


2.140
log
@One more attempt at getting the data to a far section
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.139 1995/02/19 11:27:06 pfrench Exp pfrench $
d4 3
d340 2
d367 76
a446 11
struct	AudioSet {
	ULONG	Volume;			// 0-100
	ULONG	V1;					// 0-0xFFFF
	ULONG	V2;					// 0-0xFFFF
	UWORD	Balance;		// 0-0xFFFF
	UWORD	Mode;
	WORD	Pan1;
	WORD	Pan2;
	struct FastGadget *FG;
	ULONG	AudioOn;
};
d448 1
a448 1
static struct	AudioSet	CurAudioSet={0,0,0};
d458 1
a458 1
CFAR CSTATIC struct Hack
a485 2
static char *FaceMess[]={"Removing interface from Preview Monitor,",
		"Press HELP to restore."};
d495 1
a495 1
static UBYTE
a532 501
#define TEXT_LINE(j,l,w) {PNL_TEXT,j,l,w,0,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL}
#define STRING_LINE(j,l,w) {PNL_STRING,j,l,w,0,0,0,0,CreateStringPL,DrawStringPL,HandleStringPL,DestroyStringPL}
#define DIVIDE_LINE(j,l,w) {PNL_DIVIDE,j,l,w,0,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL}
#define POPUP_LINE(j,l,w) {PNL_POPUP,j,l,w,0,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL}
#define DIFF_LINE(j,l,w) {PNL_DIFF,j,l,w,0,0,0,0,CreateDiffPL,DrawDiffPL,NULL,NULL}
#define CROUTON_LINE(j,l,w) {PNL_CROUTON,j,l,w,0,0,0,0,CreateCroutonPL,DrawCroutonPL,HandleCroutonPL,DestroyCroutonPL}
#define TOGGLE_LINE(j,l,w) {PNL_TOGGLE,j,l,w,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL}
#define TIME_LINE(j,l,w) {PNL_TIME,j,l,w,0,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL}
#define FLYTIME_LINE(j,l,w) {PNL_FLYTIME,j,l,w,0,0,0,0,CreateFlyTimePL,DrawFlyTimePL,HandleFlyTimePL,DestroyFlyTimePL}
#define DUOSLIDE_LINE(j,l,w) {PNL_DUOSLIDE,j,l,w,0,0,0,0,CreateDuoSlidePL,DrawDuoSlidePL,HandleDuoSlidePL,DestroyDuoSlidePL}
#define EZTIME_LINE(j,l,w) {PNL_EZTIME,j,l,w,0,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL}
#define EZLEN_LINE(j,l,w) {PNL_EZLEN,j,l,w,0,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL}
#define EZNUM_LINE(j,l,w) {PNL_EZNUM,j,l,w,0,0,0,0,CreateEZNumPL,DrawEZTimePL,HandleEZNumPL,DestroyEZNumPL}
#define NUMBER_LINE(j,l,w) {PNL_NUMBER,j,l,w,0,0,0,0,CreateNumberPL,DrawStringPL,NULL,DestroyNumberPL}
#define FXSPEED_LINE(j,l,w) {PNL_FXSPEED,j,l,w,0,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL}
#define FXTIME_LINE(j,l,w) {PNL_FXTIME,j,l,w,0,0,0,0,CreateDiffPL,DrawDiffPL,NULL,NULL}
#define SLIDER_LINE(j,l,w) {PNL_SLIDER,j,l,w,0,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL}
#define NUMSLIDER_LINE(j,l,w) {PNL_NUMSLIDER,j,l,w,0,0,0,0,CreateNumSliderPL,DrawNumSliderPL,HandleNumSliderPL,DestroyNumSliderPL}
#define STEPSLIDE_LINE(j,l,w) {PNL_STEPSLIDE,j,l,w,0,0,0,0,CreateStepSliderPL,DrawStepSliderPL,HandleStepSliderPL,DestroyStepSliderPL}
#define FLYSLIDER_LINE(j,l,w) {PNL_FLYSLIDER,j,l,w,0,0,0,0,CreateFlySliderPL,DrawFlySliderPL,HandleFlySliderPL,DestroyFlySliderPL}
#define EZSLIDER_LINE(j,l,w) {PNL_EZSLIDER,j,l,w,0,0,0,0,CreateEZSliderPL,DrawEZSliderPL,HandleEZSliderPL,DestroyEZSliderPL}
#define IN_TYPE_LINE(j,l,w) {PNL_IN_TYPE,j,l,w,0,0,0,0,CreateInOutPL,DrawInOutPL,HandleInOutPL,DestroyInOutPL}
#define OUT_TYPE_LINE(j,l,w) {PNL_OUT_TYPE,j,l,w,0,0,0,0,CreateInOutPL,DrawInOutPL,HandleInOutPL,DestroyInOutPL}
#define CHOICE4_LINE(j,l,w) {PNL_CHOICE4,j,l,w,0,0,0,0,CreateChoicePL,DrawChoicePL,HandleChoicePL,DestroyChoicePL}
#define CHOICE5_LINE(j,l,w) {PNL_CHOICE5,j,l,w,0,0,0,0,CreateChoicePL,DrawChoicePL,HandleChoicePL,DestroyChoicePL}
#define PLAY_LINE(j,l,w) {PNL_PLAY,j,l,w,0,0,0,0,CreatePlayPL,DrawPlayPL,HandlePlayPL,DestroyPlayPL}
#define VCR_LINE(j,l,w) {PNL_VCR,j,l,w,0,0,0,0,CreateVCRPL,DrawVCRPL,0,DestroyVCRPL}
#define BUTTON_LINE(j,l,w) {PNL_BUTTON,j,l,w,0,0,0,0,CreateButtonPL,DrawButtonPL,HandleButtonPL,DestroyButtonPL}
#define CHECK_LINE(j,l,w) {PNL_CHECK,j,l,w,0,0,0,0,CreateCheckPL,DrawCheckPL,HandleCheckPL,DestroyCheckPL}
#define x_LINE(j,l,w) {PNL_x,j,l,w,0,0,0,0,x}
#define LAST_LINE { 0,0,0,0,0 }

CFAR CSTATIC struct PanelLine ReqStringPL[] = {
	TEXT_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	STRING_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE };

CFAR CSTATIC struct PanelLine ReqNumPL[] = {
	TEXT_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	EZNUM_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE };

CFAR CSTATIC struct PanelLine ReqTimePL[] = {
	TEXT_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	EZTIME_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE };

CFAR CSTATIC struct PanelLine ReqTellPL[] = {
	TEXT_LINE(PNL_CENTER,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE };

CFAR CSTATIC struct PanelLine SetupPL[] = {
	TEXT_LINE(PNL_CENTER,"Toaster Setup",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	OUT_TYPE_LINE(PNL_CENTER,"Control Monitor ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	TOGGLE_LINE(PNL_LEFT,"Video Input Termination ",0 ),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	POPUP_LINE(PNL_CENTER,"GPI Remote Trigger ",0 ),
	TOGGLE_LINE(PNL_LEFT,"Flyer Output ",0 ),
	TEXT_LINE(PNL_LEFT,"",1),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine TweakPL[] = {
	TEXT_LINE(PNL_CENTER," Flyer Tweaks ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	POPUP_LINE(PNL_RIGHT,"Mode  ",0),
	EZNUM_LINE(PNL_CENTER, "Position",0),
	EZNUM_LINE(PNL_CENTER, "Clock",0),
	EZNUM_LINE(PNL_CENTER, "Coarse",0),
	EZNUM_LINE(PNL_CENTER, "Fine",0),
//	EZNUM_LINE(PNL_CENTER, "Pedestal",0),
//	TOGGLE_LINE(PNL_CENTER, "",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine TBCPL[] = {
	TEXT_LINE(PNL_CENTER," Flyer TBC Control ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	STEPSLIDE_LINE(  PNL_CENTER, "Horizontal",1), // Centered slider 0-0x7ff
	STEPSLIDE_LINE(  PNL_CENTER, "Phase",0), // Centered slider 0-0x7ff
	STEPSLIDE_LINE(  PNL_LEFT, "Hue",1),  // Centered slider -64 - 63
	STEPSLIDE_LINE(  PNL_LEFT, "Brightness",0), // 0 - 127
	STEPSLIDE_LINE(  PNL_LEFT, "Saturation",1),  // 0 - 127
	STEPSLIDE_LINE(  PNL_LEFT, "Contrast",0),  // 0 - 127
//	STEPSLIDE_LINE(  PNL_LEFT, "Fader",1),  // 0 - 255
	TEXT_LINE(PNL_CENTER,"",0),
	POPUP_LINE(  PNL_CENTER, "Input",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};


CFAR CSTATIC struct PanelLine XPTBCPL[] = {
	TEXT_LINE(PNL_CENTER," Flyer TBC Control ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	POPUP_LINE(  PNL_LEFT, "Input",1),
	POPUP_LINE(  PNL_LEFT, "Key Mode",0),
	STEPSLIDE_LINE(  PNL_CENTER, "Fader",0),  // 0 - 255
	DIVIDE_LINE(PNL_LEFT," Termination  ",0 ),
	TOGGLE_LINE(  PNL_CENTER, "",0),
	DIVIDE_LINE(PNL_LEFT," Keyer  ",0 ),
	TOGGLE_LINE(  PNL_CENTER, "",0),
	DIVIDE_LINE(PNL_LEFT," Encoder  ",0 ),
	TOGGLE_LINE(  PNL_CENTER, "",0),
	DIVIDE_LINE(PNL_LEFT," Decoder  ",0 ),
	TOGGLE_LINE(  PNL_CENTER, "",0),
	TEXT_LINE(PNL_CENTER,"",1),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine ErrorPL[] = {
	TEXT_LINE(PNL_CENTER,"Crouton Error",0),
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"name",0),
	DIVIDE_LINE(PNL_LEFT,"Vital Statistics: ",0 ),
	TEXT_LINE(PNL_CENTER,"Current Home",0),
	TEXT_LINE(PNL_CENTER,"Birthplace ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR struct PanelLine RawRecPL[] = {
	TEXT_LINE(PNL_CENTER,"        Record Raw Footage",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_CENTER,"",0),
	POPUP_LINE(PNL_RIGHT,"  Drive",1),
	POPUP_LINE(PNL_CENTER,"Quality",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	DIFF_LINE(PNL_LEFT,"Approximate Time Available ",0),
	DIFF_LINE(PNL_LEFT,"Reorganized Time Available ",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	DIFF_LINE(PNL_CENTER,"Length ",1),
	POPUP_LINE(PNL_RIGHT,"   Source",0),
	STEPSLIDE_LINE(  PNL_LEFT, "Audio Gain L",1),  // 0 - 15
	STEPSLIDE_LINE(  PNL_LEFT, "Audio Gain R",0),  // 0 - 15
	TEXT_LINE(PNL_CENTER,0,0),
	TEXT_LINE(PNL_CENTER,"",0),
	TEXT_LINE(PNL_CENTER,"",0),
	LAST_LINE
};

CFAR struct PanelLine MarkClipPL[] = {
	TEXT_LINE(PNL_CENTER,"         Mark Clips    ",0),
//	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	STRING_LINE(PNL_CENTER,"Clip Name",1),
	DIFF_LINE(PNL_RIGHT,"Length ",0),
	STRING_LINE(PNL_CENTER,"Comment",0),
	DUOSLIDE_LINE(PNL_LEFT," ",0),
//	DIVIDE_LINE(PNL_LEFT,"",0 ),
	TEXT_LINE(PNL_LEFT,"",0 ),
	TEXT_LINE(PNL_CENTER,NULL,0), // This one is the space for the bar
	FLYTIME_LINE(PNL_LEFT,"Icon",0),

	TOGGLE_LINE(PNL_CENTER,"Include",0),
	TEXT_LINE(PNL_CENTER,"",0),

	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

LONG	aa=0,zz=100;
CFAR CSTATIC struct PanelLine FileInfoPL[] = {
	TEXT_LINE(PNL_CENTER,"File Information",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	STRING_LINE(PNL_LEFT,"Name",0),
	TEXT_LINE(PNL_CENTER,"Type ",0),
	TEXT_LINE(PNL_LEFT,"Description",0),
	TEXT_LINE(PNL_CENTER,"File Size",0),
	TEXT_LINE(PNL_CENTER,"Date",0),
	TEXT_LINE(PNL_LEFT,"Attributes",0),
	TEXT_LINE(PNL_LEFT,"Protection",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine RexxPL[] = {
	TEXT_LINE(PNL_CENTER,"ARexx Macro",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	STRING_LINE(PNL_CENTER,"Parameters:",0),
	TOGGLE_LINE(PNL_CENTER," ",0 ),
	EZTIME_LINE(PNL_LEFT,"Delay from",1), // Start Time
	POPUP_LINE(PNL_CENTER,"previous",0), // Start Time
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE };

CFAR CSTATIC struct PanelLine FramePL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	EZTIME_LINE(PNL_CENTER,"Length",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine LumaKeyPL[] = {
	TEXT_LINE(PNL_LEFT,"Luminance Key Control",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	IN_TYPE_LINE(PNL_LEFT,"Clip",0),
	EZNUM_LINE(PNL_CENTER,"Level",1),
	EZTIME_LINE(PNL_CENTER,"Start Time",1),
	EZTIME_LINE(PNL_CENTER,"Duration",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine TrailsPL[] = {
	TEXT_LINE(PNL_LEFT,"Trails Control",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	EZNUM_LINE(PNL_RIGHT,"Effect Level",0),
	EZLEN_LINE(PNL_RIGHT,"Start Time",1),
	EZLEN_LINE(PNL_RIGHT,"Duration",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine CFXPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	FXSPEED_LINE(PNL_LEFT,"Speed",1),
	EZTIME_LINE(PNL_CENTER,"Duration",0),
	EZTIME_LINE(PNL_LEFT,"Start Time",1),
	POPUP_LINE(PNL_LEFT,"Cycles ",0),
	STEPSLIDE_LINE(PNL_LEFT,"Effect Position",0),
	POPUP_LINE(PNL_LEFT,"Modes ",1),
	POPUP_LINE(PNL_LEFT," ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};


CFAR CSTATIC struct PanelLine VideoPL[] = {
	TEXT_LINE(PNL_LEFT,"Video Input",0),
	TEXT_LINE(PNL_LEFT,"name",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
//	EZLEN_LINE(PNL_CENTER,"Length",0),
EZTIME_LINE(PNL_CENTER,"Length",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine XPVideoPL[] = {
	TEXT_LINE(PNL_LEFT,"Video Input",0),
	TEXT_LINE(PNL_LEFT,"name",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	TIME_LINE(PNL_CENTER,"Length",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine EffectPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	FXSPEED_LINE(PNL_LEFT,"Speed",0),
	EZLEN_LINE(PNL_CENTER,"Duration",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine XPEffectPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	FXSPEED_LINE(PNL_LEFT,"Speed",1),
	EZLEN_LINE(PNL_CENTER,"Frames",0),
	POPUP_LINE(PNL_RIGHT,"Effect Color ",1 ),
	EZTIME_LINE(PNL_CENTER,"Start Key",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine AnimFXPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	FXSPEED_LINE(PNL_LEFT,"Speed",0),
	FXTIME_LINE(PNL_LEFT,"Length  ",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine XPAnimFXPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	FXSPEED_LINE(PNL_LEFT,"Speed",1),
	FXTIME_LINE(PNL_LEFT,"Length ",0),
	POPUP_LINE(PNL_RIGHT,"Effect Color ",1 ),
	EZLEN_LINE(PNL_CENTER,"Start Key",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};



CFAR CSTATIC struct PanelLine ClipPL[] = {
	TEXT_LINE(PNL_LEFT,"Video Clip ",0),
	CROUTON_LINE(PNL_LEFT,"Video Clip ",0),
	PLAY_LINE(PNL_LEFT,"",1),
//	TEXT_LINE(PNL_LEFT,"",1),
	DIFF_LINE(PNL_LEFT,"Length ",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	DUOSLIDE_LINE(PNL_LEFT," ",0),
	TEXT_LINE(PNL_LEFT,"",1),
//	DIVIDE_LINE(PNL_LEFT,"Audio ",0),
	TOGGLE_LINE(PNL_CENTER,0,0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	LAST_LINE  // { 0,0,0,0,0 } // end of array marker
};

CFAR CSTATIC struct PanelLine XPClipPL[] = {
	TEXT_LINE(PNL_LEFT,"Video Clip ",0),
	CROUTON_LINE(PNL_LEFT,"",0),
	PLAY_LINE(PNL_LEFT,"",1),
//	TEXT_LINE(PNL_LEFT,"",1),
	DIFF_LINE(PNL_LEFT,"Length ",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	DUOSLIDE_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"Audio ",0),
	DUOSLIDE_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"",0),
//	EZNUM_LINE(  PNL_CENTER, "Volume",1),
	NUMSLIDER_LINE(  PNL_CENTER, "Volume",1),
	EZSLIDER_LINE(  PNL_CENTER, "Balance",0),
	EZLEN_LINE(  PNL_CENTER,"Fade In",1),
	EZLEN_LINE( PNL_CENTER,"Fade Out",0),
	POPUP_LINE(PNL_CENTER,"Channels",1),
	BUTTON_LINE(PNL_CENTER,"Process",0 ),
	DIVIDE_LINE(PNL_CENTER,"",0),
	LAST_LINE  // { 0,0,0,0,0 } // end of array marker
};

CFAR CSTATIC struct PanelLine AudClipPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	DIFF_LINE(PNL_LEFT,"Length ",0),
	DUOSLIDE_LINE(PNL_LEFT,"Audio Trim",0),
	TEXT_LINE(PNL_LEFT,"",0),
	EZTIME_LINE(PNL_CENTER,"Start Time",0),
	DIVIDE_LINE(PNL_LEFT,"",1 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine XPAudClipPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	DIFF_LINE(PNL_LEFT,"Length ",0),
	DUOSLIDE_LINE(PNL_LEFT,"Audio Trim",0),
	TEXT_LINE(PNL_LEFT,"",0),
	EZTIME_LINE(PNL_JUST,"Start Time",1),
	POPUP_LINE(PNL_RIGHT,"Channels",0 ),
	NUMSLIDER_LINE(  PNL_LEFT, "Volume",1),
	EZSLIDER_LINE(  PNL_CENTER, "Balance",0),
	EZLEN_LINE(PNL_CENTER,"Fade In",1),
	EZLEN_LINE(PNL_CENTER,"Fade Out",0),
	BUTTON_LINE(PNL_CENTER,"Process",0 ),

//	EZNUM_LINE( PNL_CENTER, "Ch.1:   Level ",1),
//	EZSLIDER_LINE( PNL_LEFT, "",0),
//	EZNUM_LINE( PNL_CENTER, "Ch.2:   Level ",1),
//	EZSLIDER_LINE( PNL_LEFT, "",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine KeyPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
//	EZLEN_LINE(PNL_CENTER,"Length",0),
	EZTIME_LINE(PNL_CENTER,"Length",0),
	EZTIME_LINE(PNL_LEFT,"Delay from",1), // Start Time
	POPUP_LINE(PNL_CENTER,"previous",0),  // Time Mode
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine XPKeyPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	EZTIME_LINE(PNL_CENTER,"Length",0),
	EZTIME_LINE(PNL_LEFT,"Delay from",1), // Start Time
	POPUP_LINE(PNL_CENTER,"previous",0),  // Time Mode
	DIVIDE_LINE(PNL_LEFT,"",0 ),
//	IN_TYPE_LINE(PNL_LEFT,0,1),
//	OUT_TYPE_LINE(PNL_LEFT,0,0),
	EZLEN_LINE(PNL_CENTER,"Fade In",1),
	EZLEN_LINE(PNL_CENTER,"Fade Out",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine CrawlPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	CHOICE4_LINE(PNL_LEFT,"Speed",1),
	FXTIME_LINE(PNL_LEFT,"Duration  ",0),
	EZTIME_LINE(PNL_LEFT,"Delay from",1), // Start Time
	POPUP_LINE(PNL_CENTER,"previous",0), // Start Time
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine ScrollPL[] = {
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	CHOICE5_LINE(PNL_LEFT,"Speed",1),
	FXTIME_LINE(PNL_LEFT,"Duration  ",0),
	POPUP_LINE(PNL_RIGHT,"Scroll",0 ),
	EZTIME_LINE(PNL_LEFT,"Delay from",1), // Start Time
	POPUP_LINE(PNL_CENTER,"previous",0), // Start Time
	EZTIME_LINE(PNL_LEFT,"Hold Duration",1),
	EZTIME_LINE(PNL_LEFT,"Fade Out",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

/*
CFAR CSTATIC struct PanelLine TestPL[] = {
	TEXT_LINE(PNL_LEFT,"TEXT L",0),
	DIVIDE_LINE(PNL_LEFT,"DIVIDE L",0 ),
	TEXT_LINE(PNL_CENTER,"TEXT C",0),
	DIVIDE_LINE(PNL_CENTER,"DIVIDE C",0 ),
	STRING_LINE(PNL_LEFT,"STRING L",1),
	STRING_LINE(PNL_CENTER,"STRING C",0),
	POPUP_LINE(PNL_RIGHT,"POPUP ",1 ),
	EZNUM_LINE( PNL_CENTER, "EZNUM C",0),
	TOGGLE_LINE(PNL_CENTER,"TOGGLE C",0),
	DUOSLIDE_LINE(PNL_LEFT,"DuoSLide",0),
	DIFF_LINE(PNL_CENTER,"",1),
//	EZTIME_LINE(PNL_LEFT,"EZTIME L",1),
//	EZTIME_LINE(PNL_CENTER,"EZTIME C",0),
	DIVIDE_LINE(PNL_CENTER,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine TestPL3[] = {
	CROUTON_LINE(PNL_CENTER,"CROUTON C",0),
	CHOICE4_LINE(PNL_CENTER,"CHOICE4 C",1),
	EZSLIDER_LINE(PNL_LEFT,"EZSLIDER",0),
	TOGGLE_LINE(PNL_LEFT,"TOGGLE L",0),
	EZLEN_LINE( PNL_CENTER, "EZLEN C",1),
	EZLEN_LINE( PNL_LEFT, "EZLEN L",0),
	IN_TYPE_LINE(PNL_CENTER,"IN_TYPE C",1),
	OUT_TYPE_LINE(PNL_CENTER,"OUT_TYPE C",0),
	CHOICE5_LINE(PNL_CENTER,"CHOICE5 C",0),
	NUMBER_LINE(PNL_CENTER,"NUMBER C",1),
	NUMBER_LINE(PNL_LEFT,"NUMBER L",0),
	DIVIDE_LINE(PNL_CENTER,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine TestPL2[] = {
	CROUTON_LINE(PNL_CENTER,"CROUTON L",0),
	FXSPEED_LINE(PNL_LEFT,"FXSPEED",1),
	SLIDER_LINE(PNL_LEFT,"SLIDER",0),
	TOGGLE_LINE(PNL_LEFT,"TOGGLE L",0),
	TIME_LINE(PNL_CENTER,"TIME C",1),
	TIME_LINE(PNL_LEFT,"TIME L",0),
	DIFF_LINE(PNL_LEFT,"DIFF L ",1 ),
	DIFF_LINE(PNL_CENTER,"DIFF C ",0 ),
	VCR_LINE(PNL_LEFT,"VCR",1 ),
	PLAY_LINE(PNL_LEFT,"PLAY",0 ),
	DIVIDE_LINE(PNL_CENTER,"",0 ),
	LAST_LINE
};

CFAR CSTATIC struct PanelLine XPTestPL[] = {
	TEXT_LINE(PNL_LEFT,"Control Panel Test",0),
	DIVIDE_LINE(PNL_LEFT," Blammo! ",0 ),
	STRING_LINE(PNL_LEFT,"Name",1),
	POPUP_LINE(PNL_RIGHT,"Panel Type",0 ),
	NUMBER_LINE( PNL_CENTER, "% Potato",0),
	PLAY_LINE(PNL_CENTER,"Test Panel? ",0),
	DIVIDE_LINE(PNL_CENTER,"  Bye Bye  ",0 ),
	LAST_LINE
};
*/

a570 1371

CFAR struct TagHelp TagNames[] = {
	{	"!!NULL TAG!!",0},
	{	"Version",0},
	{	"Revision",0},
	{	"AAeffect",0},
	{	"NonAAeffect",0},
	{	"KillInterfaceNonAA",0},
	{	"KillInterfaceAA",0},
	{	"ButtonELHlogic",0},
	{	"CustomButtonELHlogic",1}, // Table
	{	"NumberOfAnims",0},
	{	"RequestFileName",0},
	{	"AnimFiles",1},  // Table
	{	"Frames",0},
	{	"FieldSync",0},
	{	"VariableSpeeds",0},
	{	"ForcePlayForward",0},
	{	"ForcePlayReverse",0},
	{	"LoopAnims",0},
	{	"AnimControl",1},  // Table
	{	"AudioFastSamples",0},
	{	"AudioMediumSamples",0},
	{	"AudioSlowSamples",0},
	{	"AudioFiles",1}, // Table
	{	"AudioControl",1},  // Table
	{	"PauseTimes",1},  // Table
	{	"LatchColors",1},  // Table
	{	"TransparentColors",1},  // Table
	{	"PaletteColors",1},  // Table
	{	"Equations",1}, // Table
	{	"Encoder",0},
	{	"VerticalScroll",0},
	{	"ReverseTime",0},
	{	"ReverseButtLog",0},
	{	"ReverseCustomButtLog",1}, // Table
	{	"KeyMode",0},
	{	"MatteColor",0},
	{	"CustomMatteColor",0},
	{	"BorderColor",0},
	{	"CustomBorderColor",0},
	{	"LineNumbers",1},     // Table
	{	"LineNumberPlane",0},
	{	"ForceFreeze4",0},
	{	"ForceFreeze8",0},
	{	"ForceLive",0},
	{	"ForceLumKeyOn",0},
	{	"ForceLumKeyOff",0},
	{	"ForceLumKeyOnBlack",0},
	{	"ForceLumKeyOnWhite",0},
	{	"BadDefaultFX",0},
	{	"LoadPictures",1}, // Table
	{	"FadeInDuration",0},
	{	"FadeOutDuration",0},
	{	"DigitalFX",0},
	{	"pad1",0},
	{	"LUT",0},
	{	"DigitalPairs",0},
	{	"LatchAM",0},
	{	"LatchBM",0},
	{	"LatchIS",0},
	{	"HonorPreviewOverLay",0},
	{	"ForceDefaultMatte",0},
	{	"TurnAudioFilterOff",0},
	{	"AudioStartField",0},
	{	"NumAudioFields",0},
	{	"ISandClipPause",0},
	{	"Interlaced",0},
	{	"FirstFieldNTSCII",0},
	{	"BounceILBM",0},
	{	"LatchRanges",1}, // Table
	{	"LatchList",1}, // Table
	{	"TransparentRanges",1},  // Table
	{	"TransparentList",1}, // Table
	{	"Color0Transparent",0},
	{	"AbortIfSlow",0},
	{	"NumSkipFieldsAtEnd",0},
	{	"TBarDoesAuto",0},
	{	"DoNotStompSprite",0},
	{	"AbortLoopAtEnd",0},
	{	"NonAAremap",0},
	{	"100PercentWhiteMatte",0},
	{	"UseEffectColor",0},
	{	"LoopCount",0},
	{	"CroutonType",0},
	{	"TimeLine",0},
	{	"IndexID",0},
	{	"FCountMode",0},
	{	"VariableFCount",0},
	{	"SlowFCount",0},
	{	"MedFCount",0},
	{	"FastFCount",0},
	{	"VariableFCount68000",0},
	{	"SlowFCount68000",0},
	{	"MedFCount68000",0},
	{	"FastFCount68000",0},
	{	"NumFields",0},
	{	"StartTime",0},
	{	"DescriptorList",1}, // Table
	{	"AboutList",1},  // Table
	{	"CommentList",1},  // Table
	{	"AlgoFXtype",0},
	{	"AlgoFXborder",0},
	{	"NumFramesSlow",0},
	{	"NumFramesMedium",0},
	{	"NumFramesFast",0},
	{	"NumFramesVariable",0},
	{	"Page",1}, // Table
	{	"Speed",0},
	{	"Delay",0},
	{	"Duration",0},
	{	"AudioAttack",0},
	{	"AudioDecay",0},
	{	"RecFields",0},
	{	"AudioOn",0},
	{	"AudioStart",0},
	{	"AudioDuration",0},
	{	"ClipStartField",0},
	{	"FadeInVideo",0},
	{	"MaxDuration",0},
	{	"VideoSource",0},
	{	"LoadedSlices",0},
	{	"OriginalLocation",1}, // Table
	{	"AudioVolume1",0},
	{	"AudioVolume2",0},
	{	"AudioPan1",0},
	{	"AudioPan2",0},
	{	"PanelMode",0},
	{	"ColorMode",0},
	{	"CycleMode",0},
	{	"DataMode",0},
	{	"AdjustedVideoStart",0},
	{	"AdjustedVideoDuration",0},
	{	"Asynchronous",0},
	{	"CommandLine",1},  // Table
	{	"SMPTEtime",1},  // Table
	{	"TBarPosition",0},
	{"",0}   // IMPORTANT to null terminate!
};

// Convert free 512 byte (.5k)  blocks in FlyerVolInfo
ULONG BlocksToFrames(ULONG blox, ULONG mode)
{ // 3M/s worst case = 3*1024*2blocks/sec ==> N blocks =N/6144sec.s =30*N/6144 frames

	switch(mode)
	{
		case STD_COMP_MODE:
			return((30*blox)/6144);
			break;
		case AUDIO_COMP_MODE:
		// 44.1khz*2byte samples*2stereo channels*(1000/1024)=172.266kb/s=344.53blox/s
		// 344.53 blox/sec==> t(secs)=blox/344.53==> frames=30*blox/344.53
			return((30*blox)/345);
			break;
		case EXTD_COMP_MODE:
		default:
			return((42*blox)/6144); // 42 is arbitrary num from 30/.707
			break;
	}
}

//|~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~|//
// The following 'CTRL_' functions are called as PanelLine.UserFun functions
// within the PanelLine's Handle() function.

// TBC Control function
ULONG __asm CTRL_TBCSet(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	int type=(int)Obj;
	ULONG flags;

	if(!pl->PropGadg)
		flags=(ULONG)pl->Param;
	switch(type)
	{
		case TBC_CPHZ:
			TBC_dat.Phase =*(pl->Param);
			DUMPSDECL("Phase: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_HPHZ:
			TBC_dat.HorAdj =*(pl->Param);
			DUMPSDECL("Horiz: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_BRT:
			TBC_dat.Bright = (BYTE) *(pl->Param);
			DUMPSDECL("Bright: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_HUE:
			TBC_dat.Hue = (BYTE) *(pl->Param);
			DUMPSDECL("Hue: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_CON:
			TBC_dat.Contrast = (UBYTE) *(pl->Param);
			DUMPSDECL("Cont: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_SAT:
			TBC_dat.Sat = (UBYTE)*(pl->Param);
			DUMPSDECL("Sat: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_FAD:
			TBC_dat.Fader = (BYTE) *(pl->Param);
			DUMPSDECL("Fade: ",(LONG)*pl->Param,"\\");
			break;
		case TBC_INP:
			TBC_dat.InputSel = TBC_Input[pl->PropStart];
			break;
		case TBC_KEYM:
			TBC_dat.KeyerFlags &=~(TBCKF_MODE0|TBCKF_MODE1);
			TBC_dat.KeyerFlags |= TBC_KeyMode[pl->PropStart];
			break;

		case TBC_KEY:
//			TBC_dat.KeyerFlags=0;
			if(flags&1)
				TBC_dat.KeyerFlags |=TBCKF_FADEROUT;
			else
				TBC_dat.KeyerFlags &=~TBCKF_FADEROUT;
			if(flags&1<<1)
				TBC_dat.KeyerFlags |=TBCKF_KEYONB;
			else
				TBC_dat.KeyerFlags &=~TBCKF_KEYONB;
			break;
		case TBC_ENC:
			TBC_dat.Flags=0;
			if(flags&1)
				TBC_dat.Flags |= TBCGF_BYPASS;
			if(flags&1<<3)
				TBC_dat.Flags |= TBCGF_FREEZE;
			TBC_dat.EncFlags=0;
			if(flags&1<<1)
				TBC_dat.EncFlags |=TBCEF_BARS;
			if(flags&1<<2)
				TBC_dat.EncFlags |=TBCEF_KILLCOLOR;
			break;
		case TBC_DEC:
			TBC_dat.DecFlags=0;
			if(flags&1<<1)
				TBC_dat.DecFlags |=TBCDF_AGC;
			if(flags&1<<2)
				TBC_dat.DecFlags |=TBCDF_CHROMAAGC;
			if(flags&1)
				TBC_dat.DecFlags |=TBCDF_MONOCHROME;
			break;
		case TBC_TRM:
			TBC_dat.Term=0;
			if(flags&1<<4)
				TBC_dat.Term |= TBCTF_FADERB;
			if(flags&1<<3)
				TBC_dat.Term |= TBCTF_FADERA;
			if(flags&1<<2)
				TBC_dat.Term |= TBCTF_OUT;
			if(flags&1<<1)
				TBC_dat.Term |= TBCTF_GENIN;
			if(flags&1)
				TBC_dat.Term |= TBCTF_COMPIN;
			break;
		default:
			return(0);
	}
	ESparams2.Data1 =(LONG) HACK_TBCW;
	ESparams2.Data2 =(LONG) &TBC_dat;
	SendSwitcherReply(ES_Hack,&ESparams2);
	return(0);
}

// Hack rectest popup f'n
ULONG __asm CTRL_RecTest(REG(a1) struct PanelLine *pl,REG(a0) struct Hack *hak)
{

	if(Hack!=Hacks[pl->PropStart])
	{
		Hack=Hacks[pl->PropStart];
		TweakPL[3].Param = &(Hack->hk_Position);
		TweakPL[3].UserObj=(APTR)Hack;
		UpdatePanStr(&(TweakPL[3]),pl->Win);

		TweakPL[4].Param = &(Hack->hk_Clock);
		TweakPL[4].UserObj=(APTR)Hack;
		UpdatePanStr(&(TweakPL[4]),pl->Win);

		TweakPL[5].Param = &(Hack->hk_Coarse);
		TweakPL[5].UserObj=(APTR)Hack;
		UpdatePanStr(&(TweakPL[5]),pl->Win);

		TweakPL[6].Param = &(Hack->hk_Fine);
		TweakPL[6].UserObj=(APTR)Hack;
		UpdatePanStr(&(TweakPL[6]),pl->Win);

//		TweakPL[7].Param = &(Hack->hk_Pedestal);
//		TweakPL[7].UserObj=(APTR)Hack;
//		UpdatePanStr(&(TweakPL[7]),pl->Win);

//		TweakPL[8].Param=(long *)Hack->hk_Shift;
//		TweakPL[8].UserObj=(APTR)Hack;
	}

	ESparams2.Data1 =(LONG) HACK_TWEAK;
	ESparams2.Data2 =(LONG) Hack;  // Hack ptr
	SendSwitcherReply(ES_Hack,&ESparams2);
	return(0);
}

ULONG	__asm CTRL_Hack(REG(a1) struct PanelLine *pl, REG(a0) struct Hack *hack)
{
	ULONG Flags=hack->hk_Flags;
	DUMPMSG("CTRL_Hack()");
	hack->hk_Flags &= ~HKF_TESTREC;
	ESparams2.Data1 =(LONG) HACK_TWEAK;
	ESparams2.Data2 =(LONG) hack;  // Hack ptr
	SendSwitcherReply(ES_Hack,&ESparams2);

	hack->hk_Flags = Flags;
	return(0);
}

// Source popup f'n  object is Drive PLine for available time update
ULONG __asm CTRL_SetSource(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct FlyerVolInfo *FVI=NULL;
	LONG	T;

	CurFlySource=pl->PropStart;

//	ESparams1.Data1 = CurFlySource + 1 + SOURCE_INDEX_OFFSET;
	ESparams1.Data1 = SrcInd[CurFlySource];
	if(CurCompMode==AUDIO_COMP_MODE)
	{
		ESparams1.Data1 = 0;
	}
	DUMPUDECL("SetSource( ",ESparams1.Data1,",");
	SendSwitcherReply(ES_RecordSource,&ESparams1);
	if(Obj)
	{
		if(FlyerDriveCount && (FVI=GetFlyerInfo(FlyerDrives[CurFlyDrive])))
		{
			T=BlocksToFrames(FVI->Largest,CurCompMode);
			((struct PanelLine *)Obj)->G4 = (struct Gadget *)T;
			T=BlocksToFrames(FVI->Optimized,CurCompMode);
			((struct PanelLine *)Obj)->G5 = (struct Gadget *)T;
			if(((struct PanelLine *)Obj)->G4>((struct PanelLine *)Obj)->G5)
				((struct PanelLine *)Obj)->G5=((struct PanelLine *)Obj)->G4; // Don't let optimized be smaller!!!
		}
	}
	return(0);
}

// Drive popup f'n  object is ignored
ULONG __asm CTRL_SetDrive(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct FlyerVolInfo *vi;
	char *name;
	DUMPSTR("SetDrive( ");
	name=( ((char **)pl->Param)[pl->PropStart] );

	if( *name==AUDIO_BYTE )
	{
		name +=2 ; // Skip speaker symbol char and space
		CurCompMode=AUDIO_COMP_MODE;
		if( (pl->Flags&PL_PARTNER) && pl->Partners )
			(pl->Partners)->PropStart = AUDIO_COMP_MODE;
		ESparams1.Data1 = CurCompMode;
		SendSwitcherReply(ES_CompressionMode,&ESparams1);
	}
	ESparams2.Data1=(LONG)name;
	DUMPSTR((char *)ESparams2.Data1);
	DUMPMSG(" ) \\");
	ESparams2.Data2=(LONG)NULL;
	CurFlyDrive=pl->PropStart;
	if(vi=(struct FlyerVolInfo *)SendSwitcherReply(ES_FlyerDriveInfo,&ESparams2))
	{
		DUMPHEXIL(" vi = ",(LONG)vi,"\\");
		DUMPUDECL("vi->Largest =  ",(LONG)vi->Largest,"\\");
		DUMPUDECL("vi->Optimized =  ",(LONG)vi->Optimized,"\\");
		pl->G4 = (struct Gadget *) BlocksToFrames(vi->Largest,CurCompMode);
		pl->G5 = (struct Gadget *) BlocksToFrames(vi->Optimized,CurCompMode);
		if(pl->G4>pl->G5) pl->G5=pl->G4; // Don't let optimized be smaller!!!
	}
	return(0);
}

// Compression popup f'n  object is Drive PLine for available time update
ULONG __asm CTRL_SetCompression(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct FlyerVolInfo *FVI=NULL;
	LONG	T;
//	ULONG CompMode;
	DUMPUDECL("SetCompression( ",pl->PropStart," ) \\");
	ESparams1.Data1 =(LONG) pl->PropStart;
	CurCompMode = pl->PropStart;
//	CompMode=CurCompMode;
	SendSwitcherReply(ES_CompressionMode,&ESparams1);
	if(Obj)
	{
		if(FlyerDriveCount && (FVI=GetFlyerInfo(FlyerDrives[CurFlyDrive])))
		{
			if( FlyerDrives[CurFlyDrive][0]==AUDIO_BYTE )
			{
				CurCompMode=AUDIO_COMP_MODE;
				pl->PropStart=AUDIO_COMP_MODE;
			}

//			else if( IS_AUDIO_SOURCE(CurFlySource) )
//				CompMode=AUDIO_COMP_MODE;

			T=BlocksToFrames(FVI->Largest,CurCompMode);
			((struct PanelLine *)Obj)->G4 = (struct Gadget *)T;
			T=BlocksToFrames(FVI->Optimized,CurCompMode);
			((struct PanelLine *)Obj)->G5 = (struct Gadget *)T;
			if(((struct PanelLine *)Obj)->G4>((struct PanelLine *)Obj)->G5)
				((struct PanelLine *)Obj)->G5=((struct PanelLine *)Obj)->G4; // Don't let optimized be smaller!!!
		}
	}
	return(0);
}

// 2 or 3 monitor mode setting
ULONG __asm CTRL_SetFace(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	DUMPUDECL("SetFace( ",(LONG)*pl->Param," ) \\");
	if(*pl->Param)
		Config.Flags1 |= (1<<spB_PrvwOLay);
	else
	{
		Config.Flags1 &= ~(1<<spB_PrvwOLay);
		DUMPSTR(FaceMess[0]);
		DUMPMSG(FaceMess[1]);
		SimpleRequest(pl->Win,FaceMess,2,REQ_CENTER | REQ_H_CENTER,NULL);
	}
	ESparams1.Data1=(LONG)&Config;
	SendSwitcherReply(ES_SetPrefs,&ESparams1);
	return(0);
}

// Source Termination setting
ULONG __asm CTRL_SetTermination(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	DUMPUDECL("SetTermination( ",(LONG)pl->Param," ) \\");
	Config.Termination = (LONG)pl->Param;
	ESparams1.Data1=(LONG)&Config;
	SendSwitcherReply(ES_SetPrefs,&ESparams1);
	return(0);
}

// Flyer Output Setting
ULONG __asm CTRL_SetFlyOut(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	if(((LONG)pl->Param)&1) Config.Flags1 |= spB_FlyerVID3;
	else Config.Flags1 &= ~spB_FlyerVID3;
	if(((LONG)pl->Param)&2) Config.Flags1 |= spB_FlyerVID4;
	else Config.Flags1 &= ~spB_FlyerVID4;
	return(0);
}

// Set GPI setting
ULONG __asm CTRL_SetGPI(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	DUMPUDECL("SetGPI( ",pl->PropStart," ) \\");
	Config.GPI = pl->PropStart;
	ESparams1.Data1=(LONG)&Config;
	SendSwitcherReply(ES_SetPrefs,&ESparams1);
	return(0);
}

UWORD __asm GetRecSense()
{
	UWORD	s;
	DUMPSTR("GetRecSense: ");
	ESparams2.Data1 =(LONG) &AudCtrl;
	ESparams2.Data2 =(LONG) 1;
	SendSwitcherReply(ES_AudioControl,&ESparams2);
	s=(AudCtrl.LeftSense<<8);
	s|=AudCtrl.RightSense;
	DUMPHEXIW(" = ",s,"\\");
	return(s);
}

UWORD __asm GetRecGain()
{
	UWORD	s;
	UBYTE *c;
	c=(UBYTE *)&s;
	DUMPSTR("RecGain");
	ESparams2.Data1 =(LONG) &AudCtrl;
	ESparams2.Data2 =(LONG) 1;
	SendSwitcherReply(ES_AudioControl,&ESparams2);
	s=(AudCtrl.LeftGain<<8);
	s|=AudCtrl.RightGain;
	DUMPUDECB(" L: ",c[0],"   ");
	DUMPUDECB(" R: ",c[1],"\\");
	return(s);
}

// Record gain control function, object is *FlyAudCtrl
ULONG __asm CTRL_SetRecGain(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct FlyAudCtrl	*aud=Obj;
	ULONG	Y=*pl->Param;
	DUMPUDECL("SetRecGain: ",Y,"\\");
	if(!aud) return(0);
	if(pl->Flags&PL_IN)
		aud->LeftGain =  Y&0x0F;
	else
		aud->RightGain = Y&0x0F;
	ESparams2.Data1 =(LONG) aud;
	ESparams2.Data2 =(LONG) 2;
	SendSwitcherReply(ES_AudioControl,&ESparams2);
	return((ULONG)aud->LeftGain);
}


// For Diagnostic purposes only
ULONG __asm CTRL_DumpPLine(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
#ifdef SERDEBUG
	DUMPMSG("PanelLine = { ");
	if((ULONG)pl->Param>0xFFFF)
	{
		DUMPHEXIL("	*Param: ",(LONG)*pl->Param,"  ");
		DUMPHEXIL(" @@",(LONG)pl->Param,"\\");
	}
	else DUMPUDECL("	Param: ",(LONG)pl->Param,"\\ ");
	if((ULONG)pl->Param2>0xFFFF)
	{
		DUMPHEXIL("	*Param2: ",(LONG)*pl->Param2,"  ");
		DUMPHEXIL(" @@",(LONG)pl->Param2,"\\");
	}
	else DUMPUDECL("	Param2: ",(LONG)pl->Param2,"\\ ");
	DUMPUDECL("	PropStart ",(LONG)pl->PropStart,"	");
	DUMPUDECL("	PropEnd ",(LONG)pl->PropEnd," \\");
	DUMPHEXIL("	Flags ",(LONG)pl->Flags," \\");
	DUMPHEXIL("	Obj: ",(LONG)Obj," };\\");
#endif
	return(0);
}

// Return overall volume (0-100), from v1,v2,balance,etc.
ULONG	GetVolume(struct AudioSet	*aud)
{
	ULONG	V=0;

#ifdef SERDEBUG
	DUMPHEXIL("AudioSet @@ ",(LONG)aud,"  = { \\");
	DUMPUDECL("Volume: ",aud->Volume,"	");
	DUMPUDECL("V1: ",aud->V1,"	");
	DUMPUDECL("V2: ",aud->V2,"\\");
	DUMPHEXIW("Balance: ",aud->Balance,"	");
	DUMPHEXIW("P1: ",aud->Pan1,"	");
	DUMPHEXIW("P2: ",aud->Pan2,"\\");
	DUMPHEXIW("Mode: ",aud->Mode,"	} \\");
#endif
	if(!aud) return(0);
	switch(aud->Mode)
	{
		case  AMODE_LEFT:
			if(aud->V1) V=((aud->V1+1)*100)/MAXPOT;
			break;
		case  AMODE_RIGHT:
			if(aud->V2) V=((aud->V2+1)*100)/MAXPOT;
			break;
		case  AMODE_STEREO:
		default:
			if(V=MAX(aud->V1,aud->V2)) V=((V+1)*100)/MAXPOT;
			break;
	}
	return(aud->Volume=V);
}

// Volume control function, object is *AudioSet
ULONG __asm CTRL_SetVolume(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct AudioSet	*aud=Obj;
	ULONG	Y;
	UWORD R=MAXPOT,L=MAXPOT;

	if(!aud) return(0);
	switch(aud->Mode)
	{
		case  AMODE_LEFT:
			aud->V1 = (MAXPOT*aud->Volume/pl->PropEnd)&0x0000FFFF;
			PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
			break;
		case  AMODE_RIGHT:
			aud->V2 = (MAXPOT*aud->Volume/pl->PropEnd)&0x0000FFFF;
			PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
			break;
		case  AMODE_STEREO:
		default:
			R = aud->Balance;
			L=MAXPOT-R;
			if(R>MAXPOT>>1)  // Scale balance to 100% volume (0xFFFF)
			{
				Y=L*MAXPOT;
				L=Y/R;
				R=MAXPOT;
				aud->V1= ((L*(aud->Volume))/pl->PropEnd)&0x0000FFFF;
				aud->V2= ((R*(aud->Volume))/pl->PropEnd)&0x0000FFFF;
			}
			else if(R>MAXPOT>>1) {
				Y=R*MAXPOT;
				R=Y/L;
				L=MAXPOT;
				aud->V1= ((L*(aud->Volume))/pl->PropEnd)&0x0000FFFF;
				aud->V2= ((R*(aud->Volume))/pl->PropEnd)&0x0000FFFF;
			}
			else // R==MAXPOT>>1
				aud->V2 = aud->V1 = (MAXPOT*aud->Volume/pl->PropEnd)&0x0000FFFF;
			PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
			PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
			break;
	}
	ESparams1.Data1 =(LONG) aud->FG;
	SendSwitcherReply(ES_ChangeAudio,&ESparams1);
	return(aud->Volume);
}

// Return Balance (0-0xFFFF), from v1,v2,balance,etc.
ULONG	GetBalance(struct AudioSet	*aud)
{
	ULONG	V;
	UWORD R,L;

	if(!aud) return(0);
	switch(aud->Mode)
	{
		case  AMODE_LEFT: // just return aud->Balance !??
		case  AMODE_RIGHT:
			break;
		case  AMODE_STEREO:
		default:
			if(!(V=MAX(aud->V1,aud->V2))) return(MAXPOT>>1);
			if(aud->V1<aud->V2)
			{
				V=aud->V1*MAXPOT/aud->V2; // Scale up to full Volume
				L=V/2;
				R=MAXPOT-L;
			}
			else 	if(aud->V1>aud->V2) {
				V=aud->V2*MAXPOT/aud->V1; // Scale up to full Volume
				R=V/2;
				L=MAXPOT-R;
			}  // V1==V2
				else R = L = MAXPOT>>1;
			R &= 0x0000FFFF;
			aud->Balance=R;
			break;
	}
	return(aud->Balance);
}

// Fake balance Volume control function, object is AudioSet
ULONG __asm CTRL_SetBalance(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct AudioSet	*aud=Obj;
	ULONG	V,V1,V2;
	UWORD R,L;

	aud->Balance = R = ((struct PropInfo *)pl->PropGadg->SpecialInfo)->HorizPot;
	switch(aud->Mode)
	{
		case  AMODE_LEFT:
			if(aud->Balance==MAXPOT) aud->Pan1=(MAXPOT>>1); // want 32767, not -32768
			aud->Pan1 = aud->Balance - (MAXPOT>>1);
			PutValue((struct FastGadget *)aud->FG,TAG(AudioPan1),aud->Pan1);
			break;
		case  AMODE_RIGHT:
			if(aud->Balance==MAXPOT) aud->Pan2=(MAXPOT>>1); // want 0x7FFF not 0x8000
			else aud->Pan2 = aud->Balance - (MAXPOT>>1);
			PutValue((struct FastGadget *)aud->FG,TAG(AudioPan2),aud->Pan2);
			break;
		case  AMODE_STEREO:
		default:
			V=aud->Volume*MAXPOT/100;
			DUMPHEXIW("Aud Balance: ",aud->Balance,"\\");
			if(R<MAXPOT>>1)
			{
				V2=2*R;
				aud->V2=(V2*V/MAXPOT)&0x0000FFFF;
				aud->V1=V&0x0000FFFF;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
			}
			else if(R>MAXPOT>>1)
			{
				L=MAXPOT-R;
				V1=2*L;
				aud->V2=V&0x0000FFFF;
				aud->V1=(V1*V/MAXPOT)&0x0000FFFF;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
			}
			else {
				aud->V1 = aud->V2 = V;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
			}
			break;
	}
	ESparams1.Data1 =(LONG) aud->FG;
	SendSwitcherReply(ES_ChangeAudio,&ESparams1);
	return((ULONG)R);
}

// Set stereo output source popup function, object is AudioSet,
ULONG __asm CTRL_SetPan(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct AudioSet	*aud=Obj;
	if(aud->Mode!=pl->PropStart) // mode actually changed
	{
		switch(aud->Mode=pl->PropStart)
		{
			case   AMODE_LEFT:
				aud->Pan1 = aud->Balance - (MAXPOT>>1);
				aud->Pan2 =	0;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioPan1),aud->Pan1);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioPan2),aud->Pan2);
				aud->V1 = (MAXPOT*aud->Volume/100)&0x0000FFFF;
				aud->V2 = 0;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
				SET_LEFT(aud->AudioOn);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioOn),aud->AudioOn);
				break;
			case  AMODE_RIGHT:
				aud->Pan1 =	0;
				aud->Pan2 = aud->Balance - (MAXPOT>>1);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioPan1),aud->Pan1);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioPan2),aud->Pan2);
				aud->V1 = 0;
				aud->V2 = (MAXPOT*aud->Volume/100)&0x0000FFFF;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume2),aud->V2);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioVolume1),aud->V1);
				SET_RIGHT(aud->AudioOn);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioOn),aud->AudioOn);
				break;
			case  AMODE_NOAUDIO:
				SET_NOAUDIO(aud->AudioOn);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioOn),aud->AudioOn);
				break;
			case  AMODE_STEREO:
			default:
				aud->Pan1 =PAN_LEFT;
				aud->Pan2 =PAN_RIGHT;
				PutValue((struct FastGadget *)aud->FG,TAG(AudioPan1),aud->Pan1);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioPan2),aud->Pan2);
				CTRL_SetVolume(pl,Obj); // recalc V1,V2 based on Volume,Balance
				SET_STEREO(aud->AudioOn);
				PutValue((struct FastGadget *)aud->FG,TAG(AudioOn),aud->AudioOn);
				break;
		}
	}
	ESparams1.Data1 =(LONG) aud->FG;
	SendSwitcherReply(ES_ChangeAudio,&ESparams1);
	return(aud->Mode);
}

// Fake balance Volume control function, object is AudioSet
ULONG __asm CTRL_SetAudio(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	struct AudioSet	*aud=Obj;
	if(pl->Param)
		aud->AudioOn |= AUD_ENABLE;
	else
		aud->AudioOn &= ~AUD_ENABLE;
	PutValue((struct FastGadget *)aud->FG,TAG(AudioOn),aud->AudioOn);
	ESparams1.Data1 =(LONG) aud->FG;
	SendSwitcherReply(ES_ChangeAudio,&ESparams1);
	return(aud->AudioOn);
}


//  Play or abort current FG clip
ULONG __asm CTRL_Play(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	if(Obj)
	{
		PlayFG=NULL;
		DUMPMSG("Play");
		if(SKellFG!=Obj)
		{
			ESparams1.Data1 =(LONG) Obj;
			SendSwitcherReply(ES_PanelClose,&ESparams1);
			if(EDITOR_MODE || SendSwitcherReply(ES_Select,&ESparams1))
			{
				SKellFG=(struct FastGadget *)Obj;
				PlayFG = SKellFG;
				SendSwitcherReply(ES_Auto,&ESparams1);
			}
			else
			{
				DUMPSTR("SELECT FAILED!!! on FG");
				DUMPMSG( ((struct ExtFastGadget *)Obj)->FileName );
				SKellFG=NULL;
			}
		}
		else if(ESparams1.Data1 =(LONG) Obj)
		{
			PlayFG = SKellFG;
			SendSwitcherReply(ES_PanelClose,&ESparams1);
			SendSwitcherReply(ES_Auto,&ESparams1);
		}
	}
	else
	{
		DUMPMSG("Stop");
		SendSwitcherReply(ES_Stop,NULL);
		if(ESparams1.Data1 =(LONG) PlayFG)
			SendSwitcherReply(ES_PanelOpen,&ESparams1);
		PlayFG=NULL;
	}
	return((ULONG)Obj);
}

//|~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~~*~~|//



void AddFlyerDrive(char *devname)
{
	if(!FlyerBase) return;
	DUMPUDECL("FlyerDrive[",FlyerDriveCount,"] = ");
	DUMPMSG(devname);
	if(*devname)
		strncpy(FlyerDrives[FlyerDriveCount++],devname,19);
	FlyerDrives[FlyerDriveCount][0]=0;
}

struct FlyerVolInfo *GetFlyerInfo(char *devname)
{
	struct FlyerVolInfo *vi=NULL;
	if(*devname)
	{
		DUMPSTR("FlyerDriveInfo( ");
		if( *devname==AUDIO_BYTE ) devname +=2 ; // Skip speaker symbol char and space
		ESparams2.Data1=(LONG)devname;
		DUMPSTR((char *)ESparams2.Data1);
		ESparams2.Data2=NULL;
		if(vi=(struct FlyerVolInfo *)SendSwitcherReply(ES_FlyerDriveInfo,&ESparams2))
		{
			DUMPHEXIL(" ) = ",(LONG)vi,"\\");
			DUMPUDECL("FlyerVolumeInfo->Largest 	=  ",(LONG)vi->Largest,"\\");
			DUMPUDECL("FlyerVolumeInfo->Optimized 	=  ",(LONG)vi->Optimized,"\\");
			DUMPUDECB("FlyerVolumeInfo->Flags 	= ",vi->Flags,"\\");
			return(vi);
		}
	}
	return(NULL);
}

int CheckFlyerDrives()
{
	struct FlyerVolInfo *FVI=NULL;
	int	i;
	if(!FlyerBase) return(0);
	for(i=0;i<FlyerDriveCount && *(FlyerDrives[i]); i++)
	{
		DUMPUDECL("Checking Flyer Drive #",(LONG)i," Name: ");
		DUMPMSG(FlyerDrives[i]);
		if(FVI=GetFlyerInfo(FlyerDrives[i]))
		{
			if( IS_AUDIO_DRIVE(FVI) )
			{
				DUMPUDECL("Audio Flag set on # ",(LONG)i,"\\");
				TempCh[0]=AUDIO_BYTE; // Add little speaker symbol character
				TempCh[1]=' ';
				strncpy(&(TempCh[2]),FlyerDrives[i],18);
				strncpy(FlyerDrives[i],TempCh,18);
				TempCh[0]=0;
			}
		}
	}
	return(i);
}

void SortFlyerDrives()
{
//	QuickSortArray(FlyerDrives, FlyerDriveCount,CompareFlyerDrives,SwapFlyerDrives);
// for some unknown reason, this call takes forever... literally
// So this hack version, which depends on the drives already marked with AUDIO_BYTE
	int	i,b=FlyerDriveCount-1;
	UBYTE *temp;

	while(*(FlyerDrives[b])==AUDIO_BYTE)
		b--; // b is index of last non-audio drive

	for(i=0; i<b; i++)
	{
		if( (*(FlyerDrives[i])==AUDIO_BYTE) )
		{
			temp=FlyerDrives[i];
			FlyerDrives[i]=FlyerDrives[b];
			FlyerDrives[b--]=temp;
		}
	}
	return;

}

ULONG CheckTag(struct FastGadget *FG,ULONG TagID)
{
#ifdef SERDEBUG
	ULONG	c=0;
	if(FG) {
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
		c=SendSwitcherReply(ES_TagSize,&ESparams2);
	}
	DUMPHEXIL("ES_TagSize( ",(LONG)FG,", ");
	DUMPSTR(TagNames[TagID&~0x80000000].th_Name);
	DUMPSDECL(" 		) = ",c,"\\");
	return(c);
#else
	if(FG){
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
	 	return((ULONG)SendSwitcherReply(ES_TagSize,&ESparams2));
	}
	else return(0);
#endif
}

LONG GetValue(struct FastGadget *FG,ULONG TagID)
{
#ifdef SERDEBUG
	LONG	c=0;
	if(FG) {
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
		c=SendSwitcherReply(ES_GetValue,&ESparams2);
	}
	DUMPHEXIL("ES_GetValue( ",(LONG)FG,", ");
	DUMPSTR(TagNames[TagID&~0x80000000].th_Name);
	DUMPSDECL(" 		) = ",c,"\\");
	return(c);
#else
	if(FG){
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
	 	return(SendSwitcherReply(ES_GetValue,&ESparams2));
	}
	else return(0);
#endif
}

LONG GetTable(struct FastGadget *FG,ULONG TagID, UBYTE *Table, ULONG Size)
{
	LONG	c=0,d=666;
	if(FG) {
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=TagID;
		c=SendSwitcherReply(ES_TagSize,&ESparams2);
//		DUMPSDECL("Table TAG Size= ",c,"\\");
//		DUMPSDECL("Table Input Size= ",Size,"\\");
		if( (ESparams4.Data2=(LONG)Table) && (ESparams4.Data3=MIN(Size,c)) )
		{
//			DUMPMSG(Table);
			ESparams4.Data1=(LONG)FG;
			ESparams4.Data4=TagID&~0x80000000;
			d=SendSwitcherReply(ES_GetTable,&ESparams4);
//			DUMPMSG(Table);
		}
	}
	DUMPHEXIL("ES_GetTable( ",(LONG)FG,",");
	DUMPSTR(TagNames[TagID].th_Name);
	DUMPSDECL(")= ",d,"\\");
	if(Table) DUMPMSG(Table);
	return(c);
}

LONG PutValue(struct FastGadget *FG,ULONG TagID,LONG Value)
{
#ifdef SERDEBUG
	if(FG) {
		ESparams3.Data1=(LONG)FG;
		ESparams3.Data2=TagID;
		ESparams3.Data3=Value;
		SendSwitcherReply(ES_PutValue,&ESparams3);
	}
	DUMPHEXIL("PutValue( ",(LONG)FG,", ");
	DUMPSTR(TagNames[TagID&~0x80000000].th_Name);
	DUMPSDECL(" 		,",Value," ) \\");
	return(0);
#else
	if(FG) {
		ESparams3.Data1=(LONG)FG;
		ESparams3.Data2=TagID;
		ESparams3.Data3=Value;
		return(SendSwitcherReply(ES_PutValue,&ESparams3));
	}
	else return(0);
#endif
}

LONG PutTable(struct FastGadget *FG,ULONG TagID,UBYTE *Table, ULONG Size)
{
	LONG	c=0;
	if(FG) {
		ESparams4.Data1=(LONG)FG;
		ESparams4.Data2=(LONG)Table;
		ESparams4.Data3=Size;
		ESparams4.Data4=TagID&~0x80000000;
		c=SendSwitcherReply(ES_PutTable,&ESparams4);
	}
#ifdef SERDEBUG
	DUMPHEXIL("PutTable( ",(LONG)FG,", ");
	DUMPSTR(TagNames[TagID&~0x80000000].th_Name);
	DUMPSTR(" , ");
	DUMPSTR(Table);
	DUMPUDECL(" ) = ",c,"\\");
#endif
	return(c);
}


/*
// channels: bit 0 = L exist, 2=L enable, Bit 1 = R exist, 3=R enable,
// just like AudioOn tag value
void SwitchFlyerAudio(struct FastGadget *FG,LONG Channels)
{
	PutValue(FG,TAG(AudioOn),Channels);
	switch((Channels>>2)&3)
	{
		case 0:  // all disabled, why change vol??
			break;
		case 1:
			PutValue(FG,TAG(AudioPan1),0);
			break;
		case 2:
			PutValue(FG,TAG(AudioPan2),0);
			break;
		case 3:
			PutValue(FG,TAG(AudioPan1),-1);
			PutValue(FG,TAG(AudioPan2),1);
			break;
	}
	ESparams1.Data1 =(LONG) aud->FG;
	SendSwitcherReply(ES_ChangeAudio,&ESparams1);
}

// channels: bit 0 = L exist, 2=L enable, Bit 1 = R exist, 3=R enable,
// just like AudioOn tag value
void SetFlyerAudio(struct FastGadget *FG,UWORD Vol1,UWORD Vol2,LONG Channels)
{
	PutValue(FG,TAG(AudioOn),Channels);
	switch((Channels>>2)&3)
	{
		case 0:  // all disabled, why change vol??
			break;
		case 1:
			PutValue(FG,TAG(AudioVolume1),Vol1);
			PutValue(FG,TAG(AudioPan1),0);
			break;
		case 2:
			PutValue(FG,TAG(AudioVolume2),Vol2);
			PutValue(FG,TAG(AudioPan2),0);
			break;
		case 3:
			PutValue(FG,TAG(AudioVolume1),Vol1);
			PutValue(FG,TAG(AudioVolume2),Vol2);
			PutValue(FG,TAG(AudioPan1),-1);
			PutValue(FG,TAG(AudioPan2),1);
			break;
	}
	ESparams1.Data1 =(LONG) aud->FG;
	SendSwitcherReply(ES_ChangeAudio,&ESparams1);
}
*/


void __inline SetInPoint(struct FastGadget *FG, ULONG InField, ULONG OutField)
{
	PutValue(FG,TAG(ClipStartField),InField);
	PutValue(FG,TAG(Duration),(OutField+4-InField));
}

void __inline SetOutPoint(struct FastGadget *FG, ULONG InField, ULONG OutField)
{
	PutValue(FG,TAG(Duration),(OutField+4-InField));
}

void __inline SetAudioInPoint(struct FastGadget *FG, ULONG InField, ULONG OutField)
{
	PutValue(FG,TAG(AudioStart),InField);
	PutValue(FG,TAG(AudioDuration),(OutField+4-InField));
}

void __inline SetAudioOutPoint(struct FastGadget *FG, ULONG InField, ULONG OutField)
{
	PutValue(FG,TAG(AudioDuration),(OutField+4-InField));
}

// Return MaxBlocks
ULONG	DHD_InitRecord(ULONG Unit,ULONG Flags)
{
	DUMPUDECL("DHD_InitRecord( ",Unit,",");
	DUMPHEXIL(" ",Flags," ); \\ ");
	if(ESparams1.Data1=(LONG)CurFG)
	{
		SendSwitcherReply(ES_SelectDefault,NULL);
//		SendSwitcherReply(ES_FreeCrouton,&ESparams1); // if freshly recorded clip
		CurFG=NULL;
	}
	SendSwitcherReply(ES_InitRecord,NULL);
	DUMPMSG("InitRecord() Done");
	return((ULONG)1);
}

// Src is raw CurFlySource= popup array entry 0-AUDIO_ONLY_SOURCE
void DHD_SetupRecord(LONG Src, LONG Comp)
{
	DUMPUDECL("DHD_SetupRecord( ",Src,",");
	DUMPUDECL(" ",Comp,") \\");

	ESparams1.Data1 = SrcInd[Src];
//	ESparams1.Data1 = Src + 1 + SOURCE_INDEX_OFFSET;
	SendSwitcherReply(ES_RecordSource,&ESparams1);

	ESparams1.Data1 =(LONG) Comp;
	SendSwitcherReply(ES_CompressionMode,&ESparams1);

	ESparams2.Data1 =(LONG) &AudCtrl;
	ESparams2.Data2 =(LONG) 2;
	SendSwitcherReply(ES_AudioControl,&ESparams2);
	return;
}

// Return MaxBlocks
ULONG	DHD_InitPlay(char *name,ULONG Flags)
{
	DUMPSTR("DHD_InitPlay( ");
	DUMPHEXIL(" ",Flags," ); \\ ");
	SendSwitcherReply(ES_InitPlay,NULL);
	return((ULONG)1);
}

int	__inline DHD_CheckRecord()
{
	return(	SendSwitcherReply(ES_CheckRecord,NULL) );
}

void	__inline DHD_Abort(ULONG Unit)
{
	DUMPUDECL("DHD_Abort( ",Unit,"); \\ ");
	SendSwitcherReply(ES_Stop,NULL);
	return;
}

void	__inline DHD_Play(ULONG Unit)
{
	DUMPUDECL("DHD_Play( ",Unit,"); \\ ");
	SendSwitcherReply(ES_Auto,NULL);
	return;
}

void	__inline DHD_Reorganize(char *name)
{
	DUMPSTR("DHD_Reorganize( ");
	DUMPSTR(name);
	DUMPMSG(" )");
	ESparams1.Data1 =(LONG) name;
	SendSwitcherReply(ES_DefragFlyer,&ESparams1);
	return;
}

void	__inline Main2Blank()
{
	DUMPMSG("Main2Blank");
	SendSwitcherReply(ES_Main2Blank,NULL);
	return;
}

ULONG	DHD_Record(char *name, ULONG RecFields, ULONG Stop, ULONG Flags)
{
	DUMPSTR("DHD_Record( ");
	DUMPSTR(name);
	DUMPSTR(" )");
	ESparams5.Data1=(LONG)name;
	ESparams5.Data2=(LONG)RecFields;
	ESparams5.Data3=(LONG)0;
	ESparams5.Data4=(LONG)0;
	ESparams5.Data5=(LONG)0;
	return((ULONG)SendSwitcherReply(ES_Record,&ESparams5));
}

struct ClipInfo *DHD_ClipInfo(char *name)
{
	struct ClipInfo *ci=NULL;
	if(*name)
	{
		DUMPSTR("FlyerClipInfo( ");
		ESparams2.Data1=(LONG)name;
		DUMPSTR((char *)ESparams2.Data1);
		ESparams2.Data2=NULL;
		ci=(struct ClipInfo *)SendSwitcherReply(ES_FlyerClipInfo,&ESparams2);
		DUMPHEXIL(" ) = ",(LONG)ci,"\\");
		DUMPUDECL("ci->Fields =  ",(LONG)ci->Fields,"\\");
		DUMPBITSL("ci->Flags =  ",(LONG)ci->Flags,"\\");
		return(ci);
	}
	return(NULL);
}


ULONG	DHD_MakeClipIcon(char *name)
{
	struct	ClipInfo * ci;
	ULONG	x=FALSE;	//assume error

	DUMPSTR("DHD_MakeClipIcon( ");
	DUMPSTR(name);
	DUMPSTR(" )");

	DisplayWaitSprite();

	if( (ci=DHD_ClipInfo(name)) && (ci->Flags&CIF_HASVIDEO) ) {
		ESparams4.Data1=(LONG)name;
		ESparams4.Data2=(LONG)0;				// currently no CrUD
		ESparams4.Data3=(LONG)0;
		ESparams4.Data4=(LONG)(ci->Fields/2);	// center field
		x=(ULONG)SendSwitcherReply(ES_MakeClipIcon,&ESparams4);
		ESparams1.Data1=(LONG)name;
		SendSwitcherReply(ES_AppendIcon,&ESparams1);
	}

	DisplayNormalSprite();
	return(x);
}

void	SetRCBFlags(struct RenderCallBack	*rcb)
{
	if(rcb->pline->Flags&PL_AUDIO)
	{
		rcb->Flags &= ~DHD_VIDEOSLIDER;
		rcb->Flags |=	DHD_AUDIOSLIDER ;
	}
	else
	{
		rcb->Flags &=	~DHD_AUDIOSLIDER;
		rcb->Flags |=	DHD_VIDEOSLIDER ;
	}
	if(rcb->pline->Flags&PL_IN)
	{
		rcb->Flags &=~DHD_OUTPOINT;
		rcb->Flags |=DHD_INPOINT  ;
	}
	else
	{
		rcb->Flags &=~DHD_INPOINT;
		rcb->Flags |=DHD_OUTPOINT;
	}
}

void	SetRCBTags(struct RenderCallBack	*rcb)
{
	struct PanelLine *PartPL;
	if(rcb->pline->Flags&PL_AUDIO)
	{
		if(rcb->pline->Flags&PL_IN)
			SetAudioInPoint(rcb->FG,rcb->Frame,rcb->Max);
		else if(rcb->pline->Flags&PL_OUT)
			SetAudioOutPoint(rcb->FG,rcb->Min,rcb->Frame);
	}
	else {
		if(rcb->pline->Flags&PL_IN)
			SetInPoint(rcb->FG,rcb->Frame,rcb->Max);
		else if(rcb->pline->Flags&PL_OUT)
			SetOutPoint(rcb->FG,rcb->Min,rcb->Frame);
	}
	if( (rcb->pline->Flags&PL_PARTNER) && (PartPL=rcb->pline->Partners) )
	{
		if(PartPL->Flags&PL_AUDIO)
		{
			if(PartPL->Flags&PL_IN)
				SetAudioInPoint(rcb->FG,rcb->Frame,rcb->Max);
			else if(PartPL->Flags&PL_OUT)
				SetAudioOutPoint(rcb->FG,rcb->Min,rcb->Frame);
		}
		else {   // Probably unnecessary, since I don't want to drag video with audio
			if(PartPL->Flags&PL_IN)
				SetInPoint(rcb->FG,rcb->Frame,rcb->Max);
			else if(PartPL->Flags&PL_OUT)
				SetOutPoint(rcb->FG,rcb->Min,rcb->Frame);
		}
	}
}

void	DHD_Shuttle(struct RenderCallBack	*rcb)
{
	DUMPMSG("DHD_Shuttle()");
	DUMPHEXIL("PL->Flags ",rcb->pline->Flags,"\\");
	ESparams1.Data1=(LONG)rcb;
	SetRCBFlags(rcb);
	SendSwitcherReply(ES_Shuttle,&ESparams1);
	rcb->Frame += 1;
	rcb->Frame &= ~0x00000003;
	SetRCBTags(rcb);
	DUMPHEXIL("PL->Flags ",rcb->pline->Flags,"\\");
	return;
}

void	DHD_Jog(struct RenderCallBack	*rcb)
{
	DUMPMSG("DHD_Jog()");
	DUMPHEXIL("PL->Flags ",rcb->pline->Flags,"\\");
	SetRCBFlags(rcb);
	rcb->Flags |= DHD_MOUSE_UPDATE;
	ESparams1.Data1=(LONG)rcb;
	SendSwitcherReply(ES_Jog,&ESparams1);
	DUMPUDECL("JUMP BACK!  frame: ",rcb->Frame,"  ");
	rcb->Frame += 1;
	rcb->Frame &= ~0x00000003;
	rcb->RenderFn(rcb);
	DUMPUDECL("new frame: ",rcb->Frame,"\\");
	SetRCBTags(rcb);
	DUMPHEXIL("PL->Flags ",rcb->pline->Flags,"\\");
	return;
}

void	DHD_Jump(struct RenderCallBack	*rcb)
{
	DUMPUDECL("DHD_Jump() min: ",rcb->Min,"   ");
	DUMPUDECL("frame: ",rcb->Frame,"  ");
	DUMPUDECL("max: ",rcb->Max,"  \\ ");
	DUMPHEXIL("PL->Flags ",rcb->pline->Flags,"\\");
	if(rcb->Frame>rcb->Max) rcb->Frame = rcb->Max;
	if(rcb->Frame<rcb->Min) rcb->Frame = rcb->Min;
	rcb->Frame &= ~0x00000003;
	SetRCBFlags(rcb);
	rcb->Flags &= ~DHD_MOUSE_UPDATE;

	ESparams2.Data1=(LONG)rcb->FG;
	ESparams2.Data2=(LONG)rcb->Frame;
	SendSwitcherReply(ES_Jump,&ESparams2);

	rcb->RenderFn(rcb);
	SetRCBTags(rcb);
	DUMPHEXIL("PL->Flags ",rcb->pline->Flags,"\\");
	return;
}

ULONG RecordClip(char *ClipName, ULONG RecFields, int FlySource, int CompMode)
{
	ULONG	Y;

	CurCompMode = CompMode;
	CurFlySource = FlySource;

	DisplayWaitSprite();
	DHD_InitRecord(0,0xC0DED00D);
	DHD_SetupRecord(CurFlySource,CompMode);
	DHD_Record(ClipName,RecFields,0,0xDEADBABE);

	Delay(50);
	while( (Y=DHD_CheckRecord())==FERR_BUSY )
	{
		switch(Y)
		{
			case FERR_OKAY:
				DHD_MakeClipIcon(ClipName);
				return(Y);
				break;
			case FERR_EXISTS:
			case FERR_EXHAUSTED:
			default:
				return(Y);
				break;
		}
		Delay(50);
	}
	DHD_InitPlay("",0xC0DED00D);
	DisplayNormalSprite();
}
@


2.139
log
@Cannot have static items that are FAR
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.138 1995/02/19 01:03:41 CACHELIN4000 Exp pfrench $
d4 3
d342 1
d383 1
a383 1
far CSTATIC char Size[20],Name[MAX_STRING_BUFFER]="Clip.0",Dir[MAX_STRING_BUFFER];
d388 1
a388 1
far CSTATIC struct Hack
d497 1
a497 1
far CSTATIC struct PanelLine ReqStringPL[] = {
d504 1
a504 1
far CSTATIC struct PanelLine ReqNumPL[] = {
d511 1
a511 1
far CSTATIC struct PanelLine ReqTimePL[] = {
d518 1
a518 1
far CSTATIC struct PanelLine ReqTellPL[] = {
d527 1
a527 1
far CSTATIC struct PanelLine SetupPL[] = {
d541 1
a541 1
far CSTATIC struct PanelLine TweakPL[] = {
d555 1
a555 1
far CSTATIC struct PanelLine TBCPL[] = {
d572 1
a572 1
far CSTATIC struct PanelLine XPTBCPL[] = {
d591 1
a591 1
far CSTATIC struct PanelLine ErrorPL[] = {
d602 1
a602 1
far struct PanelLine RawRecPL[] = {
d622 1
a622 1
far struct PanelLine MarkClipPL[] = {
d643 1
a643 1
far CSTATIC struct PanelLine FileInfoPL[] = {
d657 1
a657 1
far CSTATIC struct PanelLine RexxPL[] = {
d667 1
a667 1
far CSTATIC struct PanelLine FramePL[] = {
d675 1
a675 1
far CSTATIC struct PanelLine LumaKeyPL[] = {
d686 1
a686 1
far CSTATIC struct PanelLine TrailsPL[] = {
d696 1
a696 1
far CSTATIC struct PanelLine CFXPL[] = {
d713 1
a713 1
far CSTATIC struct PanelLine VideoPL[] = {
d723 1
a723 1
far CSTATIC struct PanelLine XPVideoPL[] = {
d732 1
a732 1
far CSTATIC struct PanelLine EffectPL[] = {
d743 1
a743 1
far CSTATIC struct PanelLine XPEffectPL[] = {
d756 1
a756 1
far CSTATIC struct PanelLine AnimFXPL[] = {
d767 1
a767 1
far CSTATIC struct PanelLine XPAnimFXPL[] = {
d782 1
a782 1
far CSTATIC struct PanelLine ClipPL[] = {
d797 1
a797 1
far CSTATIC struct PanelLine XPClipPL[] = {
d820 1
a820 1
far CSTATIC struct PanelLine AudClipPL[] = {
d831 1
a831 1
far CSTATIC struct PanelLine XPAudClipPL[] = {
d853 1
a853 1
far CSTATIC struct PanelLine KeyPL[] = {
d864 1
a864 1
far CSTATIC struct PanelLine XPKeyPL[] = {
d879 1
a879 1
far CSTATIC struct PanelLine CrawlPL[] = {
d890 1
a890 1
far CSTATIC struct PanelLine ScrollPL[] = {
d905 1
a905 1
far CSTATIC struct PanelLine TestPL[] = {
d923 1
a923 1
far CSTATIC struct PanelLine TestPL3[] = {
d939 1
a939 1
far CSTATIC struct PanelLine TestPL2[] = {
d954 1
a954 1
far CSTATIC struct PanelLine XPTestPL[] = {
d969 1
a969 1
far PanHandler	PanHandlers[] = {
d1005 1
a1005 1
far struct TagHelp TagNames[] = {
@


2.138
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.137 1995/02/14 10:46:12 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d339 2
d379 1
a379 1
far static char Size[20],Name[MAX_STRING_BUFFER]="Clip.0",Dir[MAX_STRING_BUFFER];
d384 1
a384 1
far static struct Hack
d493 1
a493 1
far static struct PanelLine ReqStringPL[] = {
d500 1
a500 1
far static struct PanelLine ReqNumPL[] = {
d507 1
a507 1
far static struct PanelLine ReqTimePL[] = {
d514 1
a514 1
far static struct PanelLine ReqTellPL[] = {
d523 1
a523 1
far static struct PanelLine SetupPL[] = {
d537 1
a537 1
far static struct PanelLine TweakPL[] = {
d551 1
a551 1
far static struct PanelLine TBCPL[] = {
d568 1
a568 1
far static struct PanelLine XPTBCPL[] = {
d587 1
a587 1
far static struct PanelLine ErrorPL[] = {
d639 1
a639 1
far static struct PanelLine FileInfoPL[] = {
d653 1
a653 1
far static struct PanelLine RexxPL[] = {
d663 1
a663 1
far static struct PanelLine FramePL[] = {
d671 1
a671 1
far static struct PanelLine LumaKeyPL[] = {
d682 1
a682 1
far static struct PanelLine TrailsPL[] = {
d692 1
a692 1
far static struct PanelLine CFXPL[] = {
d709 1
a709 1
far static struct PanelLine VideoPL[] = {
d719 1
a719 1
far static struct PanelLine XPVideoPL[] = {
d728 1
a728 1
far static struct PanelLine EffectPL[] = {
d739 1
a739 1
far static struct PanelLine XPEffectPL[] = {
d752 1
a752 1
far static struct PanelLine AnimFXPL[] = {
d763 1
a763 1
far static struct PanelLine XPAnimFXPL[] = {
d778 1
a778 1
far static struct PanelLine ClipPL[] = {
d793 1
a793 1
far static struct PanelLine XPClipPL[] = {
d816 1
a816 1
far static struct PanelLine AudClipPL[] = {
d827 1
a827 1
far static struct PanelLine XPAudClipPL[] = {
d849 1
a849 1
far static struct PanelLine KeyPL[] = {
d860 1
a860 1
far static struct PanelLine XPKeyPL[] = {
d875 1
a875 1
far static struct PanelLine CrawlPL[] = {
d886 1
a886 1
far static struct PanelLine ScrollPL[] = {
d901 1
a901 1
far static struct PanelLine TestPL[] = {
d919 1
a919 1
far static struct PanelLine TestPL3[] = {
d935 1
a935 1
far static struct PanelLine TestPL2[] = {
d950 1
a950 1
far static struct PanelLine XPTestPL[] = {
d1574 1
a1574 1
	if(!aud) return(0);       
@


2.137
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.136 1995/02/14 10:27:50 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d371 1
a371 1

d374 1
a374 1
far static char Size[20],Name[CLIP_PATH_MAX]="Clip.0",Dir[120];
d398 1
a398 1
#define SCROLL_NUM	3
d421 1
a421 1
	*Scrolls[] = {"Scroll Once","Scroll Repeat","Scroll Hold"},
d426 3
a428 1
	*CutTracks[] = {"Video","Audio",""},
d440 3
d526 1
a526 1
	TOGGLE_LINE(PNL_CENTER,"Flyer Output ",0 ),
a581 1

d653 2
a654 1
	EZLEN_LINE(PNL_CENTER,"Start Time",0),
d671 2
a672 2
	EZLEN_LINE(PNL_CENTER,"Start Time",1),
	EZLEN_LINE(PNL_CENTER,"Duration",0),
d688 3
a690 1
	TEXT_LINE(PNL_LEFT,"Trails Control",0),
d693 6
a698 3
	EZNUM_LINE(PNL_RIGHT,"Effect Position",0),
	EZLEN_LINE(PNL_LEFT,"Start Time",1),
	EZLEN_LINE(PNL_RIGHT,"Duration",0),
d849 2
a850 1
	EZLEN_LINE(PNL_CENTER,"Delay",0),
a857 1
	EZTIME_LINE(PNL_CENTER,"Delay",1),
d859 2
d873 4
a876 4
	CHOICE4_LINE(PNL_LEFT,"Speed",0),
	EZLEN_LINE(PNL_LEFT,"Delay",0),
	POPUP_LINE(PNL_RIGHT,"Scroll",0 ),
	EZLEN_LINE(PNL_LEFT,"Hold Duration",0),
d884 2
a885 2
	CHOICE5_LINE(PNL_LEFT,"Speed",0),
	EZLEN_LINE(PNL_LEFT,"Delay",0),
d887 4
a890 1
	EZLEN_LINE(PNL_LEFT,"Hold Duration",0),
d973 4
d1123 3
a1125 3
	{	"pad3",0},
	{	"pad4",0},
	{	"pad5",0},
d1438 10
d1605 2
d1692 2
d1745 2
d1759 2
d1770 1
d1779 1
d1791 1
a1794 10
/*
		ESparams1.Data1 =(LONG) Obj;
		SendSwitcherReply(ES_PanelClose,&ESparams1);
		SendSwitcherReply(ES_SelectDefault,&ESparams1);
		if(SendSwitcherReply(ES_Select,&ESparams1))
		{
			SendSwitcherReply(ES_Auto,&ESparams1);
		}
 */

d1800 3
a1802 2
		ESparams1.Data1 =(LONG) SKellFG;
		SendSwitcherReply(ES_PanelOpen,&ESparams1);
d1945 2
a1946 2
		DUMPSDECL("Table TAG Size= ",c,"\\");
		DUMPSDECL("Table Input Size= ",Size,"\\");
d1949 1
a1949 1
			DUMPMSG(Table);
d1953 1
a1953 1
			DUMPMSG(Table);
d2029 2
d2057 2
d2214 2
d2696 1
a2696 1
	LONG	I=0,M=0,T=0xF,trig=0,type=PanType;
d2703 1
d2726 1
d2735 8
a2742 2
		Config.Termination = (UBYTE) (SetupPL[4].Param);
		Config.Flags1 = (UBYTE) ( M!=0 ? (1<<spB_PrvwOLay):0);
a2749 4
		DUMPUDECB("SystemPrefs = { \\	",Config.Termination,"\\");
		DUMPUDECB("	",Config.GPI,"\\");
		DUMPUDECB("	",Config.Flags1," } \\");

d2751 1
a2751 1
		SendSwitcherReply(ES_SavePrefs,&ESparams1);
d2754 1
d2761 1
a2761 1
	ULONG ow=0,DLay,B;
d2767 1
d2770 5
d2778 1
d2789 4
d2801 2
d3099 90
a3188 1
	return(DoFXALGOPanel(Edit,FG));
d3219 9
a3227 1
			smpte = SMPTEToLong(&si);
d3279 1
a3279 1
//	AudClipPL[0].UserFun=CTRL_Play;
d3281 1
d3307 1
a3307 1
//	XPAudClipPL[0].UserFun=CTRL_Play;
d3309 1
d3391 1
a3391 1
			PutValue(FG,TAG(AudioStart),t_In<<1);
d3419 2
d3454 9
a3462 1
			smpte = SMPTEToLong(&si);
d3522 1
a3522 1
	ClipPL[1].UserFun=CTRL_Play;
d3527 1
d3568 1
d3645 1
a3645 1
					SetAudioInPoint(FG,A_In<<1,A_Out<<1);
d3647 1
a3647 1
				else if(t_Out != SP[1])
d3650 1
a3650 1
					SetAudioOutPoint(FG,A_In<<1,A_Out<<1);
d3691 2
d3801 1
a3801 1
		FadeOut=15,pmode=0;
d3810 1
d3838 4
d3857 3
a3859 4
	XPKeyPL[5].Param = &FadeIn;
	XPKeyPL[5].PropStart = 1;
	XPKeyPL[5].PropEnd = A;
	XPKeyPL[5].Flags = PL_IN;
d3861 1
a3861 1
	XPKeyPL[6].Param = &FadeOut;
d3864 6
a3869 1
	XPKeyPL[6].Flags = PL_OUT;
d3878 1
d3883 1
d3915 2
d3923 25
d3951 1
a3951 1
	LONG type=PanType,A=1,Speed=A,B=84,DLay=B,C=120,Time=120;
d3958 1
d3960 1
a3960 1
		Time=(C=GetValue(FG,TAG(Duration)));
a3961 1

d3963 4
d3975 2
d3978 12
a3989 13
		CrawlPL[3].Param = &B;
		CrawlPL[3].PropStart = 1;
		CrawlPL[3].PropEnd = 3600;
		CrawlPL[3].Flags = PL_DEL;

		CrawlPL[4].Param = (long *)Crawls;		// POPUP
		CrawlPL[4].PropStart = DEF_SCROLL;
		CrawlPL[4].PropEnd = CRAWL_NUM;

		CrawlPL[5].Param = &C;
		CrawlPL[5].PropStart = 1;
		CrawlPL[5].PropEnd = 3600;
		CrawlPL[5].Flags = PL_LEN;
d3995 5
a3999 1
		if(Speed!=A) PutValue(FG,TAG(Speed),A);
a4000 1
		if(Time!=C) PutValue(FG,TAG(Duration),C);
d4003 2
d4013 2
a4014 2
	LONG type=PanType,A=1,Speed=A,B=84,DLay=B,C=120,Time=120;
	char Label[MAX_PANEL_STR]="Arnie beats off";
d4020 1
d4022 3
a4024 1
		Time=(C=GetValue(FG,TAG(Duration)));
d4026 6
a4032 1
	}
d4041 2
d4044 3
a4046 4
		ScrollPL[3].Param = &B;
		ScrollPL[3].PropStart = 1;
		ScrollPL[3].PropEnd = 3600;
		ScrollPL[3].Flags = PL_DEL;
d4052 1
a4052 1
		ScrollPL[5].Param = &C;
d4054 2
a4055 2
		ScrollPL[5].PropEnd = 3600;
		ScrollPL[5].Flags = PL_LEN;
d4057 13
d4074 5
a4078 1
		if(Speed!=A) PutValue(FG,TAG(Speed),A);
d4080 4
a4083 1
		if(Time!=C) PutValue(FG,TAG(Duration),C);
d4093 2
a4094 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,F=0,T=0,LG=2,RG=2,NG=2,STOP=0, Spot=0,types[16];
d4097 2
a4113 11
/*
			RawRecPL[2].Param = (long *)CurFlyTracks;
			RawRecPL[2].Param2 = (long *)Tracks;		// Toggle
			RawRecPL[2].PropEnd = 1;
			RawRecPL[2].Flags = PL_AUDIO;

			RawRecPL[2].Param = (long *)Name;		// STRING
			RawRecPL[2].PropEnd= CLIP_NAME_MAX;
			RawRecPL[2].Flags= PL_IN; // kludge hack 'til markclip works
*/

a4123 1

d4223 10
d4238 2
d4252 1
a4252 1
			MarkClipPL[3].G5 = (struct Gadget *)300; // string gad width
a4254 1
			if(B>T) B=T;
d4257 2
a4258 2
			MarkClipPL[5].PropStart = 0;
			MarkClipPL[5].PropEnd = T;
d4265 2
a4266 2
			MarkClipPL[8].PropStart = 0;
			MarkClipPL[8].PropEnd = T;
d4301 1
a4301 1
	LONG type=PAN_EASY,B=6660,Z=0,F=0,T=0,STOP=0, Spot=0;
d4303 1
d4310 9
d4320 2
d4342 1
a4344 1
			if(B>T) B=T;
d4347 2
a4348 2
			MarkClipPL[5].PropStart = 0;
			MarkClipPL[5].PropEnd = T;
d4353 1
a4353 1
			F=T/2;
d4355 2
a4356 2
			MarkClipPL[8].PropStart = 0;
			MarkClipPL[8].PropEnd = T;
a4357 1
// Partnership between these last two is essential???
d4463 1
a4463 1
				strncpy(Name,fib->fib_FileName,MAX_STRING_BUFFER);
d4465 1
a4465 1
				FileInfoPL[2].PropEnd=75;
@


2.136
log
@Add Rec Gain controls to RawRec, strip audio/video to Mark Clip
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.135 1995/02/13 14:38:09 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d4023 1
a4023 1
			MarkClipPL[9].Flags = PL_AUDIO;
d4101 1
a4101 1
			MarkClipPL[9].Flags = PL_AUDIO;
@


2.135
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: COntrols.c,v 2.134 1995/02/11 17:52:59 CACHELIN4000 Exp CACHELIN4000 $
* $Log: COntrols.c,v $
d327 1
a327 1
#define SERDEBUG	1
a413 2
	*Names[]= {"Paul","Mark","Daniel","Junior","Kiki","","Robert","Wil",""},
	*Pops[]  = {"Not Thirsty","Coke","OJ","Margarita","Beer","Wine","Zima","Coors",""},
d420 1
a420 1
//	*Tracks[] = {"Video","Audio","Time Code",""},
d515 1
a515 1
	TOGGLE_LINE(PNL_LEFT,"Flyer Output ",0 ),
a586 1
//	STRING_LINE(PNL_CENTER,"Clip Name",1),
a587 2
//	DIVIDE_LINE(PNL_LEFT,"",0),
//	TEXT_LINE(PNL_LEFT,"",0),
d595 2
a596 1
//	DIVIDE_LINE(PNL_LEFT,"",0),
d616 1
a616 1
//	VCR_LINE(PNL_CENTER,"",0),
d1436 16
d1457 1
d1459 4
a1462 2

	aud->LeftGain = aud->RightGain = Y&0x0F;
d2655 1
d2658 1
d3842 1
a3842 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,F=0,T=0,STOP=0, Spot=0,types[16];
d3852 3
d3920 16
a3935 2
			RawRecPL[11].PropStart = 36+8+PNL_DIV;  // Spacer
			RawRecPL[12].PropStart = 0;  // Spacer
d3944 2
a3945 1
//				types[11]= RawRecPL[11].Type;
d3951 2
a3952 1
//				RawRecPL[11].Type = PNL_SKIP;
d4009 1
a4009 1
                     
d4017 4
a4020 3
//			MarkClipPL[9].Param = NULL;  // VCR Panel no time gadg
			MarkClipPL[9].Param = &Spot;
			MarkClipPL[9].Param2 = &Spot;
d4037 2
a4038 1
//		RawRecPL[11].Type =types[11];
d4095 4
a4098 3
//			MarkClipPL[9].Param = NULL;  // VCR Panel no time gadg
			MarkClipPL[9].Param = &Spot;
			MarkClipPL[9].Param2 = &Spot;
@


2.134
log
@Add SMPTE, audio record level support
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.133 1995/02/10 15:27:46 Kell Exp CACHELIN4000 $
* $Log: Controls.c,v $
d324 1
a324 1
//#define SERDEBUG	1
d393 1
a393 1
#define FLY_SRC_NUM	5
d421 5
a425 1
	*Sources[] = {"Flyer In","Flyer Y/C","Input 1","Input 2","Main Out","Audio Only",""},
d431 1
d514 1
d1294 2
a1295 9
//	if( !IS_AUDIO_SOURCE(CurFlySource) )
//		ESparams1.Data1 = CurFlySource + 1 + SOURCE_INDEX_OFFSET;
//	else   // Selected Audio Only ==> set toggle
//	{
//		ESparams1.Data1 = 0;
//		CompMode=AUDIO_COMP_MODE;
//	}

	ESparams1.Data1 = CurFlySource + 1 + SOURCE_INDEX_OFFSET;
a1305 2
//			if( FlyerDrives[CurFlyDrive][0]==AUDIO_BYTE )
//				CompMode=AUDIO_COMP_MODE;
d2048 2
a2049 1
	ESparams1.Data1 = Src + 1 + SOURCE_INDEX_OFFSET;
d2635 1
a2635 1
	LONG	M=0,T=0xF,trig=0,type=PanType;
d2640 1
d2659 5
d2672 7
a2678 1

@


2.133
log
@ES_RecordSource now doesn't have record audio volume parameters.
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.132 1995/02/01 17:54:31 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d358 1
d453 1
d777 1
a777 1
	SLIDER_LINE(  PNL_CENTER, "Volume",1),
d806 1
a806 1
	SLIDER_LINE(  PNL_LEFT, "Volume",1),
d1097 2
d1424 28
d1471 1
d1516 1
a1516 1
	if(!aud) return(0);
d1520 1
a1520 1
			aud->V1 = (MAXPOT*aud->Volume/100)&0x0000FFFF;
d1524 1
a1524 1
			aud->V2 = (MAXPOT*aud->Volume/100)&0x0000FFFF;
d1536 2
a1537 2
				aud->V1= ((L*(aud->Volume))/100)&0x0000FFFF;
				aud->V2= ((R*(aud->Volume))/100)&0x0000FFFF;
d1543 2
a1544 2
				aud->V1= ((L*(aud->Volume))/100)&0x0000FFFF;
				aud->V2= ((R*(aud->Volume))/100)&0x0000FFFF;
d1547 1
a1547 1
				aud->V2 = aud->V1 = (MAXPOT*aud->Volume/100)&0x0000FFFF;
d2043 1
a2043 1
void DHD_SetupRecord(LONG Src, UWORD Vol1, UWORD Vol2, LONG Comp)
d2046 1
a2046 6

// **!!!! WE NEED TO INITIALIZE THE RECORD VOLUME VIA, ES_AudioControl
//	DUMPHEXIL(" ",Vol1,",");
//	DUMPHEXIL(" ",Vol2,", 0); \\ ");
//	ESparams3.Data1 =(LONG) Vol1;
//	ESparams3.Data2 =(LONG) Vol2;
a2047 3
//	if( IS_AUDIO_SOURCE(Src) ) ESparams1.Data1=0;
//	else ESparams1.Data1 = Src + 1 + SOURCE_INDEX_OFFSET;

d2053 4
d2221 1
d2228 1
d2235 1
d2246 1
d2255 1
d2268 1
d2281 1
a2281 1
	DHD_SetupRecord(CurFlySource,0xFFFF,0xFFFF,CompMode);
d3014 1
a3014 1
	t_In=36,t_Out=69,type=PanType,Time,S=0,SP[12]={36,69,0,0},AudioOn=1,pmode=0;
d3016 1
d3035 2
d3041 2
a3042 2
		SP[0] = t_In  = (SP[3]>>2)<<1;			 // In Frame
		SP[1] = t_Out = ((SP[3]+SP[4]-4)>>2)<<1;  // Out Frame
d3047 1
d3100 2
a3101 2
	AudClipPL[3].PropStart = 0;
	AudClipPL[3].PropEnd = A-LENGTH_ADJUST;  // Min length= 1 colorframe
d3127 2
a3128 2
	XPAudClipPL[3].PropStart = 0;
	XPAudClipPL[3].PropEnd = A-LENGTH_ADJUST;
d3234 1
a3234 1
		type=PanType,SP[16]={36,69,0,36},AudioOn=1,pmode=0,Relate=0;
d3237 1
d3258 2
d3262 2
a3263 2
		SP[0] = t_In  = (SP[3]>>2)<<1;			 // In Frame
		SP[1] = t_Out = ( (SP[3]+SP[4]-4)>>2 )<<1;  // Out Frame
d3266 2
a3267 2
		SP[7]= A_In  = (SP[5] >> 2)<<1;
		SP[8]= A_Out = ((SP[5]+SP[6]-4)>>2)<<1;
d3271 1
d3334 2
a3335 2
	ClipPL[5].PropStart = 0;
	ClipPL[5].PropEnd = A-LENGTH_ADJUST;
d3374 2
a3375 2
	XPClipPL[5].PropStart = 0;
	XPClipPL[5].PropEnd = A-LENGTH_ADJUST;
d3387 2
a3388 2
		XPClipPL[8].PropStart = 0;
		XPClipPL[8].PropEnd = A-LENGTH_ADJUST;
d3390 1
d3946 1
@


2.132
log
@Add Process button, fix cutting room jump from record panel
@
text
@d2 5
a6 2
* $Id: COntrols.c,v 2.131 1995/01/25 18:34:57 CACHELIN4000 Exp CACHELIN4000 $
* $Log: COntrols.c,v $
d1279 1
a1279 1
//		ESparams3.Data1 = CurFlySource + 1 + SOURCE_INDEX_OFFSET;
d1282 1
a1282 1
//		ESparams3.Data1 = 0;
d1286 1
a1286 1
	ESparams3.Data1 = CurFlySource + 1 + SOURCE_INDEX_OFFSET;
d1289 1
a1289 1
		ESparams3.Data1 = 0;
d1291 2
a1292 4
	ESparams3.Data2 = ESparams3.Data3 =(LONG) 0xFFFF;
	DUMPUDECL("SetSource( ",ESparams3.Data1,",");
	DUMPUDECL(" ",ESparams3.Data2," ) \\");
	SendSwitcherReply(ES_RecordSource,&ESparams3);
d2010 9
a2018 2
	DUMPHEXIL(" ",Vol1,",");
	DUMPHEXIL(" ",Vol2,", 0); \\ ");
d2020 2
a2021 2
//	if( IS_AUDIO_SOURCE(Src) ) ESparams3.Data1=0;
//	else ESparams3.Data1 = Src + 1 + SOURCE_INDEX_OFFSET;
a2022 4
	ESparams3.Data1 = Src + 1 + SOURCE_INDEX_OFFSET;
	ESparams3.Data2 =(LONG) Vol1;
	ESparams3.Data3 =(LONG) Vol2;
	SendSwitcherReply(ES_RecordSource,&ESparams3);
@


2.131
log
@Change TBC controls to scaled STEPSLIDE lines
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.130 1995/01/24 18:05:37 CACHELIN4000 Exp CACHELIN4000 $
* $Log: Controls.c,v $
d356 1
a356 1
ULONG CurFlyDrive=0,CurFlySource=0,CurFlyTracks=1,CurCompMode=0;
d384 1
a384 5
#define TBCTERM_NUM	5
#define TBCSRC_NUM	4
#define TBCENCOD_NUM	4
#define TBCDECOD_NUM	3
#define TBCKEY_NUM	3
a417 1
	TBC_Input[] = {TBCIN_COMP,TBCIN_YC,TBCIN_TMAIN,TBCIN_FADER},
d421 3
a423 1
	*TBCKeyer[] = {"Key Enable","Channel B","4 Level",""},
d427 1
d537 2
a538 1
	POPUP_LINE(  PNL_CENTER, "Input",0),
d599 4
a602 1
	VCR_LINE(PNL_CENTER,"",0),
d773 2
a774 1
	POPUP_LINE(PNL_CENTER,"Channels",0 ),
d802 1
a1116 5
#define	PROPSCALE(v,l,h)	(( l + (v*(h-l))/MAXPOT ))

enum { TBC_BRT,TBC_CON,TBC_SAT,TBC_HUE,TBC_FAD,TBC_CPHZ,TBC_HPHZ,
			TBC_KEY,TBC_ENC,TBC_INP,TBC_DEC,TBC_TRM};

d1158 5
d1164 1
a1164 1
			TBC_dat.KeyerFlags=0;
d1166 3
a1168 3
				TBC_dat.KeyerFlags |=TBCKF_ENABLE;
			if(flags&1<<2)
				TBC_dat.KeyerFlags |=TBCKF_2BITS;
d1171 2
a1313 1
	ULONG CompMode=CurCompMode;
d1321 4
a1325 4

//	else if( IS_AUDIO_SOURCE(CurFlySource) )
//		CompMode=AUDIO_COMP_MODE;

d1336 2
a1337 2
		pl->G4 = (struct Gadget *) BlocksToFrames(vi->Largest,CompMode);
		pl->G5 = (struct Gadget *) BlocksToFrames(vi->Optimized,CompMode);
d2327 1
a2327 1
	LONG bri,con,sat,hue,cphas,hphas,fade,
a2347 1
	if(TBC_dat.KeyerFlags&TBCKF_2BITS)	key|=1<<2;
d2349 8
a2356 1
	if(TBC_dat.KeyerFlags&TBCKF_ENABLE)	key|=1;
d2439 4
a2442 5
	XPTBCPL[3].Param	= &fade;
	XPTBCPL[3].Param2	= &dfade;
	XPTBCPL[3].PropStart	=0;
	XPTBCPL[3].PropEnd		=255;
	XPTBCPL[3].UserObj				= (APTR) TBC_FAD;
d2445 34
a2478 27
	XPTBCPL[5].Param	=(ULONG *)term;
	XPTBCPL[5].Param2	= (long *)TBCTerm;
	XPTBCPL[5].PropStart	=0;
	XPTBCPL[5].PropEnd		=TBCTERM_NUM;
	XPTBCPL[5].UserObj				= (APTR) TBC_TRM;
	XPTBCPL[5].UserFun				= CTRL_TBCSet;

	XPTBCPL[7].Param	=(ULONG *)key;
	XPTBCPL[7].Param2	= (long *)TBCKeyer;
	XPTBCPL[7].PropStart	= 0;
	XPTBCPL[7].PropEnd		= TBCKEY_NUM;
	XPTBCPL[7].UserObj				= (APTR) TBC_KEY;
	XPTBCPL[7].UserFun				= CTRL_TBCSet;

	XPTBCPL[9].Param	=(ULONG *)enc;
	XPTBCPL[9].Param2	= (long *)TBCEncoder;
	XPTBCPL[9].PropStart	=0;
	XPTBCPL[9].PropEnd		=TBCENCOD_NUM;
	XPTBCPL[9].UserObj				= (APTR) TBC_ENC;
	XPTBCPL[9].UserFun				= CTRL_TBCSet;

	XPTBCPL[11].Param	=(ULONG *)dec;
	XPTBCPL[11].Param2	= (long *)TBCDecoder;
	XPTBCPL[11].PropStart	=0;
	XPTBCPL[11].PropEnd		=TBCDECOD_NUM;
	XPTBCPL[11].UserObj				= (APTR) TBC_DEC;
	XPTBCPL[11].UserFun				= CTRL_TBCSet;
d3122 2
d3132 1
a3132 1
				type = Panel(Edit,XPAudClipPL,TUNE_QUICK);
d3136 1
a3136 1
				type = Panel(Edit,AudClipPL,TUNE_FINE);
d3138 5
a3374 1

d3376 1
d3384 1
a3384 1
				type = Panel(Edit,ClipPL,TUNE_FINE);
d3400 1
a3400 1
				type = Panel(Edit,XPClipPL,TUNE_QUICK);
d3402 4
d3758 1
a3758 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,F=0,T=1000,STOP=0, Spot=0;
d3792 3
d3805 1
a3806 1
			RawRecPL[3].Flags = PL_FLYER;
a3824 1
			RawRecPL[9].G5 = (struct Gadget *)2; // Diff
a3827 1
			RawRecPL[10].UserObj =(APTR)&RawRecPL[2]; // what's this for???
d3836 15
d3857 1
d3869 2
d3876 1
d3879 3
d3905 76
d3986 2
a3987 2
			MarkClipPL[8].Flags = PL_FLYER | PL_CFRAME | PL_AUDIO;
// Partnership between these last two is essential
d4055 1
a4055 1
		type = Panel(Edit, XPTestPL,TUNE_NONE);
d4094 1
a4094 1
				FileInfoPL[2].PropEnd=MAX_STRING_BUFFER;
@


2.130
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.129 1995/01/24 16:50:04 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d380 1
d445 1
d519 7
a525 7
	EZSLIDER_LINE(  PNL_CENTER, "Horizontal",1), // Centered slider 0-0x7ff
	EZSLIDER_LINE(  PNL_CENTER, "Phase",0), // Centered slider 0-0x7ff
	EZSLIDER_LINE(  PNL_LEFT, "Hue",1),  // Centered slider -64 - 63
	EZSLIDER_LINE(  PNL_LEFT, "Brightness",0), // 0 - 127
	SLIDER_LINE(  PNL_LEFT, "Saturation",1),  // 0 - 127
	SLIDER_LINE(  PNL_LEFT, "Contrast",0),  // 0 - 127
//	SLIDER_LINE(  PNL_LEFT, "Fader",1),  // 0 - 255
d537 1
a537 1
	SLIDER_LINE(  PNL_CENTER, "Fader",0),  // 0 - 255
a1118 1
	UWORD lev=0;
d1120 2
a1121 3
	if(pl->PropGadg)
		lev=((struct PropInfo *)pl->PropGadg->SpecialInfo)->HorizPot;
	else
a1124 3
		case TBC_FAD:
			TBC_dat.Fader = (BYTE) PROPSCALE(lev,0,255);
			break;
d1126 2
a1127 1
			TBC_dat.Phase = (UWORD) PROPSCALE(lev,0,0x7FF);
d1130 2
a1131 1
			TBC_dat.HorAdj = (UWORD) PROPSCALE(lev,0,0xFFF);
d1134 2
a1135 1
			TBC_dat.Bright = (BYTE) PROPSCALE(lev,-64,63);
d1137 4
d1142 2
a1143 1
			TBC_dat.Contrast = (UBYTE) PROPSCALE(lev,0,127);
d1146 2
a1147 1
			TBC_dat.Sat = (UBYTE) PROPSCALE(lev,0,127);
d1149 3
a1151 2
		case TBC_HUE:
			TBC_dat.Hue = (BYTE) PROPSCALE(lev,-64,63);
d1157 1
d1166 1
d1171 1
d1178 1
d2319 2
a2320 3
	LONG bri=(TBC_dat.Bright+64)*MAXPOT,con=TBC_dat.Contrast*MAXPOT,sat=TBC_dat.Sat*MAXPOT,
		hue=(TBC_dat.Hue+64)*MAXPOT,cphas=TBC_dat.Phase*MAXPOT,hphas=TBC_dat.HorAdj*MAXPOT,
		fade=TBC_dat.Fader*MAXPOT,
d2323 4
d2331 7
a2337 1
	fade /= 255;
d2339 1
d2343 1
a2343 1

d2349 1
a2349 1

d2353 1
a2353 1

a2360 1
	hphas /= 0xFFF;
d2362 3
a2364 1
	TBCPL[2].PropStart	=hphas;
a2367 1
	cphas /= 0x7FF;
d2369 3
a2371 1
	TBCPL[3].PropStart	=cphas;
a2374 1
	hue /= 127;
d2376 3
a2378 1
	TBCPL[4].PropStart	=hue;
a2381 1
	bri /= 127;
d2383 3
a2385 1
	TBCPL[5].PropStart	=bri;
d2389 1
a2389 1
	sat /= 127;
d2391 1
d2393 1
a2393 1
	TBCPL[6].PropEnd		=MAXPOT;
d2397 1
a2397 1
	con /= 127;
d2399 1
d2401 1
a2401 1
	TBCPL[7].PropEnd		=MAXPOT;
d2406 1
d2408 1
a2408 1
	TBCPL[8].PropEnd		=MAXPOT;
a2418 1

d2426 1
d2428 1
a2428 1
	XPTBCPL[3].PropEnd		=MAXPOT;
d2481 3
d2488 5
d2951 1
a2951 1
	LONG FadeIn=0,FadeOut=0,V=0,P=0,V1=0xFFFF,V2=0x4000,A=800,
d3077 1
a3077 1
	XPAudClipPL[7].Param2 = (LONG *)&(XPAudClipPL[9]); // Balance PL
d3084 1
a3084 1
	XPAudClipPL[8].Param =&CurAudioSet.Volume;  // !!! Unnecessary in CTRL_SetBalance???
d3086 3
a3088 1
	XPAudClipPL[8].PropStart = CurAudioSet.Balance;  // Should move initial value to Param
d3160 1
a3160 1
	LONG Vol=0,P,V1=0xFFFF,V2=0x8000,A=800,t_In=36,t_Out=69,A_In,A_Out,AFade_In=0,AFade_Out=0,
d3320 1
a3320 1
		XPClipPL[10].Param2 = (LONG *)&(XPClipPL[12]); // Balance PL
d3327 1
a3327 1
		XPClipPL[11].Param = &CurAudioSet.Volume; // Overall volume control for "Balance"
d3329 3
a3331 1
		XPClipPL[11].PropStart = CurAudioSet.Balance;
d3798 1
a3798 1
			RawRecPL[10].PropEnd = 3; // 4; //6; (Audio Only moved...)
@


2.129
log
@Re-enable TBC inputs
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.128 1995/01/24 11:19:50 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d309 1
a309 1
#define SERDEBUG	1
d3798 1
a3798 1
			MarkClipPL[5].Flags = PL_AVAIL;
a3814 1

@


2.128
log
@TBC panels, some cutting room additions
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.127 1995/01/13 14:23:30 CACHELIN4000 Exp CACHELIN4000 $
d4 3
a329 25
#define	AUDIO_BYTE	0xA2
#define MAX_AUD_FADE	750 // Max 1500 fields (Marty, Nov  3 1994)
#define	IS_AUDIO_DRIVE(FVI)		((FVI->Flags&FVIF_AUDIOREADY) && !(FVI->Flags&FVIF_VIDEOREADY))
#define STD_COMP_MODE			0
#define EXTD_COMP_MODE		1
#define AUDIO_COMP_MODE		3  //0xFFFF
#define	AMODE_STEREO			0
#define	AMODE_LEFT				1
#define	AMODE_RIGHT				2
#define	AMODE_NOAUDIO			3
#define	PAN_LEFT					-32768;
#define	PAN_RIGHT					32767;
#define HAS_LEFT(f)			((f&AUD_CH1_EXISTS) && !(f&AUD_CH2_EXISTS))
#define HAS_RIGHT(f)		(!(f&AUD_CH1_EXISTS) && (f&AUD_CH2_EXISTS))
#define HAS_STEREO(f)		((f&AUD_CH1_EXISTS) && (f&AUD_CH2_EXISTS))
#define HAS_ANYAUDIO(f)		(f&AUD_EXISTS)
#define IS_LEFT(f)			((f&AUD_CH1_ENABLE) && !(f&AUD_CH2_ENABLE))
#define IS_RIGHT(f)			(!(f&AUD_CH1_ENABLE) && (f&AUD_CH2_ENABLE))
#define IS_STEREO(f)		((f&AUD_CH1_ENABLE) && (f&AUD_CH2_ENABLE))
#define IS_ANYAUDIO(f)			(f&AUD_ENABLE)
#define SET_LEFT(f)			f = ( (f&(~AUD_CH2_ENABLE))|AUD_CH1_ENABLE )
#define SET_RIGHT(f)		f = ( (f&(~AUD_CH1_ENABLE))|AUD_CH2_ENABLE )
#define SET_STEREO(f)		f |= (AUD_CH1_ENABLE|AUD_CH2_ENABLE)
#define SET_NOAUDIO(f)	f &= ~AUD_ENABLE

a343 1
#define COMMENT_MAX 256
d405 2
a406 2
//	*Sources[] = {"Flyer In","Flyer Y/C","Input 1","Input 2","Main Out","Audio Only",""},
	*Sources[] = {"Input 1","Input 2","Main Out","Audio Only",""},
d579 1
a579 1
	TEXT_LINE(PNL_LEFT,"",0),
d583 1
d3772 10
a3781 6
			if( !(FG=(struct FastGadget *)SendSwitcherReply(ES_LoadCrouton,&ESparams2)) )
				break;
			else
			{
				T = (GetValue(FG,TAG(RecFields))>>1);  // Clip Frame Length
			}
d3784 12
a3795 8
			MarkClipPL[3].Param = (long *)Name;  // Name String
			MarkClipPL[3].PropEnd = CLIP_NAME_MAX;
			MarkClipPL[3].Flags = PL_DEL;

			MarkClipPL[4].Param = &B;  // Diff
			MarkClipPL[4].Param2 = &Z;
			MarkClipPL[4].G5 = (struct Gadget *)2; // Diff
			MarkClipPL[4].Flags = PL_LEN;
a3824 1
	DUMPSTR("*~~");
@


2.127
log
@Add Partner stuff to video control panel, DHD_Jog,Jump and Shuttle
Put in Play buttons/crouton button, fix CTRL_Play() to ahndel SWITCHER_MODE,
Add none to Audio channels again, add audio toggle to EZ video again,  etc.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.126 1995/01/12 12:03:52 CACHELIN4000 Exp CACHELIN4000 $
d4 5
a329 1
#define AUDIO_COMP_MODE		0xFFFF
d332 1
d369 1
a369 1
far static char Size[20],Name[120]="Clip.0",Dir[120];
d375 4
a378 4
		HackA={HACK_TWEAK,HKF_PLAY_A,-29,1,14,7,0,0,60},*Hack=&HackA,
		HackB={HACK_TWEAK,HKF_PLAY_B,-29,2,2,7,0,0,60},
		HackC={HACK_TWEAK,HKF_RECORD_A|HKF_TESTREC,20,3,0,3,0,0,0},
		HackD={HACK_TWEAK,HKF_RECORD_B|HKF_TESTREC,20,2,6,3,0,0,0},
d380 4
a383 4
		BakHackA={HACK_TWEAK,HKF_PLAY_A,-29,1,14,7,0,0,60},
		BakHackB={HACK_TWEAK,HKF_PLAY_B,-29,2,2,7,0,0,60},
		BakHackC={HACK_TWEAK,HKF_RECORD_A|HKF_TESTREC,20,3,0,3,0,0,0},
		BakHackD={HACK_TWEAK,HKF_RECORD_B|HKF_TESTREC,20,2,6,3,0,0,0},
d387 1
d389 1
a389 1
#define QUAL_NUM	2 		// number of entires in Qual array
d397 5
a401 5
#define SOURCE_INDEX_OFFSET	2 // This is the number of Flyer sources skipped
															// in the popup/sources Array cause of no TBC
#define AUDIO_ONLY_SOURCE		5-SOURCE_INDEX_OFFSET // Index of Audio Only popup element
                             // if CurFlySource == this, then flyer should get 0 as source
#define IS_AUDIO_SOURCE(x) ((x)==AUDIO_ONLY_SOURCE)
d408 1
a408 1
far UBYTE
d414 3
a416 1
								&FDrive[300],&FDrive[320],&FDrive[340],&FDrive[360],&FDrive[380],&FDrive[400]},
d425 1
a425 1
	*Quals[] = {"Standard Play","Extended Play"},
d434 6
d531 36
d581 3
a583 3
//	TEXT_LINE(PNL_CENTER,"",0),
	STRING_LINE(PNL_CENTER,"Clip Name",1),
	POPUP_LINE(PNL_RIGHT,"  Drive",0),
d585 1
a585 1
	TEXT_LINE(PNL_LEFT,"",0),
d587 1
d590 1
d593 1
a593 1
	DIVIDE_LINE(PNL_LEFT,"",0),
a603 1
	DUOSLIDE_LINE(PNL_LEFT," ",0),
d606 5
a610 2
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	TEXT_LINE(PNL_CENTER," ",0),
d865 1
a914 1

d925 1
d1122 90
a1211 1
// within the PanelLine's Handle() fiunction.
d1243 4
a1246 2
	ESparams1.Data1 =(LONG) Hack;  // Hack ptr
	SendSwitcherReply(ES_Hack,&ESparams1);
d1255 4
a1258 2
	ESparams1.Data1 =(LONG) hack;
	SendSwitcherReply(ES_Hack,&ESparams1);
d1268 1
a1268 1
	ULONG CompMode=CurCompMode;
d1270 11
a1280 3
	if( !IS_AUDIO_SOURCE(CurFlySource) )
		ESparams3.Data1 = CurFlySource + 1 + SOURCE_INDEX_OFFSET;
	else   // Selected Audio Only ==> set toggle
a1282 1
		CompMode=AUDIO_COMP_MODE;
d1292 3
a1294 3
			if( FlyerDrives[CurFlyDrive][0]==AUDIO_BYTE )
				CompMode=AUDIO_COMP_MODE;
			T=BlocksToFrames(FVI->Largest,CompMode);
d1296 1
a1296 1
			T=BlocksToFrames(FVI->Optimized,CompMode);
d1317 1
a1317 1
		CompMode=AUDIO_COMP_MODE;
d1319 3
a1321 2
	else if( IS_AUDIO_SOURCE(CurFlySource) )
		CompMode=AUDIO_COMP_MODE;
d1345 1
a1345 1
	ULONG CompMode;
d1349 1
a1349 1
	CompMode=CurCompMode;
d1356 9
a1364 4
				CompMode=AUDIO_COMP_MODE;
			else if( IS_AUDIO_SOURCE(CurFlySource) )
				CompMode=AUDIO_COMP_MODE;
			T=BlocksToFrames(FVI->Largest,CompMode);
d1366 1
a1366 1
			T=BlocksToFrames(FVI->Optimized,CompMode);
a1796 18
struct ClipInfo *DHD_ClipInfo(char *name)
{
	struct ClipInfo *ci=NULL;
	if(*name)
	{
		DUMPSTR("FlyerClipInfo( ");
		ESparams2.Data1=(LONG)name;
		DUMPSTR((char *)ESparams2.Data1);
		ESparams2.Data2=NULL;
		ci=(struct ClipInfo *)SendSwitcherReply(ES_FlyerClipInfo,&ESparams2);
		DUMPHEXIL(" ) = ",(LONG)ci,"\\");
		DUMPUDECL("ci->Fields =  ",(LONG)ci->Fields,"\\");
		DUMPBITSL("ci->Flags =  ",(LONG)ci->Flags,"\\");
		return(ci);
	}
	return(NULL);
}

d2008 5
a2012 2
	if( IS_AUDIO_SOURCE(Src) ) ESparams3.Data1=0;
	else ESparams3.Data1 = Src + 1 + SOURCE_INDEX_OFFSET;
d2079 19
d2320 157
d2486 3
a2488 2
		ESparams1.Data1 =(LONG) Hack;  // Hack ptr
		SendSwitcherReply(ES_Hack,&ESparams1);
d3064 1
a3064 1
	XPAudClipPL[8].Param =&CurAudioSet.Volume;
d3066 1
a3066 1
	XPAudClipPL[8].PropStart = CurAudioSet.Balance;
d3703 1
a3703 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,T=0,STOP=0, Spot=0;
d3705 1
a3705 2

	if(*Name==0) strncpy(Name,"Clip.0",CLIP_NAME_MAX);
a3722 1
*/
d3727 1
d3750 5
a3754 5
			RawRecPL[5].Param = (long *)Quals;		// POPUP
			RawRecPL[5].PropStart = CurCompMode;
			RawRecPL[5].PropEnd = QUAL_NUM;
			RawRecPL[5].UserFun = CTRL_SetCompression;
			RawRecPL[5].UserObj = (APTR)&RawRecPL[3]; // PLine with Max and opt sizes
d3764 12
a3775 12
			RawRecPL[8].Param = &T;     // Diff
			RawRecPL[8].Param2 = &Z;
			RawRecPL[8].Flags = PL_LEN;
			RawRecPL[8].G5 = (struct Gadget *)2; // Diff

			RawRecPL[9].Param = (long *)Sources;		// POPUP
			RawRecPL[9].UserFun = CTRL_SetSource;
			RawRecPL[9].UserObj =(APTR)&RawRecPL[2]; // what's this for???
			RawRecPL[9].UserObj = (APTR)&RawRecPL[3]; // PLine with Max and opt sizes
			RawRecPL[9].PropStart = CurFlySource;
			RawRecPL[9].PropEnd = 4; //6;
			RawRecPL[9].Flags = PL_AUDIO;
d3786 25
d3812 19
a3830 18
			MarkClipPL[3].Param = &Z;
			MarkClipPL[3].Param2 = &B;
			MarkClipPL[3].PropStart = 0;
			MarkClipPL[3].PropEnd = T;
			MarkClipPL[3].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;

			MarkClipPL[4].Param = (long *)Name;  // Name String
			MarkClipPL[4].PropEnd = CLIP_NAME_MAX;
			MarkClipPL[4].Flags = PL_DEL;

			MarkClipPL[5].Param = &B;  // Diff
			MarkClipPL[5].Param2 = &Z;
			MarkClipPL[5].G5 = (struct Gadget *)2; // Diff
			MarkClipPL[5].Flags = PL_LEN;

//			MarkClipPL[8].Param = NULL;  // VCR Panel no time gadg
			MarkClipPL[8].Param = &Spot;
			MarkClipPL[8].Param2 = &Spot;
d3870 1
d3905 2
d3924 2
a3925 2
	if(!SwitPort)
		DoTestPanel(Edit);
d3968 1
a3968 1
				if (((ft=getft(Path)) != -1) && (strftime(&TempCh,60,"%a, %b %d, %Y %I:%M %p",localtime(&ft))))
d4051 7
@


2.126
log
@Framestore duration EZLEN-> EZTIME
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.125 1995/01/06 22:16:54 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d318 4
d331 1
d337 1
d339 1
a339 1
#define IS_RIGHT(f)		(!(f&AUD_CH1_ENABLE) && (f&AUD_CH2_ENABLE))
d341 1
d345 1
d423 1
a423 1
	*Channels[] ={ "Stereo (L+R)", "Left Only" , "Right Only"},
d569 2
a570 2
	TEXT_LINE(PNL_LEFT,"File Size",0),
	TEXT_LINE(PNL_LEFT,"Date",0),
d694 2
d699 2
a700 2
//	PLAY_LINE(PNL_LEFT,"",1),
	TEXT_LINE(PNL_LEFT,"",1),
d706 1
a706 1
//	TOGGLE_LINE(PNL_CENTER,0,0),
d714 2
a715 2
//	PLAY_LINE(PNL_LEFT,"",1),
	TEXT_LINE(PNL_LEFT,"",1),
d1471 4
d1490 13
d1513 1
a1513 1
			if(SendSwitcherReply(ES_Select,&ESparams1))
d1530 10
d1956 1
a1956 1
void	DHD_Shuttle(struct RenderCallBack	*rcb)
a1957 2
	DUMPMSG("DHD_Shuttle()");
	ESparams1.Data1=(LONG)rcb;
d1978 1
d1980 3
a1982 3
	SendSwitcherReply(ES_Shuttle,&ESparams1);
	rcb->Frame += 1;
	rcb->Frame &= ~0x00000003;
d1996 27
d2029 2
a2031 22
	rcb->Flags |= DHD_MOUSE_UPDATE;
	if(rcb->pline->Flags&PL_AUDIO)
	{
		rcb->Flags &= ~DHD_VIDEOSLIDER;
		rcb->Flags |=	DHD_AUDIOSLIDER ;
	}
	else
	{
		rcb->Flags &=	~DHD_AUDIOSLIDER;
		rcb->Flags |=	DHD_VIDEOSLIDER ;
	}
	if(rcb->pline->Flags&PL_IN)
	{
		rcb->Flags &=~DHD_OUTPOINT;
		rcb->Flags |=DHD_INPOINT  ;
	}
	else
	{
		rcb->Flags &=~DHD_INPOINT;
		rcb->Flags |=DHD_OUTPOINT;
	}

a2032 1

d2038 1
a2038 14

	if(rcb->pline->Flags&PL_AUDIO)
	{
		if(rcb->pline->Flags&PL_IN)
			SetAudioInPoint(rcb->FG,rcb->Frame,rcb->Max);
		else if(rcb->pline->Flags&PL_OUT)
			SetAudioOutPoint(rcb->FG,rcb->Min,rcb->Frame);
	}
	else {
		if(rcb->pline->Flags&PL_IN)
			SetInPoint(rcb->FG,rcb->Frame,rcb->Max);
		else if(rcb->pline->Flags&PL_OUT)
			SetOutPoint(rcb->FG,rcb->Min,rcb->Frame);
	}
a2046 2
	ESparams2.Data1=(LONG)rcb->FG;
	ESparams2.Data2=(LONG)rcb->Frame;
d2050 1
a2051 20
	if(rcb->pline->Flags&PL_AUDIO)
	{
		rcb->Flags &= ~DHD_VIDEOSLIDER;
		rcb->Flags |=	DHD_AUDIOSLIDER ;
	}
	else
	{
		rcb->Flags &=	~DHD_AUDIOSLIDER;
		rcb->Flags |=	DHD_VIDEOSLIDER ;
	}
	if(rcb->pline->Flags&PL_IN)
	{
		rcb->Flags &=~DHD_OUTPOINT;
		rcb->Flags |=DHD_INPOINT  ;
	}
	else
	{
		rcb->Flags &=~DHD_INPOINT;
		rcb->Flags |=DHD_OUTPOINT;
	}
d2053 2
d2056 1
d2058 1
a2058 13
	if(rcb->pline->Flags&PL_AUDIO)
	{
		if(rcb->pline->Flags&PL_IN)
			SetAudioInPoint(rcb->FG,rcb->Frame,rcb->Max);
		else if(rcb->pline->Flags&PL_OUT)
			SetAudioOutPoint(rcb->FG,rcb->Min,rcb->Frame);
	}
	else {
		if(rcb->pline->Flags&PL_IN)
			SetInPoint(rcb->FG,rcb->Frame,rcb->Max);
		else if(rcb->pline->Flags&PL_OUT)
			SetOutPoint(rcb->FG,rcb->Min,rcb->Frame);
	}
d2816 2
a2817 2
		type=PanType,SP[16]={36,69,0,36},AudioOn=1,pmode=0;
	char Label[MAX_PANEL_STR]="",*pan[]={"L","R"};
d2871 4
d2897 1
a2897 1
//	ClipPL[1].UserFun=CTRL_Play;
d2916 12
d2937 1
a2937 1
//	XPClipPL[1].UserFun=CTRL_Play;
d2955 1
d2957 1
a2957 1
	if(!(AudioOn&AUD_EXISTS))
d2969 5
d2998 1
a2998 1
		XPClipPL[14].PropEnd = 3;
d3009 1
a3013 1
					SetAudioInPoint(FG,t_In<<1,t_Out<<1);
d3015 1
a3015 1
					A_Out = t_Out;
a3018 2
					SetAudioOutPoint(FG,t_In<<1,t_Out<<1);
					A_In = t_In;
d3020 1
d3025 1
a3184 2
//	if(type==PAN_EASY)
	{
d3186 39
a3224 42
		KeyPL[0].Label =Label;
		KeyPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		KeyPL[0].Param = (long *)CommentBuf;
		KeyPL[0].PropEnd = COMMENT_MAX;

		KeyPL[2].Param = &Time;
		KeyPL[2].PropStart = 1;
		KeyPL[2].PropEnd = 3600;
		KeyPL[2].Flags = PL_LEN | PL_CFRAME;

		KeyPL[3].Param = &DLay;
		KeyPL[3].PropStart = 1;
		KeyPL[3].PropEnd = 3600;
		KeyPL[3].Flags = PL_DEL;
//		type = MiniPanel(Edit, KeyPL,TUNE_FINE);
	}
//	if(type==PAN_EXPERT)
	{
		XPKeyPL[0].Label =Label;
		XPKeyPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPKeyPL[0].Param = (long *)CommentBuf;
		XPKeyPL[0].PropEnd = COMMENT_MAX;

		XPKeyPL[2].Param = &Time;
		XPKeyPL[2].PropStart = 1;
		XPKeyPL[2].PropEnd = 3600;
		XPKeyPL[2].Flags = PL_LEN | PL_CFRAME;

		XPKeyPL[3].Param = &DLay;
		XPKeyPL[3].PropStart = 1;
		XPKeyPL[3].PropEnd = 600;
		XPKeyPL[3].Flags = PL_DEL;

		XPKeyPL[5].Param = &FadeIn;
		XPKeyPL[5].PropStart = 1;
		XPKeyPL[5].PropEnd = A;
		XPKeyPL[5].Flags = PL_IN;

		XPKeyPL[6].Param = &FadeOut;
		XPKeyPL[6].PropStart = 1;
		XPKeyPL[6].PropEnd = A;
		XPKeyPL[6].Flags = PL_OUT;
a3225 2
//		type = MiniPanel(Edit, XPKeyPL,TUNE_QUICK);
	}
d3567 2
a3568 1
	WORD A,i=1;
a3581 1
				strcpy(Size,"Size   ");
a3585 2
//				stcl_d(num,type);
//				FileInfoPL[4].Label = num;
d3593 22
a3614 2
					stcl_d(&Size[5],fib->fib_Size);
					strcat(Size," bytes");
d3617 1
a3617 1
				if (((ft=getft(Path)) != -1) && (strftime(&TempCh[7],60,"%A, %B %d, %Y %I:%M:%S %p",localtime(&ft))))
d3620 2
a3621 27
				strcpy(TempC2,"Attributes: ");
				if (fib->fib_Protection & FIBF_ARCHIVE)
					strcat(TempC2,"archived,");
				if (fib->fib_Protection & FIBF_PURE)
					strcat(TempC2,"reentrant,");
				if (fib->fib_Protection & FIBF_SCRIPT)
					strcat(TempC2,"script,");
				A = strlen(TempC2)-1;
				if (TempC2[A] == ',') TempC2[A] = 0;
//				else strcat(TempC2,"none");
				else TempC2[0]=0;
				FileInfoPL[7].Label = TempC2;

				strcpy(TempMem,"Protected from: ");
				if (fib->fib_Protection & FIBF_DELETE)
					strcat(TempMem,"deletion,");
				if (fib->fib_Protection & FIBF_EXECUTE)
					strcat(TempMem,"execution,");
				if (fib->fib_Protection & FIBF_WRITE)
					strcat(TempMem,"writing,");
				if (fib->fib_Protection & FIBF_READ)
					strcat(TempMem,"reading,");
				A = strlen(TempMem)-1;
				if (TempMem[A] == ',') TempMem[A] = 0;
//				else strcat(TempMem,"nothing");
				else TempMem[0]=0;
				FileInfoPL[8].Label = TempMem;
@


2.125
log
@All Tables ARE even length now!
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.124 1995/01/05 17:54:15 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d578 1
a578 1
	EZLEN_LINE(PNL_CENTER,"Length",0),
d620 2
a621 2
	EZLEN_LINE(PNL_CENTER,"Length",0),
//EZTIME_LINE(PNL_CENTER,"Length",0),
d755 2
a756 1
	EZLEN_LINE(PNL_CENTER,"Length",0),
@


2.124
log
@Fix available time swap between Extended and Std. modes
@
text
@d2 5
a6 2
* $Id: COntrols.c,v 2.123 1995/01/04 23:40:23 CACHELIN4000 Exp CACHELIN4000 $
* $Log: COntrols.c,v $
d292 1
a292 1
//#define SERDEBUG	1
d2788 1
a2788 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d2843 1
a2843 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3013 1
a3013 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
@


2.123
log
@Fix Matte color bugs in DoFXAnimPanel()
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.122 1995/01/04 17:36:29 CACHELIN4000 Exp CACHELIN4000 $
* $Log: Controls.c,v $
d1030 1
a1030 1
		case EXTD_COMP_MODE:
d1038 1
a1038 1
		case STD_COMP_MODE:
@


2.122
log
@Quantize Audio sliders on Color Frame (add PL_CFRAME flag)
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.121 1995/01/04 11:02:25 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d2323 1
d2328 2
a2329 1
			Color -= 1; // map 1-9 to 0-8 , or -1 -> -2 for CustomColor
d2351 1
d2422 3
a2424 3
			ESparams2.Data1=(LONG)FG;
			ESparams2.Data2=FGC_BG;
			SendSwitcherReply(ES_FGcommand,&ESparams2);
d2429 3
a2431 3
			ESparams2.Data1=(LONG)FG;
			ESparams2.Data2=FGC_BORDER;
			SendSwitcherReply(ES_FGcommand,&ESparams2);
d2436 1
a2436 1
		PutValue(FG,TAG(PanelMode),pmode);  // ...just following orders
d2478 11
a2488 5
//	if(type==PAN_EASY)
	{
		AnimFXPL[0].Label =Label;
		AnimFXPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		AnimFXPL[0].Param = NULL; //(long *)CommentBuf;
d2490 1
a2490 1
		AnimFXPL[1].Label =""; // Label;
d2492 2
a2493 3
		AnimFXPL[4].Param =&B;						// SMFV choice
		AnimFXPL[4].Param2 =SP;						// Array of field counts
		AnimFXPL[4].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME
d2495 1
a2495 9
		AnimFXPL[5].Param = &S;	// Time slider
		AnimFXPL[5].Param2 = &A;
//		type = MiniPanel(Edit,AnimFXPL,TUNE_FINE);
	}
//	if(type==PAN_EXPERT)
	{
		XPAnimFXPL[0].Label =Label;
		XPAnimFXPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPAnimFXPL[0].Param = NULL;
d2497 3
a2499 1
		XPAnimFXPL[1].Label = ""; //Label;
d2501 2
a2502 3
		XPAnimFXPL[4].Param =&B;						// SMFV choice
		XPAnimFXPL[4].Param2 =SP;						// Array of field counts
		XPAnimFXPL[4].PropStart = NULL;	// PLine (time) to update
d2504 8
a2511 3
		XPAnimFXPL[5].Param = &S;	// Time slider
		XPAnimFXPL[5].Param2 = &A;
		if(Matte)
d2513 2
a2514 8
			XPAnimFXPL[6].Param = (long *)Colors;		// POPUP
			XPAnimFXPL[6].PropEnd = COLOR_NUM - 1; // don't include "Special"
			XPAnimFXPL[6].PropStart = Color<0 ? 0 : Color;
			if((GetValue(FG,TAG(CustomMatteColor))!=0))
			{
				XPAnimFXPL[6].PropEnd = COLOR_NUM;
				XPAnimFXPL[6].PropStart = Color<0 ? (COLOR_NUM - 1) : Color;
			}
d2516 8
a2523 1
		else if(Border)
d2525 2
a2526 8
			XPAnimFXPL[6].Param = (long *)Colors;		// POPUP
			XPAnimFXPL[6].PropEnd = COLOR_NUM - 2; // don't include "Special"
			XPAnimFXPL[6].PropStart = Color<0 ? 0 : Color;
			if((GetValue(FG,TAG(CustomBorderColor))!=0))
			{
				XPAnimFXPL[6].PropEnd = COLOR_NUM -1 ; // should swap ptrs for "Snow" and Special" here
				XPAnimFXPL[6].PropStart = Color<0 ? (COLOR_NUM - 2) : Color;
			}
a2527 6
		else XPAnimFXPL[6].Type = PNL_SKIP;
		XPAnimFXPL[7].Param = &D;	// Start Time slider
		XPAnimFXPL[7].PropStart = 1;
		XPAnimFXPL[7].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
//		type = MiniPanel(Edit,XPAnimFXPL,TUNE_QUICK);
//		if(!Matte) XPAnimFXPL[6].Type = PNL_POPUP;
d2530 4
a2539 1
				if(!Matte) XPEffectPL[6].Type = PNL_POPUP;
a2547 1

d2551 1
d2553 5
d2559 1
d2561 4
@


2.121
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: COntrols.c,v 2.120 1994/12/31 02:05:06 CACHELIN4000 Exp CACHELIN4000 $
* $Log: COntrols.c,v $
d2670 1
a2670 1
	AudClipPL[3].Flags = PL_IN | PL_AUD1 | PL_DUAL;
d2697 1
a2697 1
	XPAudClipPL[3].Flags = PL_IN | PL_AUD1 | PL_DUAL;
@


2.120
log
@Fix AUDIO_ONLY avail time again, standardize Source setting, CurFlySource
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.119 1994/12/30 21:22:20 CACHELIN4000 Exp CACHELIN4000 $
* $Log: Controls.c,v $
d1926 1
@


2.119
log
@Fixed audio duration
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.118 1994/12/30 13:09:58 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d1089 3
a1091 5
//	if( (CurFlySource=pl->PropStart)<=4) // remove FlyerIn 'til TBC detection
//		ESparams3.Data1 = pl->PropStart+1;
//	if( (CurFlySource=pl->PropStart)<AUDIO_ONLY_SOURCE-2)
	if( !IS_AUDIO_SOURCE(CurFlySource=pl->PropStart) )
		ESparams3.Data1 = pl->PropStart+1 + 2;
d1806 2
a1807 3
	if( IS_AUDIO_SOURCE(Src) ) Src=0;
	else Src++; // may be 0 for 1st video source
	ESparams3.Data1 = Src;
d2049 1
a2049 2
//	DHD_SetupRecord(CurFlySource+1,0xFFFF,0xFFFF,0);
	DHD_SetupRecord(CurFlySource+1+2,0xFFFF,0xFFFF,CompMode); // until Flyer TBC ready
@


2.118
log
@Add Audio only calc to BlocksToFrames(), CTRL_SetSource(), etc.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.117 1994/12/28 17:48:48 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d359 7
a365 1
#define AUDIO_ONLY_SOURCE		5
d1016 1
a1016 1
			return(30*blox/(6144));
d1019 3
a1021 1
			return(blox/86); 		// 44.1khz*2byte samples*2stereo channels*(1000/1024)=172.266
d1025 1
a1025 1
			return(42*blox/(6144)); // 42 is arbitrary num from 30/.707
d1088 2
a1089 1
	if( (CurFlySource=pl->PropStart)<AUDIO_ONLY_SOURCE-2)
d1131 3
d1168 2
d1799 1
d1805 2
a1806 1
	if( Src==(AUDIO_ONLY_SOURCE+1) ) Src=0;
@


2.117
log
@add 1 b4 rounding down rcb->frame in DHD_Jog()
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.116 1994/12/24 12:33:41 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d294 8
a301 5
#define	AMODE_STEREO	0
#define	AMODE_LEFT		1
#define	AMODE_RIGHT		2
#define	PAN_LEFT			-32768;
#define	PAN_RIGHT			32767;
d1003 14
a1016 2
	if(mode) 	return(42*blox/(6144)); // 42 is arbitrary num from 30/.707
	else return(30*blox/(6144));
d1069 1
a1069 1
// Source popup f'n object is ignored
d1072 3
d1080 1
d1082 2
d1088 14
d1110 1
d1113 6
a1118 1
	if( *name==AUDIO_BYTE ) name +=2 ; // Skip speaker symbol char and space
d1129 2
a1130 2
		pl->G4 = (struct Gadget *) BlocksToFrames(vi->Largest,CurCompMode);
		pl->G5 = (struct Gadget *) BlocksToFrames(vi->Optimized,CurCompMode);
d1136 1
a1136 1
// Compression popup f'n  object is ignored
d1141 1
d1145 1
d1151 3
a1153 1
			T=BlocksToFrames(FVI->Largest,CurCompMode);
d1155 1
a1155 1
			T=BlocksToFrames(FVI->Optimized,CurCompMode);
d1157 1
a1157 1
			if(((struct PanelLine *)Obj)->G4>((struct PanelLine *)Obj)->G5) 
d3386 2
a3387 1
			RawRecPL[9].UserObj =(APTR)&RawRecPL[2];
@


2.116
log
@fix bug with AUDIO_ONLY_SOURCE vs CurFlySource (add 1)
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.115 1994/12/23 17:45:10 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d1087 1
d1109 2
d1900 3
a1903 1

d1905 1
d2258 33
a2290 1
//	if(type==PAN_EASY)
d2292 9
a2300 12
		EffectPL[0].Label =Label;
		EffectPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		EffectPL[1].Label =""; // Label;
		EffectPL[4].Param =&B;						// SMFV choice
		EffectPL[4].Param2 =SP;						// Array of field counts
		EffectPL[4].PropStart =(LONG)&EffectPL[5];	// PLine (time) to update
		EffectPL[5].Param = &S;	// Time slider
		EffectPL[5].Param2 = (LONG *)&EffectPL[4];	// FXSpeed gadg to set to V
		EffectPL[5].PropStart = 1;
		EffectPL[5].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
		EffectPL[5].Flags = PL_LEN;
//		type = MiniPanel(Edit,EffectPL,TUNE_FINE);
d2302 1
a2302 1
//	if(type==PAN_EXPERT)
d2304 5
a2308 22
		XPEffectPL[0].Label =Label;
		XPEffectPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPEffectPL[1].Label = ""; //Label;
		XPEffectPL[4].Param =&B;						// SMFV choice
		XPEffectPL[4].Param2 =SP;						// Array of field counts
		XPEffectPL[4].PropStart =(LONG)&XPEffectPL[5];	// PLine (time) to update
		XPEffectPL[5].Param = &S;	// Time slider
		XPEffectPL[5].Param2 = (LONG *)&XPEffectPL[4];	// FXSpeed gadg to set to V
		XPEffectPL[5].PropStart = 1;
		XPEffectPL[5].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
		if(Matte)
		{
			XPEffectPL[6].Param = (long *)Colors;		// POPUP
			XPEffectPL[6].PropEnd = COLOR_NUM - 1; // don't include "Special"
			XPEffectPL[6].PropStart = Color<0 ? 0 : Color;
			if((GetValue(FG,TAG(CustomMatteColor))!=0))
			{
				XPEffectPL[6].PropEnd = COLOR_NUM;
				XPEffectPL[6].PropStart = Color<0 ? (COLOR_NUM - 1) : Color;
			}
		}
		else if(Border)
d2310 2
a2311 8
			XPEffectPL[6].Param = (long *)Colors;		// POPUP
			XPEffectPL[6].PropEnd = COLOR_NUM - 2; // don't include "Special"
			XPEffectPL[6].PropStart = Color<0 ? 0 : Color;
			if((GetValue(FG,TAG(CustomBorderColor))!=0))
			{
				XPEffectPL[6].PropEnd = COLOR_NUM -1 ; // should swap ptrs for "Snow" and Special" here
				XPEffectPL[6].PropStart = Color<0 ? (COLOR_NUM - 2) : Color;
			}
a2312 7
		else XPEffectPL[6].Type = PNL_SKIP;
		XPEffectPL[7].Param = &D;	// Start Time slider
		XPEffectPL[7].PropStart = 1;
		XPEffectPL[7].PropEnd = t_In;	// (t_In>=330 ? t_In:330);
		XPEffectPL[5].Flags = PL_LEN;
//		type = MiniPanel(Edit,XPEffectPL,TUNE_QUICK);
//	if(!Matte) XPEffectPL[6].Type = PNL_POPUP;
d2315 4
d2320 1
a2325 1
				if(!Matte) XPEffectPL[6].Type = PNL_POPUP;
d2332 1
a2333 1

d2341 6
a2346 1
			PutValue(FG,TAG(MatteColor), (XPEffectPL[6].PropStart < COLOR_NUM -1) ? XPEffectPL[6].PropStart : -1 );
d2348 6
a2353 1
			PutValue(FG,TAG(BorderColor), (XPEffectPL[6].PropStart < COLOR_NUM -2) ? XPEffectPL[6].PropStart : -2 );
d2507 1
a2507 1
#define LENGTH_ADJUST		0   // 2
d2588 1
a2588 1
//	AudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
d2615 1
a2615 1
//	XPAudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
d2805 1
a2805 1
//	ClipPL[3].G5 = (struct Gadget *)2; // diff
d2833 1
a2833 1
//	XPClipPL[3].G5 = (struct Gadget *)2; // diff
d3278 1
@


2.115
log
@change LENGTH_ADJUST to 0 so short clips have correct out points.. i hope
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.114 1994/12/23 15:01:55 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d1733 1
a1733 1
	if(Src==AUDIO_ONLY_SOURCE) Src=0;
@


2.114
log
@Make GetTable() requests use 256byte buffer, instead of 255...
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.113 1994/12/23 11:36:30 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d2482 2
d2571 1
a2571 1
	AudClipPL[3].PropEnd = A-2;  // Min length= 1 colorframe
d2598 1
a2598 1
	XPAudClipPL[3].PropEnd = A-2;
d2788 1
a2788 1
	ClipPL[5].PropEnd = A-2;
d2816 1
a2816 1
	XPClipPL[5].PropEnd = A-2;
d2828 1
a2828 1
		XPClipPL[8].PropEnd = A-2;
@


2.113
log
@Use PropEnd for string limits
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.112 1994/12/23 10:08:47 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d311 1
a311 1
#define COMMENT_MAX 255
@


2.112
log
@Add AUDIO_ONLY_SOURCE define, fix DHD_SetupRecord 'bug' for audio only initialization.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.111 1994/12/22 21:57:59 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d256 1
a256 1
#define SERDEBUG	1
d638 2
a639 1
	PLAY_LINE(PNL_LEFT,"",1),
d653 2
a654 1
	PLAY_LINE(PNL_LEFT,"",1),
d2002 1
a2002 1
	ReqStringPL[2].Param2 = (LONG *)buffsize-1;
d2178 1
a2178 1
	RexxPL[2].Param2 = (LONG *)COMMENT_MAX;
a2509 1

d2549 1
d2576 1
d2991 1
d3040 1
d3058 1
d3150 1
d3202 1
d3259 1
a3259 1
			RawRecPL[2].Param2= (long *)CLIP_NAME_MAX;
d3326 1
a3326 1
			MarkClipPL[4].Param2 =(long *) CLIP_NAME_MAX;
d3385 1
a3385 1
	XPTestPL[2].Param2 =(long *) 50;
d3437 1
a3437 1
				FileInfoPL[2].Param2=(LONG *)MAX_STRING_BUFFER;
@


2.111
log
@fixes to Rexx panel
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.110 1994/12/21 17:33:10 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d253 1
a253 1
//#define SERDEBUG	1
d335 1
a335 1

d1039 1
a1039 1
	if( (CurFlySource=pl->PropStart)<=2)
d1456 5
a1460 5
				CommentBuf[0]=AUDIO_BYTE; // Add little speaker symbol character
				CommentBuf[1]=' ';
				strncpy(&(CommentBuf[2]),FlyerDrives[i],18);
				strncpy(FlyerDrives[i],CommentBuf,18);
				CommentBuf[0]=0;
d1576 1
a1576 1
	if(d && Table) DUMPMSG(Table);
d1719 1
@


2.110
log
@add recordclip(), fix CTRL_Play, add play line to clip panel
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.109 1994/12/16 21:02:36 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d1131 24
d1554 1
a1554 1
	LONG	c=0;
d1559 2
d1563 1
d1565 3
a1567 2
			ESparams4.Data4=TagID;
			c=SendSwitcherReply(ES_GetTable,&ESparams4);
d1571 3
a1573 3
	DUMPSTR(TagNames[TagID&~0x80000000].th_Name);
	DUMPSDECL(")= ",c,"\\");
	if(c && Table) DUMPHEX("Table: ",Table,c);
d1608 1
a1608 1
		ESparams4.Data4=TagID;
d1614 3
a1616 1
	DUMPHEXIL(" 		,",(LONG)*Table," )\\");
d2160 1
a2160 1
	ULONG w=0,ow=0,DLay,B;
d2164 1
a2164 1
		ow=w=GetValue(FG,TAG(Asynchronous));
d2172 1
a2172 1
	RexxPL[3].Param = (LONG *)w;
d2181 1
a2181 1
	if(PAN_CANCEL==MiniPanel(NULL,RexxPL,TUNE_NONE))
d2185 2
a2186 2
	if(w!=ow)
		PutValue(FG,TAG(Asynchronous),w);
d2188 1
a2188 1
		PutValue(FG,TAG(Delay),B);
d2972 1
a2972 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d2993 1
a2993 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3019 1
a3019 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3109 1
a3109 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3129 1
a3129 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3162 1
a3162 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3180 1
a3180 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3213 1
a3213 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX+1);
d3292 1
@


2.109
log
@Add RecordClip Function
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.108 1994/12/15 16:42:59 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d629 1
a629 1
	TEXT_LINE(PNL_LEFT,"",1),
d643 1
a643 1
	TEXT_LINE(PNL_LEFT,"",1),
d1344 1
a1344 1
		if(CurFG!=SKellFG)
d1346 2
a1347 1
			ESparams1.Data1 =(LONG) CurFG;
d1350 1
a1350 1
				SKellFG=CurFG;
d1356 1
a1356 1
				DUMPMSG( ((struct ExtFastGadget *)CurFG)->FileName );
d1360 1
a1360 1
		else if(ESparams1.Data1 =(LONG) SKellFG)
d1370 2
a1371 2
		if(ESparams1.Data1 =(LONG) SKellFG)
			SendSwitcherReply(ES_PanelOpen,&ESparams1);
d1920 1
d1943 2
d1998 3
a2000 3
	ReqTellPL[1].Label = line1;
	ReqTellPL[2].Label = line2;
	ReqTellPL[3].Label = line3;
d2508 1
a2508 1
	AudClipPL[0].UserFun=CTRL_Play;
d2534 1
a2534 1
	XPAudClipPL[0].UserFun=CTRL_Play;
d2749 1
a2749 1
//		XPClipPL[1].UserFun=CTRL_Play;
@


2.108
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.107 1994/12/09 16:42:17 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d1733 1
a1733 1
ULONG	DHD_Record(char *name, ULONG Start, ULONG Stop, ULONG Flags)
d1739 1
a1739 1
	ESparams5.Data2=(LONG)0;
d1909 30
@


2.107
log
@Use AUD_ENABLE flags for channels popup
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.106 1994/12/08 16:08:38 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d2438 1
a2438 1
		else if( HAS_LEFT(AudioOn) && IS_LEFT(AudioOn) )
d2444 1
a2444 1
		else if( HAS_RIGHT(AudioOn) && IS_RIGHT(AudioOn) )
d2639 1
a2639 1
		if( (AudioOn&AUD_CH1_EXISTS) && !(AudioOn&AUD_CH2_EXISTS) )
d2641 3
a2643 2
			CurAudioSet.Mode=AMODE_LEFT;
			CurAudioSet.Pan1 = 0;
d2645 1
d2647 1
a2647 1
		else if( !(AudioOn&AUD_CH1_EXISTS) && (AudioOn&AUD_CH2_EXISTS) )
d2649 1
a2649 1
			CurAudioSet.Mode=AMODE_RIGHT;
d2653 1
a2653 1
		else  if( (AudioOn&AUD_CH1_EXISTS) && (AudioOn&AUD_CH2_EXISTS) )
d2655 2
a2656 4
			CurAudioSet.Mode=AMODE_STEREO;
			CurAudioSet.Pan1 = PAN_LEFT;
			CurAudioSet.Pan2 = PAN_RIGHT;
			PutValue(FG,TAG(AudioPan1),CurAudioSet.Pan1);
@


2.106
log
@Reorganize Audio, video control panels (Yet Again), fix Streeo pan oversight
Add Start Time to Rexx panel, etc.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.105 1994/12/07 23:14:31 CACHELIN4000 Exp CACHELIN4000 $
d4 4
d259 1
d266 9
d346 1
a346 1
	*Channels[] ={ "Stereo (L+R)", "Right Only" , "Left Only"},
d1242 1
d1247 2
a1248 1
			aud->Pan2 = aud->Balance - (MAXPOT>>1);
d1299 2
d1311 2
d1321 2
a2390 2

#define MAX_AUD_FADE	750 // Max 1500 fields (Marty, Nov  3 1994)
d2427 9
a2435 1
		if( (AudioOn&AUD_CH1_EXISTS) && !(AudioOn&AUD_CH2_EXISTS) )
d2441 1
a2441 1
		else if( !(AudioOn&AUD_CH1_EXISTS) && (AudioOn&AUD_CH2_EXISTS) )
d2447 1
a2447 7
		else {
			CurAudioSet.Mode=AMODE_STEREO;
			CurAudioSet.Pan1 = PAN_LEFT;
			CurAudioSet.Pan2 = PAN_RIGHT;
			PutValue(FG,TAG(AudioPan1),CurAudioSet.Pan1);
			PutValue(FG,TAG(AudioPan2),CurAudioSet.Pan2);
		}
d2818 1
a2818 1
//		PutValue(FG,TAG(AudioOn),AudioOn);
@


2.105
log
@Add Channels popup to XPVidClip, change volume num to slider (Sorry James, SKell said Tim siad to do it)
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.104 1994/12/07 00:12:22 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d491 1
d630 2
a631 3
	EZLEN_LINE(  PNL_CENTER,"Fade In",0),
	EZSLIDER_LINE(  PNL_CENTER, "Balance",1),
//	TOGGLE_LINE( PNL_LEFT," ",1),
a655 1
//	TEXT_LINE(PNL_LEFT,"",0 ),
d657 4
a660 3

//	EZNUM_LINE(  PNL_RIGHT, "Volume",1),
	SLIDER_LINE(  PNL_RIGHT, "Volume",1),
a661 5
	EZLEN_LINE(  PNL_RIGHT,"Fade In",0),
	EZSLIDER_LINE(  PNL_CENTER, "Balance",1),

	EZLEN_LINE(PNL_RIGHT,"Fade Out",0),

a1226 1
/*
a1234 1
*/
d1275 1
a1275 2
				aud->Pan1 =PAN_LEFT;
//				aud->Pan1 = aud->Balance - (MAXPOT>>1);
d1286 1
a1286 2
				aud->Pan2 =PAN_RIGHT;
//				aud->Pan2 = aud->Balance - (MAXPOT>>1);
d2062 1
a2062 1
	ULONG w=0,ow=0;
d2067 1
d2073 1
d2077 6
d2089 2
d2504 10
a2513 10
	XPAudClipPL[8].Param = &FadeIn;
	XPAudClipPL[8].PropStart = 0;
	XPAudClipPL[8].PropEnd = MAX_AUD_FADE;
	XPAudClipPL[8].Flags = PL_AUD1;  // means Attack on EZLen types

	XPAudClipPL[9].Param =&CurAudioSet.Volume;
	XPAudClipPL[9].Param2 = (long *) pan;
	XPAudClipPL[9].PropStart = CurAudioSet.Balance;
	XPAudClipPL[9].UserFun= CTRL_SetBalance;
	XPAudClipPL[9].UserObj=(APTR)&CurAudioSet;
d2723 9
a2731 9
		XPClipPL[11].Param = &AFade_In;
		XPClipPL[11].PropStart = 0;
		XPClipPL[11].PropEnd = MAX_AUD_FADE;

		XPClipPL[12].Param = &CurAudioSet.Volume; // Overall volume control for "Balance"
//		XPClipPL[12].Param2 = (LONG *)pan;
		XPClipPL[12].PropStart = CurAudioSet.Balance;
		XPClipPL[12].UserFun= CTRL_SetBalance;
		XPClipPL[12].UserObj=(APTR)&CurAudioSet;
@


2.104
log
@Add SortFLyerDrives(), Audio drive tweaks and various cosmetics
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.103 1994/12/05 20:06:38 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d251 2
d256 2
a257 2
#define	IS_AUDIO_DRIVE(FVI)		((FVI->Flags&FVIF_AUDIOREADY) && !(FVI->Flags&FVIF_VIDEOREADY))
#define	AUDIO_BYTE	0xA2
d624 2
a625 1
	EZNUM_LINE(  PNL_CENTER, "Volume",1),
d630 2
a631 1
	DIVIDE_LINE(PNL_LEFT,"",0),
d656 2
a657 1
	EZNUM_LINE(  PNL_RIGHT, "Volume",1),
d1229 1
d1238 1
d1279 2
a1280 1
				aud->Pan1 = aud->Balance - (MAXPOT>>1);
d1291 2
a1292 1
				aud->Pan2 = aud->Balance - (MAXPOT>>1);
d1302 2
a1303 2
				aud->Pan1 = -32768;
				aud->Pan2 = 32767;
d2412 7
a2418 1
			CurAudioSet.Pan1 = 0;
d2420 1
a2421 1

d2622 8
d2724 1
a2724 1
		XPClipPL[12].Param2 = (LONG *)pan;
d2732 7
@


2.103
log
@Use global CurCompMode for retain compression settings
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.102 1994/12/05 19:21:30 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d251 2
d300 2
d407 1
a407 1
	POPUP_LINE(PNL_RIGHT,"Mode:  ",0),
d419 1
a419 1
	TEXT_LINE(PNL_CENTER,"Crouton Error:",0),
d440 2
a441 2
	DIFF_LINE(PNL_CENTER,"Length: ",1),
	POPUP_LINE(PNL_RIGHT,"   Source:",0),
d455 1
a455 1
	DIFF_LINE(PNL_RIGHT,"Length: ",0),
d469 1
a469 1
	TEXT_LINE(PNL_LEFT,"Comment",0),
d552 1
a552 1
	EZLEN_LINE(PNL_CENTER,"Duration:",0),
d563 1
a563 1
	EZLEN_LINE(PNL_CENTER,"Frames:",0),
d565 1
a565 1
	EZTIME_LINE(PNL_CENTER,"Start Key:",0),
d589 1
a589 1
	EZLEN_LINE(PNL_CENTER,"Start Key:",0),
d598 1
a598 1
	DIFF_LINE(PNL_LEFT,"Length: ",0),
d612 1
a612 1
	DIFF_LINE(PNL_LEFT,"Length: ",0),
d631 1
a631 1
	DIFF_LINE(PNL_LEFT,"Length: ",0),
d642 1
a642 1
	DIFF_LINE(PNL_LEFT,"Length: ",0),
d945 2
a946 1
	return(30*blox/(6144));
d1019 1
d1021 3
a1023 1
	ESparams2.Data1=(LONG)( ((char **)pl->Param)[pl->PropStart] );
d1033 2
a1034 2
		pl->G4 = (struct Gadget *) BlocksToFrames(vi->Largest,0);
		pl->G5 = (struct Gadget *) BlocksToFrames(vi->Optimized,0);
d1052 1
a1052 1
			T=BlocksToFrames(FVI->Largest,0);
d1054 1
a1054 1
			T=BlocksToFrames(FVI->Optimized,0);
a1060 3
char *FaceMess[]={"Removing interface from Preview Monitor,",
		"Press HELP to restore."};

d1358 1
d1362 8
a1369 5
		vi=(struct FlyerVolInfo *)SendSwitcherReply(ES_FlyerDriveInfo,&ESparams2);
		DUMPHEXIL(" ) = ",(LONG)vi,"\\");
		DUMPUDECL("vi->Largest =  ",(LONG)vi->Largest,"\\");
		DUMPUDECL("vi->Optimized =  ",(LONG)vi->Optimized,"\\");
		return(vi);
a1373 1
#define		AUDIO_BYTE	0xA2
d1378 1
a1378 1
	if(FlyerBase) return(0);
d1380 3
d1384 2
a1385 1
			if( (FVI->Flags&FVIF_AUDIOREADY) && !(FVI->Flags&FVIF_VIDEOREADY) )
d1387 4
a1390 2
				CommentBuf[0]=AUDIO_BYTE;
				strncpy(&(CommentBuf[1]),FlyerDrives[i],18);
d1394 2
d1399 24
d2426 1
a2426 1
	AudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
d2452 1
a2452 1
	XPAudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
d2634 1
a2634 1
	ClipPL[3].G5 = (struct Gadget *)2; // diff
d2662 1
a2662 1
	XPClipPL[3].G5 = (struct Gadget *)2; // diff
a2746 1

@


2.102
log
@Add Quality popup to record panel.
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.100 1994/12/03 18:36:24 CACHELIN4000 Exp CACHELIN4000 $
* $Log: controls.c,v $
d267 1
a267 1
ULONG CurFlyDrive=0,CurFlySource=0,CurFlyTracks=1;
d1035 1
d3092 1
a3092 1
			RawRecPL[5].PropStart = DEF_QUALITY;
@


2.101
log
@*** empty log message ***
@
text
@d222 1
a222 1
#define SERDEBUG	1
d282 1
a282 1
#define QUAL_NUM	6 		// number of entires in Qual array
d308 1
a308 1
	*Quals[] = {" D2 ","Beta SP"," Hi-8 ","S-VHS","VHS","Recognizable",""},
d347 1
d422 1
a422 2
	TEXT_LINE(PNL_CENTER,"",0),
//	POPUP_LINE(PNL_LEFT,"Quality",1),
d425 3
a427 1
	DIVIDE_LINE(PNL_LEFT,"",0),
d484 33
a522 1
//IN_TYPE_LINE(PNL_LEFT,0,0),
d1028 2
d1033 10
d3060 1
d3062 3
a3064 8
			RawRecPL[3].Param = (long *)Quals;		// POPUP
			RawRecPL[3].PropStart = DEF_QUALITY;
			RawRecPL[3].PropEnd = QUAL_NUM;
			RawRecPL[3].UserFun = CTRL_SetCompression;
*/
			RawRecPL[3].Param = (long *)Name;		// STRING
			RawRecPL[3].Param2= (long *)CLIP_NAME_MAX;
			RawRecPL[3].Flags= PL_IN; // kludge hack 'til markclip works
d3068 6
a3073 6
				RawRecPL[4].Param = (long *)FlyerDrives;		// POPUP
				RawRecPL[4].PropStart = CurFlyDrive;
				RawRecPL[4].PropEnd = FlyerDriveCount;
				RawRecPL[4].UserFun = CTRL_SetDrive;
				RawRecPL[4].G4 = (struct Gadget *)B;
				RawRecPL[4].G5 = (struct Gadget *)C;
d3077 1
a3077 1
				RawRecPL[4].Param = (long *)FlyDrives;		// POPUP
d3079 5
a3083 5
				RawRecPL[4].PropStart = 0;
				RawRecPL[4].PropEnd = 1;
				RawRecPL[4].Param2 = NULL;
				RawRecPL[4].G4 = (struct Gadget *)B;
				RawRecPL[4].G5 = (struct Gadget *)C;
d3085 7
a3091 1
			RawRecPL[4].Flags = PL_FLYER;
d3093 1
a3093 1
			RawRecPL[6].Param = (LONG *)&(RawRecPL[4].G4);  // Diff
d3097 1
a3097 1
			RawRecPL[7].Param = (LONG *)&(RawRecPL[4].G5);  // Diff
@


2.100
log
@Add PanelMode tag check, quicktune gadgets, diff text placement
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.99 1994/11/18 18:31:19 Kell Exp CACHELIN4000 $
* $Log: Controls.c,v $
a86 3
*Revision 2.72  94/10/12  18:03:50  CACHELIN4000
**** empty log message ***
*
a95 3
*Revision 2.68  94/10/07  07:40:26  Kell
**** empty log message ***
*
a125 9
*Revision 2.56  94/10/04  17:54:42  CACHELIN4000
**** empty log message ***
*
*Revision 2.55  94/10/03  21:11:03  CACHELIN4000
**** empty log message ***
*
*Revision 2.54  94/10/03  19:05:00  CACHELIN4000
**** empty log message ***
*
a129 3
*Revision 2.52  94/10/02  00:23:28  CACHELIN4000
**** empty log message ***
*
a132 3
*Revision 2.50  94/10/01  22:58:03  CACHELIN4000
**** empty log message ***
*
a152 9
*Revision 2.43  94/09/29  15:50:57  CACHELIN4000
**** empty log message ***
*
*Revision 2.42  94/09/29  13:51:26  CACHELIN4000
**** empty log message ***
*
*Revision 2.41  94/09/29  12:20:01  CACHELIN4000
**** empty log message ***
*
a155 3
*Revision 2.39  94/09/28  18:17:54  CACHELIN4000
**** empty log message ***
*
a162 6
*Revision 2.36  94/09/28  00:09:03  CACHELIN4000
**** empty log message ***
*
*Revision 2.35  94/09/27  23:39:39  CACHELIN4000
**** empty log message ***
*
a172 3
*Revision 2.31  1994/09/24  15:11:59  CACHELIN4000
**** empty log message ***
*
a178 70
*Revision 2.27  94/09/14  19:02:51  CACHELIN4000
*Panel croutons, Audio panel re-do...
*
*Revision 2.26  94/09/13  20:19:46  CACHELIN4000
*Move PNL_CROUTON FG to Param2, comment to Param, Add Audio support f'ns
*
*Revision 2.24  94/09/12  13:04:22  CACHELIN4000
**** empty log message ***
*
*Revision 2.23  94/09/10  20:11:35  CACHELIN4000
*makeserver
*
*Revision 2.22  94/09/09  20:39:26  CACHELIN4000
**** empty log message ***
*
*Revision 2.21  94/09/09  13:39:41  CACHELIN4000
*Make some pretty test panels for the drooling interface czar wannabes
*
*Revision 2.20  94/09/07  14:43:46  CACHELIN4000
**** empty log message ***
*
*Revision 2.18  94/09/06  22:27:41  CACHELIN4000
*Cry Havoc, and let slip the dogs of war
*
*Revision 2.17  94/09/05  19:07:37  CACHELIN4000
**** empty log message ***
*
*Revision 2.14  94/09/02  20:18:08  CACHELIN4000
*More Tweaks.
*
*Revision 2.13  94/09/01  21:13:55  CACHELIN4000
**** empty log message ***
*
*Revision 2.12  94/09/01  18:02:45  CACHELIN4000
*Audio Tag corrections
*
*Revision 2.11  94/09/01  10:41:21  CACHELIN4000
*TAG() define...
*
*Revision 2.10  94/09/01  03:33:29  Kell
*Tweeked the TAG fields to Frames and visa versa conversions.
*Fixed some TAGs that were getting ored with 0x8000000 (instead of 0x80000000)
*
*Revision 2.9  1994/08/30  17:26:34  CACHELIN4000
*Replace GadIndx hack with PLine->Flags kludge.
*
*Revision 2.8  94/08/30  10:31:42  Kell
*Changed SendSwitcherReply calls to work with new ESParams structures.
*
*Revision 2.7  1994/08/30  09:46:00  CACHELIN4000
*Change ES_Messages to use ESparams struct
*
*Revision 2.6  94/08/26  21:48:24  Kell
*Removed working with some obsolete Flyer tag items
*
*Revision 2.5  1994/08/24  12:07:28  CACHELIN4000
*Add Audio Fine-tune to clip panel
*
*Revision 2.4  94/07/11  17:59:48  CACHELIN4000
*Remove test panel access
*
*Revision 2.3  94/07/07  17:01:58  CACHELIN4000
*Caps-Lock expert mode
*
*Revision 2.2  94/07/06  22:35:28  CACHELIN4000
*Tamed Test Panel
*
*Revision 2.0  94/06/21  16:14:06  CACHELIN4000
*FirstCheckIn
*
d222 1
a222 1
//#define SERDEBUG	1
d419 1
a419 1
	TEXT_LINE(PNL_CENTER,"                  Record Raw Footage",0),
d438 2
a439 2
	TEXT_LINE(PNL_RIGHT,"Mark",1),
	TEXT_LINE(PNL_LEFT,"Clips",0),
d441 1
a441 2
	FLYTIME_LINE(PNL_CENTER,"In",1),
	FLYTIME_LINE(PNL_CENTER,"Out",0),
d443 1
a443 1
	DIFF_LINE(PNL_LEFT,"Length ",0),
d603 1
a603 1
	POPUP_LINE(PNL_JUST,"Channels",0 ),
d605 1
a605 1
	EZNUM_LINE(  PNL_JUST, "Volume",1),
d607 1
a607 1
	EZLEN_LINE(  PNL_JUST,"Fade In",0),
d610 1
a610 1
	EZLEN_LINE(PNL_JUST,"Fade Out",0),
d2285 1
a2285 1
		type = (pmode==1) ? PAN_EXPERT:PAN_EASY ;
a2287 1
		type = GetValue(FG,TAG(PanelMode)) ? PAN_EASY:PAN_EXPERT ;
d2325 79
a2403 77

		AudClipPL[0].Label = Label;
		AudClipPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		AudClipPL[0].Param = (long *)CommentBuf;
		AudClipPL[0].UserFun=CTRL_Play;
		AudClipPL[0].UserObj=(APTR)FG;

		AudClipPL[2].Param =  &t_Out;
		AudClipPL[2].Param2 = &t_In;
		AudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
		AudClipPL[2].PropStart = PANEL_LENGTHX<<16;
		AudClipPL[2].PropStart += 12 + PIN_YOFF;

		AudClipPL[3].Param = &t_In;
		AudClipPL[3].Param2 = &t_Out;
		AudClipPL[3].PropStart = 0;
		AudClipPL[3].PropEnd = A-2;  // Min length= 1 colorframe
		AudClipPL[3].Flags = PL_IN | PL_AUD1 | PL_DUAL;

		AudClipPL[5].Param = &S;
		AudClipPL[5].PropStart = 0;
		AudClipPL[5].PropEnd = MAX_DELAY;
		AudClipPL[5].Flags = PL_DEL;


		XPAudClipPL[0].Label = Label;
		XPAudClipPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPAudClipPL[0].Param = (long *)CommentBuf;
		XPAudClipPL[0].UserFun=CTRL_Play;
		XPAudClipPL[0].UserObj=(APTR)FG;

		XPAudClipPL[2].Param = &t_Out;
		XPAudClipPL[2].Param2 = &t_In;
		XPAudClipPL[2].G5 =(struct Gadget *) 2; // diff add-on...
		XPAudClipPL[2].PropStart = PANEL_LENGTHX<<16;
		XPAudClipPL[2].PropStart += 12 + PIN_YOFF;

		XPAudClipPL[3].Param = &t_In;
		XPAudClipPL[3].Param2 = &t_Out;
		XPAudClipPL[3].PropStart = 0;
		XPAudClipPL[3].PropEnd = A-2;
		XPAudClipPL[3].Flags = PL_IN | PL_AUD1 | PL_DUAL;

		XPAudClipPL[5].Param = &S;
		XPAudClipPL[5].PropStart = 0;
		XPAudClipPL[5].PropEnd = MAX_DELAY;
		XPAudClipPL[5].Flags = PL_DEL;

		XPAudClipPL[6].Param = (LONG *)Channels;
		XPAudClipPL[6].PropStart = CurAudioSet.Mode;
		XPAudClipPL[6].PropEnd = 3;
		XPAudClipPL[6].UserFun=CTRL_SetPan;
		XPAudClipPL[6].UserObj=(APTR)&CurAudioSet;

		XPAudClipPL[7].Param = &CurAudioSet.Volume;
		XPAudClipPL[7].Param2 = (LONG *)&(XPAudClipPL[9]); // Balance PL
		XPAudClipPL[7].PropStart = 0;
		XPAudClipPL[7].PropEnd = 100;
		XPAudClipPL[7].Flags = PL_AUD1|PL_AUD2;
		XPAudClipPL[7].UserFun=CTRL_SetVolume;
		XPAudClipPL[7].UserObj=(APTR)&CurAudioSet;

		XPAudClipPL[8].Param = &FadeIn;
		XPAudClipPL[8].PropStart = 0;
		XPAudClipPL[8].PropEnd = MAX_AUD_FADE;
		XPAudClipPL[8].Flags = PL_AUD1;  // means Attack on EZLen types

		XPAudClipPL[9].Param =&CurAudioSet.Volume;
		XPAudClipPL[9].Param2 = (long *) pan;
		XPAudClipPL[9].PropStart = CurAudioSet.Balance;
		XPAudClipPL[9].UserFun= CTRL_SetBalance;
		XPAudClipPL[9].UserObj=(APTR)&CurAudioSet;

		XPAudClipPL[10].Param = &FadeOut;
		XPAudClipPL[10].PropStart = 0;
		XPAudClipPL[10].PropEnd = MAX_AUD_FADE;
		XPAudClipPL[10].Flags = PL_AUD2;  // means Decay on EZLen types
d2406 3
d2420 3
d2486 1
a2486 1
		type = (pmode==1) ? PAN_EXPERT:PAN_EASY ;
d2526 1
a2526 45
//	if(type==PAN_EASY)
	{
		ClipPL[0].Label = "";

		ClipPL[1].Label = Label;
		ClipPL[1].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		ClipPL[1].Param = (long *)CommentBuf;
		ClipPL[1].PropEnd = COMMENT_MAX ; // max string length
		ClipPL[1].PropStart=0;		// set to non-zero if comment is changed...
//		ClipPL[1].UserFun=CTRL_Play;
		ClipPL[1].UserObj=(APTR)FG;

		ClipPL[2].UserFun=CTRL_Play;
		ClipPL[2].UserObj=(APTR)FG;

		ClipPL[3].Param = &t_Out; // out
		ClipPL[3].Param2 = &t_In; // in
		ClipPL[3].G5 = (struct Gadget *)2; // diff
		ClipPL[3].PropStart = PANEL_LENGTHX<<16;
		ClipPL[3].PropStart += 12 + PIN_YOFF;

		ClipPL[5].Param = &t_In;
		ClipPL[5].Param2 = &t_Out;
		ClipPL[5].PropStart = 0;
		ClipPL[5].PropEnd = A-2;
		ClipPL[5].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;

/* 		type = Panel(Edit,ClipPL,TUNE_FINE);
		if(t_In  != SP[0])
		{
			SetAudioInPoint(FG,t_In<<1,t_Out<<1);
			A_In = t_In;
			A_Out = t_Out;
		}
		else if(t_Out != SP[1])
		{
			SetAudioOutPoint(FG,t_In<<1,t_Out<<1);
			A_In = t_In;
			A_Out = t_Out;
		}
 */
	}
//	if(type==PAN_EXPERT)
	{
		XPClipPL[0].Label = ""; //Label;
d2528 33
a2560 5
		XPClipPL[1].Label = Label;
		XPClipPL[1].Param2 = (FG ? (long *)FG->Data:(long *)NULL); // icon bitmap
		XPClipPL[1].Param = (long *)CommentBuf;
		XPClipPL[1].PropEnd = COMMENT_MAX ; // max string length
		XPClipPL[1].PropStart=0;		// set to non-zero if comment is changed...
d2562 1
a2562 1
		XPClipPL[1].UserObj=(APTR)FG;
d2564 2
a2565 2
		XPClipPL[2].UserFun=CTRL_Play;
		XPClipPL[2].UserObj=(APTR)FG;
d2567 12
a2578 47
		XPClipPL[3].Param = &t_Out;
		XPClipPL[3].Param2 = &t_In;
		XPClipPL[3].G5 = (struct Gadget *)2; // diff
		XPClipPL[3].PropStart = PANEL_LENGTHX<<16;
		XPClipPL[3].PropStart += 12 + PIN_YOFF;

		XPClipPL[5].Param = &t_In;
		XPClipPL[5].Param2 = &t_Out;
		XPClipPL[5].PropStart = 0;
		XPClipPL[5].PropEnd = A-2;
		XPClipPL[5].Flags = PL_IN | PL_DUAL | PL_FLYER | PL_CFRAME;

		if(!(AudioOn&AUD_EXISTS))
		{
			XPClipPL[7].Type = 0;
//			type = Panel(Edit,XPClipPL,TUNE_QUICK);
//			XPClipPL[7].Type = PNL_DIVIDE;
		}
		else
		{
			XPClipPL[8].Param = &A_In;
			XPClipPL[8].Param2 = &A_Out;
			XPClipPL[8].PropStart = 0;
			XPClipPL[8].PropEnd = A-2;
			XPClipPL[8].Flags = PL_AUDIO | PL_IN | PL_CFRAME | PL_DUAL;

			XPClipPL[10].Param = &CurAudioSet.Volume;
			XPClipPL[10].Param2 = (LONG *)&(XPClipPL[12]); // Balance PL
			XPClipPL[10].PropStart = 0;
			XPClipPL[10].PropEnd = 100;
			XPClipPL[10].Flags =  PL_AUD1|PL_AUD2;
			XPClipPL[10].UserFun=CTRL_SetVolume;
			XPClipPL[10].UserObj=(APTR)&CurAudioSet;

			XPClipPL[11].Param = &AFade_In;
			XPClipPL[11].PropStart = 0;
			XPClipPL[11].PropEnd = MAX_AUD_FADE;

			XPClipPL[12].Param = &CurAudioSet.Volume; // Overall volume control for "Balance"
			XPClipPL[12].Param2 = (LONG *)pan;
			XPClipPL[12].PropStart = CurAudioSet.Balance;
			XPClipPL[12].UserFun= CTRL_SetBalance;
			XPClipPL[12].UserObj=(APTR)&CurAudioSet;

			XPClipPL[13].Param = &AFade_Out;
			XPClipPL[13].PropStart = 0;
			XPClipPL[13].PropEnd = MAX_AUD_FADE;
d2580 33
a2612 2
//			type = Panel(Edit,XPClipPL,TUNE_QUICK);
		}
a2614 2


d2616 1
d2622 1
a2622 1
				if(t_In  != SP[0])
a2637 2
				if(!(AudioOn&AUD_EXISTS))
					XPClipPL[7].Type = PNL_DIVIDE;
d2640 3
d3075 1
d3078 14
a3091 20
			MarkClipPL[4].Param = &B;
			MarkClipPL[4].PropStart = 0;
			MarkClipPL[4].PropEnd = T;

			MarkClipPL[6].Param = &B;  // Diff
			MarkClipPL[6].Param2 = &Z;
			MarkClipPL[6].G5 = (struct Gadget *)2; // Diff
			MarkClipPL[6].Flags = PL_LEN;

			MarkClipPL[5].Param = (long *)Name;  // Name String
			MarkClipPL[5].Param2 =(long *) CLIP_NAME_MAX;

			MarkClipPL[3].Flags = PL_IN | PL_FLYER;
			MarkClipPL[4].Flags = PL_OUT | PL_FLYER;
			MarkClipPL[5].Flags = PL_DEL;

			MarkClipPL[4].PropStart = 24;
//			MarkClipPL[9].Param = NULL;  // VCR Panel no time gadg
			MarkClipPL[9].Param = &Spot;
			MarkClipPL[9].Param2 = &Spot;
@


2.99
log
@Changed Tag Synchronous to Asynchronous
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.98 1994/11/18 16:51:52 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d331 1
a331 1
#define SERDEBUG	1
d449 2
a450 2
#define IN_TYPE_LINE(j,l,w) {PNL_IN_TYPE,j,l,w,0,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL}
#define OUT_TYPE_LINE(j,l,w) {PNL_OUT_TYPE,j,l,w,0,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL}
d697 1
d700 2
a701 3
	EZTIME_LINE(PNL_CENTER,"Start Time",1),
	DIFF_LINE(PNL_LEFT,"Length    ",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
d708 1
d711 1
a711 2
	DIFF_LINE(PNL_LEFT,"Length    ",1),
	EZTIME_LINE(PNL_LEFT,"Start Time",0),
d713 1
a713 1
	POPUP_LINE(PNL_CENTER,"             Channels",0 ),
d715 1
a715 1
	EZNUM_LINE(  PNL_LEFT, "Volume",1),
d717 1
a717 1
	EZLEN_LINE(  PNL_LEFT,"Fade In",0),
d720 1
a720 1
	EZLEN_LINE(PNL_LEFT,"Fade Out",0),
d871 136
a1006 138
#ifdef SERDEBUG
far UBYTE *TagName[] = {
	"!!NULL TAG!!",
	"Version",
	"Revision",
	"AAeffect",
	"NonAAeffect",
	"KillInterfaceNonAA",
	"KillInterfaceAA",
	"ButtonELHlogic",
	"CustomButtonELHlogic",
	"NumberOfAnims",
	"RequestFileName",
	"AnimFiles",
	"Frames   ",
	"FieldSync",
	"VariableSpeeds",
	"ForcePlayForward",
	"ForcePlayReverse",
	"LoopAnims",
	"AnimControl",
	"AudioFastSamples",
	"AudioMediumSamples",
	"AudioSlowSamples",
	"AudioFiles",
	"AudioControl",
	"PauseTimes",
	"LatchColors",
	"TransparentColors",
	"PaletteColors",
	"Equations",
	"Encoder",
	"VerticalScroll",
	"ReverseTime",
	"ReverseButtLog",
	"ReverseCustomButtLog",
	"KeyMode",
	"MatteColor",
	"CustomMatteColor",
	"BorderColor",
	"CustomBorderColor",
	"LineNumbers",
	"LineNumberPlane",
	"ForceFreeze4",
	"ForceFreeze8",
	"ForceLive",
	"ForceLumKeyOn",
	"ForceLumKeyOff",
	"ForceLumKeyOnBlack",
	"ForceLumKeyOnWhite",
	"BadDefaultFX",
	"LoadPictures",
	"FadeInDuration",
	"FadeOutDuration",
	"DigitalFX",
	"Matte   ",
	"LUT",
	"DigitalPairs",
	"LatchAM  ",
	"LatchBM  ",
	"LatchIS  ",
	"HonorPreviewOverLay",
	"ForceDefaultMatte",
	"TurnAudioFilterOff",
	"AudioStartField",
	"NumAudioFields",
	"ISandClipPause",
	"Interlaced",
	"FirstFieldNTSCII",
	"BounceILBM",
	"LatchRanges",
	"LatchList ",
	"TransparentRanges",
	"TransparentList",
	"Color0Transparent",
	"AbortIfSlow",
	"NumSkipFieldsAtEnd",
	"TBarDoesAuto",
	"DoNotStompSprite",
	"AbortLoopAtEnd",
	"NonAAremap",
	"100PercentWhiteMatte",
	"UseEffectColor",
	"LoopCount ",
	"CroutonType",
	"TimeLine ",
	"IndexID  ",
	"FCountMode",
	"VariableFCount",
	"SlowFCount",
	"MedFCount",
	"FastFCount",
	"VariableFCount68000",
	"SlowFCount68000",
	"MedFCount68000",
	"FastFCount68000",
	"NumFields ",
	"StartTime ",
	"DescriptorList",
	"AboutList",
	"CommentList",
	"AlgoFXtype",
	"AlgoFXborder",
	"NumFramesSlow",
	"NumFramesMedium",
	"NumFramesFast",
	"NumFramesVariable",
	"Page     ",
	"Speed    ",
	"Delay    ",
	"Duration",
	"AudioAttack",
	"AudioDecay",
	"RecFields",
	"AudioOn  ",
	"AudioStart",
	"AudioDuration",
	"ClipStartField",
	"FadeInVideo",
	"MaxDuration",
	"VideoSource",
	"LoadedSlices",
	"OriginalLocation",
	"AudioVolume1",
	"AudioVolume2",
	"AudioPan1 ",
	"AudioPan2 ",
	"AudioHeadStart		",
	"AudioHeadDuration	",
	"AudioTailStart		",
	"AudioTailDuration	",
	"AdjustedVideoStart",
	"AdjustedVideoDuration",
	"Asynchronous",
	"CommandLine",
	""};

#endif
d1089 1
d1110 41
d1458 23
d1491 1
a1491 1
	DUMPSTR(TagName[TagID&~0x80000000]);
d1519 1
a1519 1
	DUMPSTR(TagName[TagID&~0x80000000]);
d1535 1
a1535 1
	DUMPSTR(TagName[TagID&~0x80000000]);
d1561 1
a1561 1
	DUMPSTR(TagName[TagID&~0x80000000]);
d1907 1
a1907 1
	if(PAN_CANCEL==MiniPanel(NULL,ReqStringPL,FALSE))
d1920 1
a1920 1
	if(PAN_CANCEL==MiniPanel(NULL,ReqNumPL,FALSE))
d1934 1
a1934 1
	if(PAN_CANCEL==MiniPanel(NULL,ReqTimePL,FALSE))
d1947 1
a1947 1
	if(PAN_CANCEL==MiniPanel(NULL,ReqTellPL,FALSE))
d2008 1
a2008 1
	type=MiniPanel(Edit,TweakPL,FALSE);
d2037 2
d2043 1
d2048 1
d2050 1
a2050 1
		type = MiniPanel(Edit,SetupPL,FALSE);
d2064 1
a2064 1
		SendSwitcherReply(ES_SetPrefs,&ESparams1);
d2086 1
a2086 1
	if(PAN_CANCEL==MiniPanel(NULL,RexxPL,FALSE))
d2103 1
a2103 1
	LONG B=2,t_In=300,type=PanType,Speed=1,S,SP[4]={45,30,15,9},D=0, Color=0;
d2117 3
d2134 1
a2134 1
	if(type==PAN_EASY)
d2147 1
a2147 1
		type = MiniPanel(Edit,EffectPL,TRUE);
d2149 1
a2149 1
	if(type==PAN_EXPERT)
d2188 2
a2189 2
		type = MiniPanel(Edit,XPEffectPL,FALSE);
		if(!Matte) XPEffectPL[6].Type = PNL_POPUP;
d2191 16
d2220 1
d2229 2
a2230 1
	LONG A=0,B=2,t_In=900,type=PanType,Speed=1,S,SP[4]={45,30,15,9},D=0, Color=0;
d2245 2
d2262 1
a2262 1
	if(type==PAN_EASY)
d2276 1
a2276 1
		type = MiniPanel(Edit,AnimFXPL,TRUE);
d2278 1
a2278 1
	if(type==PAN_EXPERT)
d2318 2
a2319 2
		type = MiniPanel(Edit,XPAnimFXPL,FALSE);
		if(!Matte) XPAnimFXPL[6].Type = PNL_POPUP;
d2321 17
d2351 1
d2376 2
a2377 2
	t_In=36,t_Out=69,type=PanType,Time,S=0,SP[12]={36,69,0,0},AudioOn=1;
	char Label[MAX_PANEL_STR]="Audio Clip: ", *pan[]={"L","R"};
d2394 3
d2398 2
d2436 1
a2436 2
	if(type==PAN_EASY)
	{
d2440 1
a2440 1
//		AudClipPL[0].UserFun=CTRL_Play;
d2443 16
a2458 14
		AudClipPL[2].Param = &t_In;
		AudClipPL[2].Param2 = &t_Out;
		AudClipPL[2].PropStart = 0;
		AudClipPL[2].PropEnd = A-2;  // Min length= 1 colorframe
		AudClipPL[2].Flags = PL_IN | PL_AUD1 | PL_DUAL;

		AudClipPL[4].Param = &S;
		AudClipPL[4].PropStart = 0;
		AudClipPL[4].PropEnd = MAX_DELAY;
		AudClipPL[4].Flags = PL_DEL;

		AudClipPL[5].Param = AudClipPL[2].Param2; // out
		AudClipPL[5].Param2 = AudClipPL[2].Param; // in
		AudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...
a2459 4
		type = Panel(Edit,AudClipPL,TRUE);
	}
	if(type==PAN_EXPERT)
	{
d2464 1
a2464 1
//		XPAudClipPL[0].UserFun=CTRL_Play;
d2467 11
a2477 9
		XPAudClipPL[2].Param = &t_In;
		XPAudClipPL[2].Param2 = &t_Out;
		XPAudClipPL[2].PropStart = 0;
		XPAudClipPL[2].PropEnd = A-2;
		XPAudClipPL[2].Flags = PL_IN | PL_AUD1 | PL_DUAL;

		XPAudClipPL[4].Param = XPAudClipPL[2].Param2; // out
		XPAudClipPL[4].Param2 = XPAudClipPL[2].Param; // in
		XPAudClipPL[4].G5 =(struct Gadget *) 2; // diff add-on...
d2514 14
a2527 3
		type = Panel(Edit,XPAudClipPL,FALSE);
	}
	if(type==PAN_CONTINUE)
d2546 1
d2549 1
a2549 1
	else if(type==PAN_CANCEL)
d2567 2
a2568 2
		type=PanType,SP[16]={36,69,0,36},AudioOn=1;
	char Label[MAX_PANEL_STR]="Video Clip: ",*pan[]={"L","R"};
d2588 2
d2629 1
a2629 1
	if(type==PAN_EASY)
d2647 2
d2656 1
a2656 1
		type = Panel(Edit,ClipPL,TRUE);
d2669 1
d2671 1
a2671 1
	if(type==PAN_EXPERT)
d2689 2
d2701 2
a2702 2
			type = Panel(Edit,XPClipPL,FALSE);
			XPClipPL[7].Type = PNL_DIVIDE;
d2734 1
a2734 1
			type = Panel(Edit,XPClipPL,FALSE);
d2738 30
d2776 2
d2813 1
a2813 1
	if(type==PAN_EASY)
d2821 1
a2821 1
		type = MiniPanel(Edit,VideoPL,TRUE);
d2823 1
a2823 1
	if(type==PAN_EXPERT)
d2831 1
a2831 1
		type = MiniPanel(Edit,XPVideoPL,FALSE);
d2833 13
d2882 1
a2882 1
		type = MiniPanel(Edit, FramePL,FALSE);
d2898 2
a2899 1
	LONG A=0,B=2,t_In,t_Out,type=PanType,Speed=1,Time=69,DLay=12,FadeIn=15,FadeOut=15;
d2916 2
a2917 1

d2919 1
a2919 1
	if(type==PAN_EASY)
d2935 1
a2935 1
		type = MiniPanel(Edit, KeyPL,TRUE);
d2937 1
a2937 1
	if(type==PAN_EXPERT)
d2963 1
a2963 1
		type = MiniPanel(Edit, XPKeyPL,FALSE);
d2965 16
d3006 1
d3050 1
a3050 1
		type = MiniPanel(Edit, CrawlPL,FALSE);
d3101 1
a3101 1
		type = MiniPanel(Edit, ScrollPL,FALSE);
d3122 1
a3122 1
	if(FlyerDriveCount && (FVI=GetFlyerInfo(FlyerDrives[0])))
d3250 1
a3250 1
		type = MiniPanel(Edit, ErrorPL,TRUE);
d3283 1
a3283 1
		type = Panel(Edit, XPTestPL,FALSE);
d3367 1
a3367 2
//				if(result=Panel(Edit,FileInfoPL,FALSE))
				if( result=(MiniPanel(Edit,FileInfoPL,FALSE) ? 1:0) )
@


2.98
log
@Add RexxPanel tags..
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.97 1994/11/16 15:13:23 CACHELIN4000 Exp CACHELIN4000 $
* $Log: Controls.c,v $
d1001 1
a1001 1
	"Synchronous",
d2007 1
a2007 1
		ow=w=GetValue(FG,TAG(Synchronous));
d2021 1
a2021 1
		PutValue(FG,TAG(Synchronous),w);
@


2.97
log
@Fix I/O point swap bug, add Rexx panel, make things far static to help linker (?)
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.96 1994/11/15 21:41:24 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d325 1
a325 1
//#define SERDEBUG	1
d422 1
a422 1
far char RexxArgs[COMMENT_MAX+1],*Waits[]={"Wait for Return",""};
d574 1
a574 1
	TOGGLE_LINE(PNL_CENTER,"",0 ),
d834 25
a858 14
  DoFXALGOPanel,
//  DoFXANIMPanel,
  DoFXILBMPanel,
  DoFXALGOPanel,
  DoFXCRPanel,
  DoVIDEOPanel,
  DoAUDIOPanel,
  DoCONTROLPanel,
  NULL,		// DoPROJECTPanel,
  DoFRAMESTOREPanel,
  DoKEYPanel,
  DoSCROLLPanel,
  DoCRAWLPanel,
	DoERRORPanel,
d896 1
a896 1
	"pad1",
d986 1
a986 1
	"pad2",
d992 8
d2000 1
a2000 1
	ULONG w=0;
d2004 2
a2005 1
//		GetTable(FG,TAG_RexxArgs,Args,COMMENT_MAX);
d2009 1
d2015 4
d3216 1
a3216 1
	for(i=CR_FXANIM; i<= CR_CRAWL; i++)
d3226 2
a3227 1
#define VALID_CTYPE(t)		((t<=CR_ERROR)&&(t>=CR_FXANIM))
d3251 2
d3255 1
@


2.96
log
@Fix initial clip length bug
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.95 1994/11/10 00:31:47 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d358 1
a358 1
struct	AudioSet	CurAudioSet={0,0,0};
d361 1
a361 1
UBYTE CommentBuf[COMMENT_MAX+1];	//The Get/PutTable commands need an EVEN length!!!!!
d363 1
a363 1
char Size[20],Name[120]="Clip.0",Dir[120];
d368 1
a368 1
struct Hack
d393 1
a393 1
UBYTE
d419 2
d450 23
a472 3
struct PanelLine MakePL[PNL_MAX] = {
	TEXT_LINE(PNL_CENTER,"Panel Maker",0),
	STRING_LINE(PNL_LEFT,"Title",0),
d474 3
a476 1
	TEXT_LINE(PNL_CENTER,"<Title>",0),
d478 1
a478 3
	POPUP_LINE(PNL_RIGHT,"Add Gadget",0 ),
	LAST_LINE
};
d480 1
a480 1
struct PanelLine SetupPL[PNL_MAX] = {
d493 1
a493 1
struct PanelLine TweakPL[PNL_MAX] = {
d507 1
a507 1
struct PanelLine ErrorPL[PNL_MAX] = {
d518 1
a518 1
struct PanelLine RawRecPL[PNL_MAX] = {
d537 1
a537 1
struct PanelLine MarkClipPL[PNL_MAX] = {
d553 1
a553 1
struct PanelLine FileInfoPL[] = {
d567 9
a575 1
struct PanelLine FramePL[] = {
d583 1
a583 1
struct PanelLine VideoPL[] = {
d594 1
a594 1
struct PanelLine XPVideoPL[] = {
d603 1
a603 1
struct PanelLine EffectPL[] = {
d614 1
a614 1
struct PanelLine XPEffectPL[] = {
d627 1
a627 1
struct PanelLine AnimFXPL[] = {
d638 1
a638 1
struct PanelLine XPAnimFXPL[] = {
d651 1
a651 1
struct PanelLine ClipPL[] = {
d665 1
a665 1
struct PanelLine XPClipPL[] = {
d685 1
a685 1
struct PanelLine AudClipPL[] = {
d696 1
a696 1
struct PanelLine XPAudClipPL[] = {
d721 1
a721 1
struct PanelLine KeyPL[] = {
d730 1
a730 1
struct PanelLine XPKeyPL[] = {
d744 1
a744 1
struct PanelLine CrawlPL[] = {
d755 1
a755 1
struct PanelLine ScrollPL[] = {
d766 1
a766 1
struct PanelLine TestPL[] = {
d784 1
a784 1
struct PanelLine TestPL3[] = {
d800 1
a800 1
struct PanelLine TestPL2[] = {
d816 1
a816 1
struct PanelLine XPTestPL[] = {
d830 1
a830 1
PanHandler	PanHandlers[] = {
d852 1
a852 1
UBYTE *TagName[] = {
d1810 52
d1933 1
d1975 19
d1999 1
d2484 6
a2489 2
		ClipPL[5].Param2 = &t_In;
		ClipPL[5].Param = &t_Out;
a2492 4

		ClipPL[3].Param = ClipPL[5].Param2; // out
		ClipPL[3].Param2 = ClipPL[5].Param; // in
		ClipPL[3].G5 = (struct Gadget *)2; // diff
@


2.95
log
@Remove FlyerIn, FlyerY/C sources from popup..
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.94 1994/11/10 00:10:47 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d2378 2
a2379 2
		ClipPL[5].Param = &t_In;
		ClipPL[5].Param2 = &t_Out;
@


2.94
log
@Implement Audio source channels popup, CTRL_SetPan
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.93 1994/11/09 18:50:38 CACHELIN4000 Exp CACHELIN4000 $
d4 3
d1006 1
d1008 1
a1008 1
		ESparams3.Data1 = pl->PropStart+1;
@


2.93
log
@Fix New Audio Balance/Volume system... i hope
@
text
@@


2.92
log
@More MessinG around...
@
text
@d2 5
a6 2
* $Id: COntrols.c,v 2.90 94/11/04 17:19:15 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	COntrols.c,v $
d310 1
a310 1
#define SERDEBUG	1
d332 1
a332 1
#define	AMODE_RIGHT	2
a1061 25
// Return Balance (0-0xFFFF), from v1,v2,balance,etc.
ULONG	GetBalance(struct AudioSet	*aud)
{
	ULONG	V;
	UWORD R,L;

	if(!aud) return(0);
	if(!(V=MAX(aud->V1,aud->V2))) return(MAXPOT>>1);

	if(aud->V1<aud->V2)
	{
		V=aud->V1*MAXPOT/aud->V2; // Scale up to full Volume
		L=V/2;
		R=MAXPOT-L;
	}
	else 	if(aud->V1>aud->V2) {
		V=aud->V2*MAXPOT/aud->V1; // Scale up to full Volume
		R=V/2;
		L=MAXPOT-R;
	}  // V1==V2
	else R = L = MAXPOT>>1;
	R &= 0x0000FFFF;
	return(aud->Balance=R);
}

a1062 1

d1074 1
a1074 1
	if(R>=L)  // Scale balance to 100% volume (0xFFFF)
d1080 1
a1080 1
	else {
d1084 8
d1094 1
a1094 1
	if(pl->Flags&PL_AUD1)
d1097 1
a1097 1
	if(pl->Flags&PL_AUD2)
d1102 25
d1131 1
a1131 1
	ULONG	Y;
d1135 2
d1138 9
a1146 1
	if(R!=MAXPOT>>1)
d1149 3
a1151 12
		if(R>=L)  // Scale balance to 100% volume (0xFFFF)
		{
			Y=L*MAXPOT;
			L=Y/R;
			R=MAXPOT;
		}
		else {
			Y=R*MAXPOT;
			R=Y/L;
			L=MAXPOT;
		}
		aud->V2= ((R*(aud->Volume))/100)&0x0000FFFF;
a1152 1
		aud->V1= ((L*(aud->Volume))/100)&0x0000FFFF;
d1156 3
a1158 3
		aud->V1 = aud->V2 = ((MAXPOT*(aud->Volume))/100)&0x0000FFFF;
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume2),aud->V2);
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume1),aud->V1);
d1160 1
a1160 1
	return(Y);
d3041 1
a3041 1
	if( FlyerBase && (IntuiMsg->Qualifier&(IEQUALIFIER_CONTROL|IEQUALIFIER_LALT)) )
@


2.91
log
@check-in file so make will work.. i hope.
@
text
@d2287 1
a2287 1
	V=GetVolume(&CurAudioSet);
@


2.90
log
@Remove Rename from fileinfo, fix audio panel, etc.
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.89 94/11/04 00:31:17 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d307 1
a307 1
//#define SERDEBUG	1
d327 17
d397 1
a397 1
	*Channels[] ={ "Right" , "Left"},
d656 2
a657 1
	TEXT_LINE(PNL_LEFT,"",0 ),
d931 1
a931 1
	"" };
d1034 52
a1085 2
// Volume control function, object is FastGadget
// *PLine->Param2 is Balance PLine (%)
d1088 1
a1088 1
	struct PanelLine *Bal=(struct PanelLine *)pl->Param2;
d1092 1
a1092 1
	if(Bal)
d1094 1
a1094 1
		R = ((struct PropInfo *)Bal->PropGadg->SpecialInfo)->HorizPot;
d1108 1
a1108 1
	Y=(R*(*pl->Param))/100;
d1110 2
a1111 2
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume2),Y&0x0000FFFF);
	Y=(L*(*pl->Param))/100;
d1113 1
a1113 1
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume1),Y&0x0000FFFF);
d1117 1
a1117 2
// Fake balance Volume control function, object is FastGadget,
// *PLine->Param is overall volume (%)
d1120 1
d1124 2
a1125 1
	R = ((struct PropInfo *)pl->PropGadg->SpecialInfo)->HorizPot;
d1140 4
a1143 4
		Y=(R*(*pl->Param))/100;
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume2),Y&0x0000FFFF);
		Y=(L*(*pl->Param))/100;
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume1),Y&0x0000FFFF);
d1146 3
a1148 3
		Y=(MAXPOT*(*pl->Param))/100;
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume2),Y&0x0000FFFF);
		PutValue((struct FastGadget *)Obj,TAG(AudioVolume1),Y&0x0000FFFF);
d1153 1
a1153 1
// Set clip pan, for channel 0 or 1 object is FastGadget
d1157 1
d2070 4
a2073 2
			PutValue(FG,TAG(AudioPan1),-1);
			PutValue(FG,TAG(AudioPan2),1);
d2077 3
a2079 2
			PutValue(FG,TAG(AudioPan1),0);
			PutValue(FG,TAG(AudioPan2),0);
d2082 1
d2086 1
d2089 6
a2094 2
		C=MAXPOT/V;
		P=(C*(V2-V1) + MAXPOT)>>1;
d2098 3
d2102 6
d2109 2
d2160 5
a2164 1
		XPAudClipPL[7].Param = &V;
d2170 1
a2170 1
		XPAudClipPL[7].UserObj=(APTR)FG;
d2177 1
a2177 1
		XPAudClipPL[9].Param =&V;
d2179 1
a2179 1
		XPAudClipPL[9].PropStart = P;
d2181 1
a2181 1
		XPAudClipPL[9].UserObj=(APTR)FG;
d2263 4
a2266 2
			PutValue(FG,TAG(AudioPan1),-1);
			PutValue(FG,TAG(AudioPan2),1);
d2270 3
a2272 2
			PutValue(FG,TAG(AudioPan1),0);
			PutValue(FG,TAG(AudioPan2),0);
d2281 8
a2288 7
	if( C && (Vol=MAX(V1,V2)) )
	{
		C=MAXPOT/Vol;
		P=(C*(V2-V1) + MAXPOT)>>1;
		Vol = ((Vol+1)*100)/MAXPOT;
	}
	else P=MAXPOT>>1;
d2368 1
a2368 1
			XPClipPL[10].Param = &Vol;
d2374 1
a2374 1
			XPClipPL[10].UserObj=(APTR)FG;
d2380 1
a2380 1
			XPClipPL[12].Param = &Vol; // Overall volume control for "Balance"
d2382 1
a2382 1
			XPClipPL[12].PropStart = P;
d2384 1
a2384 1
			XPClipPL[12].UserObj=(APTR)FG;
@


2.89
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.88 94/11/03 23:11:36 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d623 1
a623 1
	EZLEN_LINE(PNL_CENTER,"Start Time",1),
d635 1
a635 1
	EZLEN_LINE(PNL_LEFT,"Start Time",0),
d1115 2
d1118 1
d1124 2
d1732 1
a1732 1
#define MAX_DELAY 18   // !!! arbitrary Delay Limit
d2013 1
a2016 1
	V = ((V+1)*100)/MAXPOT;
d2023 1
a2023 1
		AudClipPL[0].UserFun=CTRL_Play;
a2031 4
		AudClipPL[5].Param = AudClipPL[2].Param2; // out
		AudClipPL[5].Param2 = AudClipPL[2].Param; // in
		AudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...

d2037 4
d2049 1
a2049 1
		XPAudClipPL[0].UserFun=CTRL_Play;
a2109 4
		if( V1 != (SP[7]*100)/0xFFFF)
			PutValue(FG,TAG(AudioVolume1),(V1*0xFFFF)/100);
		if( V2 != (SP[8]*100)/0xFFFF)
			PutValue(FG,TAG(AudioVolume2),(V2*0xFFFF)/100);
d2185 1
a2188 2
	Vol = ((Vol+1)*100)/MAXPOT;

d2198 1
a2198 1
		ClipPL[1].UserFun=CTRL_Play;
d2237 1
a2237 1
		XPClipPL[1].UserFun=CTRL_Play;
d2785 1
a2785 1
BOOL __asm DoInfoPanel(
d2794 1
a2794 1
	BOOL Success = FALSE,result=FALSE;
d2859 1
a2859 1
				if(result=MiniPanel(Edit,FileInfoPL,FALSE))
d2872 1
a2872 1
							if ( !(Success=Rename(Path,Dir)) )
d2881 4
a2891 1
								DoAllNewDir(Edit);
a2893 1
				Success = TRUE;
@


2.88
log
@CTRL_Play(), remove record tracks toggle, fix CTRL_SetSource, etc.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.87 94/11/03 11:08:07 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d301 1
a301 1
#define SERDEBUG	1
@


2.87
log
@Limit Coarse tweak to 0-9, not 0-15
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.86 94/11/02 20:23:11 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d298 1
a298 1
//#define SERDEBUG	1
d305 1
a305 1
extern struct FastGadget *CurFG;
d322 1
a322 1
ULONG CurFlyDrive=0,CurFlySource=0,CurFlyTracks=7;
d367 3
a369 2
	*Tracks[] = {"Video","Audio","Time Code",""},
	*Sources[] = {"Flyer In","Flyer Y/C","Input 1","Input 2","Main Out",""},
d456 1
a456 1
	TOGGLE_LINE(PNL_CENTER,"Tracks:",0),
d581 1
a581 1
	TEXT_LINE(PNL_LEFT,"",0),
d595 1
a596 1
	TEXT_LINE(PNL_LEFT,"Comment: ",0),
d967 7
a973 5
	CurFlySource = pl->PropStart;
	ESparams3.Data1 = pl->PropStart+1;
	DUMPUDECL("SetSource( ",pl->PropStart+1," ) \\");
	ESparams3.Data2 =(LONG) 0xFFFF;
	ESparams3.Data3 =(LONG) 0xFFFF;
d1091 20
a1110 1
		SendSwitcherReply(ES_Auto,NULL);
d1112 2
d1115 1
d1273 2
a1296 1

d1322 1
a1323 1
// Set clip volume, for channel 0 or 1
d1952 2
d2012 2
d2038 2
d2066 1
a2066 1
		XPAudClipPL[8].PropEnd = A-2;
d2077 1
a2077 1
		XPAudClipPL[10].PropEnd = A-2;
a2185 1
		ClipPL[2].Label = ""; // Label;
d2192 2
d2195 3
a2224 1
		XPClipPL[3].Label = "";
d2231 5
d2237 4
a2246 4
		XPClipPL[2].Param = XPClipPL[5].Param2; // out
		XPClipPL[2].Param2 = XPClipPL[5].Param; // in
		XPClipPL[2].G5 = (struct Gadget *)2; // diff

d2271 1
a2271 1
			XPClipPL[11].PropEnd = A-2;
d2281 1
a2281 1
			XPClipPL[13].PropEnd = A-2;
d2617 1
d2620 1
a2620 1
			RawRecPL[2].PropEnd = 3;
d2622 1
a2622 1
/*
d2668 1
d2670 1
a2670 1
			RawRecPL[9].PropEnd = 5;
@


2.86
log
@fix Balance/Volume setting, lack of render after DHD_Jog message,
monaural audio clip support with Pan, even volumes losing 1
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.85 94/11/01 18:57:35 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 4
d1615 1
a1615 1
	TweakPL[5].PropEnd=15;
@


2.85
log
@Backup Tweak values..
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.84 94/10/31 17:22:17 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d998 1
d1001 1
d1003 19
a1021 2
	Y = *pl->Param*0xFFFF;
	Y /= (pl->PropEnd - pl->PropStart);
d1024 1
d1030 1
a1030 13
// Set clip pan, for channel 0 or 1 object is FastGadget
ULONG __asm CTRL_SetPan(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
{
	ULONG	Y;
	Y = *pl->Param*0xFFFF;
	if(pl->Flags&PL_AUD1)
		PutValue((struct FastGadget *)Obj,TAG(AudioPan2),Y&0x0000FFFF);
	else if(pl->Flags&PL_AUD2)
		PutValue((struct FastGadget *)Obj,TAG(AudioPan1),Y&0x0000FFFF);
	return(Y);
}

// Fake balance Volume control function, object is FastGadget, 
d1038 1
a1038 2
	L=MAXPOT-R;
	if(R>=L)  // Scale balance to 100% volume (0xFFFF)
d1040 16
a1055 2
		L*=(MAXPOT/R);
		R=MAXPOT;
d1058 3
a1060 2
		R*=(MAXPOT/L);
		L=MAXPOT;
d1062 12
a1073 4
	Y=(R*(*pl->Param)/100);
	PutValue((struct FastGadget *)Obj,TAG(AudioVolume2),Y&0x0000FFFF);
	Y=(L*(*pl->Param)/100);
	PutValue((struct FastGadget *)Obj,TAG(AudioVolume1),Y&0x0000FFFF);
d1496 3
d1922 2
a1923 2
	LONG FadeIn=0,FadeOut=0,V=100,P=0,V1=0xFFFF,V2=0x4000,A=800,t_In=36,t_Out=69,type=PanType,Time,
		S=0,SP[12]={36,69,0,0},AudioOn=1;
d1945 3
a1947 5
    FadeIn = SP[5] >>1;
    FadeOut= SP[6] >>1;
    S = SP[2] >>1;
		PutValue(FG,TAG(AudioPan1),-1);
		PutValue(FG,TAG(AudioPan2),1);
d1949 11
d1962 10
a1971 3
	if(V=(100*MAX(V1,V2))/0xFFFF)
		P=(100*V2)/V;
	else V=MAXPOT>>1;
a1997 1
//		P1=0x0000; P2=0xFFFF;
d2018 1
d2085 1
a2085 1
	LONG Vol=100,OldVol,V1=100,V2=100,A=800,B=0,C,t_In=36,t_Out=69,A_In,A_Out,AFade_In=0,AFade_Out=0,
a2087 1
	// *tog[]={"Play Audio ","Show Video "}
a2105 2
//		SP[13] = GetValue(FG,TAG(AudioPan1));
//		SP[14] = GetValue(FG,TAG(AudioPan2));
d2107 1
a2107 4
		C=(AudioOn&AUD_ENABLE ? 1:0); // Audio Toggle
		OldVol=Vol=(1+MAX(V1,V2)*100)/0xFFFF;
		V1=(V1*100)/0xFFFF;
		V2=(V2*100)/0xFFFF;
d2112 1
a2112 1
		SP[2] = B     =((GetValue(FG,TAG(FadeInVideo)) !=0) ? 0:1); // FadeIn flag
d2118 11
a2128 2
		PutValue(FG,TAG(AudioPan1),-1);
		PutValue(FG,TAG(AudioPan2),1);
d2135 9
a2164 14
/* 		if(AudioOn&AUD_EXISTS)
		{
			ClipPL[8].Param=(long *)C;
			ClipPL[8].Param2=(long *)tog;
			ClipPL[8].PropEnd = 1;
			ClipPL[8].Flags = (AudioOn&AUD_CH1_EXISTS) ? PL_AUD1:0;
			ClipPL[8].Flags |= (AudioOn&AUD_CH2_EXISTS) ? PL_AUD2:0;
		}
		else
		{
			ClipPL[8].Type=PNL_SKIP;
			ClipPL[7].Type=PNL_SKIP;
		}
*/
a2165 9

/*
		DUMPHEXIL("Aud Bits: ",(long)ClipPL[8].Param,"\\");
		if(!(AudioOn&AUD_EXISTS))
		{
			ClipPL[8].Type=PNL_TOGGLE;  // reset for next call !!
			ClipPL[7].Type=PNL_DIVIDE;
		}
*/
a2177 1
//		C=(LONG)ClipPL[8].Param;
a2199 6
		if(!C)
		{
			V2=0;
			V1=0;
		}

d2214 2
a2215 1
			XPClipPL[10].Param = &V1;
d2226 1
a2226 10
/*
			XPClipPL[12].Param = &V2;
			XPClipPL[12].PropStart = 0;
			XPClipPL[12].PropEnd = 100;
			XPClipPL[12].Flags = PL_AUD2 ;
			XPClipPL[12].UserFun=CTRL_SetVolume;
			XPClipPL[12].UserObj=(APTR)FG;
*/

			XPClipPL[12].Param = &V1; // Overall volume control for "Balance"
d2228 1
a2228 2
			XPClipPL[12].PropStart = 0;
			XPClipPL[12].PropEnd = 100;
a2255 2
//		PutValue(FG,TAG(AudioPan1),			SP[13]);
//		PutValue(FG,TAG(AudioPan2),			SP[14]);
d2258 3
a2260 1
		PutValue(FG,TAG(AudioOn),AudioOn);
@


2.84
log
@Re-Do Tweak panel, etc.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.83 94/10/28 16:52:01 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d315 3
a317 1
struct Hack	HackA={HACK_TWEAK,HKF_PLAY_A,-29,1,14,7,0,0,60},*Hack=&HackA,
d321 6
a326 1
		*Hacks[]={&HackA,&HackB,&HackC,&HackD};
d359 1
a359 1
	*Tweaks[] ={ "Play A","Play B","Record A","Record B","Rec. Test"},
d1541 1
a1541 1
	int i;
d1543 1
a1543 1
	for(i=0;i<3;i++)
d1550 1
d1557 1
a1557 1
	TweakPL[2].PropEnd=3;
d1593 11
a1603 1
	MiniPanel(Edit,TweakPL,FALSE);
d1912 2
@


2.83
log
@Add Pedestal preset to Tweak
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.82 94/10/28 15:25:40 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d316 1
a316 1
		*Hacks[]={&HackC,&HackD,&HackA,&HackB};
d349 1
a349 1
	*Tweaks[] ={ "Record A","Record B","Play A","Play B","Rec. Test"},
d378 1
a378 1
#define PLAY_LINE(j,l,w) {PNL_PLAY,j,l,w,0,0,0,0,CreatePlayPL,DrawPlayPL,NULL,DestroyPlayPL}
d415 1
a415 1
	EZNUM_LINE(PNL_CENTER, "Pedestal",0),
d563 1
a563 1
	DUOSLIDE_LINE(PNL_LEFT,"Video Trim",0),
d597 1
a597 1
	DIFF_LINE(PNL_LEFT,"Duration: ",0),
d607 9
a615 4
	EZLEN_LINE(PNL_CENTER,"Start Time",1),
	DIFF_LINE(PNL_LEFT,"Duration: ",0),
	DIVIDE_LINE(PNL_LEFT,"Fine Tune ",0 ),
	EZLEN_LINE(PNL_LEFT,"Fade In",1),
d617 5
a621 4
	EZNUM_LINE( PNL_CENTER, "Ch.1:   Level ",1),
	EZSLIDER_LINE( PNL_LEFT, "",0),
	EZNUM_LINE( PNL_CENTER, "Ch.2:   Level ",1),
	EZSLIDER_LINE( PNL_LEFT, "",0),
d727 1
a727 1
	TOGGLE_LINE(PNL_CENTER,"Test Panel? ",0),
d920 3
a922 3
		TweakPL[7].Param = &(Hack->hk_Pedestal);
		TweakPL[7].UserObj=(APTR)Hack;
		UpdatePanStr(&(TweakPL[7]),pl->Win);
d992 1
a992 1
	else if(pl->Flags&PL_AUD2)
d1033 11
d1531 1
a1531 1

d1533 8
d1544 1
d1546 1
a1546 1
	TweakPL[2].PropEnd=4;
d1572 5
a1576 5
	TweakPL[7].Param = &(Hack->hk_Pedestal) ;	// EZ_NUM
	TweakPL[7].UserFun =CTRL_Hack;
	TweakPL[7].UserObj=(APTR)Hack;
	TweakPL[7].PropStart=0;
	TweakPL[7].PropEnd=255;
d1865 2
a1866 2
	LONG FadeIn=0,FadeOut=0,V1,V2,A=800,t_In=36,t_Out=69,type=PanType,Time,
		S=0,SP[12]={36,69,0,0},P1,P2,AudioOn=1;
d1868 1
a1869 1

a1883 4
		V1=(V1*100)/0xFFFF;
		V2=(V2*100)/0xFFFF;
		SP[9]  = P1 = GetValue(FG,TAG(AudioPan1));
		SP[10] = P2 = GetValue(FG,TAG(AudioPan2));
d1891 1
a1891 1
//		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1894 3
a1927 4
		XPAudClipPL[5].Param = XPAudClipPL[3].Param; // out
		XPAudClipPL[5].Param2 = XPAudClipPL[2].Param; // in
		XPAudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...

d1934 3
a1936 4
		XPAudClipPL[4].Param = &S;
		XPAudClipPL[4].PropStart = 0;
		XPAudClipPL[4].PropEnd = MAX_DELAY;
		XPAudClipPL[4].Flags = PL_DEL;
d1938 6
a1943 1
		XPAudClipPL[7].Param = &FadeIn;
d1945 4
a1948 2
		XPAudClipPL[7].PropEnd = A-2;
		XPAudClipPL[7].Flags = PL_AUD1;  // means Attack on EZLen types
d1950 1
a1950 1
		XPAudClipPL[8].Param = &FadeOut;
d1953 1
a1953 1
		XPAudClipPL[8].Flags = PL_AUD2;  // means Decay on EZLen types
d1955 4
a1958 5
		XPAudClipPL[9].Param = &V1;
		XPAudClipPL[9].PropStart = 0;
		XPAudClipPL[9].PropEnd = 100;
		XPAudClipPL[9].Flags = PL_AUD1;
		XPAudClipPL[9].UserFun=CTRL_SetVolume;
d1961 4
a1964 20
		XPAudClipPL[10].Param = &P1;
		XPAudClipPL[10].Param2 =(long *) pan;
//		XPAudClipPL[10].PropStart = -32768; // propstart,end ignored on EZSlider
//		XPAudClipPL[10].PropEnd = 32767;  // param = Horizpot - (MAXPOT/2)
		XPAudClipPL[10].Flags = PL_AUD1;
		XPAudClipPL[10].UserFun=CTRL_SetPan;
		XPAudClipPL[10].UserObj=(APTR)FG;

		XPAudClipPL[11].Param = &V2;
		XPAudClipPL[11].PropStart = 0;
		XPAudClipPL[11].PropEnd = 100;
		XPAudClipPL[11].Flags = PL_AUD2;
		XPAudClipPL[11].UserFun=CTRL_SetVolume;
		XPAudClipPL[11].UserObj=(APTR)FG;

		XPAudClipPL[12].Param = &P2;
		XPAudClipPL[12].Param2 =(long *) pan;
		XPAudClipPL[12].Flags = PL_AUD2;
		XPAudClipPL[12].UserFun=CTRL_SetPan;
		XPAudClipPL[12].UserObj=(APTR)FG;
d2000 2
a2001 2
		PutValue(FG,TAG(AudioPan1),			SP[9]);
		PutValue(FG,TAG(AudioPan2),			SP[10]);
d2160 1
a2160 1
			XPClipPL[10].Flags = PL_AUD1 ;
d2181 1
a2181 2
			XPClipPL[12].Flags = PL_AUD2 ;
			XPClipPL[12].UserFun=NULL; // CTRL_SetBalance;
d2649 2
a2650 2
	char Mystr[50]="Aboud's",*ts="Test"; //,*LR[]={"L","R"};
	long	D=98,type=PAN_EXPERT;
d2666 2
a2667 3
	XPTestPL[5].Param = (long *)1;			// TOGGLE
	XPTestPL[5].Param2 =(long *)&ts ;
	XPTestPL[5].PropEnd = 1;
@


2.82
log
@fix reversed Hack array
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.81 94/10/28 11:57:26 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d309 6
a314 4
struct Hack	HackA={HACK_TWEAK,HKF_PLAY_A,-22,2,15,7},*Hack=&HackA,
		HackB={HACK_TWEAK,HKF_PLAY_B,-22,2,15,7},
		HackC={HACK_TWEAK,HKF_RECORD_A|HKF_TESTREC,19,3,15,3},
		HackD={HACK_TWEAK,HKF_RECORD_B|HKF_TESTREC,19,3,15,3},*Hacks[]={&HackC,&HackD,&HackA,&HackB};
@


2.81
log
@Fix Audio Fade bug.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.80 94/10/27 23:45:14 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d309 1
a309 1
		HackD={HACK_TWEAK,HKF_RECORD_B|HKF_TESTREC,19,3,15,3},*Hacks[]={&HackA,&HackB,&HackC,&HackD};
@


2.80
log
@Buffer Tweak panel, re-do VidClip controls to meet new spec, add CTRL_SetBalance
change PLine User-Function names to start with CTRL_ not DHD_
@
text
@d2 6
a7 2
* $Id: COntrols.c,v 2.79 94/10/25 20:01:18 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	COntrols.c,v $
d2175 1
a2175 1
			PutValue(FG,TAG(AudioAttack),		AFade_In);
d2177 1
a2177 1
			PutValue(FG,TAG(AudioDecay),		AFade_Out);
@


2.79
log
@extend Tweak panel, check flyerbase before finding drives...
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.78 94/10/25 18:08:29 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d299 4
a302 1
struct Hack	MyHack={HACK_TWEAK,HKF_PLAY_A,0,0,0},*Hack=&MyHack;
d312 1
a312 1
#define PNL_NUM	14
d330 1
a330 1
		"PROJECT","FRAMESTORE","KEY","SCROLL","CRAWL","ERROR","RAWREC","MARKCLIP",""},
d401 1
a401 1
	TOGGLE_LINE(PNL_CENTER, "",0),
d550 2
a551 2
	DIVIDE_LINE(PNL_LEFT,"Audio ",0),
	TOGGLE_LINE(PNL_CENTER,0,0),
d567 1
a567 1
	EZNUM_LINE(  PNL_CENTER, "L Volume",1),
d569 1
a569 1
	EZNUM_LINE(  PNL_CENTER, "R Volume",1),
d702 1
a702 1
	DIVIDE_LINE(PNL_LEFT,"Whacko!",0 ),
d706 1
a706 7
	TOGGLE_LINE(PNL_LEFT,"Test Panel? ",0),
	TIME_LINE(PNL_LEFT,"In",1),
	TIME_LINE(PNL_LEFT,"Out",0),
	FXSPEED_LINE(PNL_LEFT,"Speed",0),
	SLIDER_LINE(PNL_LEFT,"Slide",1),
	SLIDER_LINE(PNL_LEFT,"Slide",0),
	VCR_LINE(PNL_LEFT,0,0),
d730 2
a731 1
  DoNewClipPanel ,
d872 4
d877 1
a877 1
ULONG __asm DHD_RecTest(REG(a1) struct PanelLine *pl,REG(a0) struct Hack *hak)
d879 2
a880 1
	if(pl->PropStart<2)// if rectest chosen
d882 23
a904 7
		hak->hk_Flags = HKF_TESTREC|(pl->PropStart==0 ? HKF_RECORD_A:HKF_RECORD_B);
		DUMPMSG(pl->PropStart==0 ? "RecordTest(A)":"RecordTest(B)");
	}
	else
	{
		hak->hk_Flags = (pl->PropStart==2 ? HKF_PLAY_A:HKF_PLAY_B);
		DUMPMSG(pl->PropStart==2 ? "PlayTest(A)":"PlayTest(B)");
d906 1
a906 2

	ESparams1.Data1 =(LONG) hak;  // Hack ptr
d911 1
a911 1
ULONG	__asm DHD_Hack(REG(a1) struct PanelLine *pl, REG(a0) struct Hack *hack)
d913 2
a914 1
	DUMPMSG("DHD_Hack()");
d918 1
d922 2
a923 2
// Source popup f'n
ULONG __asm DHD_SetSource(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
d934 2
a935 2
// Drive popup f'n
ULONG __asm DHD_SetDrive(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
d954 2
a955 2
// Compression popup f'n
ULONG __asm DHD_SetCompression(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
d963 2
a964 1
ULONG __asm DHD_SetVolume(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
d976 2
a977 2
// Set clip pan, for channel 0 or 1
ULONG __asm DHD_SetPan(REG(a1) struct PanelLine *pl,REG(a0) APTR Obj)
d988 28
d1018 1
a1018 1
	if(FlyerBase) return;
d1498 1
a1498 1
	char *sh[]={"Shift",""};
d1502 1
a1502 1
	TweakPL[2].UserFun = DHD_RecTest;// Popup f'n
d1508 1
a1508 1
	TweakPL[3].UserFun = DHD_Hack;
d1514 1
a1514 1
	TweakPL[4].UserFun =DHD_Hack;
d1520 1
a1520 1
	TweakPL[5].UserFun =DHD_Hack;
d1526 1
a1526 1
	TweakPL[6].UserFun =DHD_Hack;
d1532 1
a1532 1
	TweakPL[7].UserFun =DHD_Hack;
d1537 3
a1539 3
	TweakPL[8].Param=(long *)Hack->hk_Shift;
	TweakPL[8].Param2=(long *)sh;
	TweakPL[8].PropEnd=1;
d1917 1
a1917 1
		XPAudClipPL[9].UserFun=DHD_SetVolume;
d1925 1
a1925 1
		XPAudClipPL[10].UserFun=DHD_SetPan;
d1932 1
a1932 1
		XPAudClipPL[11].UserFun=DHD_SetVolume;
d1938 1
a1938 1
		XPAudClipPL[12].UserFun=DHD_SetPan;
d1987 2
a1988 1
	char Label[MAX_PANEL_STR]="Video Clip: ",*tog[]={"Play Audio ","Show Video "};
d2007 2
a2008 2
		SP[13] = GetValue(FG,TAG(AudioPan1));
		SP[14] = GetValue(FG,TAG(AudioPan2));
d2024 2
a2025 2
		DUMPSDECL("In Point: ",t_In,"		");
		DUMPSDECL("Out Point: ",t_Out,"\\");
d2053 1
a2053 1
		if(AudioOn&AUD_EXISTS)
d2066 1
d2069 1
d2076 1
d2089 1
a2089 1
		C=(LONG)ClipPL[8].Param;
d2131 1
d2136 1
a2136 1
			XPClipPL[10].UserFun=DHD_SetVolume;
d2143 1
d2148 10
a2157 1
			XPClipPL[12].UserFun=DHD_SetVolume;
d2184 2
a2185 2
		PutValue(FG,TAG(AudioPan1),			SP[13]);
		PutValue(FG,TAG(AudioPan2),			SP[14]);
d2506 1
a2506 1
			RawRecPL[3].UserFun = DHD_SetCompression;
d2517 1
a2517 1
				RawRecPL[4].UserFun = DHD_SetDrive;
d2547 1
a2547 1
			RawRecPL[9].UserFun = DHD_SetSource;
d2625 2
a2626 2
	char Mystr[50]="Aboud's",*ts="Test",*LR[]={"L","R"};
	long	SP[20]={16,32,64,0},A=0,B=2,C,In=0,t_Out=498,D=98,type=PAN_EXPERT,E=50;
d2631 2
a2632 5
	CommentBuf[0]=0;
	TestPL[4].Param = (long *)Mystr;	// STRING
	TestPL[4].Param2 =(long *) 50;
	TestPL[5].Param = (long *)Mystr;	// STRING
	TestPL[5].Param2 =(long *) 50;
d2634 21
a2654 143
	TestPL[6].Param = (long *)Pops;		// POPUP
	TestPL[6].PropStart = 4;
	TestPL[6].PropEnd = 8;

	TestPL[7].Param = (long *)&D;			// NUMBER
	TestPL[7].PropStart = 0;  // min
	TestPL[7].PropEnd = 100;  // max

	TestPL[8].Param = (long *)7;			// TOGGLE
	TestPL[8].Param2 =(long *)Names ;
	TestPL[8].PropEnd = 5;

//	TestPL[10].Param = (long *)&In;			// EZTIME
//	TestPL[10].PropStart = 0;
//	TestPL[10].PropEnd = 500;
	TestPL[10].Param = (long *)&t_Out; // DIFF
	TestPL[10].Param2 = (long *)&In;

	TestPL[9].Param = (long *)&In;
	TestPL[9].Param2 = (long *)&t_Out;  // DUOSLIDE
	TestPL[9].PropStart = 0;
	TestPL[9].PropEnd = 500;
	TestPL[9].Flags = PL_FLYER;


	if(PAN_CANCEL!=(type=Panel(Edit, TestPL,TRUE)))
  {
		TestPL2[0].Param = (long *)CommentBuf;

		TestPL2[1].Param = (long *)&B;			// FXSPEED
		TestPL2[1].Param2 = (long *)SP;
		TestPL2[1].PropStart = (long)&TestPL2[4];		// PLine (time) to update
		TestPL2[1].PropEnd = 500;

		TestPL2[2].Param = (long *)&A;			// SLIDER
		TestPL2[2].PropStart = 0;
		TestPL2[2].PropEnd = 100;

		TestPL2[3].Param = (long *)7;			// TOGGLE
		TestPL2[3].Param2 =(long *)Names ;
		TestPL2[3].PropEnd = 5;
		TestPL2[4].Param = (long *)&In;			// TIME
		TestPL2[4].PropStart = 0;
		TestPL2[4].PropEnd = 500;
		TestPL2[5].Param = (long *)&t_Out;			// TIME
		TestPL2[5].PropStart = 0;
		TestPL2[5].PropEnd = 500;

		TestPL2[6].Param = (long *)&In;			// DIFF
		TestPL2[6].Param2 = (long *)&t_Out;
		TestPL2[7].Param = (long *)&In;			// DIFF
		TestPL2[7].Param2 = (long *)&t_Out;
		if(PAN_CANCEL!=(type=Panel(Edit, TestPL2,TRUE)))
  	{
			TestPL3[1].Param = (long *)&E;

			TestPL2[0].Param = (long *)&CommentBuf[0];

			TestPL3[2].Label = "";
			TestPL3[2].Param2 =(long *) LR;
			TestPL3[2].Param = (long *)&A;			// SLIDER
			TestPL3[2].PropStart = 0;
			TestPL3[2].PropEnd = 100;

			TestPL3[3].Param = (long *)7;			// TOGGLE
			TestPL3[3].Param2 =(long *)Names ;
			TestPL3[3].PropEnd = 5;

			TestPL3[4].Param = (long *)&In;			// TIME
			TestPL3[4].PropStart = 0;
			TestPL3[4].PropEnd = 500;

			TestPL3[5].Param = (long *)&t_Out;			// TIME
			TestPL3[5].PropStart = 0;
			TestPL3[5].PropEnd = 500;

			TestPL3[8].Param = (long *)&B;
			TestPL3[9].Param = (long *)&C;
			TestPL3[10].Param = (long *)&D;

			type=Panel(Edit, TestPL3,TRUE);
		}
	}
	switch(type)
	{
		case	PAN_EASY:
		case	PAN_EXPERT:
			XPTestPL[2].Param = (long *)Mystr;	// STRING
			XPTestPL[2].Param2 =(long *) 50;

			XPTestPL[3].Param = (long *)Pnls;		// POPUP
			XPTestPL[3].PropStart = 6;
			XPTestPL[3].PropEnd = PNL_NUM;

			XPTestPL[4].Param = (long *)&D;			// NUMBER
			XPTestPL[4].PropStart = 0;  // min
			XPTestPL[4].PropEnd = 100;  // max

			XPTestPL[5].Param = (long *)1;			// TOGGLE
			XPTestPL[5].Param2 =(long *)&ts ;
			XPTestPL[5].PropEnd = 1;

			XPTestPL[6].Param = (long *)&In;			// EZTIME
			XPTestPL[6].PropStart = 0;
			XPTestPL[6].PropEnd = 500;

			XPTestPL[7].Param = (long *)&t_Out;			// TIME
			XPTestPL[7].Param2 = (long *)&XPTestPL[8];  	// FXSpeed gadg to set to V
			XPTestPL[7].PropStart = 0;
			XPTestPL[7].PropEnd = 500;

			XPTestPL[8].Param = (long *)&B;			// FXSPEED
			XPTestPL[8].Param2 = (long *)SP;
			XPTestPL[8].PropStart = (long)&XPTestPL[7];		// PLine (time) to update
			XPTestPL[8].PropEnd = 500;

			XPTestPL[9].Param = (long *)&A;			// SLIDER
			XPTestPL[9].PropStart = 0;
			XPTestPL[9].PropEnd = 100;

			XPTestPL[10].Param = (long *)&C;			// SLIDER
			XPTestPL[10].PropStart = 0;
			XPTestPL[10].PropEnd = 100;

			XPTestPL[11].Param = (long *)&E;			// VCR

			XPTestPL[6].Flags = PL_IN;
			XPTestPL[7].Flags = PL_OUT;
			XPTestPL[2].Flags = PL_LEN;
			XPTestPL[4].Flags = PL_DEL;

			type = Panel(Edit, XPTestPL,FALSE);
			if(type == PAN_CANCEL) break;
		case PAN_CONTINUE:
			if(XPTestPL[5].Param)
			{
				if( (PanelFun=PanHandlers[XPTestPL[3].PropStart]) )  // check type for validity 1st!!!
					Jam_On = PanelFun(Edit,FG);
			}
			break;
		case PAN_CANCEL:
			Jam_On=FALSE;
			break;
d2675 1
a2675 2
		DoSetupPanel(Edit,NULL);
//		DoTestPanel(Edit);
@


2.78
log
@Fix Tweak panel to get flyer volumes
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.77 94/10/24 17:20:32 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d394 2
a395 1
//	BUTTON_LINE(PNL_CENTER, "Rec. Test",0),
d966 1
d997 1
d1446 2
d1479 9
a1487 2
//	TweakPL[7].UserObj = (APTR)Hack ;	// Button
//	TweakPL[7].UserFun =DHD_RecTest;
@


2.77
log
@Insert MiniPanel call, fix inpoint/outpoint calculations
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.76 94/10/24 12:21:50 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d279 1
a279 1

d1296 21
d1340 21
d1390 21
d1440 1
d2845 2
a2846 1
	if(IntuiMsg->Qualifier&(IEQUALIFIER_CONTROL|IEQUALIFIER_LALT))
@


2.76
log
@Update grazer after rename, etc.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.75 94/10/21 23:21:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d263 1
a263 1
// #define SERDEBUG	1
d363 1
a363 1
	POPUP_LINE(PNL_LEFT,"Add Gadget",0 ),
d383 1
a383 1
	POPUP_LINE(PNL_LEFT,"Mode:  ",0),
d499 1
a499 1
	POPUP_LINE(PNL_LEFT,"Effect Color ",1 ),
d523 1
a523 1
	POPUP_LINE(PNL_LEFT,"Effect Color ",1 ),
d620 1
a620 1
	POPUP_LINE(PNL_LEFT,"Scroll",0 ),
d631 1
a631 1
	POPUP_LINE(PNL_LEFT,"Scroll",0 ),
d644 1
a644 1
	POPUP_LINE(PNL_LEFT,"POPUP ",1 ),
d691 1
a691 1
	POPUP_LINE(PNL_LEFT,"Panel Type",0 ),
d895 1
d1407 1
a1407 1
	Panel(Edit,TweakPL,FALSE);
d1434 1
a1434 1
		type = Panel(Edit,SetupPL,FALSE);
d1502 1
a1502 1
		type = Panel(Edit,EffectPL,TRUE);
d1543 1
a1543 1
		type = Panel(Edit,XPEffectPL,FALSE);
d1611 1
a1611 1
		type = Panel(Edit,AnimFXPL,TRUE);
d1653 1
a1653 1
		type = Panel(Edit,XPAnimFXPL,FALSE);
d1716 1
a1716 1
		SP[1] = t_Out = ((SP[3]+SP[4]-1)>>2)<<1;  // Out Frame
d1881 1
a1881 1
		SP[1] = t_Out = ((SP[3]+SP[4]-1)>>2)<<1;  // Out Frame
d1885 1
a1885 1
		SP[8]= A_Out = ((SP[5]+SP[6]-1)>>2)<<1;
d2070 1
a2070 1
		type = Panel(Edit,VideoPL,TRUE);
d2080 1
a2080 1
		type = Panel(Edit,XPVideoPL,FALSE);
d2118 1
a2118 1
		type = Panel(Edit, FramePL,FALSE);
d2169 1
a2169 1
		type = Panel(Edit, KeyPL,TRUE);
d2197 1
a2197 1
		type = Panel(Edit, XPKeyPL,FALSE);
d2267 1
a2267 1
		type = Panel(Edit, CrawlPL,FALSE);
d2318 1
a2318 1
		type = Panel(Edit, ScrollPL,FALSE);
d2465 1
a2465 1
		type = Panel(Edit, ErrorPL,TRUE);
d2709 2
a2710 1
				if(result=Panel(Edit,FileInfoPL,FALSE))
@


2.75
log
@Connect SetupPanel to new messages, structure
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.74 94/10/20 11:53:44 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d260 1
a260 1
//#define SERDEBUG	1
d407 1
a407 1
	POPUP_LINE(PNL_LEFT,"      Drive",0),
d412 1
a412 1
	POPUP_LINE(PNL_LEFT,"      Source:",0),
a525 2
#define USE_DUO

a531 4
#ifndef USE_DUO
	FLYSLIDER_LINE(PNL_LEFT,"In",1),
	FLYSLIDER_LINE(PNL_LEFT,"Out",0),
#else
a533 1
#endif
a545 5

#ifndef USE_DUO
	FLYTIME_LINE(PNL_LEFT,"In",1),
	FLYTIME_LINE(PNL_LEFT,"Out",0),
#else
a547 1
#endif
a548 4
#ifndef USE_DUO
	FLYTIME_LINE(PNL_LEFT,"In",1),
	FLYTIME_LINE(PNL_LEFT,"Out",0),
#else
a550 1
#endif
a562 4
#ifndef USE_DUO
	FLYSLIDER_LINE(PNL_LEFT,"In",1),
	FLYSLIDER_LINE(PNL_LEFT,"Out",0),
#else
a564 1
#endif
a573 4
#ifndef USE_DUO
	FLYTIME_LINE(PNL_LEFT,"In",1),
	FLYTIME_LINE(PNL_LEFT,"Out",0),
#else
a575 1
#endif
d929 24
a1150 16
void __inline SetVolume(struct FastGadget *FG,UWORD Vol,LONG Channel)
{
	if(Channel)
		PutValue(FG,TAG(AudioVolume2),Vol);
	else
		PutValue(FG,TAG(AudioVolume1),Vol);
}

// Set clip pan, for channel 0 or 1
void __inline SetPan(struct FastGadget *FG,WORD Pan,LONG Channel)
{
	if(Channel)
		PutValue(FG,TAG(AudioPan2),Pan);
	else
		PutValue(FG,TAG(AudioPan1),Pan);
}
a1724 15
#ifndef USE_DUO
		AudClipPL[2].Param = &t_In;
		AudClipPL[2].PropStart = 0;
		AudClipPL[2].PropEnd = A-2;  // Min length= 1 colorframe
		AudClipPL[2].Flags = PL_IN | PL_AUD1;

		AudClipPL[3].Param = &t_Out;
		AudClipPL[3].PropStart = 0;
		AudClipPL[3].PropEnd = A-2;
		AudClipPL[3].Flags = PL_OUT | PL_AUD2;

		AudClipPL[5].Param = AudClipPL[3].Param; // out
		AudClipPL[5].Param2 = AudClipPL[2].Param; // in
		AudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...
#else
a1733 1
#endif
a1749 15
#ifndef USE_DUO
		XPAudClipPL[2].Param = &t_In;
		XPAudClipPL[2].PropStart = 0;
		XPAudClipPL[2].PropEnd = A-2;
		XPAudClipPL[2].Flags = PL_IN | PL_AUD1;

		XPAudClipPL[3].Param = &t_Out;
		XPAudClipPL[3].PropStart = 0;
		XPAudClipPL[3].PropEnd = A-2;
		XPAudClipPL[3].Flags = PL_OUT | PL_AUD2;

		XPAudClipPL[5].Param = XPAudClipPL[3].Param; // out
		XPAudClipPL[5].Param2 = XPAudClipPL[2].Param; // in
		XPAudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...
#else
a1759 1
#endif
d1779 2
d1787 2
d1794 2
d1800 2
a1903 17
#ifndef USE_DUO
		ClipPL[5].Param = &t_In;
		ClipPL[5].PropStart = 0;
		ClipPL[5].PropEnd = A-2;
		ClipPL[5].Flags = PL_IN | PL_FLYER | PL_CFRAME;

		ClipPL[6].Param = &t_Out;
		ClipPL[6].PropStart = 0;
		ClipPL[6].PropEnd = A-2;
		ClipPL[6].Flags = PL_OUT | PL_FLYER | PL_CFRAME;

		ClipPL[3].Param = ClipPL[6].Param; // out
		ClipPL[3].Param2 = ClipPL[5].Param; // in
		ClipPL[3].G5 = (struct Gadget *)2; // diff

#else

a1913 2
#endif

a1959 17
#ifndef USE_DUO
		XPClipPL[5].Param = &t_In;
		XPClipPL[5].PropStart = 0;
		XPClipPL[5].PropEnd = A-2;
		XPClipPL[5].Flags = PL_IN | PL_FLYER | PL_CFRAME;

		XPClipPL[6].Param = &t_Out;
		XPClipPL[6].PropStart = 0;
		XPClipPL[6].PropEnd = A-2;
		XPClipPL[6].Flags = PL_OUT | PL_FLYER | PL_CFRAME;

		XPClipPL[2].Param = XPClipPL[6].Param; // out
		XPClipPL[2].Param2 = XPClipPL[5].Param; // in
		XPClipPL[2].G5 = (struct Gadget *)2; // diff

#else

a1965 1

a1969 3
#endif


a1983 12

#ifndef USE_DUO
			XPClipPL[8].Param = &A_In;
			XPClipPL[8].PropStart = 0;
			XPClipPL[8].PropEnd = A-2;
			XPClipPL[8].Flags = PL_AUDIO | PL_IN | PL_CFRAME;

			XPClipPL[9].Param = &A_Out;
			XPClipPL[9].PropStart = 0;
			XPClipPL[9].PropEnd = A-2;
			XPClipPL[9].Flags = PL_AUDIO | PL_OUT | PL_CFRAME;
#else
a1988 1
#endif
d1993 2
d2004 2
d2732 1
a2732 1
								strncat(Dir,".nfo",119);
d2734 1
a2734 1
								/* DoAllNewDir(Edit); */
@


2.74
log
@Switch to new PLine->UserFun for function calls, add setup panel
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.73 94/10/14 13:39:08 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d285 1
d318 2
a319 1
	*Inputs[] ={ "1  ","2  ","3  ","4  "},
d366 1
a366 1
	TOGGLE_LINE(PNL_CENTER,"Video Input Termination ",0 ),
d1172 1
a1172 1
	PutValue(FG,TAG(Duration),(OutField+2-InField));
d1177 1
a1177 1
	PutValue(FG,TAG(Duration),(OutField+2-InField));
d1183 1
a1183 1
	PutValue(FG,TAG(AudioDuration),(OutField+2-InField));
d1188 1
a1188 1
	PutValue(FG,TAG(AudioDuration),(OutField+2-InField));
d1307 1
d1330 1
d1356 1
d1428 1
a1428 2
	LONG	M=0,T=0xF,type=PanType;
	//struct ToastConfig  Config;
d1430 5
a1436 1

d1444 1
a1444 1
		SetupPL[6].PropStart =0;
d1452 10
a1461 6
/*		Config.GPI = SetupPL[7].PropStart;
		Config.Terminate = SetupPL[5].Param;
		Config.2Monitor = SetupPL[3].Param;
		ESparams1.Data1=Config;
		SendSwitcherReply(ES_Config,&ESparams1);
*/
@


2.73
log
@Add CheckFlyerDrives() to sort Audio drives and add 0xA2 as 1st byte of name
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.72 94/10/12 18:03:50 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d313 3
a315 1
	*Channels[] ={ "Right" , "Left"};
d356 13
a381 1

d882 1
a882 1
void __asm DHD_RecTest(REG(a0) struct PanelLine *pl)
d886 1
a886 1
		((struct Hack *)(pl->G5))->hk_Flags = HKF_TESTREC|(pl->PropStart==0 ? HKF_RECORD_A:HKF_RECORD_B);
d891 1
a891 1
		((struct Hack *)(pl->G5))->hk_Flags = (pl->PropStart==2 ? HKF_PLAY_A:HKF_PLAY_B);
d895 1
a895 1
	ESparams1.Data1 =(LONG) pl->G5;  // Hack ptr
d897 1
a897 1
	return;
d900 1
a900 1
void	__asm DHD_Hack(REG(a0) struct Hack *hack)
d906 1
a906 1
	return;
d910 1
a910 1
void __asm DHD_SetSource(REG(a0) struct PanelLine *pl)
d917 1
a917 1
	return;
d921 1
a921 1
void __asm DHD_SetDrive(REG(a0) struct PanelLine *pl)
d937 1
a937 1
	return;
d941 1
a941 1
void __asm DHD_SetCompression(REG(a0) struct PanelLine *pl)
d946 1
d1380 1
a1380 1
	TweakPL[2].Param2 = (long *)DHD_RecTest;// Popup f'n
d1382 1
a1382 1
	TweakPL[2].G5=(struct Gadget *)Hack;
d1386 2
a1387 2
	TweakPL[3].Param2 =(LONG *)DHD_Hack;
	TweakPL[3].G5=(struct Gadget *)Hack;
d1392 2
a1393 2
	TweakPL[4].Param2 =(LONG *)DHD_Hack;
	TweakPL[4].G5=(struct Gadget *)Hack;
d1398 2
a1399 2
	TweakPL[5].Param2 =(LONG *)DHD_Hack;
	TweakPL[5].G5=(struct Gadget *)Hack;
d1404 2
a1405 2
	TweakPL[6].Param2 =(LONG *)DHD_Hack;
	TweakPL[6].G5=(struct Gadget *)Hack;
d1409 2
a1410 2
//	TweakPL[7].Param = (LONG *)Hack ;	// Button
//	TweakPL[7].Param2 =(LONG *)DHD_RecTest;
d1417 35
d1466 1
a1466 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d1572 1
a1572 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d1695 1
a1695 1
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d1881 1
a1881 1
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2125 1
a2125 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2172 1
a2172 1
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2211 1
a2211 1
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2309 1
a2309 1
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2360 1
a2360 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2428 1
a2428 1
			RawRecPL[3].Param2 = (long *)DHD_SetCompression;
d2439 1
a2439 1
				RawRecPL[4].Param2 = (long *)DHD_SetDrive;
d2469 1
a2469 1
			RawRecPL[9].Param2 = (long *)DHD_SetSource;
d2529 1
a2529 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d2722 2
a2723 1
		DoTestPanel(Edit);
@


2.72
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.71 94/10/12 17:34:59 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d936 2
a937 1
		strncpy(FlyerDrives[FlyerDriveCount++],devname,20);
d958 17
d2393 1
@


2.71
log
@Use DuoSLider for VideoXP, Audio, AudioXP panels
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.70 94/10/11 21:40:06 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d539 1
a539 1
	TEXT_LINE(PNL_LEFT,"",1),
@


2.70
log
@DuoSlide for ClipPL
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.69 94/10/07 11:36:39 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d522 2
d526 4
d531 1
d534 4
d550 1
d553 4
d566 1
d569 4
d1650 1
d1661 15
a1680 4
		AudClipPL[5].Param = AudClipPL[3].Param; // out
		AudClipPL[5].Param2 = AudClipPL[2].Param; // in
		AudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...

d1691 1
d1702 15
a1721 4
		XPAudClipPL[5].Param = XPAudClipPL[3].Param; // out
		XPAudClipPL[5].Param2 = XPAudClipPL[2].Param; // in
		XPAudClipPL[5].G5 =(struct Gadget *) 2; // diff add-on...

d1928 1
d1943 16
d1973 2
d1984 7
a1990 1

@


2.69
log
@Fix HAck,RecTest f'ns
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.68 94/10/07 07:40:26 Kell Exp Locker: CACHELIN4000 $
d4 3
d242 1
a242 1
// #define SERDEBUG	1
d312 1
d492 1
d500 1
d503 4
d617 4
a620 2
	EZTIME_LINE(PNL_LEFT,"EZTIME L",1),
	EZTIME_LINE(PNL_CENTER,"EZTIME C",0),
d1805 1
d1820 14
d2397 1
a2397 1
	long	SP[20]={16,32,64,0},A=0,B=2,C,In=64,t_Out=128,D=98,type=PAN_EXPERT,E=50;
d2420 8
a2427 1
	TestPL[9].Param = (long *)&In;			// EZTIME
d2430 2
a2431 4
	TestPL[10].Param = (long *)&t_Out;			// TIME
	TestPL[10].Param2 = (long *)&TestPL[11];  	// FXSpeed gadg to set to V
	TestPL[10].PropStart = 0;
	TestPL[10].PropEnd = 500;
@


2.68
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.66 1994/10/06 23:04:57 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d505 1
a505 1
	CROUTON_LINE(PNL_LEFT,"",1),
d841 9
a1182 9
void	__asm DHD_Hack(REG(a0) struct Hack *hack)
{
	DUMPMSG("DHD_Hack()");
	ESparams1.Data1 =(LONG) hack;
	SendSwitcherReply(ES_Hack,&ESparams1);
	return;
}


d1335 1
@


2.67
log
@Fixed a little bug in the ES_Hack code.
@
text
@a825 2
		ESparams1.Data1 =(LONG) pl->G5;  // Hack ptr
		SendSwitcherReply(ES_Hack,&ESparams1);
d833 2
@


2.66
log
@Fix ANIMFX panels
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.65 94/10/06 19:15:37 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
@


2.65
log
@Matte/Border awareness in DoANIMFXPanel() .. left ghost
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.64 94/10/06 09:30:39 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d233 1
a233 1
//#define SERDEBUG	1
d475 1
a475 1
	FXTIME_LINE(PNL_CENTER,"Length ",0),
a1334 49
/*
// CT_FXANIM
BOOL DoFXANIMPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG A=0,B=2,t_In=300,type=PanType,Speed=1,S,SP[4]={0,20,50,0};
	char Label[MAX_PANEL_STR]="";

	if(FG)
	{
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
		Speed=GetValue(FG,TAG(FCountMode));
		Speed&=0x00000003; // 3,0,1,2 == S,M,F,V
		B=notFCM[Speed];	 // B=gadget button SMFV=0123
		SP[0]=GetValue(FG,TAG(NumFramesSlow));
		SP[1]=GetValue(FG,TAG(NumFramesMedium));
		SP[2]=GetValue(FG,TAG(NumFramesFast));
		SP[3]=GetValue(FG,TAG(NumFramesVariable));
		t_In=GetValue(FG,TAG(MaxDuration))>>1;
	}
	S=SP[notFCM[Speed]];

	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		AnimFXPL[0].Label = Label;
		AnimFXPL[0].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		AnimFXPL[0].Param = NULL; //(long *)CommentBuf;

		AnimFXPL[1].Label = ""; //Label;
		AnimFXPL[4].Param =&B;				// SMFV choice
		AnimFXPL[4].Param2 =SP;  // Array of speeds
		AnimFXPL[4].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME
		AnimFXPL[5].Param = &S;	// Time label
		AnimFXPL[5].Param2 = &A;
		type = Panel(Edit,AnimFXPL,FALSE);
	}
	if(type==PAN_CONTINUE)
	{
		if(B!=notFCM[Speed])
		{
			PutValue(FG,TAG(FCountMode),FCM[B]);
			ESparams2.Data1=(LONG)FG;
			ESparams2.Data2=FGC_FCOUNT;
			SendSwitcherReply(ES_FGcommand,&ESparams2);
		}
		return(TRUE);
	}
	return(FALSE);
}
*/
d1536 4
d1541 1
d1543 4
a1546 7
		if( Matte && Color!= XPAnimFXPL[6].PropStart )
			PutValue(FG,TAG(MatteColor), (XPAnimFXPL[6].PropStart < COLOR_NUM -1) ? XPAnimFXPL[6].PropStart : -1 );
		else if( Border && Color!= XPAnimFXPL[6].PropStart )
			PutValue(FG,TAG(BorderColor), (XPAnimFXPL[6].PropStart < COLOR_NUM -2) ? XPAnimFXPL[6].PropStart : -2 );
		ESparams2.Data1=(LONG)FG;
		ESparams2.Data2=FGC_FCOUNT;
		SendSwitcherReply(ES_FGcommand,&ESparams2);
d2678 1
a2678 1
				if( (PanelFun=PanHandlers[indx]) )  // check type for validity 1st!!!
@


2.64
log
@Audio Duration ->RecFields.. bug fix
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.63 94/10/06 01:02:19 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d230 1
a230 1
#define SERDEBUG	1
d461 1
a461 1
	FXTIME_LINE(PNL_LEFT,"Duration:  ",0),
d466 14
d1332 1
a1332 1

d1380 1
d1487 109
@


2.63
log
@Fix RecTest for A/B channel, DHD_Shuttle not updating I/O point bug
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.62 94/10/05 23:34:05 Kell Exp Locker: CACHELIN4000 $
d4 3
d1494 1
a1494 1
		Time = A = (GetValue(FG,TAG(Duration))>>2)<<1 ;
@


2.62
log
@Fix Rec_Test stuff (AC)
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.61 1994/10/05 16:29:07 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d251 1
a251 1
struct Hack	MyHack={HACK_TWEAK,HKF_PLAY,0,0,0},*Hack=&MyHack;
d282 1
a282 1
	*Tweaks[] ={ "Record" , "Play", "Rec. Test"},
d796 1
a796 1
	if(pl->PropStart==0) // if rectest chosen
d798 2
a799 2
		((struct Hack *)(pl->G5))->hk_Flags = HKF_TESTREC|HKF_RECORD;
		DUMPMSG("RecTest()");
d803 1
a803 1
	else 
d805 2
a806 2
		((struct Hack *)(pl->G5))->hk_Flags = HKF_PLAY;
		DUMPMSG("Play()");
d1195 13
d1276 1
a1276 1
	TweakPL[2].PropEnd=2;
@


2.61
log
@Open all Panels on multi-select...
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.60 94/10/05 05:31:30 Kell Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d221 1
a221 1
//#define SERDEBUG	1
d328 1
a328 1
	BUTTON_LINE(PNL_CENTER, "Rec. Test",0),
d793 1
a793 1
	if(pl->PropStart==2) // if rectest chosen
d795 1
a795 1
		((struct Hack *)(pl->G5))->hk_Flags = HKF_TESTREC;
d800 6
d1286 2
a1287 2
	TweakPL[7].Param = (LONG *)Hack ;	// Button
	TweakPL[7].Param2 =(LONG *)DHD_Hack;
@


2.60
log
@Fixed the Get/Put Table comment stuff.
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.58 1994/10/05 01:06:35 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d2542 1
a2542 2
	char Label[MAX_PANEL_STR]="";
	BOOL BagIt=FALSE;
d2551 1
a2551 1
	while (FG && !BagIt)
a2552 1
//		DUMPHEXIL("while FG=",(LONG)FG," ");
a2557 2
//			DUMPHEXIL("  Type: ",(LONG)type," ");
//			DUMPHEXIL("  # ",(LONG)indx,"\\");
a2559 2
				strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
//				DUMPHEXIL("VALID! FG->ObjectType= ",type,"\\");
a2560 1

d2563 4
a2566 2
				if(IntuiMsg->Qualifier & IEQUALIFIER_CAPSLOCK) PanType=PAN_EXPERT;
				else PanType=PAN_EASY;
d2568 1
a2568 1
					BagIt = PanelFun(Edit,FG);
a2572 1
//		else DUMPMSG(" (Not Selected) ");
@


2.59
log
@PutTable now does correct ES_PutTable command.
@
text
@d4 3
d215 1
a215 1
#define SERDEBUG	1
d234 1
d236 2
a237 1
UBYTE CommentBuf[COMMENT_MAX+1];
d1595 1
a1595 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1652 1
a1652 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1799 1
a1799 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1877 1
a1877 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1898 1
a1898 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1923 1
a1923 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1996 1
a1996 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d2015 1
a2015 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d2048 1
a2048 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d2066 1
a2066 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d2099 1
a2099 1
			PutTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
@


2.58
log
@Diff add-ons, ES_Hack, DoTweakPanel, TweakPL, etc.
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.57 94/10/04 18:13:53 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d951 1
a951 1
		c=SendSwitcherReply(ES_PutValue,&ESparams4);
@


2.57
log
@Remember Drive, Source, Tracks and Name between record panel invocations
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.56 94/10/04 17:54:42 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d234 1
d265 1
d292 1
d306 14
d776 13
d1122 9
d1234 38
d1502 1
d1531 1
d1676 1
d1736 1
d2150 1
d2159 1
d2182 1
d2185 3
a2193 1
			MarkClipPL[6].Flags = PL_LEN;
d2536 5
@


2.56
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.55 94/10/03 21:11:03 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d227 2
a228 2
char Size[20],Name[120],Dir[120];

d2018 1
a2018 1
	strncpy(Name,"Clip.0",CLIP_NAME_MAX);
d2030 1
a2030 1
			RawRecPL[2].Param = (long *)7;
d2047 1
a2047 1
				RawRecPL[4].PropStart = 0;
d2077 1
a2077 1
			RawRecPL[9].PropStart = 0;
d2411 1
@


2.55
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.54 94/10/03 19:05:00 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d1442 1
a1442 1
		XPAudClipPL[4].PropEnd = A-2;
d1491 2
d1699 4
@


2.54
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.53 94/10/03 18:49:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d1608 12
a1619 2
		if(t_In  != SP[0]) SetAudioInPoint(FG,t_In<<1,t_Out<<1);
		else if(t_Out != SP[1]) SetAudioOutPoint(FG,t_In<<1,t_Out<<1);
@


2.53
log
@Don't make icon for Audio clips, Update dir after record, XPClip volume=0 if audio off
un-reverse audio volume channel setting
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.52 94/10/02 00:23:28 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 4
d2095 1
a2095 1
	DoAllNewDir(Edit)
@


2.52
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.51 94/10/02 00:03:19 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d193 1
a193 1
// #define SERDEBUG	1
d205 1
d587 2
a588 1
  DoFXANIMPanel,
d965 2
a967 2
	else
		PutValue(FG,TAG(AudioVolume2),Vol);
d1100 1
a1100 1
	if(ci=DHD_ClipInfo(name)) {
d1363 1
d1367 1
a1367 1
		SP[4] = GetValue(FG,TAG(AudioDuration));
d1524 1
a1524 1
		if( !(SP[4]= GetValue(FG,TAG(Duration))) ) SP[4]=8;
d1526 1
a1526 1
		if( !(SP[6]= GetValue(FG,TAG(AudioDuration))) ) SP[6]=8;
d1534 1
a1581 1
			C=(AudioOn&AUD_ENABLE ? 1:0); // Audio Toggle
d1603 1
d1629 5
d2091 1
@


2.51
log
@Bullet-proof Clip control panel against missing tags.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.50 94/10/01 22:58:03 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d1583 1
d1585 2
a1586 1

d1590 5
a1594 1
		if(!(AudioOn&AUD_EXISTS)) ClipPL[8].Type=PNL_TOGGLE;  // reset for next call !!
@


2.50
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.49 94/10/01 14:52:16 Kell Exp Locker: CACHELIN4000 $
d4 3
d187 1
a187 1
//#define SERDEBUG	1
d1511 2
a1512 1
		A = (GetValue(FG,TAG(RecFields))>>2);  // Clip Frame Length
d1515 1
a1515 1
		SP[4]= GetValue(FG,TAG(Duration));
d1517 1
a1517 1
		SP[6]= GetValue(FG,TAG(AudioDuration));
d1537 3
a1539 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);			
@


2.49
log
@Fixed bugs related to saving / loading comments.
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.48 1994/10/01 13:00:35 Kell Exp Kell $
* $Log: controls.c,v $
@


2.48
log
@Now saves center icon of recorded clip.
DHD_FlyerClipInfo for getting length of recorded clip, etc.
@
text
@d2 1
a2 1
* $Id: controls.c,v 2.47 1994/10/01 01:03:29 Kell Exp Kell $
d4 4
d181 1
a181 1
// #define SERDEBUG	1
d840 2
a841 2
		ESparams2.Data2=ES_TagSize;
		c=SendSwitcherReply(ES_GetValue,&ESparams2);
d851 1
a851 1
	DUMPSDECL(" 		) = ",c,"\\");
d1530 1
a1530 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1572 1
d1574 1
d1727 1
d1773 1
d1865 1
d1916 1
@


2.47
log
@Added DHD_MakeClipIcon. Currently puts up Wait sprite when making icon.
@
text
@d2 1
a2 1
* $Id: controls.c,v 2.46 1994/09/30 21:36:52 CACHELIN4000 Exp Kell $
d4 3
d790 18
d1073 2
a1074 1
	ULONG	x;
d1082 7
a1088 5
	ESparams4.Data1=(LONG)name;
	ESparams4.Data2=(LONG)0;
	ESparams4.Data3=(LONG)0;
	ESparams4.Data4=(LONG)0;
	x=(ULONG)SendSwitcherReply(ES_MakeClipIcon,&ESparams4);
@


2.46
log
@assure even frame numbers in aduio, video panels
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.45 94/09/30 13:17:47 pfrench Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d196 3
d1048 20
@


2.45
log
@Removed doallnewdir from doinfopanel because the grazer
was traversing the list of selected files.
@
text
@d2 6
a7 2
* $Id: Controls.c,v 2.44 1994/09/30 11:28:57 CACHELIN4000 Exp pfrench $
* $Log: Controls.c,v $
d1294 1
a1294 1
		Time = A = GetValue(FG,TAG(Duration))>>1 ;
d1309 2
a1310 2
		SP[0] = t_In  = SP[3] >> 1;			 // In Frame
		SP[1] = t_Out = t_In+(SP[4]>>1)-2;  // Out Frame
d1451 1
a1451 1
		A = GetValue(FG,TAG(RecFields))>>1;  // Clip Frame Length
d1468 3
a1470 3
		SP[0] = t_In  = SP[3] >> 1;			 // In Frame
		SP[1] = t_Out = t_In+(SP[4]>>1)-2;  // Out Frame
		if(t_In > t_Out) t_Out = t_In;
d1472 2
a1473 2
		SP[7]= A_In  = SP[5] >> 1;
		SP[8]= A_Out = A_In+(SP[6]>>1)-2;
@


2.44
log
@Audio InPoints set on EZ Clip Adjust
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.43 94/09/29 15:50:57 CACHELIN4000 Exp $
* $Log:	Controls.c,v $
d2283 1
a2283 1
								DoAllNewDir(Edit);
@


2.43
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.42 94/09/29 13:51:26 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
a982 1
	DUMPSTR(name);
a984 7
	if(ESparams1.Data1=(LONG)name);
		if( CurFG=(struct FastGadget *)SendSwitcherReply(ES_LoadCrouton,&ESparams1))
		{
			ESparams1.Data1=(LONG)CurFG;
			SendSwitcherReply(ES_Select,&ESparams1);
		}
	DUMPMSG("InitPlay() Done");
d1513 3
a1515 6
		if(!(AudioOn&AUD_EXISTS))
		{
			ClipPL[8].Type=PNL_TOGGLE;  // reset for next call !!
			if(t_In  != SP[0]) SetAudioInPoint(FG,t_In,t_Out);
			if(t_Out != SP[1]) SetAudioOutPoint(FG,t_In,t_Out);
		}
a1924 1
//				RawRecPL[4].G4 = (struct Gadget *)&B;
a1925 1
//				RawRecPL[4].G5 = (struct Gadget *)&C;
d1932 3
@


2.42
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.41 94/09/29 12:20:01 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d1950 1
a1950 1
			RawRecPL[2].Flags = PL_AVAIL;
@


2.41
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.40 94/09/28 23:42:13 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d158 1
a158 1
#define SERDEBUG	1
@


2.40
log
@Add DHD_Reorganize(), rearrange record panel again
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.39 94/09/28 18:17:54 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	controls.c,v $
a271 1
	DIVIDE_LINE(PNL_LEFT,"",0),
d958 3
d1513 1
d1515 3
d1944 1
d1955 1
a1955 1
			RawRecPL[11].PropStart = 36;  // Spacer
@


2.39
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.38 94/09/28 14:46:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d262 2
a263 1
	EZTIME_LINE(PNL_CENTER,"Record Time",1),
a264 1
	DIFF_LINE(PNL_LEFT,"Reorganized Time Available ",0),
d266 1
a267 2
	TEXT_LINE(PNL_CENTER,"",1),
	VCR_LINE(PNL_LEFT,"",0),
d1001 10
d1897 1
a1897 1
			RawRecPL[2].Param = (long *)15;
d1900 1
a1929 1
//			RawRecPL[6].Param = &B;  // Diff
d1933 2
a1934 4
			RawRecPL[7].Param = &T;
			RawRecPL[7].PropStart = 0;
			RawRecPL[7].PropEnd = B;
			RawRecPL[7].Flags = PL_LEN;
d1936 8
a1943 4
			RawRecPL[8].Param = (long *)Sources;		// POPUP
			RawRecPL[8].Param2 = (long *)DHD_SetSource;
			RawRecPL[8].PropStart = 0;
			RawRecPL[8].PropEnd = 5;
a1944 4
			RawRecPL[9].Param = &C;  // Diff
			RawRecPL[9].Param = (LONG *)&(RawRecPL[4].G5);  // Diff
			RawRecPL[9].Param2 = &Z;

a1946 3

			RawRecPL[13].Param = NULL;  // VCR Panel no time gadg if NULL, same as param2 else
			RawRecPL[13].Param2 = &Spot;  // VCR current frame !!MUST =param unless param==0
@


2.38
log
@BlocksToFrames added
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.37 94/09/28 11:31:49 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d721 2
a722 2
		pl->G4 = (struct Gadget *) BlocksToFrames(vi->Largest);
		pl->G5 = (struct Gadget *) BlocksToFrames(vi->Optimized);
a968 8
	ESparams1.Data1=(LONG)name;
/*
	if( CurFG=(struct FastGadget *)SendSwitcherReply(ES_LoadCrouton,&ESparams1))
	{
		ESparams1.Data1=(LONG)CurFG;
		SendSwitcherReply(ES_Select,&ESparams1);
	}
*/
d970 6
d1877 2
a1878 2
		B=BlocksToFrames(FVI->Largest);
		C=BlocksToFrames(FVI->Optimized);
@


2.37
log
@add BuildFlyerList()
to NewClipPanel
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.36 94/09/28 00:09:03 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 4
d687 5
d711 1
a711 1
	DUMPMSG(" ) //");
d715 15
a729 4
		if(pl->G4) *pl->G4 = *(struct Gadget *) vi->Largest;
		if(pl->G5) *pl->G5 = *(struct Gadget *) vi->Optimized;
	}
	return;
d742 2
a743 1
 	if(*devname)
d749 5
a753 1
		return((struct FlyerVolInfo *)SendSwitcherReply(ES_FlyerDriveInfo,&ESparams2));
d1876 2
a1877 2
		B=FVI->Largest;
		C=FVI->Optimized;
d1891 1
d1903 4
a1906 2
				RawRecPL[4].G4 = (struct Gadget *)&B;
				RawRecPL[4].G5 = (struct Gadget *)&C;
d1916 2
a1917 1
			RawRecPL[6].Param = &B;  // Diff
d1931 1
@


2.36
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.35 94/09/27 23:39:39 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d714 2
a716 3
	{
		DUMPUDECL("FlyerDrive[",FlyerDriveCount,"] = ");
		DUMPMSG(devname);
a717 1
	}
a1841 1
char name[CLIP_NAME_MAX]="";
d1847 2
a1848 1
	strncpy(name,"Clip.0",CLIP_NAME_MAX);
d1867 1
a1867 1
			RawRecPL[3].Param = (long *)name;		// STRING
d1925 1
a1925 1
			MarkClipPL[5].Param = (long *)name;  // Name String
@


2.35
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.34 94/09/27 18:05:24 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d721 1
a721 2
//	struct FlyerVolInfo *vi=NULL;
/* 	if(*devname)
a727 1
//		DUMPHEXIL(") = ",(LONG)vi," //");
d729 1
a729 1
 */	return(NULL);
d910 1
a910 1
/* 	DUMPUDECL("DHD_InitRecord( ",Unit,",");
a919 1
 */
a924 1
/*
a930 1
 */
d948 1
a948 1
//	SendSwitcherReply(ES_InitPlay,NULL);
d961 1
a961 1
//	SendSwitcherReply(ES_Stop,NULL);
a1053 1
	DUMPMSG("NewClip Clicked...");
d1841 1
a1841 1
char name[CLIP_NAME_MAX]="Clip.0";
d1847 1
a1945 1
	DUMPMSG("* Panel Returned!!");
@


2.34
log
@Bag crashy FreeCrouton in DHD_InitRecord
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.33 94/09/27 17:19:58 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d241 2
a242 1
	POPUP_LINE(PNL_LEFT,"Quality",1),
d716 1
a716 1
BOOL GetFlyerInfo(char *devname, struct FlyerVolInfo *vi)
d718 2
a719 1
	if(*devname)
a723 1
		DUMPMSG(",NULL ) //");
d725 2
a726 2
		if(vi=(struct FlyerVolInfo *)SendSwitcherReply(ES_FlyerDriveInfo,&ESparams2))
			return(TRUE);
d728 1
a728 1
	return(FALSE);
d909 1
a909 1
	DUMPUDECL("DHD_InitRecord( ",Unit,",");
d919 1
d925 1
d932 1
a948 1
	SendSwitcherReply(ES_InitPlay,NULL);
d950 1
d963 1
a963 1
	SendSwitcherReply(ES_Stop,NULL);
d1056 1
d1058 1
d1844 1
a1847 1
	char *name="Clip.0";
d1850 1
a1850 1
	if(FlyerDriveCount && GetFlyerInfo(FlyerDrives[0],FVI))
d1856 1
d1863 1
a1863 1

d1867 4
d1895 1
a1910 1
			RawRecPL[7].Flags = PL_LEN;
d1914 1
a1914 2
			if(FG) return(TRUE);
			else return(FALSE);
d1943 1
a1943 1
			return(FALSE);
d1946 5
@


2.33
log
@Add POPUP f'ns (SetSource, SetDrive), tweak DHD_ functions for record panel,
add Drive popup to record panel, FlyerDriveInfo query
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.32 94/09/25 16:34:27 Kell Exp Locker: CACHELIN4000 $
d4 4
d910 1
a910 1
		SendSwitcherReply(ES_FreeCrouton,&ESparams1);
@


2.32
log
@Changes ES_StopSeq to ES_Stop
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.31 1994/09/24 15:11:59 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d114 1
d146 1
d179 1
d238 2
a239 1
	EZTIME_LINE(PNL_CENTER,"Record Time",0),
d669 29
a699 1
//	struct VolumeInfo vi;
d702 1
d704 9
d714 5
a718 4
//		ESparams2.Data2=(LONG)&vi;
//		SendSwitcherReply(ES_GetVolumeInfo,&ESparams2);
//		if(vi->Flags&VI_FLYERVIDEO)
			strncpy(FlyerDrives[FlyerDriveCount++],devname,20);
d720 1
d914 11
d931 1
a932 1
	ESparams1.Data1=(LONG)name;
d944 5
d975 6
a980 2
	ESparams1.Data1=(LONG)name;
	return((ULONG)SendSwitcherReply(ES_Record,&ESparams1));
d1833 1
a1833 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,T=B,STOP=0, Spot=0;
d1835 7
d1859 3
d1869 1
d1878 4
a1881 2
			RawRecPL[8].Param = &C;  // Diff
			RawRecPL[8].Param2 = &Z;
d1883 5
a1887 2
			RawRecPL[10].PropStart = 36;  // Spacer
			RawRecPL[11].PropStart = 0;  // Spacer
d1889 2
a1890 2
			RawRecPL[12].Param = NULL;  // VCR Panel no time gadg if NULL, same as param2 else
			RawRecPL[12].Param2 = &Spot;  // VCR current frame !!MUST =param unless param==0
@


2.31
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.30 94/09/23 10:33:05 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d889 1
a889 1
	SendSwitcherReply(ES_StopSeq,NULL);
@


2.30
log
@Record Panel, CutCLip Panel work.
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.29 94/09/20 23:40:26 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d152 1
a152 1
LONG PanType=PAN_EASY;
d155 7
d170 1
a170 1
	*Tracks[] = {"Time Code","Audio","Video"},
d224 3
a226 2
	TOGGLE_LINE(PNL_LEFT,"Tracks:",0),
	POPUP_LINE(PNL_LEFT,"Quality",0),
d232 1
d234 1
a234 1
	VCR_LINE(PNL_CENTER,"",0),
a248 2
	TEXT_LINE(PNL_CENTER,0,0),
	VCR_LINE(PNL_CENTER," ",0),
d250 1
d523 2
a524 2
  DoNewClipPanel ,//DoRawRecPanel,
  DoMarkClipPanel,
d659 14
d851 1
a851 1
	DUMPUDECL("DHD_Init( ",Unit,",");
d853 6
d865 1
a865 1
ULONG	DHD_InitPlay(ULONG Unit,ULONG Flags)
d867 2
a868 1
	DUMPUDECL("DHD_Init( ",Unit,",");
d870 7
d878 1
d890 7
d904 1
a904 1
ULONG	DHD_Record(ULONG Unit, ULONG Start, ULONG Stop, ULONG Flags)
d906 5
a910 3
	DUMPMSG("DHD_Record()");
// THIS IS BOGUS NOW.  IT HAS TO SUPPORT RECORDING VIA A FILENAME.!!!!!!!
	return((ULONG)SendSwitcherReply(ES_Record,NULL));
d1365 1
d1370 1
a1385 2
		ClipPL[5].Flags = PL_IN | PL_FLYER;
		ClipPL[6].Flags = PL_OUT | PL_FLYER;
d1405 1
a1405 1
		XPClipPL[5].Flags = PL_IN | PL_FLYER;
d1410 1
a1410 1
		XPClipPL[6].Flags = PL_OUT | PL_FLYER;
d1427 1
a1427 1
			XPClipPL[8].Flags = PL_AUDIO | PL_IN;
d1432 1
a1432 1
			XPClipPL[9].Flags = PL_AUDIO | PL_OUT;
d1549 1
a1549 1
		FramePL[2].Flags = PL_LEN;
d1594 1
a1594 1
		KeyPL[2].Flags = PL_LEN;
d1611 1
a1611 1
		XPKeyPL[2].Flags = PL_LEN;
a1760 60
BOOL DoRawRecPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG type=PanType,B=6660,C=B<<1,Z=0,T=B,Spot=0;
	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		RawRecPL[2].Param = (long *)7;
		RawRecPL[2].Param2 = (long *)Tracks;		// Toggle
		RawRecPL[2].PropEnd = 3;
		RawRecPL[3].Param = (long *)Quals;		// POPUP
		RawRecPL[3].PropStart = DEF_QUALITY;
		RawRecPL[3].PropEnd = QUAL_NUM;
		RawRecPL[5].Param = &B;  // Diff
		RawRecPL[5].Param2 = &Z;
		RawRecPL[6].Param = &T;
		RawRecPL[6].PropStart = 1;
		RawRecPL[6].PropEnd = 36000;
		RawRecPL[7].Param = &C;  // Diff
		RawRecPL[7].Param2 = &Z;

		RawRecPL[10].Param = NULL;  // VCR Panel no time gadg if NULL, same as param2 else
		RawRecPL[10].Param2 = &Spot;  // VCR current frame !!MUST =param unless param==0

		RawRecPL[6].Flags = PL_LEN;
		type = 	NewClipPanel(Edit);
	}
	if( FG && (type==PAN_CONTINUE) )
	{
		return(TRUE);
	}
	return(FALSE);
}

BOOL DoMarkClipPanel(struct EditWindow *Edit, struct FastGadget *FG)
{
	LONG type=PanType,C=6660,Z=0,Spot=0;
	if( (type==PAN_EASY) || (type==PAN_EXPERT) )
	{
		MarkClipPL[3].Param = &Z;
		MarkClipPL[3].PropStart = 0;
		MarkClipPL[3].PropEnd = 36000;
		MarkClipPL[4].Param = &C;
		MarkClipPL[4].PropStart = 0;
		MarkClipPL[4].PropEnd = 36000;
		MarkClipPL[6].Param = &C;  // Diff
		MarkClipPL[6].Param2 = &Z;

		MarkClipPL[3].Flags = PL_IN | PL_FLYER;
		MarkClipPL[4].Flags = PL_OUT| PL_FLYER;
		MarkClipPL[6].Flags = PL_LEN;
		MarkClipPL[9].Param = NULL;  // VCR Panel no time gadg
		MarkClipPL[9].Param2 = &Spot;
		type = CutClipPanel(Edit);
	}
	if( FG && (type==PAN_CONTINUE) )
	{
		return(TRUE);
	}
	return(FALSE);
}

d1771 2
a1772 1
			RawRecPL[2].PropEnd = 4;
d1776 29
a1804 9
			RawRecPL[5].Param = &B;  // Diff
			RawRecPL[5].Param2 = &Z;
			RawRecPL[6].Param = &T;
			RawRecPL[6].PropStart = 0;
			RawRecPL[6].PropEnd = B;
			RawRecPL[7].Param = &C;  // Diff
			RawRecPL[7].Param2 = &Z;
			RawRecPL[10].Param = NULL;  // VCR Panel no time gadg if NULL, same as param2 else
			RawRecPL[10].Param2 = &Spot;  // VCR current frame !!MUST =param unless param==0
d1806 1
a1806 1
			RawRecPL[6].Flags = PL_LEN;
d1831 3
a1833 2
			MarkClipPL[8].PropStart = 40; // spacing only TEXT line
			MarkClipPL[9].Param = NULL;  // VCR Panel no time gadg
@


2.29
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.28 94/09/20 23:33:17 CACHELIN4000 Exp Locker: CACHELIN4000 $
d160 1
a160 1
	*Tracks[] = {"Time Code","R. Audio","L. Audio","Video",""},
d221 3
a223 3
	TEXT_LINE(PNL_CENTER," ",1),
	TEXT_LINE(PNL_CENTER," ",0),
	TEXT_LINE(PNL_CENTER," ",0),
d232 2
a233 2
	TIME_LINE(PNL_CENTER,"In",1),
	TIME_LINE(PNL_CENTER,"Out",0),
d237 2
a238 1
	TEXT_LINE(PNL_CENTER," ",0),
a239 1
	TEXT_LINE(PNL_CENTER," ",0),
d345 2
a346 2
	TIME_LINE(PNL_LEFT,"In",1),
	TIME_LINE(PNL_LEFT,"Out",0),
d569 2
a570 2
	"pad6",
	"pad7",
d688 1
a688 1
	DUMPHEX("Table: ",Table,c);
a694 2
	LONG	c;

d699 1
a699 1
		c=SendSwitcherReply(ES_PutValue,&ESparams3);
d701 1
a701 1
	DUMPHEXIL("ES_PutValue( ",(LONG)FG,", ");
d703 2
a704 3
	DUMPSDECL(" 		,",Value," ) =");
	DUMPSDECL(" ",c,"\\");
	return(c);
d727 1
a727 1
	DUMPHEXIL("ES_PutTable( ",(LONG)FG,", ");
d729 1
a729 1
	DUMPSDECL(" 		,",c," )\\");
d793 1
a793 1
void __inline SetPan(struct FastGadget *FG,UWORD Pan,LONG Channel)
d796 2
a798 2
	else
		PutValue(FG,TAG(AudioPan2),Pan);
d812 10
d864 1
a864 1
ULONG	DHD_Shuttle(struct RenderCallBack	*rcb)
d868 2
a869 1
	return((ULONG)SendSwitcherReply(ES_Shuttle,&ESparams1));
d878 13
a890 4
	if(rcb->pline->Flags&PL_IN)
		SetInPoint(rcb->FG,rcb->Frame,rcb->Max);
	else if(rcb->pline->Flags&PL_OUT)
		SetOutPoint(rcb->FG,rcb->Min,rcb->Frame);
d896 3
a898 1
	DUMPMSG("DHD_Jump()");
d906 13
a918 4
	if(rcb->pline->Flags&PL_IN)
		SetInPoint(rcb->FG,rcb->Frame,rcb->Max);
	else if(rcb->pline->Flags&PL_OUT)
		SetOutPoint(rcb->FG,rcb->Min,rcb->Frame);
d1133 1
a1133 1
		GetTable(FG,TAG_CommentList,CommentBuf,COMMENT_MAX);
d1145 1
a1145 1
		AudClipPL[2].Flags = PL_IN;
d1150 1
a1150 1
		AudClipPL[3].Flags = PL_OUT;
d1173 1
a1173 1
		XPAudClipPL[2].Flags = PL_IN;
d1178 1
a1178 1
		XPAudClipPL[3].Flags = PL_OUT;
d1185 2
a1186 2
		XPAudClipPL[5].Param = AudClipPL[5].Param; // out
		XPAudClipPL[5].Param2 = AudClipPL[4].Param; // in
d1205 2
a1206 2
		XPAudClipPL[10].PropStart = -32768;
		XPAudClipPL[10].PropEnd = 32767;
a1215 2
		XPAudClipPL[12].PropStart = -32768;
		XPAudClipPL[12].PropEnd = 32767;
a1238 4
		if( P1!=SP[9] )
			PutValue(FG,TAG(AudioPan1),P1);
		if( P2!=SP[10] )
			PutValue(FG,TAG(AudioPan2),P2);
d1378 2
d1383 1
d1388 2
a1389 1
			XPClipPL[10].Flags = PL_AUD1;
d1397 1
a1397 1
			XPClipPL[12].Flags = PL_AUD2;
a1398 6
//		C=4;
//		if(V1) C|=1; // Volume 1 (L)
//		if(V2) C|=2;
//		XPClipPL[12].Param=(long *)C; // Audio Toggle
//		XPClipPL[12].Param2=(long *)togxp;
//		XPClipPL[12].PropEnd = 3;
d1402 1
a1453 1
//		GadIndex[GAD_LEN]=3;  // Set index for hotkey
a1463 1
//		GadIndex[GAD_LEN]=3;  // Set index for hotkey
a1468 2
		{
//			DUMPUDECL("****** NEW DURATION=",(LONG)(Time<<1),"\\");
a1469 1
		}
d1527 2
d1568 1
a1568 6
/*
		t_In = (Speed&1); // set to crouton's 0=fade,1=cut
		XPKeyPL[5].Param = &t_In;
		t_Out = (Speed&2)>>1; // set to crouton's 0=fade,1=cut
		XPKeyPL[6].Param = &t_Out;
*/
d1593 1
d1595 2
d1598 1
d1600 2
d1714 1
a1714 1
	LONG type=PanType,B=6660,C=B<<1,Z=0,T=B;
d1717 1
a1717 1
		RawRecPL[2].Param = (long *)15;
d1719 1
a1719 1
		RawRecPL[2].PropEnd = 4;
d1731 3
a1734 1
//		GadIndex[GAD_LEN]=6;  // Set index for hotkey
d1746 1
a1746 1
	LONG type=PanType,C=6660,Z=0;
d1761 2
a1762 3
//		GadIndex[GAD_IN]=3;  // Set index for hotkey
//		GadIndex[GAD_OUT]=4;  // Set index for hotkey
//		GadIndex[GAD_LEN]=6;  // Set index for hotkey
d1774 1
a1774 1
	LONG type=PAN_EASY,B=6660,C=B<<1,Z=0,T=B,STOP=0;
d1793 2
a1796 1
//			GadIndex[GAD_LEN]=6;  // Set index for hotkey
d1802 1
a1802 2
//			STOP=1;
//			break;
d1820 5
a1824 4
//			GadIndex[GAD_IN]=3;  // Set index for hotkey
//			GadIndex[GAD_OUT]=4;  // Set index for hotkey
//			GadIndex[GAD_LEN]=6;  // DIFF type
//			GadIndex[GAD_DEL]=5;  // name string Set index for hotkey
d1830 1
a1830 2
//			STOP=1;
//			break;
a1996 5

//			GadIndex[GAD_IN]=6;  // Set index for hotkey
//			GadIndex[GAD_OUT]=7;  // Set index for hotkey
//			GadIndex[GAD_LEN]=2;  // Set index for hotkey
//			GadIndex[GAD_DEL]=4;  // Set index for hotkey
@


2.28
log
@FX Tags work, TAGNames added for EZ debuggery
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.27 94/09/14 19:02:51 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d531 1
a531 1
	"Frames",
d572 1
a572 1
	"Matte",
d575 3
a577 3
	"LatchAM",
	"LatchBM",
	"LatchIS",
d588 1
a588 1
	"LatchList",
d600 1
a600 1
	"LoopCount",
d602 2
a603 2
	"TimeLine",
	"IndexID",
d613 2
a614 2
	"NumFields",
	"StartTime",
d624 3
a626 3
	"Page",
	"Speed",
	"Delay",
d631 1
a631 1
	"AudioOn",
d642 2
a643 2
	"AudioPan1",
	"AudioPan2",
d705 1
a705 1
	DUMPSDECL(", 		",Value," ) =");
d732 1
a732 1
	DUMPSDECL(", 		",c," )\\");
@


2.27
log
@Panel croutons, Audio panel re-do...
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.26 94/09/13 20:19:46 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d139 1
a139 1
#define COLOR_NUM	9 		// number of entires in Colors array
d151 1
a151 1
	*Colors[] = {"Black","White","Red","Green","Blue","Cyan","Magenta","Yellow","Snow",""},
a159 2
#define TAG(x)	(0x80000000|TAG_##x)

a284 2
	TEXT_LINE(PNL_LEFT,"Effect",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d286 2
a295 2
	TEXT_LINE(PNL_LEFT,"Effect",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d297 2
a308 2
	TEXT_LINE(PNL_LEFT,"Effect",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d310 2
a318 12
struct PanelLine XPAnimFXPL[] = {
	TEXT_LINE(PNL_LEFT,"Effect",0),
	TEXT_LINE(PNL_LEFT,"name",0),
	CROUTON_LINE(PNL_LEFT,"",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	FXSPEED_LINE(PNL_LEFT,"Speed",0),
	FXTIME_LINE(PNL_LEFT,"Duration:  ",0),
	POPUP_LINE(PNL_LEFT,"Effect Color ",0),
	DIVIDE_LINE(PNL_LEFT,"",0),
	LAST_LINE  // { 0,0,0,0,0 } // end of array marker
};

d356 2
a357 2
	SLIDER_LINE(PNL_LEFT,"In",1),
	SLIDER_LINE(PNL_LEFT,"Out",0),
d367 2
a368 2
	TIME_LINE(PNL_LEFT,"In",1),
	TIME_LINE(PNL_LEFT,"Out",0),
d372 2
a373 2
	EZLEN_LINE(PNL_CENTER,"Fade In",1),
	EZLEN_LINE(PNL_CENTER,"Fade Out",0),
d514 128
d643 1
d654 3
a656 3
	DUMPHEXIL("ES_GetValue( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID," ) =");
	DUMPSDECL(" ",c,"\\");
d683 3
a685 3
	DUMPHEXIL(" ",TagID,", ");
	DUMPSDECL(" ",c,") = \\");
	DUMPHEX("",Table,c);
d700 3
a702 3
	DUMPHEXIL("ES_PutValue( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID,",");
	DUMPSDECL(" ",Value," ) =");
d726 5
a730 3
	DUMPHEXIL("ES_PutTable( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID,",");
	DUMPSDECL(" ",c," )\\");
d908 1
a908 1
	char Label[MAX_PANEL_STR]="c00l fx";
d912 1
a912 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d924 1
a924 1
	if(type==PAN_EASY)
d926 5
a930 1
		AnimFXPL[1].Label =Label;
a937 10
	if(type==PAN_EXPERT)
	{
		XPAnimFXPL[1].Label =Label;
		XPAnimFXPL[4].Param =&B;				// SMFV choice
		XPAnimFXPL[4].Param2 =SP;  // Array of speeds
		XPAnimFXPL[4].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME
		XPAnimFXPL[5].Param = &S;	// Time label
		XPAnimFXPL[5].Param2 = &A;
		type = Panel(Edit,XPAnimFXPL,FALSE);
	}
d955 3
a957 2
	LONG B=2,t_In=300,type=PanType,Speed=1,S,SP[4]={45,30,15,9},D=0;
	char Label[MAX_PANEL_STR]="Video Effect: ";
d962 1
a962 2
		strncat(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
//		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d969 10
d986 1
d1001 1
d1010 23
a1032 3
		XPEffectPL[6].Param = (long *)Colors;		// POPUP
		XPEffectPL[6].PropStart = DEF_COLOR;
		XPEffectPL[6].PropEnd = COLOR_NUM;
d1038 1
d1046 4
a1049 1

d1134 1
a1134 2

	P1=0x8000; P2=0xFFFF;
d1160 1
d1165 1
d1170 1
d1176 1
d1181 1
d1187 1
d1309 1
a1309 4
		{
			ClipPL[8].Type=PNL_TEXT;
			ClipPL[8].Param=(long *)"";
		}
@


2.26
log
@Move PNL_CROUTON FG to Param2, comment to Param, Add Audio support f'ns
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.24 94/09/12 13:04:22 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
a255 1
	TEXT_LINE(PNL_LEFT,"Frame",0),
a256 1
	TEXT_LINE(PNL_LEFT,"name",0),
a262 10
struct PanelLine XPFramePL[] = {
	TEXT_LINE(PNL_LEFT,"Frame",0),
	CROUTON_LINE(PNL_LEFT,"",0),
	TEXT_LINE(PNL_LEFT,"name",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	EZTIME_LINE(PNL_CENTER,"Length",0),
	DIVIDE_LINE(PNL_LEFT,"",0 ),
	LAST_LINE
};

a364 2
	TEXT_LINE(PNL_LEFT,"Audio Clip",0),
	TEXT_LINE(PNL_LEFT,"<name>",0),
a375 2
	TEXT_LINE(PNL_LEFT,"Audio Clip",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d383 1
a383 5

	EZNUM_LINE( PNL_CENTER, "Volume ",1),
	EZLEN_LINE(PNL_CENTER,"Fade In",0),

	TOGGLE_LINE(PNL_LEFT,"Channels: ",1),
d385 4
a388 1

a389 6
	EZNUM_LINE( PNL_LEFT, "Ch.1 Level ",1),
	EZSLIDER_LINE( PNL_LEFT, "Pan ",0),
	EZNUM_LINE( PNL_LEFT, "Ch.2 Level ",1),
	EZSLIDER_LINE( PNL_LEFT, "Pan ",0),

	DIVIDE_LINE(PNL_LEFT,"",0 ),
a393 2
	TEXT_LINE(PNL_LEFT,"CG Key",0),
	TEXT_LINE(PNL_LEFT,"name",0),
a402 2
	TEXT_LINE(PNL_LEFT,"CG Key",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d408 2
a409 2
	IN_TYPE_LINE(PNL_LEFT,0,1),
	OUT_TYPE_LINE(PNL_LEFT,0,0),
a416 2
	TEXT_LINE(PNL_LEFT,"CG Crawl",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d418 1
a427 2
	TEXT_LINE(PNL_LEFT,"CG Scroll",0),
	TEXT_LINE(PNL_LEFT,"name",0),
d429 1
d672 8
a870 1
//		GadIndex[GAD_LEN]=5;  // Set index for hotkey
a890 1
//		GadIndex[GAD_LEN]=5;  // Set index for hotkey
d924 1
a924 1
		Vol=50,S=0,SP[12]={36,69,0,0},P1,P2;
d926 1
a929 1
//		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
a930 1

a932 1

d941 2
a942 1
		Vol=1+MAX(V1,V2)*100/0xFFFF;
d945 1
a945 1

d952 1
d957 3
a959 2
		AudClipPL[0].Label = ""; //Label;
		AudClipPL[1].Label = ""; // Label;
d961 9
a969 3
		AudClipPL[2].Label = Label;
		AudClipPL[2].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		AudClipPL[2].Param = (long *)CommentBuf;
d971 1
a971 1
		AudClipPL[4].Param = &t_In;
d973 2
a974 1
		AudClipPL[4].PropEnd = A-2;  // Min length= 1 colorframe
d976 2
a977 10
		AudClipPL[5].Param = &t_Out;
		AudClipPL[5].PropStart = 0;
		AudClipPL[5].PropEnd = A-2;

		AudClipPL[7].Param = AudClipPL[5].Param; // out
		AudClipPL[7].Param2 = AudClipPL[4].Param; // in

		AudClipPL[6].Param = &S;
		AudClipPL[6].PropStart = 0;
		AudClipPL[6].PropEnd = MAX_DELAY;
a978 4
		AudClipPL[4].Flags = PL_IN;
		AudClipPL[5].Flags = PL_OUT;
		AudClipPL[6].Flags = PL_DEL;
//		GadIndex[GAD_DEL]=6;  // Set index for hotkey
a982 3
		XPAudClipPL[1].Label = Label;
		XPAudClipPL[1].Param = (LONG *)Label;
		XPAudClipPL[1].Param2 = (LONG *)80;
a983 6
		XPAudClipPL[0].Label = ""; //Label;
		XPAudClipPL[1].Label = ""; // Label;

		XPAudClipPL[2].Label = Label;
		XPAudClipPL[2].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPAudClipPL[2].Param = (long *)CommentBuf;
d985 16
a1000 1
		XPAudClipPL[4].Param = &t_In;
d1003 1
d1005 2
a1006 3
		XPAudClipPL[5].Param = &t_Out;
		XPAudClipPL[5].PropStart = 0;
		XPAudClipPL[5].PropEnd = A-2;
d1008 7
a1014 6
		XPAudClipPL[7].Param = AudClipPL[5].Param; // out
		XPAudClipPL[7].Param2 = AudClipPL[4].Param; // in

		XPAudClipPL[6].Param = &S;
		XPAudClipPL[6].PropStart = 0;
		XPAudClipPL[6].PropEnd = A-2;
d1016 1
a1016 1
		XPAudClipPL[9].Param = &Vol;
d1020 4
a1023 3
		XPAudClipPL[10].Param = &FadeIn;
		XPAudClipPL[10].PropStart = 0;
		XPAudClipPL[10].PropEnd = A-2;
d1025 8
a1032 31
		XPAudClipPL[11].Param = (LONG *)( (V1 ? 1:0)|(V2 ? 2:0) );
		XPAudClipPL[11].Param2 = (LONG *)Channels;
		XPAudClipPL[11].PropEnd = 2;

		XPAudClipPL[12].Param = &FadeOut;
		XPAudClipPL[12].PropStart = 0;
		XPAudClipPL[12].PropEnd = A-2;

		A=(long)XPAudClipPL[11].Param;

		XPAudClipPL[4].Flags = PL_IN;
		XPAudClipPL[5].Flags = PL_OUT;
		XPAudClipPL[6].Flags = PL_DEL;

		XPAudClipPL[14].Param = &Vol;
		XPAudClipPL[14].PropStart = 0;
		XPAudClipPL[14].PropEnd = 100;

		XPAudClipPL[15].Param = &P1;
		XPAudClipPL[15].Param2 =(long *) pan;
		XPAudClipPL[15].PropStart = 0;
		XPAudClipPL[15].PropEnd = 100;

		XPAudClipPL[16].Param = &Vol;
		XPAudClipPL[16].PropStart = 0;
		XPAudClipPL[16].PropEnd = 100;

		XPAudClipPL[17].Param = &P2;
		XPAudClipPL[17].Param2 =(long *) pan;
		XPAudClipPL[17].PropStart = 0;
		XPAudClipPL[17].PropEnd = 100;
a1033 3
//		GadIndex[GAD_IN]=4;  // Set index for hotkey
//		GadIndex[GAD_OUT]=5;  // Set index for hotkey
//		GadIndex[GAD_DEL]=6;  // Set index for hotkey
a1034 13

		if(A!=(long)XPAudClipPL[11].Param)
		{
			A=(long)XPAudClipPL[11].Param;
			if(V1 && !(A&1)) // L Audio turned Off
				V1=0;
			else if(!V1 && (A&1)) // L Audio turned On
				V1=(Vol*0xFFFF)/100;
			if(V2 && !(A&2)) // R Audio turned Off
				V2=0;
			else if(!V2 && (A&2)) // R Audio turned On
				V2=(Vol*0xFFFF)/100;
		}
d1051 22
a1072 15
		if( Vol != MAX(SP[7],SP[8])*100/0xFFFF)
		{
			PutValue(FG,TAG(AudioVolume1),(Vol*0xFFFF)/100);
			PutValue(FG,TAG(AudioVolume2),(Vol*0xFFFF)/100);
		}
		if( V1!=SP[9] || V2!=SP[10] )
		{
			PutValue(FG,TAG(AudioVolume1),V1);
			PutValue(FG,TAG(AudioVolume2),V2);
			if(V2 && !V1)
				PutValue(FG,TAG(AudioPan2),0);
			else if(V1 && !V2)
				PutValue(FG,TAG(AudioPan1),0);
		}
		return(TRUE);
d1082 1
a1082 2
	char Label[MAX_PANEL_STR]="Video Clip: ",*tog[]={"Play Audio ","Show Video "},
		*togxp[]={"Right ","Left ","Video "};
d1085 1
a1087 2
//		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
//		strncpy(Label,ClipPL[0].Label,MAX_PANEL_STR);
a1088 1

a1090 1

d1233 2
a1234 2
		if(XPClipPL[1].PropStart)
			PutTable(FG,TAG_CommentList,CommentBuf,XPClipPL[1].PropEnd);
d1308 2
a1309 2
	LONG A=69,B=1,t_In=100,t_Out=1,type=PanType,Time=80;
	char Label[MAX_PANEL_STR]="Barney in Bosnia";
d1311 1
d1314 1
a1314 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d1317 1
a1318 3
		B=GetValue(FG,TAG(FadeInVideo));
		B=((B!=0) ? 0:1);
		t_Out=B;
d1320 1
a1320 1
	if(type==PAN_EASY)
d1322 9
a1330 23
		FramePL[2].Label =Label;
		FramePL[1].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		FramePL[1].Param = (long *)CommentBuf;
		FramePL[4].Param = &Time;	// Time slider
		FramePL[4].PropStart = 1;
		FramePL[4].PropEnd = (t_In>=900 ? t_In:1800);
		FramePL[5].Param = &B;
		FramePL[4].Flags = PL_LEN;
//		GadIndex[GAD_LEN]=4;  // Set index for hotkey
		type = Panel(Edit, FramePL,TRUE);
	}
	if(type==PAN_EXPERT)
	{
		XPFramePL[2].Label =Label;
		XPFramePL[1].Param2 = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPFramePL[1].Param = (long *)CommentBuf;
		XPFramePL[4].Param = &Time;	// Time slider
		XPFramePL[4].PropStart = 1;
		XPFramePL[4].PropEnd = (t_In>=900 ? t_In:1800);
		XPFramePL[5].Param = &B;
		XPFramePL[4].Flags = PL_LEN;
//		GadIndex[GAD_LEN]=4;  // Set index for hotkey
		type = Panel(Edit, XPFramePL,FALSE);
a1334 2
		{
//			DUMPUDECL("****** NEW DURATION=",(LONG)(Time<<1),"\\");
d1336 2
a1337 2
		}
		if(B!=t_Out) PutValue(FG,TAG(FadeInVideo),B^1);
d1346 2
a1347 2
	LONG A=0,B=2,t_In,t_Out,type=PanType,Speed=1,Time=69,DLay=12,FadeIn=0,FadeOut=0;
	char Label[MAX_PANEL_STR]="Overlay";
d1349 1
d1352 1
a1352 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d1356 5
d1364 14
a1377 15
		KeyPL[1].Label = Label;
		KeyPL[4].Param = &Time;
		KeyPL[4].PropStart = 1;
		KeyPL[4].PropEnd = 3600;
		KeyPL[5].Param = &DLay;
		KeyPL[5].PropStart = 1;
		KeyPL[5].PropEnd = 3600;
//		t_In = (Speed&1); // set to crouton's 0=fade,1=cut
//		KeyPL[4].Param = &t_In;
//		t_Out = (Speed&2)>>1; // set to crouton's 0=fade,1=cut
//		KeyPL[5].Param = &t_Out;
		KeyPL[4].Flags = PL_LEN;
		KeyPL[5].Flags = PL_DEL;
//		GadIndex[GAD_LEN]=4;  // Set index for hotkey
//		GadIndex[GAD_DEL]=5;  // Set index for hotkey
d1382 14
a1395 7
		XPKeyPL[1].Label = Label;
		XPKeyPL[4].Param = &Time;
		XPKeyPL[4].PropStart = 1;
		XPKeyPL[4].PropEnd = 3600;
		XPKeyPL[5].Param = &DLay;
		XPKeyPL[5].PropStart = 1;
		XPKeyPL[5].PropEnd = 600;
d1397 1
a1397 1
		XPKeyPL[7].Param = &t_In;
d1399 6
a1404 12
		XPKeyPL[8].Param = &t_Out;
		XPKeyPL[9].Param = &FadeIn;
		XPKeyPL[9].PropStart = 1;
		XPKeyPL[9].PropEnd = A;
		XPKeyPL[10].Param = &FadeOut;
		XPKeyPL[10].PropStart = 1;
		XPKeyPL[10].PropEnd = A;

		XPKeyPL[4].Flags = PL_LEN;
		XPKeyPL[5].Flags = PL_DEL;
		XPKeyPL[9].Flags = PL_IN;
		XPKeyPL[10].Flags = PL_OUT;
d1406 5
a1410 4
//		GadIndex[GAD_LEN]=4;  // Set index for hotkey
//		GadIndex[GAD_DEL]=5;  // Set index for hotkey
//		GadIndex[GAD_IN]=9;  // Set index for hotkey
//		GadIndex[GAD_OUT]=10;  // Set index for hotkey
d1422 11
d1442 2
a1443 1
	char Label[MAX_PANEL_STR]="Arnie can't get laid";
d1446 1
a1446 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d1450 1
d1454 19
a1472 10
		CrawlPL[3].Param = &A;
		CrawlPL[5].Param = (long *)Crawls;		// POPUP
		CrawlPL[5].PropStart = DEF_SCROLL;
		CrawlPL[5].PropEnd = CRAWL_NUM;
		CrawlPL[4].Param = &B;
		CrawlPL[4].PropStart = 1;
		CrawlPL[4].PropEnd = 3600;
		CrawlPL[6].Param = &C;
		CrawlPL[6].PropStart = 1;
		CrawlPL[6].PropEnd = 3600;
a1473 4
		CrawlPL[4].Flags = PL_DEL;
		CrawlPL[6].Flags = PL_LEN;
//		GadIndex[GAD_LEN]=6;  // Set index for hotkey
//		GadIndex[GAD_DEL]=4;  // Set index for hotkey
d1481 2
d1493 1
d1500 1
d1504 3
a1506 10
		ScrollPL[3].Param = &A;
		ScrollPL[5].Param = (long *)Scrolls;		// POPUP
		ScrollPL[5].PropStart = DEF_SCROLL;
		ScrollPL[5].PropEnd = SCROLL_NUM;
		ScrollPL[4].Param = &B;
		ScrollPL[4].PropStart = 1;
		ScrollPL[4].PropEnd = 3600;
		ScrollPL[6].Param = &C;
		ScrollPL[6].PropStart = 1;
		ScrollPL[6].PropEnd = 3600;
d1508 15
a1522 2
		ScrollPL[4].Flags = PL_DEL;
		ScrollPL[6].Flags = PL_LEN;
a1523 2
//		GadIndex[GAD_LEN]=6;  // Set index for hotkey
//		GadIndex[GAD_DEL]=4;  // Set index for hotkey
d1531 2
d1691 1
a1691 1

@


2.25
log
@*** empty log message ***
@
text
@d161 1
a161 1
#define CROUTON_LINE(j,l,w) {PNL_CROUTON,j,l,w,0,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL}
a340 1
	TEXT_LINE(PNL_LEFT,"<name>",0),
d342 1
d364 1
a364 1
	EZNUM_LINE(  PNL_CENTER, "Volume ",1),
d366 2
a367 1
	TOGGLE_LINE( PNL_LEFT," ",1),
d640 22
d663 3
a665 2
// channels: bit 0 = L, Bit 1 = R
void SetFlyerAudio(struct FastGadget *FG,UWORD Vol,UBYTE Channels)
d667 2
a668 1
	switch(Channels&3)
d670 1
a670 3
		case 0:
			PutValue(FG,TAG(AudioVolume1),0);
			PutValue(FG,TAG(AudioVolume2),0);
d673 1
a673 2
			PutValue(FG,TAG(AudioVolume1),Vol);
			PutValue(FG,TAG(AudioVolume2),0);
d677 1
a677 2
			PutValue(FG,TAG(AudioVolume1),0);
			PutValue(FG,TAG(AudioVolume2),Vol);
d681 2
a682 2
			PutValue(FG,TAG(AudioVolume1),Vol);
			PutValue(FG,TAG(AudioVolume2),Vol);
d689 11
a699 1
void SetInPoint(struct FastGadget *FG, ULONG InField, ULONG OutField)
d705 1
a705 1
void SetOutPoint(struct FastGadget *FG, ULONG InField, ULONG OutField)
d731 1
a731 1
void	DHD_Abort(ULONG Unit)
d738 1
a738 1
void	Main2Blank()
d981 2
a982 2
		AudClipPL[2].Param = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		AudClipPL[2].Param2 = (long *)TempCh;
d1015 2
a1016 2
		XPAudClipPL[2].Param = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		XPAudClipPL[2].Param2 = (long *)TempCh;
d1128 2
a1129 1
	LONG Vol=100,OldVol,V1,V2,A=800,B=0,C,t_In=36,t_Out=69,A_In,A_Out,AFade_In=0,AFade_Out=0,type=PanType,SP[16]={36,69,0,36};
d1154 1
d1156 2
d1169 5
a1173 3
	else strncat(Label,"Kiki's Shower",MAX_PANEL_STR);
  strcpy(TempCh,"No Comment At This Time");

d1177 1
a1177 1
		ClipPL[1].Label = ""; // Label;
d1179 5
a1183 5
		ClipPL[2].Label = Label;
		ClipPL[2].Param = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
		ClipPL[2].Param2 = (long *)CommentBuf;
		ClipPL[2].PropEnd = COMMENT_MAX ; // max string length
		ClipPL[2].PropStart=0;		// set to non-zero if comment is changed...
d1196 14
a1209 5
		ClipPL[8].Param=(long *)(Vol ? 3:2); // Audio Toggle
		ClipPL[8].Param2=(long *)tog;
		ClipPL[8].PropEnd = 2;
		DUMPHEXIL("Aud Bits: ",(long)ClipPL[8].Param,"\\");

a1211 1
//		ClipPL[8].Flags = PL_FLYER;
d1214 2
a1215 1
		if( !((long)ClipPL[8].Param) &1) Vol=0;
a1220 4
//		XPClipPL[3].Param = (long *)TempCh;
//		XPClipPL[3].Param2 = (long *)80;
//		XPClipPL[3].PropStart=1;  // indicate long string

d1223 2
a1224 2
		XPClipPL[1].Param = (FG ? (long *)FG->Data:(long *)NULL); // icon bitmap
		XPClipPL[1].Param2 = (long *)CommentBuf;
d1231 1
d1236 1
d1242 1
a1242 33
//		A_In = t_In;
//		A_Out = t_Out;
		XPClipPL[8].Param = &A_In;
		XPClipPL[8].PropStart = 0;
		XPClipPL[8].PropEnd = A-2;
		XPClipPL[9].Param = &A_Out;
		XPClipPL[9].PropStart = 0;
		XPClipPL[9].PropEnd = A-2;

		XPClipPL[10].Param = &Vol;
		XPClipPL[10].PropStart = 0;
		XPClipPL[10].PropEnd = 100;
		XPClipPL[11].Param = &AFade_In;
		XPClipPL[11].PropStart = 0;
		XPClipPL[11].PropEnd = A-2;

		C=4;
		if(V1) C|=1; // Volume 1 (L)
		if(V2) C|=2;
		XPClipPL[12].Param=(long *)C; // Audio Toggle
		XPClipPL[12].Param2=(long *)togxp;
		XPClipPL[12].PropEnd = 3;
		XPClipPL[13].Param = &AFade_Out;
		XPClipPL[13].PropStart = 0;
		XPClipPL[13].PropEnd = A-2;

		DUMPHEXIL("Aud Bits: ",C,"\\");
		XPClipPL[5].Flags = PL_IN | PL_FLYER;
		XPClipPL[6].Flags = PL_OUT | PL_FLYER;
//		GadIndex[GAD_IN]=5;  // Set index for hotkey
//		GadIndex[GAD_OUT]=6;  // Set index for hotkey
		type = Panel(Edit,XPClipPL,FALSE);
		if( ((long)XPClipPL[12].Param) != C )
d1244 36
a1279 10
			C = ((long)XPClipPL[12].Param);
			DUMPHEXIL("Aud Bits: ",C,"\\");
			if(V1 && !(C&1)) // L Audio turned Off
				V1=0;
			else if(!V1 && (C&1)) // L Audio turned On
				V1=(Vol*0xFFFF)/100;
			if(V2 && !(C&2)) // R Audio turned Off
				V2=0;
			else if(!V2 && (C&2)) // R Audio turned On
				V2=(Vol*0xFFFF)/100;
d1282 1
a1284 38
		if(B!=SP[2]) PutValue(FG,TAG(FadeInVideo),B^1);

		if(t_In!=SP[0])
		{
			PutValue(FG,TAG(ClipStartField),t_In<<1);
		 	PutValue(FG,TAG(Duration),(t_Out+2-t_In)<<1);
		}
		else if(t_Out!=SP[1])
		{
		 	PutValue(FG,TAG(Duration),(t_Out+2-t_In)<<1);
		}
		if(A_In!=SP[7])
		{
			PutValue(FG,TAG(AudioStart),A_In<<1);
		 	PutValue(FG,TAG(AudioDuration),(A_Out+2-A_In)<<1);
		}
		else if(A_Out!=SP[8])
		{
		 	PutValue(FG,TAG(AudioDuration),(A_Out+2-A_In)<<1);
		}
		if( (SP[11]>>1)!=AFade_In )
			PutValue(FG,TAG(AudioAttack),AFade_In<<1);
		if( (SP[12]>>1)!=AFade_Out )
			PutValue(FG,TAG(AudioDecay),AFade_Out<<1);
		if( OldVol != Vol )
		{
			PutValue(FG,TAG(AudioVolume1),(Vol*0xFFFF)/100);
			PutValue(FG,TAG(AudioVolume2),(Vol*0xFFFF)/100);
		}
		if( V1!=SP[9] || V2!=SP[10] )
		{
			PutValue(FG,TAG(AudioVolume1),V1);
			PutValue(FG,TAG(AudioVolume2),V2);
			if(V2 && !V1)
				PutValue(FG,TAG(AudioPan2),0);
			else if(V1 && !V2)
				PutValue(FG,TAG(AudioPan1),0);
		}
d1290 11
a1300 5
//			DUMPMSG("CANCEL WAS CLICKED");
			PutValue(FG,TAG(FadeInVideo),SP[2]^1);
			PutValue(FG,TAG(ClipStartField),SP[3]);
			PutValue(FG,TAG(Duration),SP[4]);
			Jam_On=FALSE;
d1302 1
a1302 1
	Main2Blank();
d1376 2
a1377 1
		FramePL[1].Param = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
d1389 2
a1390 1
		XPFramePL[1].Param = (FG ? (long *)FG->Data:(long *)NULL) ; // icon bitmap
d1725 1
d1753 2
d1781 2
@


2.24
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.23 94/09/10 20:11:35 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
a107 98
/*
UWORD CreateTimePL(		UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawTimePL(			UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleTimePL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyTimePL(struct PanelLine *);

UWORD CreateFlyTimePL(		UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawFlyTimePL(			UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleFlyTimePL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyFlyTimePL(struct PanelLine *);

UWORD CreateEZTimePL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawEZTimePL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleEZTimePL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyEZTimePL(struct PanelLine *);

UWORD CreateEZNumPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawEZNumPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleEZNumPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyEZNumPL(struct PanelLine *);

UWORD CreateEZLenPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawEZLenPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleEZLenPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyEZLenPL(struct PanelLine *);

UWORD CreateEZSliderPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawEZSliderPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleEZSliderPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyEZSliderPL(struct PanelLine *);

UWORD CreateSliderPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawSliderPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleSliderPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroySliderPL(struct PanelLine *);

UWORD CreateFlySliderPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawFlySliderPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleFlySliderPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyFlySliderPL(struct PanelLine *);

UWORD CreateStringPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawStringPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleStringPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyStringPL(struct PanelLine *);

UWORD CreateChoicePL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawChoicePL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleChoicePL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyChoicePL(struct PanelLine *);

UWORD CreateNumberPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
void DestroyNumberPL(struct PanelLine *);

UWORD CreatePopupPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawPopupPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandlePopupPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyPopupPL(struct PanelLine *);

UWORD CreateTextPL(		UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawTextPL(			UWORD , UWORD , struct PanelLine * , struct Window * );

UWORD CreateTogglePL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawTogglePL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleTogglePL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyTogglePL(struct PanelLine *);

UWORD CreateVCRPL(		UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawVCRPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleVCRPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
UWORD DestroyVCRPL(struct PanelLine *);

UWORD CreatePlayPL(		UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawPlayPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandlePlayPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
UWORD DestroyPlayPL(struct PanelLine *);

UWORD CreateFXSpeedPL(UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawFXSpeedPL(	UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleFXSpeedPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyFXSpeedPL(struct PanelLine *);

UWORD CreateInOutPL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawInOutPL(		UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleInOutPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyInOutPL(struct PanelLine *);

UWORD CreateDiffPL(		UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawDiffPL(			UWORD , UWORD , struct PanelLine * , struct Window * );

UWORD CreateDividePL(	UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawDividePL(		UWORD , UWORD , struct PanelLine * , struct Window * );

UWORD CreateCroutonPL(UWORD , UWORD , struct PanelLine * , struct Gadget ** );
UWORD DrawCroutonPL(	UWORD , UWORD , struct PanelLine * , struct Window * );
UWORD HandleCroutonPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
void DestroyCroutonPL(struct PanelLine *);
 */
a1150 1
//		ClipPL[5].Param2 = (long *)pan;
a1154 1
//		ClipPL[6].Param2 = (long *) pan;
@


2.23
log
@makeserver
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.22 94/09/09 20:39:26 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d104 2
d202 1
a202 1

a211 2
extern UBYTE *GadIndex;
extern char Size[],Name[],Dir[];
d224 1
d723 1
a723 1
		ESparams4.Data2=Table;
d736 1
a736 1
void SetFlyerAudio(UWORD Vol,UBYTE Channels)
a737 1
/*
d743 1
a743 1
			break
d748 1
a748 1
			break
d753 1
a753 1
			break
d759 1
a759 1
			break
d761 98
a858 1
 */
d860 1
@


2.22
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.21 94/09/09 13:39:41 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d200 1
a200 1
//#define SERDEBUG	1
d217 4
d245 1
d642 119
a762 1
#define TAG(x)	(0x80000000|TAG_##x)
d1126 1
d1138 3
a1140 1
		ClipPL[2].Param2 = (long *)TempCh;
d1162 1
d1178 3
a1180 1
		XPClipPL[1].Param2 = (long *)TempCh;
d1280 2
@


2.21
log
@Make some pretty test panels for the drooling interface czar wannabes
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.20 94/09/07 14:43:46 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d133 5
d255 1
d428 2
a429 2
	SLIDER_LINE(PNL_LEFT,"In",1),
	SLIDER_LINE(PNL_LEFT,"Out",0),
@


2.20
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.18 94/09/06 22:27:41 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d247 1
d477 6
d538 43
a580 13
	TEXT_LINE(PNL_LEFT,"Dinner Time Interface (Preliminary Design (c) 1994)",0),
	DIVIDE_LINE(PNL_LEFT,"Whacko! ",0 ),
	STRING_LINE(PNL_CENTER,"Restaurant",1),
	POPUP_LINE(PNL_LEFT,"To Drink?  ",0 ),
	EZNUM_LINE( PNL_CENTER, "Grease (%) ",0),
	TOGGLE_LINE(PNL_CENTER,"Bill?",0),
	EZTIME_LINE(PNL_CENTER,"Barf Wait",1),
	EZTIME_LINE(PNL_CENTER,"Pee Wait",0),
	FXSPEED_LINE(PNL_LEFT,"Lose It",1),
	SLIDER_LINE(PNL_LEFT,"Nausea",0),
	TOGGLE_LINE(PNL_LEFT,"Bill?",0),
	PLAY_LINE(PNL_LEFT,"FX",0 ),
	DIVIDE_LINE(PNL_CENTER,"  Bye Bye  ",0 ),
d584 1
d772 1
a772 1
		Vol=50,S=0,SP[12]={36,69,0,0};
d792 2
a793 2
		SP[9]  = GetValue(FG,TAG(AudioPan1));
		SP[10] = GetValue(FG,TAG(AudioPan2));
d883 18
a1040 3
		XPClipPL[2].Param = XPClipPL[6].Param; // out
		XPClipPL[2].Param2 = XPClipPL[5].Param; // in

d1049 3
d1563 1
a1563 1
	char Mystr[50]="Aboud's",*ts="Test";
a1567 3
/*
	TestPL[2].Param = (long *)Mystr;	// STRING
	TestPL[2].Param2 =(long *) 50;
d1569 4
a1572 25
	TestPL[3].Param = (long *)Pops;		// POPUP
	TestPL[3].PropStart = 4;
	TestPL[3].PropEnd = 8;

	TestPL[4].Param = (long *)&D;			// NUMBER
	TestPL[4].PropStart = 0;  // min
	TestPL[4].PropEnd = 100;  // max

	TestPL[5].Param = (long *)7;			// TOGGLE
	TestPL[5].Param2 =(long *)Names ;
	TestPL[5].PropEnd = 5;

	TestPL[6].Param = (long *)&In;			// EZTIME
	TestPL[6].PropStart = 0;
	TestPL[6].PropEnd = 500;

	TestPL[7].Param = (long *)&t_Out;			// TIME
	TestPL[7].Param2 = (long *)&TestPL[8];  	// FXSpeed gadg to set to V
	TestPL[7].PropStart = 0;
	TestPL[7].PropEnd = 500;

	TestPL[8].Param = (long *)&B;			// FXSPEED
	TestPL[8].Param2 = (long *)SP;
	TestPL[8].PropStart = (long)&TestPL[7];		// PLine (time) to update
	TestPL[8].PropEnd = 500;
d1574 13
a1586 1
	TestPL[9].Param = (long *)&A;			// SLIDER
d1588 56
a1643 1
	TestPL[9].PropEnd = 100;
d1645 3
a1647 6
	TestPL[10].Param = (long *)7;			// TOGGLE
	TestPL[10].Param2 =(long *)Names ;
	TestPL[10].PropEnd = 5;

	type = Panel(Edit, TestPL,TRUE);
 */
d1732 2
a1733 1
 if(!SwitPort) DoTestPanel(Edit);
@


2.19
log
@*** empty log message ***
@
text
@a137 1
UWORD HandleNumberPL(struct IntuiMsg *, struct PanelLine * , struct Window * );
d240 1
@


2.18
log
@Cry Havoc, and let slip the dogs of war
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.17 94/09/05 19:07:37 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d254 7
a260 8
//{ PNL_TEXT,PNL_CENTER,"Panel Maker",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
TEXT_LINE(PNL_CENTER,"Panel Maker",0),
STRING_LINE(PNL_LEFT,"Title",0),
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER,"<Title>",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_POPUP,PNL_LEFT,"Add Gadget",0 ,0	,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ 0,0,0,0,0 } // end of array marker
d264 8
a271 8
{ PNL_TEXT,PNL_CENTER,"Crouton Error:",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"Vital Statistics: ",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER,"Current Home",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER,"Birthplace ",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
a288 16
/*
{ PNL_TEXT,PNL_CENTER,"                  Record Raw Footage",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TOGGLE,PNL_LEFT,"Tracks:",0,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_POPUP,PNL_LEFT,"Quality",0 ,0	,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_DIFF,PNL_LEFT,"Approximate Time Available ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_EZTIME,PNL_CENTER,"Record Time",0,0	,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
{ PNL_DIFF,PNL_LEFT,"Reorganized Time Available ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER," ",1,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER," ",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER," ",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
 */
d292 13
a304 16
{ PNL_TEXT,PNL_RIGHT,"Mark",1,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"Clips",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TIME,PNL_CENTER,"In",1,0	,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
{ PNL_TIME,PNL_CENTER,"Out",0,0	,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
//{ PNL_EZTIME,PNL_CENTER,"In",1,0	,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
//{ PNL_EZTIME,PNL_CENTER,"Out",0,0	,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
//{ PNL_TEXT,PNL_RIGHT," Clip Length",1,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_STRING,PNL_CENTER,"Clip Name",1,0	,0,0,0,CreateStringPL,DrawStringPL,HandleStringPL,DestroyStringPL},
{ PNL_DIFF,PNL_LEFT,"Length ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER," ",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER," ",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_CENTER," ",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d309 11
a319 11
{ PNL_TEXT,PNL_CENTER,"File Information",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0									,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_STRING,PNL_LEFT,"Name",0,0							,0,0,0,CreateStringPL,DrawStringPL,HandleStringPL,DestroyStringPL},
{ PNL_TEXT,PNL_CENTER,"Type ",0,0							,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"Comment",0,0							,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"File Size",0,0						,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"Date",0,0								,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"Attributes",0,0					,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"Protection",0,0					,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0									,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d323 7
a329 8
{ PNL_TEXT,PNL_LEFT,"Frame",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_EZLEN,PNL_CENTER,"Length",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
// { PNL_IN_TYPE,PNL_LEFT,0,0,0			,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d333 7
a339 8
{ PNL_TEXT,PNL_LEFT,"Frame",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_EZTIME,PNL_CENTER,"Length",0,0	,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
// { PNL_IN_TYPE,PNL_LEFT,0,0,0			,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d343 8
a350 8
{ PNL_TEXT,PNL_LEFT,"Video Input",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_EZLEN,PNL_CENTER,"Length",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
// { PNL_EZTIME,PNL_CENTER,"Length",0,0		,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
// { PNL_IN_TYPE,PNL_LEFT,0,0,0				,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d354 6
a359 7
{ PNL_TEXT,PNL_LEFT,"Video Input",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TIME,PNL_CENTER,"Length",0,0		,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
// { PNL_IN_TYPE,PNL_LEFT,0,0,0				,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d363 8
a370 8
{ PNL_TEXT,PNL_LEFT,"Effect",0,0		,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_FXSPEED,PNL_LEFT,"Speed",0,0	,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL},
{ PNL_EZLEN,PNL_CENTER,"Duration:",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d374 10
a383 10
{ PNL_TEXT,PNL_LEFT,"Effect",0,0		,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_FXSPEED,PNL_LEFT,"Speed",1,0	,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL},
{ PNL_EZLEN,PNL_CENTER,"Frames:",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_POPUP,PNL_LEFT,"Effect Color ",1 ,0		,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_EZTIME,PNL_CENTER,"Start Key:",0,0		,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d387 8
a394 8
{ PNL_TEXT,PNL_LEFT,"Effect",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0					,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_FXSPEED,PNL_LEFT,"Speed",0,0			,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL},
{ PNL_FXTIME,PNL_LEFT,"Duration:  ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d398 9
a406 9
{ PNL_TEXT,PNL_LEFT,"Effect",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0					,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_FXSPEED,PNL_LEFT,"Speed",0,0			,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL},
{ PNL_FXTIME,PNL_LEFT,"Duration:  ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_POPUP,PNL_LEFT,"Effect Color ",0 ,0		,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d420 1
a420 1
	{ 0,0,0,0,0 } // end of array marker
d425 1
a426 1
	CROUTON_LINE(PNL_LEFT,"",0),
d443 10
a452 10
{ PNL_TEXT,PNL_LEFT,"Audio Clip",0,0,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"<name>",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0					,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0				,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_SLIDER,PNL_LEFT,"In",1,0				,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_SLIDER,PNL_LEFT,"Out",0,0				,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_EZLEN,PNL_CENTER,"Start Time",1,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIFF,PNL_LEFT,"Duration: ",0,0	,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d456 12
a467 15
{ PNL_TEXT,PNL_LEFT,"Audio Clip",0,0,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0					,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0				,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TIME,PNL_LEFT,"In",1,0				,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
{ PNL_TIME,PNL_LEFT,"Out",0,0			,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
{ PNL_EZLEN,PNL_CENTER,"Start Time",1,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIFF,PNL_LEFT,"Duration: ",0,0	,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"Fine Tune ",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},

{ PNL_EZNUM, PNL_CENTER, "Volume ",1,0			,0,0,0,CreateEZNumPL,DrawEZTimePL,HandleEZNumPL,DestroyEZNumPL},
{ PNL_EZLEN,PNL_CENTER,"Fade In",0,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},

{ PNL_TOGGLE,PNL_LEFT,"Channels: ",1,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_EZLEN,PNL_CENTER,"Fade Out",0,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
d469 5
a473 2
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d477 8
a484 8
{ PNL_TEXT,PNL_LEFT,"CG Key",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0		,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_EZLEN,PNL_CENTER,"Length",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_EZLEN,PNL_CENTER,"Delay",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d488 13
a500 13
{ PNL_TEXT,PNL_LEFT,"CG Key",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0		,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_EZTIME,PNL_CENTER,"Delay",1,0		,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
{ PNL_EZTIME,PNL_CENTER,"Length",0,0	,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_IN_TYPE,PNL_LEFT,0,1,0			,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL},
{ PNL_OUT_TYPE,PNL_LEFT,0,0,0			,0,0,0,CreateInOutPL,DrawInOutPL,NULL,DestroyInOutPL},
{ PNL_EZLEN,PNL_CENTER,"Fade In",1,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_EZLEN,PNL_CENTER,"Fade Out",0,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d504 9
a512 9
{ PNL_TEXT,PNL_LEFT,"CG Crawl",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0			,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_CHOICE4,PNL_LEFT,"Speed",0,0	,0,0,0,CreateChoicePL,DrawChoicePL,HandleChoicePL,DestroyChoicePL},
{ PNL_EZLEN,PNL_LEFT,"Delay",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_POPUP,PNL_LEFT,"Scroll",0 ,0		,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_EZLEN,PNL_LEFT,"Hold Duration",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d516 9
a524 9
{ PNL_TEXT,PNL_LEFT,"CG Scroll",0,0		,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"name",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0				,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_CHOICE5,PNL_LEFT,"Speed",0,0		,0,0,0,CreateChoicePL,DrawChoicePL,HandleChoicePL,DestroyChoicePL},
{ PNL_EZLEN,PNL_LEFT,"Delay",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_POPUP,PNL_LEFT,"Scroll",0 ,0		,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_EZLEN,PNL_LEFT,"Hold Duration",0,0	,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d528 14
a541 14
{ PNL_TEXT,PNL_LEFT,"Dinner Time Interface (Preliminary Design (c) 1994)",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"Whacko! ",0 ,0  								,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_STRING,PNL_CENTER,"Restaurant",1,0  					,0,0,0,CreateStringPL,DrawStringPL,HandleStringPL,DestroyStringPL},
{ PNL_POPUP,PNL_LEFT,"To Drink?  ",0 ,0		,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_EZNUM, PNL_CENTER, "Grease (%) ",0,0			,0,0,0,CreateEZNumPL,DrawEZTimePL,HandleEZNumPL,DestroyEZNumPL},
{ PNL_TOGGLE,PNL_CENTER,"Bill?",0,0  						,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_EZTIME,PNL_CENTER,"Barf Wait",1,0								,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
{ PNL_EZTIME,PNL_CENTER,"Pee Wait",0,0								,0,0,0,CreateEZTimePL,DrawEZTimePL,HandleEZTimePL,DestroyEZTimePL},
{ PNL_FXSPEED,PNL_LEFT,"Lose It",1,0						,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL},
{ PNL_SLIDER,PNL_LEFT,"Nausea",0,0							,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_TOGGLE,PNL_LEFT,"Bill?",0,0  						,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_PLAY,PNL_LEFT,"FX",0 ,0									,0,0,0,CreatePlayPL,DrawPlayPL,NULL,DestroyPlayPL},
{ PNL_DIVIDE,PNL_CENTER,"  Bye Bye  ",0 ,0									,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d545 14
a558 14
{ PNL_TEXT,PNL_LEFT,"Control Panel Test",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"Whacko!",0 ,0  								,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_STRING,PNL_LEFT,"Name",1,0  						,0,0,0,CreateStringPL,DrawStringPL,HandleStringPL,DestroyStringPL},
{ PNL_POPUP,PNL_LEFT,"Panel Type",0 ,0  	,0,0,0,CreatePopupPL,DrawPopupPL,HandlePopupPL,DestroyPopupPL},
{ PNL_NUMBER, PNL_CENTER, "% Potato",0,0  		,0,0,0,CreateNumberPL,DrawStringPL,HandleStringPL,DestroyStringPL},
{ PNL_TOGGLE,PNL_LEFT,"Test Panel? ",0,0  						,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_TIME,PNL_LEFT,"In",1,0									,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},  //#9
{ PNL_TIME,PNL_LEFT,"Out",0,0									,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
{ PNL_FXSPEED,PNL_LEFT,"Speed",0,0						,0,0,0,CreateFXSpeedPL,DrawFXSpeedPL,HandleFXSpeedPL,DestroyFXSpeedPL},
{ PNL_SLIDER,PNL_LEFT,"Slide",1,0							,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_SLIDER,PNL_LEFT,"Slide",0,0							,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_VCR,PNL_LEFT,0,0,0							,0,0,0,CreateVCRPL,DrawVCRPL,0,DestroyVCRPL},
{ PNL_DIVIDE,PNL_CENTER,"  Bye Bye  ",0 ,0									,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d972 1
a972 1
		XPClipPL[1].Label = "";
d977 7
a983 3
		XPClipPL[2].Label = Label;
		XPClipPL[2].Param = (FG ? (long *)FG->Data:(long *)NULL); // icon bitmap
		XPClipPL[2].Param2 = (long *)TempCh;
a992 2
		XPClipPL[1].Param = XPClipPL[6].Param; // out
		XPClipPL[1].Param2 = XPClipPL[5].Param; // in
@


2.17
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.16 94/09/04 17:52:40 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d94 5
d114 5
d179 3
d226 24
d251 3
a253 2
{ PNL_TEXT,PNL_CENTER,"Panel Maker",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_STRING,PNL_LEFT,"Title",0,0				,0,0,0,CreateStringPL,DrawStringPL,HandleStringPL,DestroyStringPL},
d273 15
d302 1
a428 1
#define CLIP_TIME	5		// index of first time in gad..
d430 11
a440 11
{ PNL_TEXT,PNL_LEFT,"Video Clip ",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"<name>",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0					,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
{ PNL_DIFF,PNL_LEFT,"Length: ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_SLIDER,PNL_LEFT,"In",1,0				,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_SLIDER,PNL_LEFT,"Out",0,0				,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_DIVIDE,PNL_LEFT,"Audio ",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TOGGLE,PNL_CENTER,0,0,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d444 16
a459 17
{ PNL_TEXT,PNL_LEFT,"Video Clip",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TEXT,PNL_LEFT,"<name>",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_CROUTON,PNL_LEFT,"",0,0					,0,0,0,CreateCroutonPL,DrawCroutonPL},
{ PNL_DIFF,PNL_LEFT,"Length: ",0,0		,0,0,0,CreateDiffPL,DrawDiffPL},
{ PNL_DIVIDE,PNL_LEFT,"Video ",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TIME,PNL_LEFT,"In",1,0					,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},  // Changing where these are in array will break UpdatePanStr()
{ PNL_TIME,PNL_LEFT,"Out",0,0				,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
{ PNL_DIVIDE,PNL_LEFT,"Audio ",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
//{ PNL_TOGGLE,PNL_CENTER,0,0,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_TIME,PNL_LEFT,"In",1,0					,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},  // Changing where these are in array will break UpdatePanStr()
{ PNL_TIME,PNL_LEFT,"Out",0,0				,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
{ PNL_EZNUM, PNL_CENTER, "Volume ",1,0			,0,0,0,CreateEZNumPL,DrawEZTimePL,HandleEZNumPL,DestroyEZNumPL},
{ PNL_EZLEN,PNL_CENTER,"Fade In",0,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_TOGGLE,PNL_LEFT," ",1,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_EZLEN,PNL_CENTER,"Fade Out",0,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ 0,0,0,0,0 } // end of array marker
d752 1
a752 1
	char Label[MAX_PANEL_STR]="Audio Clip: ";
d784 6
a789 3
		AudClipPL[1].Label = Label;
		AudClipPL[1].Param = (LONG *)Label;
		AudClipPL[1].Param2 = (LONG *)80;
d818 7
d954 1
a954 5

//		DUMPUDECL("StartField=",SP[3],"\\");
//		DUMPUDECL("Duration  =",SP[4],"\\");
//		DUMPUDECL("InFrame   =",SP[0],"\\");
//		DUMPUDECL("OutFrame  =",SP[1],"\\");
d958 1
a958 1
		ClipPL[0].Label = Label;
d960 2
d963 1
d968 1
d973 1
d991 1
a991 1
		XPClipPL[0].Label = Label;
d993 5
d999 1
d1009 2
a1010 2
		XPClipPL[3].Param = ClipPL[6].Param; // out
		XPClipPL[3].Param2 = ClipPL[5].Param; // in
@


2.16
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.15 94/09/03 17:50:55 CACHELIN4000 Exp Locker: CACHELIN4000 $
a3 3
*Revision 2.15  94/09/03  17:50:55  CACHELIN4000
**** empty log message ***
*
a43 3
*Revision 2.1  94/07/04  18:40:22  CACHELIN4000
**** empty log message ***
*
a46 2
*
*
d612 1
a612 1
	char Label[MAX_PANEL_STR]="Cool FX";
d617 2
a618 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d631 2
a632 1
		EffectPL[1].Label =Label;
d646 2
a647 1
		XPEffectPL[1].Label =Label;
d697 1
a697 1
	char Label[MAX_PANEL_STR]="Canned Laughter";
d701 2
a702 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d715 1
a715 1
		Vol=MAX(V1,V2)*100/0xFFFF;
d726 1
a726 1

d853 1
a853 1
	char Label[MAX_PANEL_STR]="Video Clip ",*tog[]={"Play Audio ","Show Video "},
d877 1
a877 1
		OldVol=Vol=MAX(V1,V2)*100/0xFFFF;
d888 1
d902 2
a903 2
		ClipPL[5].PropStart = 0;		//1?
		ClipPL[5].PropEnd = A-2;		//A?
d906 2
a907 2
		ClipPL[6].PropStart = 0;		//1?
		ClipPL[6].PropEnd = A-2;		//A?
d915 1
a918 2
//		GadIndex[GAD_IN]=5;  // Set index for hotkey
//		GadIndex[GAD_OUT]=6;  // Set index for hotkey
d920 1
d966 1
a966 1

d975 1
@


2.15
log
@*** empty log message ***
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.14 94/09/02 20:18:08 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d382 1
a382 1
{ PNL_TEXT,PNL_LEFT,"Video Clip",0,0	,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
d857 1
a857 1
	char Label[MAX_PANEL_STR]="Kiki's Shower",*tog[]={"Play Audio ","Show Video "},
d863 3
a865 1
		strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
d900 2
a901 1
		ClipPL[1].Label = Label;
d928 2
a929 1
		XPClipPL[1].Label = Label;
d1351 1
d1410 2
@


2.14
log
@More Tweaks.
@
text
@d2 5
a6 2
* $Id: COntrols.c,v 2.13 94/09/01 21:13:55 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	COntrols.c,v $
d404 3
a406 1
{ PNL_EZLEN,PNL_CENTER,"Fade In",1,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
a407 2
{ PNL_TOGGLE,PNL_LEFT," ",1,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_EZNUM, PNL_CENTER, "Volume ",0,0			,0,0,0,CreateEZNumPL,DrawEZTimePL,HandleEZNumPL,DestroyEZNumPL},
d435 5
a439 1
{ PNL_EZLEN,PNL_CENTER,"Fade In",1,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
d441 1
a441 2
{ PNL_TOGGLE,PNL_LEFT,"Channels: ",1,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_EZNUM, PNL_CENTER, "Volume ",0,0			,0,0,0,CreateEZNumPL,DrawEZTimePL,HandleEZNumPL,DestroyEZNumPL},
d735 1
a735 1
		AudClipPL[4].PropStart = 1;
d739 1
a739 1
		AudClipPL[5].PropStart = 1;
d746 1
a746 1
		AudClipPL[6].PropStart = 1;
d762 1
a762 1
		XPAudClipPL[4].PropStart = 1;
d766 1
a766 1
		XPAudClipPL[5].PropStart = 1;
d773 1
a773 1
		XPAudClipPL[6].PropStart = 1;
d776 3
a778 3
		XPAudClipPL[9].Param = &FadeIn;
		XPAudClipPL[9].PropStart = 1;
		XPAudClipPL[9].PropEnd = A-2;
d780 2
a781 2
		XPAudClipPL[10].Param = &FadeOut;
		XPAudClipPL[10].PropStart = 1;
a786 1
		A=(long)XPAudClipPL[11].Param;
d788 1
a788 1
		XPAudClipPL[12].Param = &Vol;
d790 3
a792 1
		XPAudClipPL[12].PropEnd = 100;
d926 1
a926 1
		XPClipPL[5].PropStart = 1;
d930 1
a930 1
		XPClipPL[6].PropStart = 1;
d939 1
a939 1
		XPClipPL[8].PropStart = 1;
d942 1
a942 1
		XPClipPL[9].PropStart = 1;
d945 5
a949 5
		XPClipPL[10].Param = &AFade_In;
		XPClipPL[10].PropStart = 1;
		XPClipPL[10].PropEnd = A-2;
		XPClipPL[11].Param = &AFade_Out;
		XPClipPL[11].PropStart = 1;
d958 3
a961 3
		XPClipPL[13].Param = &Vol;
		XPClipPL[13].PropStart = 0;
		XPClipPL[13].PropEnd = 100;
@


2.13
log
@*** empty log message ***
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.12 94/09/01 18:02:45 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d185 1
d846 1
a846 1
	LONG Vol=100,V1,V2,A=800,B=0,C,t_In=36,t_Out=69,A_In,A_Out,AFade_In=0,AFade_Out=0,type=PanType,SP[16]={36,69,0,36};
d869 1
a869 1
		Vol=MAX(V1,V2)*100/0xFFFF;
d1000 1
a1000 1
		if( Vol!=MAX(SP[9],SP[10]) )
d1003 1
a1003 1
			PutValue(FG,TAG(AudioVolume1),(Vol*0xFFFF)/100);
d1705 2
a1706 1
//				SendSwitcherReply(ES_StartControl,FG,0,0);
d1711 2
a1712 1
//				SendSwitcherReply(ES_StopControl,FG,0,0);
@


2.12
log
@Audio Tag corrections
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.11 94/09/01 10:41:21 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d869 1
a869 1
		if(t_In > t_Out) t_Out - t_In;
@


2.11
log
@TAG() define...
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.10 94/09/01 03:33:29 Kell Exp Locker: CACHELIN4000 $
d4 3
d188 1
a188 1
#define PNL_NUM	15
d544 2
d684 2
a685 2
	LONG FadeIn=0,FadeOut=0,A=800,B=0,t_In=36,t_Out=69,type=PanType,Time,
		Vol=50,S=0,SP[4]={36,69,0,0};
d691 22
a712 13
		t_In	=	GetValue(FG,TAG(ClipStartField));
		t_Out	=	(t_In+GetValue(FG,TAG(Duration)))>>1;
		t_In >>= 1;
		A		=	GetValue(FG,TAG(RecFields))>>1;
		S		=	GetValue(FG,TAG(FadeInVideo));
		S=((S!=0) ? 0:1);
	//	B		=	GetValue(FG,TAG(FadeOutVideo));
		B=((B!=0) ? 0:1);
		SP[0]=t_In;
		SP[1]=t_Out;
		SP[2]=S;
		SP[3]=B;
		Time=(A=GetValue(FG,TAG(Duration)));
d720 1
d724 1
d727 2
a728 1
		AudClipPL[5].PropEnd = A;
d731 1
d734 1
a734 1
		AudClipPL[6].PropEnd = A;
d747 1
d750 2
a751 1
		XPAudClipPL[4].PropEnd = A;
d754 2
a755 1
		XPAudClipPL[5].PropEnd = A;
d758 1
d761 2
a762 1
		XPAudClipPL[6].PropEnd = A;
d765 2
a766 1
		XPAudClipPL[9].PropEnd = A;
d769 3
a771 2
		XPAudClipPL[10].PropEnd = A;
		XPAudClipPL[11].Param = (LONG *)3;
d774 2
d788 13
d804 27
d839 1
a839 1
	LONG Vol=100,A=800,B=0,t_In=36,t_Out=69,A_In,A_Out,AFade_In=0,AFade_Out=0,type=PanType,SP[8]={36,69,0,36};
d854 9
a862 1

d866 1
d868 4
d895 1
a895 1
		ClipPL[8].Param=(long *)3; // Audio Toggle
d904 1
d913 1
a913 1
		XPClipPL[5].PropEnd = A;
d917 1
a917 1
		XPClipPL[6].PropEnd = A;
d922 2
a923 2
		A_In = t_In;
		A_Out = t_Out;
d926 1
a926 1
		XPClipPL[8].PropEnd = A;
d929 1
a929 1
		XPClipPL[9].PropEnd = A;
d933 1
a933 1
		XPClipPL[10].PropEnd = A;
d936 1
a936 1
		XPClipPL[11].PropEnd = A;
d938 4
a941 1
		XPClipPL[12].Param=(long *)7; // Audio Toggle
d954 12
a977 1
//			DUMPUDECL("****** NEW DURATION=",(LONG)((t_Out+4-t_In)<<1),"\\");
d980 27
d1481 1
a1481 1
			XPTestPL[3].PropStart = 11;
@


2.10
log
@Tweeked the TAG fields to Frames and visa versa conversions.
Fixed some TAGs that were getting ored with 0x8000000 (instead of 0x80000000)
@
text
@d2 6
a7 2
* $Id: controls.c,v 2.9 1994/08/30 17:26:34 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d196 1
a196 1
		"PROJECT","FRAMESTORE","KEY","SCROLL","CRAWL","RAWREC","MARKCLIP","ERROR",""},
d540 1
a540 1

d550 1
a550 1
		Speed=GetValue(FG,0x80000000|TAG_FCountMode);
d553 5
a557 5
		SP[0]=GetValue(FG,0x80000000|TAG_NumFramesSlow);
		SP[1]=GetValue(FG,0x80000000|TAG_NumFramesMedium);
		SP[2]=GetValue(FG,0x80000000|TAG_NumFramesFast);
		SP[3]=GetValue(FG,0x80000000|TAG_NumFramesVariable);
		t_In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
d585 1
a585 1
			PutValue(FG,0x80000000|TAG_FCountMode,FCM[B]);
d602 1
a602 1
		SP[3]=GetValue(FG,0x80000000|TAG_NumFramesVariable);
d605 1
a605 1
		Speed=GetValue(FG,0x80000000|TAG_FCountMode);
d608 4
a611 4
	 	SP[0]=GetValue(FG,0x80000000|TAG_NumFramesSlow);
		SP[1]=GetValue(FG,0x80000000|TAG_NumFramesMedium);
		SP[2]=GetValue(FG,0x80000000|TAG_NumFramesFast);
		t_In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
d652 1
a652 1
			PutValue(FG,0x80000000|TAG_FCountMode,FCM[B]); // FCM[3]=2 = variable
d654 1
a654 1
			PutValue(FG,0x80000000|TAG_VariableFCount,S<<1);   // Frames -> Fields
d686 2
a687 2
		t_In	=	GetValue(FG,0x80000000|TAG_ClipStartField);
		t_Out	=	(t_In+GetValue(FG,0x80000000|TAG_Duration))>>1;
d689 2
a690 2
		A		=	GetValue(FG,0x80000000|TAG_RecFields)>>1;
		S		=	GetValue(FG,0x80000000|TAG_FadeInVideo);
d692 1
a692 1
	//	B		=	GetValue(FG,0x80000000|TAG_FadeOutVideo);
d698 1
a698 1
		Time=(A=GetValue(FG,0x80000000|TAG_Duration));
d782 1
a782 1
		A = GetValue(FG,0x80000000|TAG_RecFields)>>1;  // Clip Frame Length
d785 2
a786 2
		SP[3]= GetValue(FG,0x80000000|TAG_ClipStartField);
		SP[4]= GetValue(FG,0x80000000|TAG_Duration);
d791 1
a791 1
		SP[2] = B     =((GetValue(FG,0x80000000|TAG_FadeInVideo) !=0) ? 0:1); // FadeIn flag
d873 1
a873 1
		if(B!=SP[2]) PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
d877 2
a878 2
			PutValue(FG,0x80000000|TAG_ClipStartField,t_In<<1);
		 	PutValue(FG,0x80000000|TAG_Duration,(t_Out+2-t_In)<<1);
d883 1
a883 1
		 	PutValue(FG,0x80000000|TAG_Duration,(t_Out+2-t_In)<<1);
d889 3
a891 3
			PutValue(FG,0x80000000|TAG_FadeInVideo,SP[2]^1);
			PutValue(FG,0x80000000|TAG_ClipStartField,SP[3]);
			PutValue(FG,0x80000000|TAG_Duration,SP[4]);
d907 2
a908 2
		Time=GetValue(FG,0x80000000|TAG_Duration)>>1; // Fields-->Frames
		t_In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
d910 1
a910 1
		B=GetValue(FG,0x80000000|TAG_FadeInVideo);
d941 1
a941 1
			PutValue(FG,0x80000000|TAG_Duration,Time<<1);    // Frames -> Fields
d943 1
a943 1
		if(B!=t_Out) PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
d958 2
a959 2
		Time=GetValue(FG,0x80000000|TAG_Duration)>>1; // Fields-->Frames
		t_In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
d961 1
a961 1
		B=GetValue(FG,0x80000000|TAG_FadeInVideo);
d994 1
a994 1
			PutValue(FG,0x80000000|TAG_Duration,Time<<1);    // Frames -> Fields
d996 1
a996 1
		if(B!=t_Out) PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
d1011 3
a1013 3
		Time=(A=GetValue(FG,0x80000000|TAG_Duration));
		DLay=(B=GetValue(FG,0x80000000|TAG_Delay));
		Speed=GetValue(FG,0x80000000|TAG_Speed); // bit0 =fade in, bit1=fade out
d1069 1
a1069 1
			PutValue(FG,0x80000000|TAG_Duration,Time);
d1087 3
a1089 3
		Speed=(A=GetValue(FG,0x80000000|TAG_Speed));
		DLay=(B=GetValue(FG,0x80000000|TAG_Delay));
		Time=(C=GetValue(FG,0x80000000|TAG_Duration));
d1112 3
a1114 3
		if(Speed!=A) PutValue(FG,0x80000000|TAG_Speed,A);
		if(DLay!=B) PutValue(FG,0x80000000|TAG_Delay,B);
		if(Time!=C) PutValue(FG,0x80000000|TAG_Duration,C);
d1128 3
a1130 3
		Speed=(A=GetValue(FG,0x80000000|TAG_Speed));
		DLay=(B=GetValue(FG,0x80000000|TAG_Delay));
		Time=(C=GetValue(FG,0x80000000|TAG_Duration));
d1154 3
a1156 3
		if(Speed!=A) PutValue(FG,0x80000000|TAG_Speed,A);
		if(DLay!=B) PutValue(FG,0x80000000|TAG_Delay,B);
		if(Time!=C) PutValue(FG,0x80000000|TAG_Duration,C);
@


2.9
log
@Replace GadIndx hack with PLine->Flags kludge.
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.8 94/08/30 10:31:42 Kell Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d157 1
a157 1
// #define SERDEBUG	1
d776 19
a794 12
		t_In	=	GetValue(FG,0x80000000|TAG_ClipStartField);
		t_Out	=	(t_In+GetValue(FG,0x80000000|TAG_Duration))>>1;
		t_In >>= 1;
		A		=	GetValue(FG,0x80000000|TAG_RecFields)>>1;
		B		=	GetValue(FG,0x80000000|TAG_FadeInVideo);
		B=((B!=0) ? 0:1);
		SP[0]=t_In;
		SP[1]=t_Out;
		SP[2]=B;
		SP[3]= GetValue(FG,0x8000000|TAG_ClipStartField);
		SP[4]= GetValue(FG,0x8000000|TAG_Duration);
	}
d799 1
d801 3
a803 2
		ClipPL[5].PropStart = 1;
		ClipPL[5].PropEnd = A;
d805 3
a807 2
		ClipPL[6].PropStart = 1;
		ClipPL[6].PropEnd = A;
d810 1
d814 1
d825 1
d829 1
d833 1
d870 1
d874 1
a874 1
		 	PutValue(FG,0x80000000|TAG_Duration,(t_Out-t_In)<<1);
d876 1
a876 1
		if(t_Out!=SP[1])
d878 2
a879 2
			DUMPUDECL("****** NEW DURATION=",(LONG)((t_Out-t_In)<<1),"\\");
		 	PutValue(FG,0x80000000|TAG_Duration,(t_Out-t_In)<<1);
d884 4
a887 3
			DUMPMSG("CANCEL WAS CLICKED");
			PutValue(FG,0x8000000|TAG_ClipStartField,SP[3]);
			PutValue(FG,0x8000000|TAG_Duration,SP[4]);
d936 1
a936 1
			DUMPUDECL("****** NEW DURATION=",(LONG)(Time<<1),"\\");
d989 1
a989 1
			DUMPUDECL("****** NEW DURATION=",(LONG)(Time<<1),"\\");
@


2.8
log
@Changed SendSwitcherReply calls to work with new ESParams structures.
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.7 1994/08/30 09:46:00 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d618 2
a619 1
		GadIndex[GAD_LEN]=5;  // Set index for hotkey
d638 2
a639 1
		GadIndex[GAD_LEN]=5;  // Set index for hotkey
d710 5
a714 1
		GadIndex[GAD_DEL]=6;  // Set index for hotkey
d745 8
a752 3
		GadIndex[GAD_IN]=4;  // Set index for hotkey
		GadIndex[GAD_OUT]=5;  // Set index for hotkey
		GadIndex[GAD_DEL]=6;  // Set index for hotkey
d800 4
a803 2
		GadIndex[GAD_IN]=5;  // Set index for hotkey
		GadIndex[GAD_OUT]=6;  // Set index for hotkey
d843 4
a846 2
		GadIndex[GAD_IN]=5;  // Set index for hotkey
		GadIndex[GAD_OUT]=6;  // Set index for hotkey
d897 2
a898 1
		GadIndex[GAD_LEN]=3;  // Set index for hotkey
d908 2
a909 1
		GadIndex[GAD_LEN]=3;  // Set index for hotkey
d949 2
a950 1
		GadIndex[GAD_LEN]=4;  // Set index for hotkey
d961 2
a962 1
		GadIndex[GAD_LEN]=4;  // Set index for hotkey
d1004 4
a1007 2
		GadIndex[GAD_LEN]=4;  // Set index for hotkey
		GadIndex[GAD_DEL]=5;  // Set index for hotkey
d1029 10
a1038 4
		GadIndex[GAD_LEN]=4;  // Set index for hotkey
		GadIndex[GAD_DEL]=5;  // Set index for hotkey
		GadIndex[GAD_IN]=9;  // Set index for hotkey
		GadIndex[GAD_OUT]=10;  // Set index for hotkey
d1079 5
a1083 2
		GadIndex[GAD_LEN]=6;  // Set index for hotkey
		GadIndex[GAD_DEL]=4;  // Set index for hotkey
d1120 6
a1125 2
		GadIndex[GAD_LEN]=6;  // Set index for hotkey
		GadIndex[GAD_DEL]=4;  // Set index for hotkey
d1156 3
a1158 1
		GadIndex[GAD_LEN]=6;  // Set index for hotkey
d1181 6
a1186 3
		GadIndex[GAD_IN]=3;  // Set index for hotkey
		GadIndex[GAD_OUT]=4;  // Set index for hotkey
		GadIndex[GAD_LEN]=6;  // Set index for hotkey
d1217 3
a1219 1
			GadIndex[GAD_LEN]=6;  // Set index for hotkey
d1239 7
a1245 4
			GadIndex[GAD_IN]=3;  // Set index for hotkey
			GadIndex[GAD_OUT]=4;  // Set index for hotkey
			GadIndex[GAD_LEN]=6;  // DIFF type
			GadIndex[GAD_DEL]=5;  // name string Set index for hotkey
d1370 9
a1378 4
			GadIndex[GAD_IN]=6;  // Set index for hotkey
			GadIndex[GAD_OUT]=7;  // Set index for hotkey
			GadIndex[GAD_LEN]=2;  // Set index for hotkey
			GadIndex[GAD_DEL]=4;  // Set index for hotkey
@


2.7
log
@Change ES_Messages to use ESparams struct
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.6 94/08/26 21:48:24 Kell Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
@


2.6
log
@Removed working with some obsolete Flyer tag items
@
text
@d2 5
a6 2
* $Id: controls.c,v 2.5 1994/08/24 12:07:28 CACHELIN4000 Exp Kell $
* $Log: controls.c,v $
d161 3
d172 1
a172 1
#define PNL_NUM	14
d183 1
a183 1
		"PROJECT","FRAMESTORE","KEY","SCROLL","CRAWL","RAWREC","MARKCLIP",""},
d199 11
d352 1
a352 1
struct PanelLine XPClipPL[] = {
d355 1
a355 1
{ PNL_CROUTON,PNL_LEFT,"",0,0					,0,0,0,CreateCroutonPL,DrawCroutonPL},
d357 3
a359 3
{ PNL_DIVIDE,PNL_LEFT,"Video ",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TIME,PNL_LEFT,"In",1,0					,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},  // Changing where these are in array will break UpdatePanStr()
{ PNL_TIME,PNL_LEFT,"Out",0,0				,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
a360 4
{ PNL_TEXT,PNL_LEFT,"",1,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_TOGGLE,PNL_CENTER,0,0,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
{ PNL_TIME,PNL_LEFT,"In",1,0					,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},  // Changing where these are in array will break UpdatePanStr()
{ PNL_TIME,PNL_LEFT,"Out",0,0				,0,0,0,CreateTimePL,DrawTimePL,HandleTimePL,DestroyTimePL},
a361 2
//{ PNL_EZLEN,PNL_CENTER,"Fade In",1,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
//{ PNL_EZLEN,PNL_CENTER,"Fade Out",0,0		,0,0,0,CreateEZLenPL,DrawEZTimePL,HandleEZLenPL,DestroyEZLenPL},
d366 1
a366 1
struct PanelLine ClipPL[] = {
d369 1
a369 1
{ PNL_CROUTON,PNL_LEFT,"",0,0					,0,0,0,CreateCroutonPL,DrawCroutonPL,NULL,NULL},
d371 11
a381 5
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_SLIDER,PNL_LEFT,"In",1,0				,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_SLIDER,PNL_LEFT,"Out",0,0				,0,0,0,CreateSliderPL,DrawSliderPL,HandleSliderPL,DestroySliderPL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
{ PNL_TOGGLE,PNL_CENTER,0,0,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
d518 1
d573 3
a575 1
			SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
d640 4
a643 1
		SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
d748 1
a748 1
	LONG A=800,B=0,t_In=36,t_Out=69,A_In,A_Out,type=PanType,SP[8]={36,69,0,36};
d750 1
a750 1
		*togxp[]={" Video ","Left Audio ","Right Audio "},*fadetog[]={"Fade In  ","Fade Out "};
a799 3
		XPClipPL[9].Param=(long *)7; // Audio Toggle
		XPClipPL[9].Param2=(long *)togxp;
		XPClipPL[9].PropEnd = 3;
d802 8
a809 1
		XPClipPL[10].Param = &A_In;
d812 1
a812 1
		XPClipPL[11].Param = &A_Out;
a814 3
		XPClipPL[12].Param=(long *)0; // Fade Toggle
		XPClipPL[12].Param2=(long *)fadetog;
		XPClipPL[12].PropEnd = 2;
d816 8
d1013 3
a1015 1
			SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
d1206 23
d1356 1
a1356 1
// if( DoTestPanel(Edit) )
d1469 1
a1469 1
#define VALID_CTYPE(t)		((t<=CR_CRAWL)&&(t>=CR_FXANIM))
d1496 1
@


2.5
log
@Add Audio Fine-tune to clip panel
@
text
@d2 5
a6 2
* $Id: Controls.c,v 2.4 94/07/11 17:59:48 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Controls.c,v $
d725 1
a725 1
	LONG A=800,B=0,t_In=36,t_Out=69,A_In,A_Out,type=PanType,SP[8]={36,69,0,1,100,36};
d742 2
a743 4
		SP[3]= GetValue(FG,0x8000000|TAG_ClipStartPoint);
		SP[4]= GetValue(FG,0x8000000|TAG_ClipEndPoint);
		SP[5]= GetValue(FG,0x8000000|TAG_ClipStartField);
		SP[6]= GetValue(FG,0x8000000|TAG_Duration);
d813 2
a814 4
			PutValue(FG,0x8000000|TAG_ClipStartPoint,SP[3]);
			PutValue(FG,0x8000000|TAG_ClipEndPoint,SP[4]);
			PutValue(FG,0x8000000|TAG_ClipStartField,SP[5]);
			PutValue(FG,0x8000000|TAG_Duration,SP[6]);
d992 1
a992 1
	char Label[MAX_PANEL_STR]="";
d1030 1
a1030 1
	char Label[MAX_PANEL_STR]="";
@


2.4
log
@Remove test panel access
@
text
@d2 1
a2 1
* $Id: Controls.c,v 2.3 94/07/07 17:01:58 CACHELIN4000 Exp Locker: CACHELIN4000 $
d4 3
d8 1
a8 1
*Caps-Lock xepert mode
d337 6
a342 1
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
a344 2
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0					,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
//{ PNL_TOGGLE,PNL_LEFT,"Play Audio",0,0,0,0,0,CreateTogglePL,DrawTogglePL,HandleTogglePL,DestroyTogglePL},
d346 2
d388 1
a388 1
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0						,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
d450 1
a450 1
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0  								,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
d461 1
a461 1
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0									,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
d466 2
a467 2
{ PNL_TEXT,PNL_LEFT,"Control Test",0,0				,0,0,0,CreateTextPL,DrawTextPL,NULL,NULL},
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0  								,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
d478 1
a478 1
{ PNL_DIVIDE,PNL_LEFT,"",0 ,0									,0,0,0,CreateDividePL,DrawDividePL,NULL,NULL},
d722 3
a724 2
	LONG A=800,B=0,t_In=36,t_Out=69,type=PanType,SP[8]={36,69,0,1,100,36};
	char Label[MAX_PANEL_STR]="Kiki's Shower",*tog[]={"Play Audio",""};
d756 1
a756 1
		ClipPL[8].Param=(long *)1; // Audio Toggle
d758 1
a758 1
		ClipPL[8].PropEnd = 1;
d775 16
a790 3
		XPClipPL[8].Param=(long *)1; // Audio Toggle
		XPClipPL[8].Param2=(long *)tog;
		XPClipPL[8].PropEnd = 1;
@


2.3
log
@Caps-Lock xepert mode
@
text
@Binary files Controls.c and t:,RCSt1A70d9e68 differ
@


2.2
log
@Tamed Test Panel
@
text
@Binary files Controls.c and t:,RCSt1A70d8638 differ
@


2.1
log
@*** empty log message ***
@
text
@Binary files Controls.c and t:,RCSt1A70ee590 differ
@


2.0
log
@FirstCheckIn
@
text
@Binary files controls.c and t:,RCSt1A70fb3d8 differ
@
