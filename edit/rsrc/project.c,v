head	2.146;
access;
symbols;
locks; strict;
comment	@*@;


2.146
date	96.11.18.18.42.29;	author Holt;	state Exp;
branches;
next	2.145;

2.145
date	96.02.15.11.39.26;	author Holt;	state Exp;
branches;
next	2.144;

2.144
date	95.11.21.16.19.39;	author Flick;	state Exp;
branches;
next	2.143;

2.143
date	95.11.14.18.22.51;	author Flick;	state Exp;
branches;
next	2.142;

2.142
date	95.10.24.17.31.41;	author Flick;	state Exp;
branches;
next	2.141;

2.141
date	95.10.14.10.41.24;	author Flick;	state Exp;
branches;
next	2.140;

2.140
date	95.10.12.16.38.41;	author Flick;	state Exp;
branches;
next	2.139;

2.139
date	95.10.10.17.20.33;	author Flick;	state Exp;
branches;
next	2.138;

2.138
date	95.10.09.23.58.47;	author Flick;	state Exp;
branches;
next	2.137;

2.137
date	95.10.09.16.46.56;	author Flick;	state Exp;
branches;
next	2.136;

2.136
date	95.10.06.16.13.14;	author Flick;	state Exp;
branches;
next	2.135;

2.135
date	95.10.03.18.07.30;	author Flick;	state Exp;
branches;
next	2.134;

2.134
date	95.10.02.15.24.24;	author Flick;	state Exp;
branches;
next	2.133;

2.133
date	95.09.25.12.44.35;	author Flick;	state Exp;
branches;
next	2.132;

2.132
date	95.08.18.17.09.19;	author Flick;	state Exp;
branches;
next	2.131;

2.131
date	95.07.13.16.56.56;	author Flick;	state Exp;
branches;
next	2.130;

2.130
date	95.07.13.13.08.33;	author Flick;	state Exp;
branches;
next	2.129;

2.129
date	95.07.07.19.23.44;	author Flick;	state Exp;
branches;
next	2.128;

2.128
date	95.07.07.17.03.45;	author Flick;	state Exp;
branches;
next	2.127;

2.127
date	95.07.06.18.21.40;	author Flick;	state Exp;
branches;
next	2.126;

2.126
date	95.07.05.16.34.24;	author pfrench;	state Exp;
branches;
next	2.125;

2.125
date	95.02.13.17.17.44;	author pfrench;	state Exp;
branches;
next	2.124;

2.124
date	95.01.27.14.07.11;	author pfrench;	state Exp;
branches;
next	2.123;

2.123
date	95.01.26.09.18.47;	author pfrench;	state Exp;
branches;
next	2.122;

2.122
date	95.01.25.19.35.18;	author pfrench;	state Exp;
branches;
next	2.121;

2.121
date	95.01.12.14.04.28;	author CACHELIN4000;	state Exp;
branches;
next	2.120;

2.120
date	95.01.12.12.46.54;	author CACHELIN4000;	state Exp;
branches;
next	2.119;

2.119
date	95.01.12.12.07.28;	author CACHELIN4000;	state Exp;
branches;
next	2.118;

2.118
date	95.01.06.18.43.44;	author pfrench;	state Exp;
branches;
next	2.117;

2.117
date	95.01.06.18.30.23;	author pfrench;	state Exp;
branches;
next	2.116;

2.116
date	94.12.31.07.06.05;	author pfrench;	state Exp;
branches;
next	2.115;

2.115
date	94.12.29.19.32.36;	author CACHELIN4000;	state Exp;
branches;
next	2.114;

2.114
date	94.12.20.19.37.42;	author CACHELIN4000;	state Exp;
branches;
next	2.113;

2.113
date	94.12.19.22.38.56;	author pfrench;	state Exp;
branches;
next	2.112;

2.112
date	94.12.07.15.52.27;	author pfrench;	state Exp;
branches;
next	2.111;

2.111
date	94.12.05.14.01.31;	author pfrench;	state Exp;
branches;
next	2.110;

2.110
date	94.11.18.17.13.35;	author pfrench;	state Exp;
branches;
next	2.109;

2.109
date	94.11.18.13.14.11;	author pfrench;	state Exp;
branches;
next	2.108;

2.108
date	94.11.18.13.11.00;	author pfrench;	state Exp;
branches;
next	2.107;

2.107
date	94.11.18.12.27.18;	author pfrench;	state Exp;
branches;
next	2.106;

2.106
date	94.11.18.12.02.16;	author CACHELIN4000;	state Exp;
branches;
next	2.105;

2.105
date	94.11.17.19.13.48;	author CACHELIN4000;	state Exp;
branches;
next	2.104;

2.104
date	94.11.15.17.52.44;	author pfrench;	state Exp;
branches;
next	2.103;

2.103
date	94.11.15.13.34.50;	author pfrench;	state Exp;
branches;
next	2.102;

2.102
date	94.11.11.11.54.13;	author pfrench;	state Exp;
branches;
next	2.101;

2.101
date	94.11.09.12.49.38;	author pfrench;	state Exp;
branches;
next	2.100;

2.100
date	94.10.11.16.56.56;	author CACHELIN4000;	state Exp;
branches;
next	2.99;

2.99
date	94.09.28.16.14.56;	author pfrench;	state Exp;
branches;
next	2.98;

2.98
date	94.09.27.19.59.57;	author pfrench;	state Exp;
branches;
next	2.97;

2.97
date	94.09.27.16.26.01;	author pfrench;	state Exp;
branches;
next	2.96;

2.96
date	94.09.20.22.51.22;	author pfrench;	state Exp;
branches;
next	2.95;

2.95
date	94.09.12.18.41.43;	author pfrench;	state Exp;
branches;
next	2.94;

2.94
date	94.09.09.16.42.39;	author pfrench;	state Exp;
branches;
next	2.93;

2.93
date	94.09.08.15.45.56;	author pfrench;	state Exp;
branches;
next	2.92;

2.92
date	94.08.30.22.41.17;	author pfrench;	state Exp;
branches;
next	2.91;

2.91
date	94.08.30.21.39.13;	author pfrench;	state Exp;
branches;
next	2.90;

2.90
date	94.08.30.17.39.32;	author pfrench;	state Exp;
branches;
next	2.89;

2.89
date	94.08.30.17.04.21;	author pfrench;	state Exp;
branches;
next	2.88;

2.88
date	94.08.30.10.48.00;	author Kell;	state Exp;
branches;
next	2.87;

2.87
date	94.08.29.20.32.50;	author pfrench;	state Exp;
branches;
next	2.86;

2.86
date	94.08.29.18.39.49;	author pfrench;	state Exp;
branches;
next	2.85;

2.85
date	94.08.29.18.00.54;	author CACHELIN4000;	state Exp;
branches;
next	2.84;

2.84
date	94.08.29.17.22.42;	author pfrench;	state Exp;
branches;
next	2.83;

2.83
date	94.08.29.17.20.39;	author pfrench;	state Exp;
branches;
next	2.82;

2.82
date	94.08.27.17.53.54;	author CACHELIN4000;	state Exp;
branches;
next	2.81;

2.81
date	94.08.27.16.18.55;	author CACHELIN4000;	state Exp;
branches;
next	2.80;

2.80
date	94.08.26.15.01.46;	author pfrench;	state Exp;
branches;
next	2.79;

2.79
date	94.08.25.17.03.11;	author pfrench;	state Exp;
branches;
next	2.78;

2.78
date	94.08.25.14.45.31;	author pfrench;	state Exp;
branches;
next	2.77;

2.77
date	94.08.25.14.36.26;	author pfrench;	state Exp;
branches;
next	2.76;

2.76
date	94.08.24.17.41.28;	author pfrench;	state Exp;
branches;
next	2.75;

2.75
date	94.08.22.20.03.32;	author pfrench;	state Exp;
branches;
next	2.74;

2.74
date	94.08.22.14.09.10;	author pfrench;	state Exp;
branches;
next	2.73;

2.73
date	94.08.22.12.57.21;	author pfrench;	state Exp;
branches;
next	2.72;

2.72
date	94.08.16.17.12.29;	author pfrench;	state Exp;
branches;
next	2.71;

2.71
date	94.08.06.11.48.29;	author pfrench;	state Exp;
branches;
next	2.70;

2.70
date	94.08.01.15.55.01;	author pfrench;	state Exp;
branches;
next	2.69;

2.69
date	94.07.31.14.41.28;	author pfrench;	state Exp;
branches;
next	2.68;

2.68
date	94.07.27.16.47.22;	author pfrench;	state Exp;
branches;
next	2.67;

2.67
date	94.07.21.18.56.20;	author pfrench;	state Exp;
branches;
next	2.66;

2.66
date	94.07.15.18.25.23;	author pfrench;	state Exp;
branches;
next	2.65;

2.65
date	94.07.12.14.50.44;	author pfrench;	state Exp;
branches;
next	2.64;

2.64
date	94.07.11.13.57.22;	author pfrench;	state Exp;
branches;
next	2.63;

2.63
date	94.07.07.17.02.29;	author CACHELIN4000;	state Exp;
branches;
next	2.62;

2.62
date	94.07.07.11.29.00;	author pfrench;	state Exp;
branches;
next	2.61;

2.61
date	94.07.07.11.25.34;	author pfrench;	state Exp;
branches;
next	2.60;

2.60
date	94.07.04.18.40.38;	author CACHELIN4000;	state Exp;
branches;
next	2.59;

2.59
date	94.06.07.15.17.56;	author CACHELIN4000;	state Exp;
branches;
next	2.58;

2.58
date	94.05.25.20.45.34;	author CACHELIN4000;	state Exp;
branches;
next	2.57;

2.57
date	94.05.25.16.39.08;	author CACHELIN4000;	state Exp;
branches;
next	2.56;

2.56
date	94.05.25.16.32.31;	author CACHELIN4000;	state Exp;
branches;
next	2.55;

2.55
date	94.05.25.16.18.23;	author CACHELIN4000;	state Exp;
branches;
next	2.54;

2.54
date	94.05.25.15.46.42;	author CACHELIN4000;	state Exp;
branches;
next	2.53;

2.53
date	94.05.12.08.31.57;	author CACHELIN4000;	state Exp;
branches;
next	2.52;

2.52
date	94.04.22.14.45.53;	author CACHELIN4000;	state Exp;
branches;
next	2.51;

2.51
date	94.04.22.14.29.57;	author CACHELIN4000;	state Exp;
branches;
next	2.50;

2.50
date	94.04.20.17.32.59;	author CACHELIN4000;	state Exp;
branches;
next	2.49;

2.49
date	94.04.12.11.32.14;	author CACHELIN4000;	state Exp;
branches;
next	2.48;

2.48
date	94.03.29.19.00.03;	author Kell;	state Exp;
branches;
next	2.47;

2.47
date	94.03.19.17.54.13;	author CACHELIN4000;	state Exp;
branches;
next	2.46;

2.46
date	94.03.19.17.36.17;	author CACHELIN4000;	state Exp;
branches;
next	2.45;

2.45
date	94.03.19.16.38.08;	author CACHELIN4000;	state Exp;
branches;
next	2.44;

2.44
date	94.03.19.15.51.18;	author CACHELIN4000;	state Exp;
branches;
next	2.43;

2.43
date	94.03.19.15.40.27;	author CACHELIN4000;	state Exp;
branches;
next	2.42;

2.42
date	94.03.19.13.05.05;	author CACHELIN4000;	state Exp;
branches;
next	2.41;

2.41
date	94.03.19.12.14.20;	author CACHELIN4000;	state Exp;
branches;
next	2.40;

2.40
date	94.03.19.09.11.05;	author Kell;	state Exp;
branches;
next	2.39;

2.39
date	94.03.19.03.12.10;	author CACHELIN4000;	state Exp;
branches;
next	2.38;

2.38
date	94.03.19.00.55.08;	author CACHELIN4000;	state Exp;
branches;
next	2.37;

2.37
date	94.03.19.00.50.16;	author CACHELIN4000;	state Exp;
branches;
next	2.36;

2.36
date	94.03.18.21.13.29;	author CACHELIN4000;	state Exp;
branches;
next	2.35;

2.35
date	94.03.18.18.20.23;	author CACHELIN4000;	state Exp;
branches;
next	2.34;

2.34
date	94.03.18.17.14.29;	author CACHELIN4000;	state Exp;
branches;
next	2.33;

2.33
date	94.03.18.09.26.41;	author Kell;	state Exp;
branches;
next	2.32;

2.32
date	94.03.18.06.11.34;	author Kell;	state Exp;
branches;
next	2.31;

2.31
date	94.03.18.05.04.48;	author CACHELIN4000;	state Exp;
branches;
next	2.30;

2.30
date	94.03.17.21.28.11;	author CACHELIN4000;	state Exp;
branches;
next	2.29;

2.29
date	94.03.17.09.53.38;	author Kell;	state Exp;
branches;
next	2.28;

2.28
date	94.03.16.19.33.58;	author CACHELIN4000;	state Exp;
branches;
next	2.27;

2.27
date	94.03.16.19.15.21;	author CACHELIN4000;	state Exp;
branches;
next	2.26;

2.26
date	94.03.16.18.12.40;	author CACHELIN4000;	state Exp;
branches;
next	2.25;

2.25
date	94.03.16.17.30.35;	author CACHELIN4000;	state Exp;
branches;
next	2.24;

2.24
date	94.03.16.16.12.41;	author CACHELIN4000;	state Exp;
branches;
next	2.23;

2.23
date	94.03.16.13.26.02;	author CACHELIN4000;	state Exp;
branches;
next	2.22;

2.22
date	94.03.16.12.21.36;	author CACHELIN4000;	state Exp;
branches;
next	2.21;

2.21
date	94.03.16.00.58.03;	author CACHELIN4000;	state Exp;
branches;
next	2.20;

2.20
date	94.03.15.22.56.07;	author CACHELIN4000;	state Exp;
branches;
next	2.19;

2.19
date	94.03.15.22.48.20;	author CACHELIN4000;	state Exp;
branches;
next	2.18;

2.18
date	94.03.15.22.09.54;	author CACHELIN4000;	state Exp;
branches;
next	2.17;

2.17
date	94.03.15.16.13.01;	author Kell;	state Exp;
branches;
next	2.16;

2.16
date	94.03.15.14.22.03;	author CACHELIN4000;	state Exp;
branches;
next	2.15;

2.15
date	94.03.15.12.18.24;	author CACHELIN4000;	state Exp;
branches;
next	2.14;

2.14
date	94.03.14.21.55.53;	author CACHELIN4000;	state Exp;
branches;
next	2.13;

2.13
date	94.03.14.00.32.10;	author CACHELIN4000;	state Exp;
branches;
next	2.12;

2.12
date	94.03.13.07.49.32;	author Kell;	state Exp;
branches;
next	2.11;

2.11
date	94.03.12.20.00.46;	author CACHELIN4000;	state Exp;
branches;
next	2.10;

2.10
date	94.03.12.13.38.32;	author CACHELIN4000;	state Exp;
branches;
next	2.9;

2.9
date	94.03.11.12.19.21;	author CACHELIN4000;	state Exp;
branches;
next	2.8;

2.8
date	94.03.11.09.48.02;	author CACHELIN4000;	state Exp;
branches;
next	2.7;

2.7
date	94.03.11.09.32.22;	author Kell;	state Exp;
branches;
next	2.6;

2.6
date	94.03.10.18.15.54;	author CACHELIN4000;	state Exp;
branches;
next	2.5;

2.5
date	94.03.09.02.05.22;	author CACHELIN4000;	state Exp;
branches;
next	2.4;

2.4
date	94.03.05.21.04.02;	author CACHELIN4000;	state Exp;
branches;
next	2.3;

2.3
date	94.02.23.14.52.13;	author Kell;	state Exp;
branches;
next	2.2;

2.2
date	94.02.19.14.30.32;	author CACHELIN4000;	state Exp;
branches;
next	2.1;

2.1
date	94.02.19.09.34.25;	author Kell;	state Exp;
branches;
next	2.0;

2.0
date	94.02.17.16.23.31;	author Kell;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.146
log
@*** empty log message ***
@
text
@/********************************************************************
* $Project.c$ - EditWindow for Croutons hierarchy
* $Id: project.c,v 2.145 1996/02/15 11:39:26 Holt Exp Holt $
* $Log: project.c,v $
*Revision 2.145  1996/02/15  11:39:26  Holt
*added es_take support
*
*Revision 2.144  1995/11/21  16:19:39  Flick
*Now puts up requester if project save fails for any reason (dope!!!)
*
*Revision 2.143  1995/11/14  18:22:51  Flick
*Project saves default to toaster:Projects the first time
*
*Revision 2.142  1995/10/24  17:31:41  Flick
*If InheritTags is aborted or fails, will now undo the overwrite (and not insert either)
*
*Revision 2.141  1995/10/14  10:41:24  Flick
*Additional line in overwrite verification requester (CANCEL will insert)
*
*Revision 2.140  1995/10/12  16:38:41  Flick
*Replaced hard-coded ViewMode values with VIEW_XXX defines (popup rearranged)
*
*Revision 2.139  1995/10/10  17:20:33  Flick
*Removed special text-rendering test for "lost" croutons -- now renders text on them too
*
*Revision 2.138  1995/10/09  23:58:47  Flick
*Changed inherit operation to list crouton name in requester, and to NOT OVERWRITE if user
*cancels.  Also supports CTRL key to manually override requester in novice mode.
*
*Revision 2.137  1995/10/09  16:46:56  Flick
*Removed unnecessary usage of popup.h
*Changed ProjectRenderNode to NOT render text over Lost Croutons (special test)
*
*Revision 2.136  1995/10/06  16:13:14  Flick
*Now erases Current Time display after deleting croutons from project
*
*Revision 2.135  1995/10/03  18:07:30  Flick
*Changed requester skipping to use individual flags in prefs, rather than global user level
*
*Revision 2.134  1995/10/02  15:24:24  Flick
*Added POPUP_TOOLS to button row, now puts up "Sure you want to inherit..." msg before doing
*an inherit, rather than after.  Many lesser warning requesters now skipped if UserLevel (in
*options panel) ==GENIUS (Delete from proj, overwrite, inherit)
*
*Revision 2.133  1995/09/25  12:44:35  Flick
*Added overwrite verification, and support for inherit-drop
*
*Revision 2.132  1995/08/18  17:09:19  Flick
*Maintenance of project running time after dragging/duplicating
*
*Revision 2.131  1995/07/13  16:56:56  Flick
*Modified text slightly for "delete croutons from project" req
*
*Revision 2.130  1995/07/13  13:08:33  Flick
*Modified text slightly on delete croutons verify requester
*
*Revision 2.129  1995/07/07  19:23:44  Flick
*Moved DEL-verify message to ProjectDropped, where it should be
*
*Revision 2.128  1995/07/07  17:03:45  Flick
*Fixed +1 vert placement bug with corner symbols during drag
*
*Revision 2.127  1995/07/06  18:21:40  Flick
*Added support for ID_CROUTONSTAMP_AUDIO
*
*Revision 2.126  1995/07/05  16:34:24  pfrench
*Now rendering locks on dragging croutons
*
*Revision 2.125  1995/02/13  17:17:44  pfrench
*Added hack to play-forward-from-crouton button's handler
*function pointer.
*
*Revision 2.124  1995/01/27  14:07:11  pfrench
*Now lets project bring up its own requester
*
*Revision 2.123  1995/01/26  09:18:47  pfrench
*Now has backup function scan for drives
*
*Revision 2.122  1995/01/25  19:35:18  pfrench
*Added Hack for putting "backup" button on save project requester
*
*Revision 2.121  1995/01/12  14:04:28  CACHELIN4000
*Tweak cosmetic button spacing...
*
*Revision 2.120  1995/01/12  12:46:54  CACHELIN4000
*change SWITCHER_MODE define to avoud enf. hit on NULL EditTop
*
*Revision 2.119  1995/01/12  12:07:28  CACHELIN4000
*add PLAY_PART button
*
*Revision 2.118  1995/01/06  18:43:44  pfrench
*Final bug fix for select all gadget
*
*Revision 2.117  1995/01/06  18:30:23  pfrench
*Added (and temporarily removed) code that replaced
*select all gadget with same gad with correct imagery
*
*Revision 2.116  1994/12/31  07:06:05  pfrench
*Now voiding project length on project edit
*
*Revision 2.115  1994/12/29  19:32:36  CACHELIN4000
*Update CurFG when new crouton is dropped onto it ==> fix crashy sequencing bug
*
*Revision 2.114  1994/12/20  19:37:42  CACHELIN4000
*Remove ID_CLOSE gadget from project IDS array ==> from project editwindow
*
*Revision 2.113  1994/12/19  22:38:56  pfrench
*Modified for now shared-code proof.library.
*
*Revision 2.112  1994/12/07  15:52:27  pfrench
*Finally got project save request going
*
*Revision 2.111  1994/12/05  14:01:31  pfrench
*ci Project.c
*Added support for moving to project save directory
*
*Revision 2.110  1994/11/18  17:13:35  pfrench
*Wasn't correctly displaying a new project after loading
*
*Revision 2.109  1994/11/18  13:14:11  pfrench
*small typo with last checked in version
*
*Revision 2.108  1994/11/18  13:11:00  pfrench
*Now redraws correctly when empty project is loaded
*
*Revision 2.107  1994/11/18  12:27:18  pfrench
*Fixed problem with dragging drawers to project not
*redrawing in their source grazer.
*
*Revision 2.106  1994/11/18  12:02:16  CACHELIN4000
*Add refresh after Denying folders access to Project Dropping.
*
*Revision 2.105  1994/11/17  19:13:48  CACHELIN4000
*Make sure ProjectDropped only accepts grazer nodes with DosClass==EN_FILE..
*
*Revision 2.104  1994/11/15  17:52:44  pfrench
*Added support to highlight delayed error croutons when
*the error is posted, and not before.
*
*Revision 2.103  1994/11/15  13:34:50  pfrench
*Added better error handling to select code.
*
*Revision 2.102  1994/11/11  11:54:13  pfrench
*Got Select All working correctly
*
*Revision 2.101  1994/11/09  12:49:38  pfrench
*Added initial support for croutongrid object
*
*Revision 2.100  1994/10/11  16:56:56  CACHELIN4000
*Add Flage to ES_LoadCrouton fro Project vs. Grazer loading
*
*Revision 2.99  94/09/28  16:14:56  pfrench
*Removed NEW_CLIP from Gadget lists
*
*Revision 2.98  1994/09/27  19:59:57  pfrench
*Needed to add POP_VIEWS ID
*
*Revision 2.97  1994/09/27  16:26:01  pfrench
*Added programs popup to the bottom of the window
*
*Revision 2.96  1994/09/20  22:51:22  pfrench
*Modified to work with dircache (Editwindow has ptr to list now)
*
*Revision 2.95  1994/09/12  18:41:43  pfrench
*get order of fast gadet now return (0...n-1)
*
*Revision 2.94  1994/09/09  16:42:39  pfrench
*Tied in an accesswindow rowcount hack. Also tried to fix
*a select problem with some croutons.
*
*Revision 2.93  1994/09/08  15:45:56  pfrench
*Added new function to assist accesswindow updating
*
*Revision 2.92  1994/08/30  22:41:17  pfrench
*Removed un-used code.
*
*Revision 2.91  1994/08/30  21:39:13  pfrench
*Modified text of project save requester
*
*Revision 2.90  1994/08/30  17:39:32  pfrench
*Fixed multiple-select-drag from grazer to project to
*leave all dragged croutons highlighted
*
*Revision 2.89  1994/08/30  17:04:21  pfrench
*Duplicate in Switcher mode doesn't highlight selected
*crouton.
*
*Revision 2.88  1994/08/30  10:48:00  Kell
*Changed SendSwitcherReply calls to work with new ESParams structures.
*
*Revision 2.87  1994/08/29  20:32:50  pfrench
*Fixed couple more bugs
*
*Revision 2.86  1994/08/29  18:39:49  pfrench
*Redraws correctly on crouton select.
*
*Revision 2.85  1994/08/29  18:00:54  CACHELIN4000
*Move Text label for default crouton bmaps over by 2 pixels
*
*Revision 2.84  94/08/29  17:22:42  pfrench
*Whooops.
*
*Revision 2.83  1994/08/29  17:20:39  pfrench
*Removed annoying code that selected first gad in
*project every time.
*
*Revision 2.82  1994/08/27  17:53:54  CACHELIN4000
**** empty log message ***
*
*Revision 2.81  94/08/27  16:18:55  CACHELIN4000
*add Stop, Play buttons, remove NewClip from ArrangeProjectGadgets()
*
*Revision 2.80  94/08/26  15:01:46  pfrench
*Added bad crouton support.
*
*Revision 2.79  1994/08/25  17:03:11  pfrench
*Added full volume name support for files loaded into project
*
*Revision 2.78  1994/08/25  14:45:31  pfrench
*Dragging croutons in switcher mode leaves them un-highlighted.
*
*Revision 2.77  1994/08/25  14:36:26  pfrench
*Duplicate now correctly sets CurFG to NULL
*
*Revision 2.76  1994/08/24  17:41:28  pfrench
*Now correctly handles double-clicking on Current FG.
*
*Revision 2.75  1994/08/22  20:03:32  pfrench
*Got project/duplicate working a little closer to
*acutal reality.  Now "duplicate" copies all selected
*croutons and inserts them contiguously after the
*last selected crouton.
*
*Revision 2.74  1994/08/22  14:09:10  pfrench
*Couple more fixes.
*
*Revision 2.73  1994/08/22  12:57:21  pfrench
*Fixed long-standing project editing bug with dragging
*multiple croutons messing up the FastGadget list.
*
*Revision 2.72  1994/08/16  17:12:29  pfrench
*Now disables "select all" button in switcher mode
*
*Revision 2.71  1994/08/06  11:48:29  pfrench
*Fixed problem with double/single click.
*
*Revision 2.70  1994/08/01  15:55:01  pfrench
*Removed calls to req file type as those files are being
*filtered out of the grazer again.
*
*Revision 2.69  1994/07/31  14:41:28  pfrench
*Now uses grazer for for saving project.
*
*Revision 2.68  1994/07/27  16:47:22  pfrench
*Added "New Project" button to bottom project.
*
*Revision 2.67  1994/07/21  18:56:20  pfrench
*Fancy support for filtering requested file types.
*
*Revision 2.66  1994/07/15  18:25:23  pfrench
*No longer hacks loading the hardcoded project name
*
*Revision 2.65  1994/07/12  14:50:44  pfrench
*Bottom project height was getting initialized too tall
*
*Revision 2.64  94/07/11  13:57:22  pfrench
*More preliminary project/project support
*
*Revision 2.63  94/07/07  17:02:29  CACHELIN4000
**** empty log message ***
*
*Revision 2.62  94/07/07  11:29:00  pfrench
*Whoops, bug fix.
*
*Revision 2.61  94/07/07  11:25:34  pfrench
*Added micro-hack to load a default project
*
*Revision 2.60  94/07/04  18:40:38  CACHELIN4000
**** empty log message ***
*
*Revision 2.59  94/06/07  15:17:56  CACHELIN4000
**** empty log message ***
*
*Revision 2.58  94/05/25  20:45:34  CACHELIN4000
*let NO FG be selected again
*
*Revision 2.53  94/05/12  08:31:57  CACHELIN4000
*add EDITORMODE logic, ES_DefaultSelect
*
*Revision 2.52  94/04/22  14:45:53  CACHELIN4000
**** empty log message ***
*
*Revision 2.51  94/04/22  14:29:57  CACHELIN4000
*Stop filtering FGC_SELECTs
*
*Revision 2.50  94/04/20  17:32:59  CACHELIN4000
*Move Panel stuff to Panel.c
*
*Revision 2.48  94/03/29  19:00:03  Kell
*Some error messages added.
*
*Revision 2.44  94/03/19  15:51:18  CACHELIN4000
*DHD Support, Expert mode record panel
*
*Revision 2.42  94/03/19  13:05:05  CACHELIN4000
*Fix Jr.s dumb parentheses bug in PNL_IN_TYPE
*
*Revision 2.39  94/03/19  03:12:10  CACHELIN4000
*DHD TAG type support
*
*Revision 2.38  94/03/19  00:55:08  CACHELIN4000
*Fix SMPTE string .
*
*Revision 2.36  94/03/18  21:13:29  CACHELIN4000
**** empty log message ***
*
*Revision 2.35  94/03/18  18:20:23  CACHELIN4000
*re-enable default project name if(*ProjectName==0)
*
*Revision 2.34  94/03/18  17:14:29  CACHELIN4000
*Add Icon to Panel
*
*Revision 2.33  94/03/18  09:26:41  Kell
**** empty log message ***
*
*Revision 2.32  94/03/18  06:11:34  Kell
**** empty log message ***
*
*Revision 2.31  94/03/18  05:04:48  CACHELIN4000
*Video Clip support
*
*Revision 2.30  94/03/17  21:28:11  CACHELIN4000
**** empty log message ***
*
*Revision 2.29  94/03/17  09:53:38  Kell
**** empty log message ***
*
*Revision 2.28  94/03/16  19:33:58  CACHELIN4000
**** empty log message ***
*
*Revision 2.16  94/03/15  14:22:03  CACHELIN4000
*Refresh Switcher after selecting croutons
*
*Revision 2.12  94/03/13  07:49:32  Kell
*Deleted some unused variables
*
*Revision 2.10  94/03/12  13:38:32  CACHELIN4000
*Add path name to crouton dropped into project
*
*Revision 2.9  94/03/11  12:19:21  CACHELIN4000
*Re-Do ProjectRenderNode()
*
*Revision 2.6  94/03/10  18:15:54  CACHELIN4000
*Fix ProjectRenderNode() to call GrazerRenderNode()
*
*Revision 2.1  94/02/19  09:34:25  Kell
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
*********************************************************************/
#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <intuition/sghooks.h>
#include <graphics/gfxmacros.h>
#include <graphics/gfxbase.h>
#include <graphics/text.h>

#include <edit.h>
#include <stdio.h>
#include <string.h>
#include <dos.h>
#include <time.h>
#include <editwindow.h>
#include <project.h>
#include <filelist.h>
#include <gadgets.h>
#include <prophelp.h>
#include <grazer.h>
#include <editswit.h>
#include <crouton_all.h>
#include <request.h>
#include <tags.h>
#include <panel.h>

#ifndef PROOF_LIB_H
#include <proof_lib.h>
#endif

#include <croutongrid.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
#include <proto/diskfont.h>

#ifndef PROTO_PASS
#include <proto.h>
#else
extern APTR OpenEditWindow,CloseEditWindow;
DrawBGFunc *DrawBG();
struct EditWindow *HandleSaveProject(struct EditWindow *,struct IntuiMessage *);
#endif
LONG UpdateAccessWindowRows( LONG newrows );

//#define SERDEBUG	1
#include <serialdebug.h>

extern struct Library *ProofBase;
extern struct EditWindow *BotProjNewProject(struct EditWindow *,struct IntuiMessage *);
extern VOID KPutStr(char *);
extern LONG KPrintF( STRPTR fmt, ... );

extern WORD ViewMode;
extern WORD GrazerLayout;
extern struct Screen *EditScreen;
extern struct Gadget Gadget1;
extern struct BitMap FileBitMap;
extern ULONG CopyFastBitMap(struct BitMap *Source,
		ULONG SrcLeftEdge,ULONG SrcTopEdge,
		struct BitMap *Dest,ULONG DestLeftEdge,ULONG DestTopEdge,
		ULONG Width,ULONG Height);

extern struct TextFont *EditFont,*DarkFont;
extern struct EditWindow *EditTop,*EditBottom;
extern struct TextExtent LastExtent;
extern struct MsgPort *EditPort,*SwitPort;
extern char TempCh[],TempC2[],*DTNames[];
extern UBYTE *TempMem,*TempMem2;
extern struct EditPrefs UserPrefs;		// User preferences live here

// The following structures are used as temparary storage space for
// holding parameters that will be stuffed into a message and set
// to the switcher.  We have the different sized structures to make
// it easy to indicate the number of parameters being set.
struct ESParams1 ESparams1 = {1};
struct ESParams2 ESparams2 = {2};
struct ESParams3 ESparams3 = {3};
struct ESParams4 ESparams4 = {4};
struct ESParams5 ESparams5 = {5};
struct ESParams6 ESparams6 = {6};
struct ESParams7 ESparams7 = {7};
struct ESParams8 ESparams8 = {8};

struct FastGadget *CurFG,*FirstFG;
int	CurGrid=0,CurRow=0,CurCol=0;

char filepathbuf[300];

VOID __asm CopyCrut(
	register __a0 struct BitMap *SrcBM,
	register __a1 struct BitMap *DstBM,
	register __d0 WORD DestX,
	register __d1 WORD DestY,
	register __d2 WORD Height);

VOID DisplayWaitSprite(VOID);
VOID DisplayNormalSprite(VOID);

static UWORD TopIDS[] = {
	ID_UP,ID_DOWN,ID_KNOB,ID_GRID,
	ID_VCR_PLAY,ID_PLAY_PART,ID_REQ_STOP,ID_CONTROLS,
	ID_ALL,ID_DELETE,ID_DUPLICATE,ID_SAVE_PROJECT,
	ID_POPUP_PROGRAMS,ID_POPUP_VIEWS,ID_POPUP_TOOLS,
	ID_END_OF_LIST
};

static UWORD BottomIDS[] = {
	ID_UP,ID_DOWN,ID_CLOSE,ID_KNOB,ID_GRID,
	ID_NEW_PROJECT,
	ID_END_OF_LIST
};

#define MAX_STRING_BUFFER	300
#define DEF_PROJ_NAME		"WorkProject"
#define DEF_PROJ_DIR		"RAM:"
UBYTE PjName[369]  ="Toaster:Projects/"; // "RAM:WorkProject";
UBYTE *ProjectName=&(PjName[0]);
struct FastGadget **PtrProject = NULL;
struct FastGadget **XtrProject = NULL;
struct FastGadget *NoSwitPtr = NULL,*SKellFG;

#define SWITCHER_MODE	( (!EditBottom) && (!EditTop || (EditTop->Height!=TOP_LARGE)) )
#define EDITOR_MODE		(!SWITCHER_MODE)

BOOL ProjectSelect(struct EditWindow *Edit,struct EditNode *Node)
{
//	DUMPMSG("ProjectSelect");

	if (Node)
	{
		if( SWITCHER_MODE )
		{
			/* THIS MUST BE BEFORE THE SENDSWITCHERREPLY
			 *
			 *	The switcher may send a REDRAW before the
			 * SELECT comes back.  Redraw will automatically
			 * clear the OptRender flag.
			 *
			 */
			Edit->ew_OptRender = TRUE;

			ESparams1.Data1=(LONG)Node;
			SKellFG=(struct FastGadget *)Node;

			if(	SendSwitcherReply(ES_Select,&ESparams1) ||
					SendSwitcherReply(ES_Select,&ESparams1) )
			{
				// struct FastGadget	*fg = (struct FastGadget *)Node;

				// fg->FGDiff.FGNode.Behavior |= EN_BADCROUTON;
				// fg->FGDiff.FGNode.Redraw = TRUE;
			}

			if ( Edit->ew_cg )
			{
				LONG			nodenum;

				nodenum = GetProjNodeOrder(Edit,(struct FastGadget *)Node);

				ob_DoMethod( Edit->ew_cg,CRGRIDM_SelectCrouton,
					nodenum,GRIDSELECT_NORMAL,CROUTONSELECT_SELECTED);
			}

			Edit->RedrawSelect = TRUE;
			Edit->DisplayGrid = TRUE;
		}
		else
		{
			if ( Node != (struct EditNode *) SKellFG ) {
				SKellFG=NULL;
				SendSwitcher(ES_SelectDefault,NULL);
			}
		}
	}
	return(FALSE);
}

/****** Project/ProjectDuplicate **************************************
*
*   NAME
*	ProjectDuplicate
*
*   SYNOPSIS
*	BOOL ProjectDuplicate(struct EditWindow *Edit)
*
*   FUNCTION
*
*
*********************************************************************
*/
BOOL ProjectDuplicate(struct EditWindow *Edit)
{
	struct FastGadget	*fg,*ins_fg = NULL;
	struct FastGadget	*first_fg = NULL,*tail_fg,*duped;
	int	dupecount=0;

	// Since "next" pointer is first LONG of the FastGadget,
	// we just substitute the Address of the FG list head
	fg = (struct FastGadget *)((struct Project *)Edit->Special)->PtrPtr;

	// Copy all of the selected croutons into their
	// own little FastGadget list.

	while ( fg = (struct FastGadget *)GetNextEditNode(Edit,(struct EditNode *)fg) )
	{
		if ( fg->FGDiff.FGNode.Status == EN_SELECTED )
		{
			struct FastGadget	*dupe_fg;

			// Insert at last selected Node
			ins_fg = fg;

			fg->FGDiff.FGNode.Status = EN_NORMAL;
			fg->FGDiff.FGNode.Redraw = TRUE;

			if (dupe_fg = DupeProjNode(fg))
			{
				if (!first_fg)
				{
					first_fg = dupe_fg;
					tail_fg = first_fg;
				}
				else
				{
					tail_fg->NextGadget = dupe_fg;
					tail_fg = dupe_fg;
				}

				if ( EDITOR_MODE )
				{
					dupe_fg->FGDiff.FGNode.Status = EN_SELECTED;
					dupe_fg->FGDiff.FGNode.Redraw = TRUE;
				}

				dupecount++;
				duped = dupe_fg;
			}
		}
	}

	// Now Insert them into the list
	if ( first_fg )
	{
		// Insert these nodes into the list
		tail_fg->NextGadget = ins_fg->NextGadget;
		ins_fg->NextGadget = first_fg;
		CurFG = NULL;

		NewLengthUpdate(Edit);

		if( EDITOR_MODE ) {
			SKellFG=NULL;
			SendSwitcher(ES_SelectDefault,NULL);
		}
	}

	if (dupecount==1)
	{
		// Calculate and update crouton's current time
		CalcCurrentTime(duped);
	}
	else
		SetCurrentTime(-1);			// For a group, can't show a time

	return(FALSE);
}

/****** Project/ProjectDouble **************************************
*
*   NAME
*	ProjectDouble
*
*   SYNOPSIS
*	BOOL ProjectDouble(struct EditWindow *Edit,struct EditNode *Node)
*
*   FUNCTION
*
*
*********************************************************************
*/
BOOL ProjectDouble(struct EditWindow *Edit,struct EditNode *Node)
{
	DUMPMSG("ProjectDouble");

	if (Node)
	{
		ESparams1.Data1=(LONG)Node;

		if(SKellFG==(struct FastGadget *)Node)
		{
			DUMPMSG("SENT AUTO");
			SendSwitcherReply(ES_Auto,&ESparams1);
			//DUMPMSG("SENT Take");
			//SendSwitcher(ES_Take,&ESparams1);			//testing 021496DEH
		}
		else if(!SendSwitcherReply(ES_Select,&ESparams1))
		{
			DUMPMSG("SENT SELECT");
			SendSwitcher(ES_Auto,&ESparams1);
			DUMPMSG("SENT AUTO");
			CurFG=(struct FastGadget *)Node;
			SKellFG=(struct FastGadget *)Node;
			//DUMPMSG("SENT Take");
			//SendSwitcher(ES_Take,&ESparams1);			//testing 021496DEH
			
		}
		else
		{
			struct FastGadget	*fg = (struct FastGadget *)Node;

			DUMPMSG("ITS A BAD CROUTON");
			fg->FGDiff.FGNode.Behavior |= EN_BADCROUTON;
			fg->FGDiff.FGNode.Redraw = TRUE;
		}
	}
	return(FALSE);
}

/****** Project/ProjectDeleted **************************************
*
*   NAME
*	ProjectDeleted
*
*   SYNOPSIS
*	BOOL ProjectDeleted(struct EditWindow *Edit)
*
*   FUNCTION
*	Called when user deletes nodes in Edit
*
*********************************************************************
*/
BOOL ProjectDeleted(struct EditWindow *Edit)
{
	struct FastGadget *FG,*Next;
	BOOL Any = FALSE;

	if ((!(WFF_WARN_PROJDEL & UserPrefs.WarnFlags))		// Avoid req if disabled
	|| BoolRequest(Edit->Window,"Remove crouton(s) from project?"))
	{
		FG = *((struct Project *)Edit->Special)->PtrPtr;
		DisplayWaitSprite();
		while (FG)
		{
			Next = FG->NextGadget;
			if (FG->FGDiff.FGNode.Status == EN_SELECTED)
			{
				Any = TRUE;
				RemoveProjNode(Edit,FG);
				FreeProjectNode(FG);
			}
			FG = Next;
		}
		if (Any)
		{
			NewLengthUpdate(Edit);
			SKellFG=NULL;
			SendSwitcher(ES_SelectDefault,NULL);
			CurFG=NULL;
			SetCurrentTime(-1);				// Will be nothing hilited now, so erase this
		}
		DisplayNormalSprite();
	}
	return(FALSE);
}

/****** Project/ProjectRenderNode *************************************
*
*   NAME
*	ProjectRenderNode
*
*   SYNOPSIS
*	VOID ProjectRenderNode(struct EditWindow *Edit,struct EditNode *Node,
*		struct RastPort *RP,UWORD LeftEdge,UWORD TopEdge);
*
*   FUNCTION
*
*
*********************************************************************
*/
// #define SMALL_FX
VOID ProjectRenderNode(struct EditWindow *Edit,struct EditNode *Node,
		struct RastPort *RP,UWORD LeftEdge,UWORD TopEdge)
{
	UWORD X1,Y1,Y2,Max;
	struct BitMap *BM;
	struct FastGadget *FG;
	char *S;
#ifdef SMALL_FX
	UWORD X2;
	struct Gadget *Gadget;
	struct SmartString *S;
#endif

	X1 = LeftEdge;
	Y1 = TopEdge;

#ifdef SMALL_FX
	if(GrazerLayout) // Small icons, 160x25
	{
		Gadget = FindGadget(&Gadget1,ID_CROUTON_SMALL);
		DrawImage(RP,(struct Image *)Gadget->GadgetRender,X1,Y1);
		Gadget = FindGadget(&Gadget1,ID_SMALL_EFFECT);  // Should do custom image for CrUD_TYPE here
		DrawImage(RP,(struct Image *)Gadget->GadgetRender,X1+5,Y1+5);
		if (S = Node->Node.Name)
		{
			X2 = 5 + Gadget->Width;
			Move(RP,X1+X2,TopEdge+7+TEXT_BASELINE);
			SafeFitText(RP,GetCString(S),SmartStringLength(S),
			Edit->ImageWidth - X2 - 3,TRUE);
		}
	}
	else  // 80x50
#endif
	{
		Y2 = TopEdge + Edit->ImageHeight - 7;
		FG = (struct FastGadget *)Node;

		if( BM=(struct BitMap *)FG->Data )
		{
			struct Gadget	*Gadget = NULL;

			SetAPen(RP,SCREEN_PEN);
			SetDrMd(RP,JAM2);
			RectFill(RP,X1,Y1,X1+Edit->ColumnSize-1,Y1+Edit->RowSize-1);
			Y2 += 1;
			WaitBlit();
//			DUMPMEM("pj BM=",(APTR)BM,(LONG)sizeof(struct BitMap));
//			DUMPMEM("pj RPBM=",(APTR)(RP->BitMap),(LONG)sizeof(struct BitMap));
//			DUMPUDECL("pj X1=",(LONG)X1," ");
//			DUMPUDECL("pj Y1=",(LONG)X1," ");
//			DUMPUDECL("pj Rows=",(LONG)(Edit->RowSize),"\\");
			CopyCrut(BM,RP->BitMap,X1,Y1+1,Edit->RowSize-2);

			if ( ((struct ExtFastGadget *)FG)->SymbolFlags & SYMF_LOCKED )
			{
				Gadget = FindGadget(&Gadget1,ID_CROUTONSTAMP_LOCKED);
				if ( Gadget )
				{
					DrawImage(	RP,
						(struct Image *)Gadget->GadgetRender,
						X1 + 5,
						Y1 + 5 );
				}
			}

			if ( ((struct ExtFastGadget *)FG)->SymbolFlags & SYMF_AUDIO )
			{
				Gadget = FindGadget(&Gadget1,ID_CROUTONSTAMP_AUDIO);
				if ( Gadget )
				{
					DrawImage(	RP,
						(struct Image *)Gadget->GadgetRender,
						X1 + 80 - 13 - 5,			// Right-justified
						Y1 + 5 );
				}
			}

			if(
			/* (((struct ExtFastGadget *)FG)->ObjectType != CT_ERROR) && */	// NOT over "Lost" BM's
			   (BM->pad==0) ) // default icon, needs name
			{
				S = ((struct ExtFastGadget *)FG)->FileName;
				Max = strlen(S);
				S+=Max;
				Max=0;
				while((*(S-1)!=':') && (*(S-1)!='/') && (S>(char *)((struct ExtFastGadget *)FG)->FileName) )
				{
					S--;
					Max++;
				}
				Max = SafeFitText(RP,S,Max,Edit->ImageWidth - 6,FALSE);
				X1 += 8 + ((Edit->ImageWidth - 6) - LastExtent.te_Width)>>1;
				Move(RP,X1,Y2);
				SafeColorText(RP,S,Max);
			}
		}
	}
	WaitBlit();
}

/****** Project/ProjectDropped ****************************************
*
*   NAME
*	ProjectDropped
*
*   SYNOPSIS
*	BOOL ProjectDropped(struct EditWindow *Source,struct EditWindow *Dest,
*		UWORD DropMode, struct EditNode *DestNode)
*
*   FUNCTION
*	Called when Dest is EW_PROJECT, Source is (same)PROJECT/GRAZER
*	Drop all nodes in Source list into Dest Window at DropMode/DestNode
*	Source may == Dest
*
*********************************************************************
*/

// DropMode (if crouton dropped in current location)
#define DROP_INVALID 0
#define DROP_VALID 1	// if DragDestination FALSE, just VALID
#define DROP_INSERT 2	// if DragDestination TRUE, either INSERT/OVERWRITE
#define DROP_OVERWRITE 3
extern LONG RebuildGrazerGrid( struct EditWindow *Edit );

VOID NewLengthUpdate(struct EditWindow *E)
{
	if (E) {
		SafeFixRowCount(E);
		NewGridLength(E);

		CalcRunningTime();		// Re-calculate sequence running time
		DisplayRunningTime();	// Forces display, will clear message

		UpdateAccessWindowRows( E->CurrentRows );
		E->DisplayGrid = TRUE;
		E->RedrawList = TRUE;
	}
}

BOOL ProjectDropped(struct EditWindow *Source,struct EditWindow *Dest,
	UWORD DropMode, struct EditNode *DestNode, UWORD qualifiers)
{
	BOOL AnyDrop = FALSE;
	struct FastGadget *FG,*FDest,*dropped,*srcFG=NULL;
	struct EditNode *Node,*Next;
	struct Project *Project;
	char *MPtr[3];
	int	droppedcount=0;

	struct SmartString *Path,*Item;

//	DUMPMSG("Entered ProjectDropped() ... ");

	if (!DestNode) DestNode = GetLastEditNode(Dest);
	else if (DropMode == DROP_INSERT)
		DestNode = GetPrevEditNode(Dest,DestNode);

// *******************
// grazer->project
	if ( Source->Node.Type == EW_GRAZER )
	{
		// start of end of list so multiple selected stuff inserts correctly
		Node = (struct EditNode *)Source->Special->pEditList->lh_TailPred;
		while (Next=(struct EditNode *)Node->Node.MinNode.mln_Pred)
		{
			if ( Node->Status==EN_DRAGGING )
			{
				Node->Status = EN_NORMAL;
				Node->Redraw = TRUE;

				if ( !AnyDrop )
				{
					if( Dest->ew_cg )
					{
						ULONG		nodenum;

						nodenum = GetProjNodeOrder(Dest,SKellFG);

						if( EDITOR_MODE )
						{
							SKellFG=NULL;
							SendSwitcher(ES_SelectDefault,NULL);
							nodenum = -1;
						}

						ob_DoMethod( Dest->ew_cg,CRGRIDM_SelectCrouton,
							nodenum,GRIDSELECT_NORMAL,CROUTONSELECT_SELECTED);
					}
					else
					{
						ChangeStatusList(Dest,EN_SELECTED,EN_NORMAL);

						if( EDITOR_MODE )
						{
							SKellFG=NULL;
							SendSwitcher(ES_SelectDefault,NULL);
						}
						else if( SKellFG ) /* && SWITCHER_MODE  is this possible??*/
						{
							ChangeStatusNode(Dest,(struct EditNode *)SKellFG,EN_SELECTED);
						}
					}

					AnyDrop = TRUE;
				}

				if ( ((struct GrazerNode *)Node)->DOSClass==EN_FILE )		// Only LOAD files
				{
					Path = ((struct Grazer *)Source->Special)->Path;
					if ( (Item = DuplicateSmartString(Path)) && AppendToPath(Node->Node.Name,Item) )
					{
						if( (FG = AllocProj(GetCString(Item))) )
						{
							DUMPSTR("Adding Crouton ... ");
							//DUMPUDECL("FG type ",GetLongValue(FG,TAG_CroutonType),"\\");

							if (DestNode)
							{
								FG->NextGadget = ((struct FastGadget *)DestNode)->NextGadget;
								((struct FastGadget *)DestNode)->NextGadget = FG;
							}
							else
							{	// insert at beginning
								Project = (struct Project *)Dest->Special;
								FG->NextGadget = *(Project->PtrPtr);
								*(Project->PtrPtr) = FG;
							}

							if( EDITOR_MODE )
							{
								ChangeStatusNode(Dest,(struct EditNode *)FG,EN_SELECTED);
							}
							DUMPMSG("  . . . Crouton Added. ");

							droppedcount++;
							dropped = FG;

//							CurFG = FG;			// We need a CurFG valid after dropping!

							if (!srcFG)			// Can only inherit to one new FG
								srcFG = FG;
						}
					}

					if (Item) FreeSmartString(Item);
				}
			}

			Node = Next;
		}
		// *******************
		// project->project (may be same project)
	} else if (	Source->Node.Type == EW_PROJECT )
	{
		struct FastGadget	*prev_fg;

		// Temporary FG list
		struct FastGadget	*first_fg = NULL,*tail_fg;

		FDest = (struct FastGadget *)DestNode; // may be NULL

		// if dropped over itself, abort
		if (FDest && (FDest->FGDiff.FGNode.Status == EN_DRAGGING))
			DropMode = DROP_INVALID; // flag to move nothing

		// Since "next" pointer is first LONG of the FastGadget,
		// we just substitute the Address of the source FG list head
		prev_fg = (struct FastGadget *)((struct Project *)Source->Special)->PtrPtr;

		// Move all of the selected source gadgets into their
		// own little FastGadget list.

		while ( FG = (struct FastGadget *)GetNextEditNode(Source,(struct EditNode *)prev_fg) )
		{
			if ( FG->FGDiff.FGNode.Status == EN_DRAGGING )
			{
				droppedcount++;
				dropped = FG;

				FG->FGDiff.FGNode.Status = EN_NORMAL;
				FG->FGDiff.FGNode.Redraw = TRUE;
				AnyDrop = TRUE;

				srcFG = FG;			// Remember last FG of those selected

				switch( DropMode )
				{
				case DROP_OVERWRITE:
				case DROP_INSERT:
					Dest->RedrawList = TRUE;
					Dest->DisplayGrid = TRUE;

					if ( Dest->Location == EW_TOP )
					{
						if (Source == Dest)
						{	// Movement within project

							// Remove the gad from the list
							prev_fg->NextGadget = FG->NextGadget;

							if (!first_fg)
							{
								first_fg = FG;
								tail_fg = first_fg;
							}
							else
							{
								tail_fg->NextGadget = FG;
								tail_fg = FG;
							}

							if ( EDITOR_MODE )
								FG->FGDiff.FGNode.Status = EN_SELECTED;
						}
						else
						{	// From bottom (read only) project to work proj
							struct FastGadget	*New;

							if (New = DupeProjNode(FG))
							{
								if (!first_fg)
								{
									first_fg = New;
									tail_fg = first_fg;
								}
								else
								{
									tail_fg->NextGadget = New;
									tail_fg = New;
								}

								if ( EDITOR_MODE )
									New->FGDiff.FGNode.Status = EN_SELECTED;
							}
						}
					}
				}
			}
			else
			{
				prev_fg = (struct FastGadget *)GetNextEditNode(Source,(struct EditNode *)prev_fg);
			}
		}

		// Now Insert them into the list
		if ( first_fg )
		{
			struct FastGadget	*ins_fg = (struct FastGadget *)DestNode;

			if ( !ins_fg )
			{
				ins_fg = (struct FastGadget *)((struct Project *)Dest->Special)->PtrPtr;
			}

			// Insert these node into the list
			tail_fg->NextGadget = ins_fg->NextGadget;
			ins_fg->NextGadget = first_fg;

			srcFG = first_fg;		// This one inherits the tags on overwrite
		}
	}

// handle OVERWRITE
	if (AnyDrop && DestNode && (DropMode == DROP_OVERWRITE))
	{
		struct FastGadget	*wasFG;
		BOOL	doit=FALSE, inherit=FALSE, backout=FALSE;

		// Verify we should overwrite & inherit
		if ((droppedcount==1) && (qualifiers & (IEQUALIFIER_LALT|IEQUALIFIER_RALT)))
		{
			inherit = TRUE;		// Assuming we pass requester test below

			MPtr[0] = "Are you sure you want to overwrite and inherit info from";

			if ((!(WFF_WARN_INHERIT & UserPrefs.WarnFlags))	// Avoid req if disabled
			|| (qualifiers & IEQUALIFIER_CONTROL))				// Manually override req?
				doit = TRUE;
		}
		else	// Verify we should overwrite
		{
			MPtr[0] = "Are you sure you want to overwrite";
			// Double-check to MAKE SURE we should overwrite this guy!

			if ((!(WFF_WARN_PROJOVERWR & UserPrefs.WarnFlags))	// Avoid req if disabled
			|| (qualifiers & IEQUALIFIER_CONTROL))					// Manually override req?
				doit = TRUE;
		}

		// If overwriting not yet approved, ask user
		if (!doit)
		{
			MPtr[1] = ((struct ExtFastGadget *)DestNode)->FileName;	// Crouton name
			MPtr[2] = "Press OK to overwrite, CANCEL to insert";
			doit = SimpleRequest(Dest->Window,MPtr,3,REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,NULL);
		}

		if (doit)		// Should we overwrite?
		{
			DUMPHEXIL("CurFG was: ",(LONG)CurFG,"		");
			Node = GetPrevEditNode(Dest,DestNode);

			if (Node)
			{
				wasFG = ((struct FastGadget *)Node)->NextGadget;

				((struct FastGadget *)Node)->NextGadget =
					((struct FastGadget *)DestNode)->NextGadget;
			}
			else
			{
				wasFG = *((struct Project *)Dest->Special)->PtrPtr;

				*((struct Project *)Dest->Special)->PtrPtr =
					((struct FastGadget *)DestNode)->NextGadget;
			}
			if(CurFG==(struct FastGadget *)DestNode)
			{
				DUMPHEXIL("CurFG was: ",(LONG)CurFG,"		");
				CurFG=(struct FastGadget *)FG;
				DUMPHEXIL("CurFG is: ",(LONG)CurFG,"\\");
			}
			if(SKellFG==(struct FastGadget *)DestNode) SKellFG=NULL;

			//Wanted me to inherit tags?
			if (inherit)
			{
				if (!InheritTags(Dest->Window,(struct FastGadget *)DestNode,srcFG))
					backout = TRUE;		// If cancelled this or failed, back out!
			}

			if (backout)			// Undo the overwrite (do not insert either)
			{
				// Reinsert deleted original
				if (Node)
					((struct FastGadget *)Node)->NextGadget = wasFG;
				else
					*((struct Project *)Dest->Special)->PtrPtr = wasFG;

//				wasFG = ((struct FastGadget *)DestNode)->NextGadget;
//				RemoveProjNode(EditTop,wasFG);		// Remove new insert
//				FreeProjectNode(wasFG);					// Free it
			}
			else
				FreeProjectNode((struct FastGadget *)DestNode);
		}
	}

	if ((droppedcount==1) && (DropMode != DROP_INVALID))
	{
		// Calculate and update crouton's current time
		CalcCurrentTime(dropped);
	}
	else
		SetCurrentTime(-1);			// For a group, can't show a time

	NewLengthUpdate(Dest);

	if (Dest != Source)
		NewLengthUpdate(Source);

	return(FALSE);
}

/****** Project/ArrangeProjectGadgets *********************************
*
*   NAME
*	ArrangeProjectGadgets
*
*   SYNOPSIS
*	VOID ArrangeProjectGadgets(struct EditWindow *Edit,UWORD WindowHeight)
*
*   FUNCTION
*	Arranges gadgets given Project
*
*********************************************************************
*/
#define X_GAP1 1
#define XX 5
VOID ArrangeProjectGadgets(struct EditWindow *Edit,UWORD WindowHeight)
{
	struct Gadget *Grid,*Play,*Control,
		*All,*Delete,*Duplicate,*Save,*ViewPop,*ProgPop,*ToolsPop,
		*NewProj,*Stop,*PlayPart;

// please note the Window may not be open
	Grid = FindGadget(Edit->Gadgets,ID_GRID);
	Grid->TopEdge = GRID_TOP;

	if ( Edit->Location == EW_TOP )
	{
		if (Edit->Height == TOP_SMALL) Grid->Height = 200;
		else Grid->Height = 400;
	}
	else Grid->Height = 175;

	// setup ID_GRID's Height
	if (Edit->Location == EW_TOP)
	{
		// Close = FindGadget(Edit->Gadgets,ID_CLOSE);
		Play = FindGadget(Edit->Gadgets,ID_VCR_PLAY);

		PlayPart = FindGadget(Edit->Gadgets,ID_PLAY_PART);
		PlayPart->UserData = (APTR) HandlePlay;

		Stop = FindGadget(Edit->Gadgets,ID_REQ_STOP);
		Control = FindGadget(Edit->Gadgets,ID_CONTROLS);


		/* Hack "select all" to be disabled */
		All = FindGadget(Edit->Gadgets,ID_ALL);

		/* temporarily using the delete gadget to find correct imagery */
//		if ( SWITCHER_MODE )
		if ( ViewMode == VIEW_PROJ_SWIT )
			Delete = FindGadget(&Gadget1,ID_GHOST_ALL);
		else
			Delete = FindGadget(&Gadget1,ID_ALL);

		/* Clone it, allocating new imagery */
		if ( Delete = AllocOneGadget(Delete) )
		{
			/* Replace the "All" gadget in the list */
			/* Currently, its predecessor is the Controls gadget */

			Control->NextGadget = Delete;
			Delete->NextGadget = All->NextGadget;
			FreeGadget(All);

			All = Delete;
			All->GadgetID = ID_ALL;
		}

		Delete = FindGadget(Edit->Gadgets,ID_DELETE);
		Duplicate = FindGadget(Edit->Gadgets,ID_DUPLICATE);
		Save = FindGadget(Edit->Gadgets,ID_SAVE_PROJECT);

		ProgPop = FindGadget(Edit->Gadgets,ID_POPUP_PROGRAMS);
		ViewPop = FindGadget(Edit->Gadgets,ID_POPUP_VIEWS);
		ToolsPop = FindGadget(Edit->Gadgets,ID_POPUP_TOOLS);
	}
	else
	{
		NewProj = FindGadget(Edit->Gadgets,ID_NEW_PROJECT);
		NewProj->UserData = (APTR) BotProjNewProject;;
	}

	if (ArrangeEditGadgets(Edit))
	{
		if (Edit->Location == EW_TOP)
		{
			Stop->TopEdge = Control->TopEdge = PlayPart->TopEdge =
			All->TopEdge = Delete->TopEdge = Duplicate->TopEdge =
			ToolsPop->TopEdge = Save->TopEdge = ViewPop->TopEdge =
			ProgPop->TopEdge = Play->TopEdge = Grid->Height + 5;

			ToolsPop->Width = 59;

			Delete->LeftEdge = GRID_LEFT;

			All->LeftEdge = Delete->LeftEdge + Delete->Width + 2*XX-1;
			Duplicate->LeftEdge = All->LeftEdge + All->Width;
			ToolsPop->LeftEdge = Duplicate->LeftEdge + Duplicate->Width;
			Control->LeftEdge = ToolsPop->LeftEdge + ToolsPop->Width + 1;

			Play->LeftEdge =  Control->LeftEdge + Control->Width + 2*XX-1;
			PlayPart->LeftEdge = Play->LeftEdge + Play->Width-1;
			Stop->LeftEdge = PlayPart->LeftEdge + PlayPart->Width;
			Save->LeftEdge = Stop->LeftEdge + Stop->Width + 2*XX-1;

			ProgPop->LeftEdge = Save->LeftEdge + Save->Width + 2*XX-1;
			ProgPop->Width = 92;
			ViewPop->Width = 65;
			ToolsPop->Height = ProgPop->Height = ViewPop->Height = 19;
			ViewPop->LeftEdge = ProgPop->LeftEdge + ProgPop->Width+1;

		}
		else
		{
			NewProj->TopEdge = Grid->Height + 5;
			NewProj->LeftEdge = (Grid->LeftEdge + Grid->Width) - (NewProj->Width + XX);
		}
	}
}

/****** Project/FreeProject ******************************************
*
*   NAME
*	FreeProject
*
*   SYNOPSIS
*	VOID FreeProject(struct EditWindow *Edit)
*
*   FUNCTION
*	Frees it all
*
*********************************************************************
*/
VOID FreeProjectNode(struct FastGadget *FG)
{
#ifndef SWIT_ONLY
	if (!SwitPort) {
		if (FG->Data)
			FreeMem(FG->Data,CR_PLANE*2);
		FreeMem(FG,sizeof(struct FastGadget));
	} else {
#endif
	DUMPMSG("Before FreeProjectNode() sends ES_FreeCrouton");
	ESparams1.Data1=(LONG)FG;
	SendSwitcher(ES_FreeCrouton,&ESparams1);
	DUMPMSG("  After FreeProjectNode() sent ES_FreeCrouton");
#ifndef SWIT_ONLY
	}
#endif
}

//*******************************************************************
VOID FreeProjectList(struct Project *Project)
{
	struct FastGadget *FG,*Next;

	FG = *(Project->PtrPtr);
	while (FG) {
		Next = FG->NextGadget;
		FreeProjectNode(FG);
		FG = Next;
	}
	*(Project->PtrPtr) = NULL;
}

//*******************************************************************
VOID FreeProject(struct EditWindow *Edit)
{
	if (Edit) {
		FreeEditWindow(Edit);
		if (Edit->Special) {
#ifndef SWIT_ONLY
		if (!SwitPort) FreeProjectList((struct Project *)Edit->Special);
#endif
			FreeMem(Edit->Special,sizeof(struct Project));
		}
		FreeSmartNode(&Edit->Node);
	}
}

//*******************************************************************
// sets up my fields in FG for use by project editor
BOOL __regargs ProjFGInit(struct FastGadget *FG)
{
	if (FG) {
		FG->FGDiff.FGNode.Behavior = EN_DRAGGABLE | EN_SELECT_ACTION
			| EN_DOUBLE_ACTION;
		return(TRUE);
	}
	return(FALSE);
}

//*******************************************************************
BOOL __regargs InitProject(struct Project *Project)
{
	struct FastGadget *FG;

	if( (FG=*(Project->PtrPtr))==NULL )
		return(FALSE);

	CurFG = NULL;

	while (FG) {
		if (!ProjFGInit(FG)) return(FALSE);
		FG = FG->NextGadget;
	}

	return(TRUE);
}


BOOL TagFilter(struct ExtFastGadget *FG)
{

	ULONG	KeyFade = 0;
	
	DUMPMSG("***************** IN TAGFILTER *****************");
//	DUMPUDECL("*FG ",FG,"\\");
//	DUMPUDECL("FG type ",GetLongValue(FG,TAG_CroutonType),"\\");
	DUMPHEXIL("FG type ",(struct ExtFastGadget *)FG->ObjectType,"\\");
	DUMPHEXIL("FG type ",(struct ExtFastGadget *)FG->TagLists,"\\");

	// see if its a key
	if (((struct ExtFastGadget *)FG)->ObjectType==0x4b455946)
	{
		// if it is a key check UserPrefs
		if (!(UserPrefs.CGKeyFlagsOn))
			KeyFade = 1; 
		if (!(UserPrefs.CGKeyFlagsOff))
			KeyFade |= 2; 
		//  put the correct tag as set by UserPrefs.
		PutValue(FG,TAG(Speed),KeyFade);
	}
	return(TRUE);
} 




//*******************************************************************
BOOL __regargs InitSetupProject(struct EditWindow *E)
{
	InitProject((struct Project *)E->Special);

	NewLengthUpdate(E);
// DOES ALL THIS PLUS CALC'ING PROGRAM TIME
//	SafeFixRowCount(E);
//	NewGridLength(E);
//	UpdateAccessWindowRows( E->CurrentRows );
//	E->RedrawList = TRUE;
//	E->DisplayGrid = TRUE;

	E->ew_OptRender = FALSE;
	return(TRUE);
}

//*******************************************************************
struct FastGadget *AllocProj(char *FileName)
{
	struct FastGadget *New = NULL;

	if (!SwitPort)
	{
		if (New = SafeAllocMem(sizeof(struct FastGadget),MEMF_CLEAR))
			New->Flags2 = CR_VidEvent;
	}
	else
	{
		BPTR		lock;

		if ( lock = Lock(FileName,ACCESS_READ) )
		{
			BOOL			gotvolpath;

			gotvolpath = NameFromLock(lock,filepathbuf,sizeof(filepathbuf));

			UnLock(lock);

			if ( gotvolpath )
			{
				ESparams2.Data1=(LONG)filepathbuf;
				ESparams2.Data2=0;
				New = (struct FastGadget *)SendSwitcherReply(ES_LoadCrouton,&ESparams2);
			}
		}
	}
	if (New)
	{	
		ProjFGInit(New);
		TagFilter(New);
	}
	return(New);
}

//*******************************************************************
struct FastGadget *DupeProjNode(struct FastGadget *FG)
{
	struct FastGadget *New;

#ifndef SWIT_ONLY
	if (!SwitPort) {
	if (New = AllocProj(NULL)) {
		CopyMem(FG,New,sizeof(struct FastGadget));
		New->NextGadget = NULL;
		if (FG->Data) {
			if (New->Data = SafeAllocMem(CR_PLANE*2,0))
				CopyMem(FG->Data,New->Data,CR_PLANE*2);
		}
	}
	} else {
#endif
		DUMPMSG("Before DupeProjNode() sends ES_DuplicateCrouton");
		ESparams1.Data1=(LONG)FG;
		New = (struct FastGadget *)
			SendSwitcherReply(ES_DuplicateCrouton,&ESparams1);
		DUMPMSG("  After DupeProjNode() sent ES_DuplicateCrouton");
	if (New) ProjFGInit(New);
#ifndef SWIT_ONLY
	}
#endif
	return(New);
}

//*******************************************************************
BOOL __regargs GetLoadedProject(struct EditWindow *Edit)
{
	BOOL Success = FALSE;

	if ( Edit!=EditBottom )
	{
		if ( PtrProject )
		{
			((struct Project *)Edit->Special)->PtrPtr = PtrProject;
			InitProject((struct Project *)Edit->Special);

			if ( Edit->ew_cg )
				ob_DoMethod( Edit->ew_cg,CRGRIDM_BuildGridFromFGList,
					((struct Project *)Edit->Special)->PtrPtr );
			Success = TRUE;
		}
	}
	else if ( XtrProject )
	{
		((struct Project *)Edit->Special)->PtrPtr = XtrProject;
		InitProject((struct Project *)Edit->Special);

		if ( Edit->ew_cg )
			ob_DoMethod( Edit->ew_cg,CRGRIDM_BuildGridFromFGList,
				((struct Project *)Edit->Special)->PtrPtr );
    Success = TRUE;
	}
	return(Success);
}

/****** Project/ResizeProject ***************************************
*
*   NAME
*	ResizeProject
*
*   SYNOPSIS
*	BOOL ResizeProject(struct EditWindow *Edit,UWORD NewHeight)
*
*   FUNCTION
*	Called by ResizeEditWindow(), does project-specific changes
*
*********************************************************************
*/
BOOL ResizeProject(struct EditWindow *Edit,UWORD NewHeight)
{
	BOOL Success;

	ArrangeProjectGadgets(Edit,NewHeight);
	CalcGridDimensions(Edit); // re-calc as soon as grid re-sized
	NewGridLength(Edit);

	if ( Edit->ew_cg )
	{
		struct Gadget *Grid;

		Grid = FindGadget(Edit->Gadgets,ID_GRID);

		ob_SetAttrs( Edit->ew_cg,
			CRGRIDA_DestHeight,	Grid->Height,
			TAG_DONE );
	}

	Success = TRUE;
	return(Success);
}

/****** Project/ProjectAll **********************************
*
*   NAME
*	ProjectAll
*
*   SYNOPSIS
*	BOOL ProjectAll(struct EditWindow *Edit)
*
*   FUNCTION
*
*
*********************************************************************
*/
BOOL ProjectAll(struct EditWindow *Edit)
{
	SKellFG=NULL;
	SendSwitcher(ES_SelectDefault,NULL);

	if ( Edit->ew_cg )
	{
		ob_DoMethod( Edit->ew_cg,CRGRIDM_SelectCrouton,
			CROUTONNUM_ALL,GRIDSELECT_NORMAL,CROUTONSELECT_SELECTED);

		Edit->ew_OptRender = TRUE;
		Edit->RedrawSelect = TRUE;
		Edit->DisplayGrid = TRUE;
	}
	else
	{
		ChangeStatusList(Edit,EN_NOT_STATUS,EN_SELECTED);
	}

	return(TRUE);
}

/****** Project/AllocInitProject ******************************************
*
*   NAME
*	AllocInitProject
*
*   SYNOPSIS
*	struct EditWindow *AllocInitProject(struct NewProject *NewProject)
*
*   FUNCTION
*	Allocates a Project, but does not open it
*
*********************************************************************
*/
struct EditWindow *AllocInitProject(struct NewProject *NewProject)
{
	struct Project *Project;
	struct EditWindow *Edit;
	UWORD *IDS;
	BOOL Success = FALSE;
	struct Gadget *Gadget;

	if (NewProject->NewEdit.Location == EW_TOP)
	{
		IDS = TopIDS;
	}
	else IDS = BottomIDS;

	if ((Edit=(struct EditWindow *)AllocSmartNode(NULL,sizeof(struct EditWindow),
		MEMF_CLEAR)) &&
		(Edit->Special = (struct EditSpecial *)AllocSmartNode(NULL,sizeof(struct Project),
		MEMF_CLEAR))) {

		Project = (struct Project *)Edit->Special;
		Project->PtrPtr = &NoSwitPtr;

		Edit->Node.Type = EW_PROJECT;
		Edit->DragDestination = TRUE;
		Edit->NodeDropped = ProjectDropped;
		Edit->NodeDeleted = ProjectDeleted;
		Edit->NodeDuplicate = ProjectDuplicate;
		Edit->NodeDouble = ProjectDouble;
		Edit->SelectAll = ProjectAll;
		Edit->NodeSelect = ProjectSelect;

		Edit->RenderNode = ProjectRenderNode;
		Edit->Resize = ResizeProject;
		Edit->Open = OpenEditWindow; // no special requirements
		Edit->Close = CloseEditWindow;  // no special requirements
		Edit->Free = FreeProject;

		if ((InitEditWindow(Edit,&NewProject->NewEdit))
			&& (Edit->Gadgets = AllocGadgetIDS(IDS,&Gadget1))) {

			ArrangeProjectGadgets(Edit,NewProject->NewEdit.Height);

			Edit->ColumnSize = Edit->IconWidth;
			Edit->RowSize = Edit->IconHeight;
			Edit->ImageWidth = Edit->ColumnSize-2;
			Edit->ImageHeight = Edit->RowSize-2;
			CalcGridDimensions(Edit);

			Gadget = FindGadget(Edit->Gadgets,ID_KNOB);
			if (AllocGrid(Edit)) {
				Success = TRUE;
			}
		}

		if (!Success) {
			if (Edit) {
				FreeProject(Edit);
				Edit = NULL;
			}
		}
	}
	return(Edit);
}

//*******************************************************************
VOID AddProjTail(struct Project *Project,struct FastGadget *FG)
{
	struct FastGadget *End;

	End = *(Project->PtrPtr);
	if (!End) {
		*(Project->PtrPtr) = FG;
	} else {
		while (End->NextGadget) End = End->NextGadget;
		End->NextGadget = FG;
	}
}

//*******************************************************************
VOID AddProjHead(struct Project *Project,struct FastGadget *FG)
{
	if (FG) {
		FG->NextGadget = *(Project->PtrPtr);
		*(Project->PtrPtr) = FG;
	}
}

//*******************************************************************
// starts numbering with zero
struct FastGadget *GetProjNode(struct FastGadget *Node,UWORD A)
{
	while (A && Node) {
		Node = Node->NextGadget;
		A--;
	}
	return(Node);
}

//*******************************************************************
struct EditNode *GetEditNode(struct EditWindow *Edit,UWORD A)
{
	if (A < 1) A = 1; // starts with 1, like GetNode()

	if (Edit->Node.Type == EW_GRAZER)
	{
		struct EditNode *Node = (struct EditNode *)Edit->Special->pEditList->lh_Head;

		while ( Node->Node.MinNode.mln_Succ )
		{
			if ( !(--A) )
				break;

			Node = (struct EditNode *)Node->Node.MinNode.mln_Succ;
		}

		if (Node->Node.MinNode.mln_Succ)
			return(Node);
		else
			return(NULL);
	}
	else
		return((struct EditNode *)GetProjNode(*(((struct Project *)
			Edit->Special)->PtrPtr),A-1));
}

//*******************************************************************
UWORD GetEditNodeStatus(struct EditWindow *Edit,struct EditNode *Node)
{
	if (Edit->Node.Type == EW_GRAZER) return(Node->Status);
	else return(((struct FastGadget *)Node)->FGDiff.FGNode.Status);
}

//*******************************************************************
UWORD GetEditNodeBehavior(struct EditWindow *Edit,struct EditNode *Node)
{
	if (Edit->Node.Type == EW_GRAZER) return(Node->Behavior);
	else return(((struct FastGadget *)Node)->FGDiff.FGNode.Behavior);
}

//*******************************************************************
struct EditNode *GetNextEditNode(struct EditWindow *Edit,struct EditNode *Node)
{
	if (!Node) return(NULL);
	if (Edit->Node.Type == EW_GRAZER)
	{
		Node = (struct EditNode *)Node->Node.MinNode.mln_Succ;

		if (Node->Node.MinNode.mln_Succ)
			return(Node);
		else
			return(NULL);
	} else
		return((struct EditNode *)((struct FastGadget *)Node)->NextGadget);
}

//*******************************************************************
struct EditNode *GetPrevEditNode(struct EditWindow *Edit,struct EditNode *Node)
{
	struct EditNode *Next;
	struct FastGadget *FG;

	if (!Node) return(NULL);
	if (Edit->Node.Type == EW_GRAZER) {
		Next = (struct EditNode *)Node->Node.MinNode.mln_Pred;
		if (Next->Node.MinNode.mln_Pred) return(Next);
		else return(NULL);
	} else {
		FG = *(((struct Project *)Edit->Special)->PtrPtr);
		while (FG) {
			if (FG->NextGadget == (struct FastGadget *)Node)
				return((struct EditNode *)FG);
			FG = FG->NextGadget;
		}
		return(NULL);
	}
}

//*******************************************************************
VOID RemoveProjNode(struct EditWindow *Edit,struct FastGadget *FG)
{
	struct FastGadget *FNext;

	if (FG) {
		FNext = (struct FastGadget *)GetPrevEditNode(Edit,(struct EditNode *)FG);
		if (FNext) FNext->NextGadget = FG->NextGadget;
		else *(((struct Project *)Edit->Special)->PtrPtr) = FG->NextGadget;
	}
}

//*******************************************************************
// if Exist NULL, add to head of list
VOID InsertProjNode(struct EditWindow *Edit,struct FastGadget *Exist,
	struct FastGadget *FG)
{
	if (FG) {
		if (!Exist) AddProjHead((struct Project *)Edit->Special,FG);
		else {
			FG->NextGadget = Exist->NextGadget;
			Exist->NextGadget = FG;
		}
	}
}

//*******************************************************************
LONG GetProjNodeOrder(struct EditWindow *Edit,struct FastGadget *find_fg )
{
	LONG						 retval = -1,order = 0;
	struct FastGadget		*fg;

	fg = *(((struct Project *)Edit->Special)->PtrPtr);

	while ( fg )
	{
		if ( fg == find_fg )
		{
			retval = order;
			break;
		}

		fg = fg->NextGadget;
		order++;
	}

	return(retval);
}

LONG GetGrazerNodeOrder(struct EditWindow *Edit,struct EditNode *find_en )
{
	LONG						 retval = -1,order = 0;
	struct EditNode		*en;

	en = (struct EditNode *)Edit->Special->pEditList->lh_Head;

	while ( en->Node.MinNode.mln_Succ )
	{
		if ( en == find_en )
		{
			retval = order;
			break;
		}

		en = (struct EditNode *)en->Node.MinNode.mln_Succ;
		order++;
	}

	return(retval);
}

//*******************************************************************
struct EditNode *GetLastEditNode(struct EditWindow *Edit)
{

	if (Edit->Node.Type == EW_GRAZER)
	{
		struct EditNode *Node;

		Node = (struct EditNode *)Edit->Special->pEditList->lh_TailPred;
		if (!Node->Node.MinNode.mln_Pred) return(NULL);
		else return(Node);

	}
	else
	{
		struct FastGadget *FG;

		FG = *(((struct Project *)Edit->Special)->PtrPtr);
		if (!FG) return(NULL);
		while (FG->NextGadget) {
			FG = FG->NextGadget;
		}

		return((struct EditNode *)FG);
	}
}

//*******************************************************************
UWORD GetEditListLen(struct EditWindow *Edit)
{
	if (Edit->Node.Type == EW_GRAZER)
		return((UWORD)ListLength(Edit->Special->pEditList));
	else
		return(SingleListLength(*(((struct Project *)Edit->Special)->PtrPtr)));
}

//*******************************************************************
UWORD SingleListLength(struct FastGadget *FG)
{
	UWORD A=0;

	while (FG) {
		A++;
		FG = FG->NextGadget;
	}
	return(A);
}

//*******************************************************************
BOOL GetEditNodeRedraw(struct EditWindow *Edit,struct EditNode *Node)
{
	if (Edit->Node.Type == EW_GRAZER) return(Node->Redraw);
	else return(((struct FastGadget *)Node)->FGDiff.FGNode.Redraw);
}

//*******************************************************************
BOOL SafeFixRowCount(struct EditWindow *Edit)
{
	UWORD A;

	if ( Edit->ew_cg )
		A = FALSE;
	else
		A = FixIconRowCount(Edit->ScrollGrid,GetEditListLen(Edit));

	if (A) ContinueRequest(Edit->Window,IoErrToText(ERROR_NO_FREE_STORE));
	return(TRUE);
}

//*******************************************************************
// attempts to get imagery out of grazer node
VOID GetImageGrazer(struct FastGadget *FG,struct GrazerNode *Node)
{
	UWORD A,Depth;
	UBYTE *B;

	if (FG && Node && Node->BitMap) {
		Depth = Node->BitMap->Depth;
		if (FG->Data = SafeAllocMem(CR_PLANE*Depth,0)) {
			B = FG->Data;
			for (A=0; A < Depth; A++) {
				CopyMem(Node->BitMap->Planes[A],B,CR_PLANE);
				B += CR_PLANE;
			}
		}
	}
}

//*******************************************************************
LONG EndProjSaveRequest( struct GrazerRequest *gr, LONG mode );

static char *ProjSaveReqText[] = {
	"Save Project",
	"Locate the directory and project below using the file requester.",
	"Enter a filename and Select \"Continue\" to save the project.",
};
#define PROJ_SAVE_REQTEXT_NUMLINES	3

struct GrazerRequest ProjSaveGrazRequest = {

	ProjSaveReqText,
	PROJ_SAVE_REQTEXT_NUMLINES,

	NULL,
	0,

	0,
	0,
	0,

	GRAZREQ_ALLOWCREATE | GRAZREQ_RESTOREVIEW | GRAZREQ_BACKUP,

	EndProjSaveRequest,
};

struct EditWindow *HandleSaveProject(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	/* Set initial path of grazer */
	char		*f,c;

	/* only get path part of project name */
	f = FilePart(ProjectName);

	/* Store the file name */
	strcpy(ProjSaveGrazRequest.gr_InitialFileName,f);

	c = *f;	*f = '\0';

	/* Store the directory */
	ProjSaveGrazRequest.gr_InitialPath = AllocSmartString(ProjectName,NULL);
	*f = c;

	/* Determine if there are any tape drives out there, and enable
	 * the "Backup" button if there are any.
	 */

	/* Clear this for "Backup" button */
	ProjSaveGrazRequest.gr_UserData = 0;

	BeginGrazerRequest( &ProjSaveGrazRequest );
	Edit = EditTop; // old one gone
	return(Edit);
}

LONG EndProjSaveRequest( struct GrazerRequest *gr, LONG mode )
{
	LONG						 retval = 0;

	if ( mode && (gr->gr_Flags & GRAZREQ_VALIDFILENAME) )
	{
		ESparams2.Data1=0;
		ESparams2.Data2=(LONG)GetCString(gr->gr_FilePath);
		if ( !SendSwitcherReply(ES_SaveProject,&ESparams2) )
		{
		// Success!
			retval = TRUE;
			strcpy(ProjectName,GetCString(gr->gr_FilePath));

			/* "Backup" button will set "gr_UserData" */
			if ( gr->gr_UserData )
			{
				extern LONG DoProjectBackup( STRPTR projname, STRPTR device, LONG unit, struct Window *win );
				struct Window		*win;

				win = EditTop->Window;

				DoProjectBackup( ProjectName, "flyerscsi.device", -1, win );
			}
		}
		else
		{
			// Some Error condition.
			ContinueRequest(EditTop->Window,"Error -- Project not saved!");
		}
	}

	if ( gr->gr_CancelBottomType == EW_GRAZER )
		DoAllNewDir(EditBottom);

	req_DoLayout(	gr->gr_CancelTopType,
						gr->gr_CancelTopHeight,
						gr->gr_CancelBottomType);

	if (gr->gr_FilePath)
	{
		FreeSmartString(gr->gr_FilePath);
		gr->gr_FilePath = NULL;
	}

	return(retval);
}
// end of project.c
@


2.145
log
@added es_take support
@
text
@d3 1
a3 1
* $Id: project.c,v 2.144 1995/11/21 16:19:39 Flick Exp Holt $
d5 3
d408 1
a408 1
#define SERDEBUG	1
d490 1
a490 1
	DUMPMSG("ProjectSelect");
d895 1
a895 1
	DUMPMSG("Entered ProjectDropped() ... ");
d957 3
a959 1
				DUMPSTR("Adding Crouton ... ");
d976 1
a976 1
				DUMPMSG("  . . . Crouton Added. ");
d1419 29
d1491 1
a1491 2
				New = (struct FastGadget *)
					SendSwitcherReply(ES_LoadCrouton,&ESparams2);
d1495 5
a1499 1
	if (New) ProjFGInit(New);
@


2.144
log
@Now puts up requester if project save fails for any reason (dope!!!)
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.143 1995/11/14 18:22:51 Flick Exp Flick $
* $Log: Project.c,v $
d405 1
a405 1
//#define SERDEBUG	1
d487 2
d643 2
d651 1
d653 2
d658 1
d660 1
d663 3
d671 1
@


2.143
log
@Project saves default to toaster:Projects the first time
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.142 1995/10/24 17:31:41 Flick Exp Flick $
d5 3
d2014 2
a2015 1
		// Some Error condition.
@


2.142
log
@If InheritTags is aborted or fails, will now undo the overwrite (and not insert either)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.141 1995/10/14 10:41:24 Flick Exp Flick $
d5 3
d470 1
a470 1
UBYTE PjName[369]  =""; // "RAM:WorkProject";
@


2.141
log
@Additional line in overwrite verification requester (CANCEL will insert)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.140 1995/10/12 16:38:41 Flick Exp Flick $
d5 3
d1082 2
a1083 1
		BOOL	doit=FALSE, inherit=FALSE;
d1121 2
d1128 2
d1143 4
a1146 1
				InheritTags(Dest->Window,(struct FastGadget *)DestNode,srcFG);
d1148 14
a1161 1
			FreeProjectNode((struct FastGadget *)DestNode);
@


2.140
log
@Replaced hard-coded ViewMode values with VIEW_XXX defines (popup rearranged)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.139 1995/10/10 17:20:33 Flick Exp Flick $
d5 3
d862 1
a862 1
	char *MPtr[2];
d1106 2
a1107 1
			doit = SimpleRequest(Dest->Window,MPtr,2,REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,NULL);
@


2.139
log
@Removed special text-rendering test for "lost" croutons -- now renders text on them too
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.138 1995/10/09 23:58:47 Flick Exp Flick $
d5 3
d1203 1
a1203 1
		if ( ViewMode == 2 )
@


2.138
log
@Changed inherit operation to list crouton name in requester, and to NOT OVERWRITE if user
cancels.  Also supports CTRL key to manually override requester in novice mode.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.137 1995/10/09 16:46:56 Flick Exp Flick $
d5 4
d787 3
a789 2
			if( (((struct ExtFastGadget *)FG)->ObjectType != CT_ERROR)	// NOT over "Lost" BM's
			&& (BM->pad==0) ) // default icon, needs name
@


2.137
log
@Removed unnecessary usage of popup.h
Changed ProjectRenderNode to NOT render text over Lost Croutons (special test)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.136 1995/10/06 16:13:14 Flick Exp Flick $
d5 4
d1068 25
a1092 8
		MPtr[0] = "Are you sure you want to overwrite crouton";
		MPtr[1] = ((struct ExtFastGadget *)DestNode)->FileName;
		// Double-check to MAKE SURE we should overwrite this guy!
		// No requester if ALT keys, as this is an annoyance if using ALT to inherit

		if ((!(WFF_WARN_PROJOVERWR & UserPrefs.WarnFlags))	// Avoid req if disabled
		|| (qualifiers & (IEQUALIFIER_CONTROL|IEQUALIFIER_LALT|IEQUALIFIER_RALT))
		|| SimpleRequest(Dest->Window,MPtr,2,REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,NULL))
d1094 3
d1098 2
d1121 3
a1123 4
			//Want me to inherit tags?
			if ((droppedcount==1) && (qualifiers & (IEQUALIFIER_LALT|IEQUALIFIER_RALT)))
			{
				MPtr[0] = "Are you sure you want to inherit info from old crouton?";
a1124 4
				if ((!(WFF_WARN_INHERIT & UserPrefs.WarnFlags))	// Avoid req if disabled
				|| SimpleRequest(Dest->Window,MPtr,1,REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,NULL))
					InheritTags(Dest->Window,(struct FastGadget *)DestNode,srcFG);
			}
@


2.136
log
@Now erases Current Time display after deleting croutons from project
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.135 1995/10/03 18:07:30 Flick Exp Flick $
d5 3
a351 1
#include <edit:popup/popup.h>
d738 1
d779 2
a780 1
			if(BM->pad==0) // default icon, needs name
@


2.135
log
@Changed requester skipping to use individual flags in prefs, rather than global user level
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.134 1995/10/02 15:24:24 Flick Exp Flick $
d5 3
d678 1
@


2.134
log
@Added POPUP_TOOLS to button row, now puts up "Sure you want to inherit..." msg before doing
an inherit, rather than after.  Many lesser warning requesters now skipped if UserLevel (in
options panel) ==GENIUS (Delete from proj, overwrite, inherit)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.133 1995/09/25 12:44:35 Flick Exp Flick $
d5 5
d653 1
a653 1
	if ((UserPrefs.UserLevel==USRLVL_GENIUS)		// Avoid req if expert user
d1060 2
a1061 1
		if ((UserPrefs.UserLevel==USRLVL_GENIUS)		// Avoid req if expert user
d1092 1
a1092 1
				if ((UserPrefs.UserLevel==USRLVL_GENIUS)		// Avoid req if expert user
@


2.133
log
@Added overwrite verification, and support for inherit-drop
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.132 1995/08/18 17:09:19 Flick Exp Flick $
d5 3
d330 1
d393 1
d427 1
a427 1
	ID_POPUP_PROGRAMS,ID_POPUP_VIEWS,
d648 2
a649 6
	if (!BoolRequest(Edit->Window,"Delete crouton(s) from project?"))
		return(FALSE);

	FG = *((struct Project *)Edit->Special)->PtrPtr;
	DisplayWaitSprite();
	while (FG)
d651 14
a664 2
		Next = FG->NextGadget;
		if (FG->FGDiff.FGNode.Status == EN_SELECTED)
d666 4
a669 3
			Any = TRUE;
			RemoveProjNode(Edit,FG);
			FreeProjectNode(FG);
d671 1
a671 8
		FG = Next;
	}
	if (Any)
	{
		NewLengthUpdate(Edit);
		SKellFG=NULL;
		SendSwitcher(ES_SelectDefault,NULL);
		CurFG=NULL;
a672 1
	DisplayNormalSprite();
d1055 2
a1056 1
		if ((qualifiers & (IEQUALIFIER_CONTROL|IEQUALIFIER_LALT|IEQUALIFIER_RALT))
d1083 2
a1084 1
				InheritTags(Dest->Window,(struct FastGadget *)DestNode,srcFG);
d1086 4
d1128 2
a1129 1
		*All,*Delete,*Duplicate,*Save,*ViewPop,*ProgPop,*NewProj,*Stop,*PlayPart;
d1182 1
d1185 1
a1196 1
			Play->TopEdge = Grid->Height + 5;
d1199 4
a1202 1
			Save->TopEdge = ViewPop->TopEdge = ProgPop->TopEdge = Play->TopEdge;
d1205 8
a1212 5
			All->LeftEdge = Delete->LeftEdge + Delete->Width + 2*XX;
			Duplicate->LeftEdge = All->LeftEdge + All->Width + X_GAP1;
			Control->LeftEdge = Duplicate->LeftEdge + Duplicate->Width + X_GAP1;
			Play->LeftEdge =  Control->LeftEdge + Control->Width + (2*XX);
			PlayPart->LeftEdge = Play->LeftEdge + Play->Width;
d1214 1
a1214 1
			Save->LeftEdge = Stop->LeftEdge + Stop->Width + 2*XX;
d1216 1
a1216 1
			ProgPop->LeftEdge = Save->LeftEdge + Save->Width + 2*XX;
d1219 2
a1220 2
			ProgPop->Height = ViewPop->Height = 19;
			ViewPop->LeftEdge = ProgPop->LeftEdge + ProgPop->Width;
@


2.132
log
@Maintenance of project running time after dragging/duplicating
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.131 1995/07/13 16:56:56 Flick Exp Flick $
d5 3
d822 1
a822 1
	UWORD DropMode, struct EditNode *DestNode)
d825 1
a825 1
	struct FastGadget *FG,*FDest,*dropped;
d828 1
d832 2
a833 1
		DUMPMSG("Entered ProjectDropped() ... ");
d918 3
d963 2
d1037 2
d1045 7
a1051 2
		DUMPHEXIL("CurFG was: ",(LONG)CurFG,"		");
		Node = GetPrevEditNode(Dest,DestNode);
a1052 12
		if (Node)
		{
			((struct FastGadget *)Node)->NextGadget =
				((struct FastGadget *)DestNode)->NextGadget;
		}
		else
		{
			*((struct Project *)Dest->Special)->PtrPtr =
				((struct FastGadget *)DestNode)->NextGadget;
		}
		if(CurFG==(struct FastGadget *)DestNode)
		{
d1054 25
a1078 2
			CurFG=(struct FastGadget *)FG;
			DUMPHEXIL("CurFG is: ",(LONG)CurFG,"\\");
a1079 4
		if(SKellFG==(struct FastGadget *)DestNode) SKellFG=NULL;

		// *** Could implement an "inherit tags" function here***
		FreeProjectNode((struct FastGadget *)DestNode);
@


2.131
log
@Modified text slightly for "delete croutons from project" req
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.130 1995/07/13 13:08:33 Flick Exp Flick $
d5 3
d508 2
a509 1
	struct FastGadget	*first_fg = NULL,*tail_fg;
d548 3
d571 8
d808 3
a810 2
		SetRunningTime(0);
		DisplayRunningTime();
d822 1
a822 1
	struct FastGadget *FG,*FDest;
d825 1
d883 1
a883 1
				if ( ((struct GrazerNode *)Node)->DOSClass==EN_FILE )
d909 3
d948 3
d1053 2
d1058 8
a1068 1
	{
a1069 1
	}
d1281 9
a1289 5
	SafeFixRowCount(E);
	NewGridLength(E);
	UpdateAccessWindowRows( E->CurrentRows );
	E->RedrawList = TRUE;
	E->DisplayGrid = TRUE;
@


2.130
log
@Modified text slightly on delete croutons verify requester
@
text
@d3 5
a7 2
* $Id: project.c,v 2.129 1995/07/07 19:23:44 Flick Exp Flick $
* $Log: project.c,v $
d625 1
a625 1
	if (!BoolRequest(Edit->Window,"Are you sure you want to delete crouton(s)?"))
@


2.129
log
@Moved DEL-verify message to ProjectDropped, where it should be
@
text
@d3 1
a3 1
* $Id: project.c,v 2.128 1995/07/07 17:03:45 Flick Exp Flick $
d5 3
d622 1
a622 1
	if (!BoolRequest(Edit->Window,"Are you sure you want to delete croutons?"))
@


2.128
log
@Fixed +1 vert placement bug with corner symbols during drag
@
text
@d3 1
a3 1
* $Id: project.c,v 2.127 1995/07/06 18:21:40 Flick Exp Flick $
d5 3
d619 3
d885 2
@


2.127
log
@Added support for ID_CROUTONSTAMP_AUDIO
@
text
@d3 1
a3 1
* $Id: project.c,v 2.126 1995/07/05 16:34:24 pfrench Exp Flick $
d5 3
d715 1
a715 1
						Y1 + 1 + 5 );
d727 1
a727 1
						Y1 + 1 + 5 );
@


2.126
log
@Now rendering locks on dragging croutons
@
text
@d3 1
a3 1
* $Id: project.c,v 2.125 1995/02/13 17:17:44 pfrench Exp pfrench $
d5 3
d707 7
d716 1
a716 1
			if ( Gadget )
d718 8
a725 5
				DrawImage(	RP,
					(struct Image *)Gadget->GadgetRender,
					X1 + 5,
					Y1 + 1 + 5 );

@


2.125
log
@Added hack to play-forward-from-crouton button's handler
function pointer.
@
text
@d3 1
a3 1
* $Id: project.c,v 2.124 1995/01/27 14:07:11 pfrench Exp pfrench $
d5 4
d687 2
d700 15
@


2.124
log
@Now lets project bring up its own requester
@
text
@d3 1
a3 1
* $Id: project.c,v 2.123 1995/01/26 09:18:47 pfrench Exp pfrench $
d5 3
d368 1
a368 1
// it easy to indicate the number of parameters being set. 
d1028 1
d1030 2
d1755 1
a1755 1
	
@


2.123
log
@Now has backup function scan for drives
@
text
@d3 1
a3 1
* $Id: project.c,v 2.122 1995/01/25 19:35:18 pfrench Exp pfrench $
d5 3
a1791 1

a1792 2
				struct RastPort	*rp;
				UBYTE					 old_mask;
a1794 4
				rp = win->RPort;

				NewBorderBox( win->RPort,6,6,win->Width-6,win->Height-28,BOX_REV_BORDER );
//				NewBorderBox( win->RPort,2,2,win->Width-2,win->Height-2,BOX_REV_BORDER );
a1795 11
				old_mask = rp->Mask;
				SafeSetWriteMask(rp,FONT_MASK);
				SetDrMd(rp,JAM2);
				SetAPen(rp,PAL_LGRAY);
				SetBPen(rp,PAL_LGRAY);
				SetFont(rp,win->WScreen->RastPort.Font);

				win->BorderLeft = win->BorderRight = 10;
				win->BorderTop = 10;
			 	win->BorderBottom = 30;

a1796 3

				SetFont(rp,DarkFont);
				SafeSetWriteMask(rp,old_mask);
@


2.122
log
@Added Hack for putting "backup" button on save project requester
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.121 1995/01/12 14:04:28 CACHELIN4000 Exp pfrench $
* $Log: Project.c,v $
d1811 1
a1811 1
				DoProjectBackup( ProjectName, "flyerscsi.device", 203, win );
@


2.121
log
@Tweak cosmetic button spacing...
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.120 1995/01/12 12:46:54 CACHELIN4000 Exp CACHELIN4000 $
d5 3
d308 1
d1733 1
a1733 1
	GRAZREQ_ALLOWCREATE | GRAZREQ_RESTOREVIEW,
d1756 7
d1781 32
@


2.120
log
@change SWITCHER_MODE define to avoud enf. hit on NULL EditTop
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.119 1995/01/12 12:07:28 CACHELIN4000 Exp CACHELIN4000 $
d5 3
d1024 2
a1025 2
//		if ( ViewMode == 2 )
		if ( SWITCHER_MODE )
d1073 2
a1074 1
			ProgPop->LeftEdge = Save->LeftEdge + Save->Width + XX;
a1075 1
			ViewPop->LeftEdge = ProgPop->LeftEdge + ProgPop->Width;
d1078 1
@


2.119
log
@add PLAY_PART button
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.118 1995/01/06 18:43:44 pfrench Exp CACHELIN4000 $
d5 3
d400 1
a400 1
#define SWITCHER_MODE	( (!EditBottom) && (EditTop->Height != TOP_LARGE) )
@


2.118
log
@Final bug fix for select all gadget
@
text
@d3 5
a7 2
* $Id: project.c,v 2.117 1995/01/06 18:30:23 pfrench Exp pfrench $
* $Log: project.c,v $
d376 1
a376 1
	ID_VCR_PLAY,ID_REQ_STOP,ID_CONTROLS,
d991 1
a991 1
		*All,*Delete,*Duplicate,*Save,*ViewPop,*ProgPop,*NewProj,*Stop;
d1009 1
d1018 2
a1019 1
		if ( ViewMode == 2 )
d1055 1
a1055 1
			Stop->TopEdge = Control->TopEdge =
d1064 2
a1065 1
			Stop->LeftEdge = Play->LeftEdge + Play->Width;
@


2.117
log
@Added (and temporarily removed) code that replaced
select all gadget with same gad with correct imagery
@
text
@d3 6
a8 2
* $Id: Project.c,v 2.116 1994/12/31 07:06:05 pfrench Exp pfrench $
* $Log: Project.c,v $
a1012 1
#ifdef LATER
d1028 1
d1030 1
a1031 1
#endif
@


2.116
log
@Now voiding project length on project edit
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.115 1994/12/29 19:32:36 CACHELIN4000 Exp pfrench $
d5 3
a366 8
static UWORD TopOnlyIDS[] = {
	ID_UP,ID_DOWN,ID_KNOB,ID_GRID,
	ID_VCR_PLAY,ID_REQ_STOP,ID_CONTROLS,
	ID_GHOST_ALL,ID_DELETE,ID_DUPLICATE,ID_SAVE_PROJECT,
	ID_POPUP_PROGRAMS,ID_POPUP_VIEWS,
	ID_END_OF_LIST
};

d1005 23
a1027 2
		if ( !(All = FindGadget(Edit->Gadgets,ID_ALL)) )
			All = FindGadget(Edit->Gadgets,ID_GHOST_ALL);
d1364 1
a1364 4
		if ( ViewMode == 2 )
			IDS = TopOnlyIDS;
		else
			IDS = TopIDS;
@


2.115
log
@Update CurFG when new crouton is dropped onto it ==> fix crashy sequencing bug
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.114 1994/12/20 19:37:42 CACHELIN4000 Exp CACHELIN4000 $
d5 3
d723 2
@


2.114
log
@Remove ID_CLOSE gadget from project IDS array ==> from project editwindow
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.113 1994/12/19 22:38:56 pfrench Exp CACHELIN4000 $
d5 3
d782 1
a782 1
						else if( SKellFG ) /* && SWITCHER_MODE */
d913 1
a913 1
               
d933 1
d946 7
@


2.113
log
@Modified for now shared-code proof.library.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.112 1994/12/07 15:52:27 pfrench Exp pfrench $
d5 3
d359 1
a359 1
	ID_UP,ID_DOWN,ID_CLOSE,ID_KNOB,ID_GRID,
d367 1
a367 1
	ID_UP,ID_DOWN,ID_CLOSE,ID_KNOB,ID_GRID,
@


2.112
log
@Finally got project save request going
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.111 1994/12/05 14:01:31 pfrench Exp pfrench $
d5 3
d281 4
a284 1
#include <object.h>
d305 1
@


2.111
log
@ci Project.c
Added support for moving to project save directory
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.110 1994/11/18 17:13:35 pfrench Exp pfrench $
d5 4
d1686 4
d1691 2
d1713 1
d1719 1
d1721 2
a1722 3
		if (EditBottom->Node.Type == EW_GRAZER)
			DoAllNewDir(EditBottom);
	}
@


2.110
log
@Wasn't correctly displaying a new project after loading
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.109 1994/11/18 13:14:11 pfrench Exp pfrench $
d5 3
d1677 9
d1702 1
d1709 1
a1709 2
		if ( EditBottom->Node.Type == EW_GRAZER )
		{
a1710 1
		}
@


2.109
log
@small typo with last checked in version
@
text
@d3 5
a7 2
* $Id: project.c,v 2.108 1994/11/18 13:11:00 pfrench Exp pfrench $
* $Log: project.c,v $
d1121 2
@


2.108
log
@Now redraws correctly when empty project is loaded
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.107 1994/11/18 12:27:18 pfrench Exp pfrench $
* $Log: Project.c,v $
a1112 1
/*	if (InitProject((struct Project *)E->Special)) */
d1114 5
a1118 8
	{
		SafeFixRowCount(E);
		NewGridLength(E);
		UpdateAccessWindowRows( E->CurrentRows );
		E->RedrawList = TRUE;
		return(TRUE);
	}
	return(FALSE);
@


2.107
log
@Fixed problem with dragging drawers to project not
redrawing in their source grazer.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.106 1994/11/18 12:02:16 CACHELIN4000 Exp pfrench $
d5 4
d1110 3
a1112 1
	if (InitProject((struct Project *)E->Special)) {
@


2.106
log
@Add refresh after Denying folders access to Project Dropping.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.105 1994/11/17 19:13:48 CACHELIN4000 Exp CACHELIN4000 $
d5 3
d691 1
a692 1
		UpdateAccessWindowRows( E->CurrentRows );
d720 1
a720 2
			if ( ( ((struct GrazerNode *)Node)->DOSClass==EN_FILE)
						&& (Node->Status==EN_DRAGGING) )
d761 1
a761 2
				Path = ((struct Grazer *)Source->Special)->Path;
				if ( (Item = DuplicateSmartString(Path)) && AppendToPath(Node->Node.Name,Item) )
d763 2
a764 1
					if( (FG = AllocProj(GetCString(Item))) )
d766 1
a766 2
			DUMPSTR("Adding Crouton ... ");
						if (DestNode)
d768 12
a779 9
							FG->NextGadget = ((struct FastGadget *)DestNode)->NextGadget;
							((struct FastGadget *)DestNode)->NextGadget = FG;
						}
						else
						{	// insert at beginning
							Project = (struct Project *)Dest->Special;
							FG->NextGadget = *(Project->PtrPtr);
							*(Project->PtrPtr) = FG;
						}
d781 5
a785 3
						if( EDITOR_MODE )
						{
							ChangeStatusNode(Dest,(struct EditNode *)FG,EN_SELECTED);
a786 1
			DUMPMSG("  . . . Crouton Added. ");
d788 2
a790 8

				if (Item) FreeSmartString(Item);
			}
			else if ( ( ((struct GrazerNode *)Node)->DOSClass!=EN_FILE)
						&& (Node->Status==EN_DRAGGING) )
			{
				Node->Status = EN_NORMAL;
				Node->Redraw = TRUE;
a792 1

a1110 1
		E->DisplayGrid = TRUE;
@


2.105
log
@Make sure ProjectDropped only accepts grazer nodes with DosClass==EN_FILE..
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.104 1994/11/15 17:52:44 pfrench Exp CACHELIN4000 $
d5 3
d787 7
d920 3
a922 1
	if (AnyDrop)
d924 1
a924 6
		NewLengthUpdate(Dest);

		if (Dest != Source)
		{
			NewLengthUpdate(Source);
		}
d1113 1
d1132 1
a1132 1
		
@


2.104
log
@Added support to highlight delayed error croutons when
the error is posted, and not before.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.103 1994/11/15 13:34:50 pfrench Exp pfrench $
d5 4
d245 1
d714 2
a715 1
			if ( Node->Status == EN_DRAGGING )
d727 1
a727 1
						
@


2.103
log
@Added better error handling to select code.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.102 1994/11/11 11:54:13 pfrench Exp pfrench $
d5 3
a359 3
			LONG			nodenum;
			ULONG			selectmode = CROUTONSELECT_SELECTED;

d375 1
a375 1
				struct FastGadget	*fg = (struct FastGadget *)Node;
d377 2
a378 3
				fg->FGDiff.FGNode.Behavior |= EN_BADCROUTON;
				fg->FGDiff.FGNode.Redraw = TRUE;
				selectmode |= CROUTONSELECT_ERROR;
d383 2
d388 1
a388 1
					nodenum,GRIDSELECT_NORMAL,selectmode);
@


2.102
log
@Got Select All working correctly
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.101 1994/11/09 12:49:38 pfrench Exp pfrench $
d5 3
d269 2
d372 2
a373 5
			if(!SendSwitcherReply(ES_Select,&ESparams1))
			{
				SendSwitcher(ES_Select,&ESparams1);
			}
			else
a1166 2

VOID KPutStr(char *);
@


2.101
log
@Added initial support for croutongrid object
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.100 1994/10/11 16:56:56 CACHELIN4000 Exp pfrench $
d5 3
d1252 15
a1266 1
	ChangeStatusList(Edit,EN_NOT_STATUS,EN_SELECTED);
@


2.100
log
@Add Flage to ES_LoadCrouton fro Project vs. Grazer loading
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.99 94/09/28 16:14:56 pfrench Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d241 3
d349 12
d374 9
d666 1
d674 1
a675 1

a676 1
		E->DisplayGrid = TRUE;
d703 1
a703 1
			if (Node->Status == EN_DRAGGING)
d710 12
a721 1
					ChangeStatusList(Dest,EN_SELECTED,EN_NORMAL);
d723 2
a724 4
					if( EDITOR_MODE )
					{
						SKellFG=NULL;
						SendSwitcher(ES_SelectDefault,NULL);
d726 1
a726 1
					else if( SKellFG ) /* && SWITCHER_MODE */
d728 11
a738 1
						ChangeStatusNode(Dest,(struct EditNode *)SKellFG,EN_SELECTED);
d763 1
d765 1
d772 1
d881 2
a882 1
	if (AnyDrop && DestNode && (DropMode == DROP_OVERWRITE)) {
d884 1
d886 1
d889 1
d891 1
d894 1
d898 2
a899 1
	if (AnyDrop) {
d901 3
a903 1
		if (Dest != Source) {
d1073 3
a1075 6
	if( (FG=*(Project->PtrPtr))==NULL ) return(FALSE);
#ifdef DONT_WANT_THIS
	CurFG=FG;
	FG->FGDiff.FGNode.Status = EN_SELECTED;
	FG->FGDiff.FGNode.Redraw = TRUE;
#else
d1077 1
a1077 1
#endif
d1082 1
d1176 4
d1187 4
d1217 11
d1373 1
a1373 1
		{
d1388 1
a1388 1
		}
d1495 22
d1577 5
a1581 1
	A = FixIconRowCount(Edit->ScrollGrid,GetEditListLen(Edit));
@


2.99
log
@Removed NEW_CLIP from Gadget lists
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.98 1994/09/27 19:59:57 pfrench Exp pfrench $
* $Log: Project.c,v $
d1067 2
a1068 1
				ESparams1.Data1=(LONG)filepathbuf;
d1070 1
a1070 1
					SendSwitcherReply(ES_LoadCrouton,&ESparams1);
@


2.98
log
@Needed to add POP_VIEWS ID
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.97 1994/09/27 16:26:01 pfrench Exp pfrench $
d5 3
d302 1
a302 1
	ID_VCR_PLAY,ID_REQ_STOP,ID_NEW_CLIP,ID_CONTROLS,
d310 1
a310 1
	ID_VCR_PLAY,ID_REQ_STOP,ID_NEW_CLIP,ID_CONTROLS,
@


2.97
log
@Added programs popup to the bottom of the window
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.96 1994/09/20 22:51:22 pfrench Exp pfrench $
d5 3
d301 1
a301 1
	ID_POPUP_PROGRAMS,ID_POPUP_DISP,
d309 1
a309 1
	ID_POPUP_PROGRAMS,ID_POPUP_DISP,
d893 1
a893 1
		ViewPop = FindGadget(Edit->Gadgets,ID_POPUP_DISP);
@


2.96
log
@Modified to work with dircache (Editwindow has ptr to list now)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.95 1994/09/12 18:41:43 pfrench Exp pfrench $
d5 3
d297 2
a298 1
	ID_GHOST_ALL,ID_DELETE,ID_DUPLICATE,ID_SAVE_PROJECT,ID_POPUP_DISP,
d305 2
a306 1
	ID_ALL,ID_DELETE,ID_DUPLICATE,ID_SAVE_PROJECT,ID_POPUP_DISP,
d861 2
a862 2
	struct Gadget *Close,*Grid,*Play,*Control,
		*All,*Delete,*Duplicate,*Save,*Pop,*NewProj,*Stop;
d878 1
a878 2
		Close = FindGadget(Edit->Gadgets,ID_CLOSE);
//		Play = FindGadget(Edit->Gadgets,ID_PLAY);
a880 1
//		Clip = FindGadget(Edit->Gadgets,ID_NEW_CLIP);
d889 2
a890 1
		Pop = FindGadget(Edit->Gadgets,ID_POPUP_DISP);
d905 1
a905 1
			Save->TopEdge = Pop->TopEdge = Play->TopEdge;
d914 5
a918 1
			Pop->LeftEdge = Save->LeftEdge + Save->Width + XX;
a919 10
/*
			Play->LeftEdge = GRID_LEFT;
			Clip->LeftEdge = Play->LeftEdge + Play->Width + XX;
			Control->LeftEdge = Clip->LeftEdge + Clip->Width + XX;
			All->LeftEdge = Control->LeftEdge + Control->Width + XX;
			Delete->LeftEdge = All->LeftEdge + All->Width + X_GAP1;
			Duplicate->LeftEdge = Delete->LeftEdge + Delete->Width + X_GAP1;
			Save->LeftEdge = Duplicate->LeftEdge + Duplicate->Width + XX;
			Pop->LeftEdge = Save->LeftEdge + Save->Width + XX;
*/
a1547 5
			if ( EditBottom->Special->dircache )
			{
				FreeDirCache(EditBottom->Special->dircache);
				EditBottom->Special->dircache = NULL;
			}
@


2.95
log
@get order of fast gadet now return (0...n-1)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.94 1994/09/09 16:42:39 pfrench Exp pfrench $
d5 3
d659 1
a659 1
		Node = (struct EditNode *)Source->Special->EditList.lh_TailPred;
d1291 1
a1291 1
		struct EditNode *Node = (struct EditNode *)Edit->Special->EditList.lh_Head;
d1420 1
a1420 1
		Node = (struct EditNode *)Edit->Special->EditList.lh_TailPred;
d1443 1
a1443 1
		return((UWORD)ListLength(&Edit->Special->EditList));
d1546 10
@


2.94
log
@Tied in an accesswindow rowcount hack. Also tried to fix
a select problem with some croutons.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.93 1994/09/08 15:45:56 pfrench Exp pfrench $
d5 4
d1389 1
a1389 1
	LONG						 retval = 0,order = 0;
a1395 2
		++order;

d1403 1
@


2.93
log
@Added new function to assist accesswindow updating
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.92 1994/08/30 22:41:17 pfrench Exp pfrench $
d5 3
d232 1
d323 1
a326 1
				SKellFG=(struct FastGadget *)Node;
d624 3
d1022 1
@


2.92
log
@Removed un-used code.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.91 1994/08/30 21:39:13 pfrench Exp pfrench $
d5 3
d577 1
a577 1
				while((*(S-1)!=':') && (*(S-1)!='/') && (S>((struct ExtFastGadget *)FG)->FileName) )
d1372 24
@


2.91
log
@Modified text of project save requester
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.90 1994/08/30 17:39:32 pfrench Exp pfrench $
d5 3
a1484 16
#ifdef OLDWAY
	char *Ms[1]={"Save Project As "};

	if(*ProjectName==0) strcpy(ProjectName,"RAM:WorkProject");
	if (SimpleRequest(Edit->Window,Ms,1,REQ_STRING|REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,ProjectName))
#ifndef SWIT_ONLY
	 if (SwitPort)
#endif
	{
		if(*ProjectName==0) strcpy(ProjectName,"RAM:WorkProject");
		ESparams2.Data1=0;
		ESparams2.Data2=(LONG)ProjectName;
		SendSwitcher(ES_SaveProject,&ESparams2);  // proj. #, file name
		DoAllNewDir(Edit);
	}
#else
a1486 2
#endif

@


2.90
log
@Fixed multiple-select-drag from grazer to project to
leave all dragged croutons highlighted
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.89 1994/08/30 17:04:21 pfrench Exp pfrench $
d5 4
d1457 2
a1458 3
	"Locate the source project below using the file requester.",
	"Select \"Continue\" to display its contents.",
	"To edit from project to project, drag croutons to the upper project.",
d1460 1
a1460 1
#define PROJ_SAVE_REQTEXT_NUMLINES	4
@


2.89
log
@Duplicate in Switcher mode doesn't highlight selected
crouton.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.88 1994/08/30 10:48:00 Kell Exp pfrench $
d5 4
d642 16
a657 5
				AnyDrop = TRUE;
				ChangeStatusList(Dest,EN_SELECTED,EN_NORMAL);
				if(EDITOR_MODE) {
					SKellFG=NULL;
					SendSwitcher(ES_SelectDefault,NULL);
d659 1
a659 1
				else if(SKellFG) ChangeStatusNode(Dest,(struct EditNode *)SKellFG,EN_SELECTED);
d662 1
d670 3
a672 2
						} else
						{ // insert at beginning
d677 3
a679 1
						if(EDITOR_MODE) ChangeStatusNode(Dest,(struct EditNode *)FG,EN_SELECTED);
d682 2
@


2.88
log
@Changed SendSwitcherReply calls to work with new ESParams structures.
@
text
@d3 5
a7 2
* $Id: project.c,v 2.87 1994/08/29 20:32:50 pfrench Exp Kell $
* $Log: project.c,v $
d383 5
a387 2
				dupe_fg->FGDiff.FGNode.Status = EN_SELECTED;
				dupe_fg->FGDiff.FGNode.Redraw = TRUE;
@


2.87
log
@Fixed couple more bugs
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.86 1994/08/29 18:39:49 pfrench Exp pfrench $
* $Log: Project.c,v $
d235 13
d301 3
a303 1
			if(!SendSwitcherReply(ES_Select,(LONG)Node,NULL,NULL))
d306 1
a306 1
				SendSwitcher(ES_Select,(long)Node,NULL,NULL);
d321 4
a324 2
			if ( Node != (struct EditNode *) SKellFG )
				SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
d396 4
a399 2
		if( EDITOR_MODE )
			SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
d422 2
d426 1
a426 1
			SendSwitcherReply(ES_Auto,(LONG)Node,NULL,NULL);
d428 1
a428 1
		else if(!SendSwitcherReply(ES_Select,(LONG)Node,NULL,NULL))
d430 1
a430 1
			SendSwitcher(ES_Auto,(LONG)Node,NULL,NULL);
d479 2
a480 1
		SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
d634 4
a637 1
				if(EDITOR_MODE) SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
d903 2
a904 1
	SendSwitcher(ES_FreeCrouton,(LONG)FG,NULL,NULL);
d1008 1
d1010 1
a1010 1
					SendSwitcherReply(ES_LoadCrouton,(LONG)filepathbuf,NULL,NULL);
d1036 1
d1038 1
a1038 1
			SendSwitcherReply(ES_DuplicateCrouton,(LONG)FG,NULL,NULL);
d1112 2
a1113 1
	SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
d1462 3
a1464 1
		SendSwitcher(ES_SaveProject,0,(LONG)ProjectName,NULL);  // proj. #, file name
d1481 3
a1483 1
		if ( !SendSwitcherReply(ES_SaveProject,0,(LONG)GetCString(gr->gr_FilePath),NULL) )
@


2.86
log
@Redraws correctly on crouton select.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.85 1994/08/29 18:00:54 CACHELIN4000 Exp pfrench $
d5 3
d372 1
a375 2
		CurFG = NULL;

d538 1
a538 1
				X1 += 6 + ((Edit->ImageWidth - 6) - LastExtent.te_Width)>>1;
@


2.85
log
@Move Text label for default crouton bmaps over by 2 pixels
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.84 94/08/29 17:22:42 pfrench Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d294 3
a296 1
			// SendSwitcher(ES_RENDER_SWIT,TRUE,0,0);
d358 1
@


2.84
log
@Whooops.
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.83 1994/08/29 17:20:39 pfrench Exp pfrench $
* $Log: Project.c,v $
d530 1
a530 1
				X1 += 4 + ((Edit->ImageWidth - 6) - LastExtent.te_Width)>>1;
@


2.83
log
@Removed annoying code that selected first gad in
project every time.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.82 1994/08/27 17:53:54 CACHELIN4000 Exp pfrench $
d5 4
d917 1
a918 1
	if( (FG=*(Project->PtrPtr))==NULL ) return(FALSE);
@


2.82
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.81 94/08/27 16:18:55 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d913 1
d918 3
@


2.81
log
@add Stop, Play buttons, remove NewClip from ArrangeProjectGadgets()
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.80 94/08/26 15:01:46 pfrench Exp Locker: CACHELIN4000 $
d5 3
d462 1
a462 1
	UWORD X1,Y1,Y2;
d465 1
a465 1

d508 16
a523 1
//			DUMPMSG("after Project copycunt");
@


2.80
log
@Added bad crouton support.
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.79 1994/08/25 17:03:11 pfrench Exp pfrench $
* $Log: Project.c,v $
d230 1
a230 1
	ID_PLAY,ID_NEW_CLIP,ID_CONTROLS,
d237 1
a237 1
	ID_PLAY,ID_NEW_CLIP,ID_CONTROLS,
d741 2
a742 2
	struct Gadget *Close,*Grid,*Play,*Clip,*Control,
		*All,*Delete,*Duplicate,*Save,*Pop,*NewProj;
d759 4
a762 2
		Play = FindGadget(Edit->Gadgets,ID_PLAY);
		Clip = FindGadget(Edit->Gadgets,ID_NEW_CLIP);
d784 1
a784 1
			Clip->TopEdge = Control->TopEdge =
d788 10
d806 1
@


2.79
log
@Added full volume name support for files loaded into project
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.78 1994/08/25 14:45:31 pfrench Exp pfrench $
d5 3
d268 7
d385 7
@


2.78
log
@Dragging croutons in switcher mode leaves them un-highlighted.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.77 1994/08/25 14:36:26 pfrench Exp pfrench $
d5 3
d210 2
d885 1
a885 1
	struct FastGadget *New;
d887 3
a889 2
	if (!SwitPort) {
		if (New = SafeAllocMem(sizeof(struct FastGadget),MEMF_CLEAR)) {
d891 18
a909 6
	} else {
		DUMPSTR("Before AllocProj() sends ES_LoadCrouton with ");
		DUMPMSG(FileName);
	   New = (struct FastGadget *)
        SendSwitcherReply(ES_LoadCrouton,(LONG)FileName,NULL,NULL);
		DUMPSTR("  After AllocProj() sent ES_LoadCrouton");
@


2.77
log
@Duplicate now correctly sets CurFG to NULL
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.76 1994/08/24 17:41:28 pfrench Exp pfrench $
d5 3
a285 34
#ifdef OLDWAY
	struct FastGadget *FG,*Next,*New,*OnlyFG;
	int Any = 0;

	FG = *(((struct Project *)Edit->Special)->PtrPtr);
	while (FG)
	{
		Next = FG->NextGadget;
		if (FG->FGDiff.FGNode.Status == EN_SELECTED)
		{
			Any++;
			if (New = DupeProjNode(FG))
			{
				OnlyFG=FG;
				InsertProjNode(Edit,FG,New);
				if(SWITCHER_MODE)
				{
					New->FGDiff.FGNode.Status = EN_NORMAL;
					FG->FGDiff.FGNode.Status = EN_NORMAL;
				}
				else
				{
					New->FGDiff.FGNode.Status = EN_SELECTED;
					FG->FGDiff.FGNode.Status = EN_NORMAL;
				}
			}
		}
		FG = Next;
	}
	if(Any==1) OnlyFG->FGDiff.FGNode.Status = EN_SELECTED;
	if (Any) NewLengthUpdate(Edit);
	if(EDITOR_MODE) SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
	return(FALSE);
#else
a341 1
#endif
d628 2
a629 1
							FG->FGDiff.FGNode.Status = EN_SELECTED;
d648 2
a649 1
								New->FGDiff.FGNode.Status = EN_SELECTED;
@


2.76
log
@Now correctly handles double-clicking on Current FG.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.75 1994/08/22 20:03:32 pfrench Exp pfrench $
d5 3
d365 2
@


2.75
log
@Got project/duplicate working a little closer to
acutal reality.  Now "duplicate" copies all selected
croutons and inserts them contiguously after the
last selected crouton.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.74 1994/08/22 14:09:10 pfrench Exp pfrench $
d5 6
d258 2
a259 1
			SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
d422 2
a423 1
	while (FG) {
d425 2
a426 1
		if (FG->FGDiff.FGNode.Status == EN_SELECTED) {
@


2.74
log
@Couple more fixes.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.73 1994/08/22 12:57:21 pfrench Exp pfrench $
d5 3
d273 1
d288 1
a288 1
				if(EDITOR_MODE)
d290 1
a290 1
					New->FGDiff.FGNode.Status = EN_SELECTED;
d295 1
a295 1
					New->FGDiff.FGNode.Status = EN_NORMAL;
d306 56
d594 5
d605 8
a612 4
#ifdef OLDWAY
// start of end of list so multiple selected stuff inserts correctly
		FG = (struct FastGadget *)GetLastEditNode(Source);
		while (FG)
d614 1
a614 1
			if (FG->FGDiff.FGNode.Status == EN_DRAGGING)
d620 1
a620 1
				switch(DropMode)
d631 15
a646 2
							RemoveProjNode(Source,FG);
							InsertProjNode(Dest,(struct FastGadget *)DestNode,FG);
d651 1
a653 47
								InsertProjNode(Dest,(struct FastGadget *)DestNode,New);
								New->FGDiff.FGNode.Status = EN_SELECTED;
							}
						}
					}
				}
			}
			FG = (struct FastGadget *)
				GetPrevEditNode(Source,(struct EditNode *)FG);
		}
#else
		{
			struct FastGadget	*prev_fg;

			// Temporary FG list
			struct FastGadget	*first_fg = NULL,*tail_fg;

			// Since "next" pointer is first LONG of the FastGadget,
			// we just substitute the Address of the source FG list head
			prev_fg = (struct FastGadget *)((struct Project *)Source->Special)->PtrPtr;

			// Move all of the selected source gadgets into their
			// own little FastGadget list.

			while ( FG = (struct FastGadget *)GetNextEditNode(Source,(struct EditNode *)prev_fg) )
			{
				if ( FG->FGDiff.FGNode.Status == EN_DRAGGING )
				{
					FG->FGDiff.FGNode.Status = EN_NORMAL;
					FG->FGDiff.FGNode.Redraw = TRUE;
					AnyDrop = TRUE;

					switch( DropMode )
					{
					case DROP_OVERWRITE:
					case DROP_INSERT:
						Dest->RedrawList = TRUE;
						Dest->DisplayGrid = TRUE;

						if ( Dest->Location == EW_TOP )
						{
							if (Source == Dest)
							{	// Movement within project

								// Remove the gad from the list
								prev_fg->NextGadget = FG->NextGadget;

d656 1
a656 1
									first_fg = FG;
d661 2
a662 2
									tail_fg->NextGadget = FG;
									tail_fg = FG;
d665 1
a665 21
								FG->FGDiff.FGNode.Status = EN_SELECTED;
							}
							else
							{	// From bottom (read only) project to work proj
								struct FastGadget	*New;

								if (New = DupeProjNode(FG))
								{
									if (!first_fg)
									{
										first_fg = New;
										tail_fg = first_fg;
									}
									else
									{
										tail_fg->NextGadget = New;
										tail_fg = New;
									}

									New->FGDiff.FGNode.Status = EN_SELECTED;
								}
a669 4
				else
				{
					prev_fg = (struct FastGadget *)GetNextEditNode(Source,(struct EditNode *)prev_fg);
				}
d671 1
a671 3
                
			// Now Insert them into the list
			if ( first_fg )
d673 8
a680 4
				if ( !DestNode )
				{
					DestNode = (struct EditNode *)((struct Project *)Dest->Special)->PtrPtr;
				}
d682 3
a684 3
				// Insert these node into the list
				tail_fg->NextGadget = ((struct FastGadget *)DestNode)->NextGadget;
				((struct FastGadget *)DestNode)->NextGadget = first_fg;
d686 4
a690 1
#endif
@


2.73
log
@Fixed long-standing project editing bug with dragging
multiple croutons messing up the FastGadget list.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.72 1994/08/16 17:12:29 pfrench Exp pfrench $
d5 4
d590 4
a593 1
			prev_fg = (struct FastGadget *)&((struct Project *)Source->Special)->PtrPtr;
d665 1
a665 1
					DestNode = (struct EditNode *)&((struct Project *)Dest->Special)->PtrPtr;
d1216 4
a1219 2
	struct EditNode *Node;
	struct FastGadget *FG;
a1220 1
	if (Edit->Node.Type == EW_GRAZER) {
d1224 6
a1229 1
	} else {
d1235 1
@


2.72
log
@Now disables "select all" button in switcher mode
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.71 1994/08/06 11:48:29 pfrench Exp pfrench $
d5 3
d536 1
d551 3
d558 1
d568 1
a568 1
								New->FGDiff.FGNode.Status = EN_NORMAL;
d572 25
a596 1
					else
d598 47
a644 2
					Dest->RedrawList = TRUE;
					Dest->DisplayGrid = TRUE;
d647 17
a664 2
			FG = (struct FastGadget *)
				GetPrevEditNode(Source,(struct EditNode *)FG);
d666 1
@


2.71
log
@Fixed problem with double/single click.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.70 1994/08/01 15:55:01 pfrench Exp pfrench $
d5 3
d165 1
d195 7
d636 4
a639 1
		All = FindGadget(Edit->Gadgets,ID_ALL);
d915 7
a921 1
	if (NewProject->NewEdit.Location == EW_TOP) IDS = TopIDS;
@


2.70
log
@Removed calls to req file type as those files are being
filtered out of the grazer again.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.69 1994/07/31 14:41:28 pfrench Exp pfrench $
d5 4
d211 1
a211 1
struct FastGadget *NoSwitPtr = NULL,*XtraProj=NULL,*SKellFG;
d213 1
a213 1
#define SWITCHER_MODE	((!EditBottom)||(EditBottom->Node.Type==EW_EMPTY))
d220 1
a220 3
		DUMPMSG("Before ProjectSelect() sends ES_Select[Default]");
		if( EDITOR_MODE ) SendSwitcher(ES_SelectDefault,(LONG)(SKellFG=NULL),NULL,NULL);
		else
d222 1
a222 1
			if(SendSwitcherReply(ES_Select,(LONG)Node,NULL,NULL))
d228 4
a231 1
			DUMPMSG("  After ProjectSelect() sent ES_Select");
a305 1
			return(FALSE);
d307 1
a307 1
		if(SendSwitcherReply(ES_Select,(LONG)Node,NULL,NULL))
@


2.69
log
@Now uses grazer for for saving project.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.68 1994/07/27 16:47:22 pfrench Exp pfrench $
d5 3
a155 1
extern LONG IsRequestedFileType( struct EditNode *Node );
d995 2
a996 5
			if ( IsRequestedFileType(Node) )
			{
				if ( !(--A) )
					break;
			}
d1001 4
a1004 2
		if (Node->Node.MinNode.mln_Succ)	return(Node);
		else															return(NULL);
d1032 1
a1032 4
		while ( Node->Node.MinNode.mln_Succ && !IsRequestedFileType(Node) )
		  {
			Node = (struct EditNode *)Node->Node.MinNode.mln_Succ;
		  }
@


2.68
log
@Added "New Project" button to bottom project.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.67 1994/07/21 18:56:20 pfrench Exp $
d5 3
d1169 27
d1199 1
a1207 2
		DUMPHEXIL("ProjectName @@ ",(LONG)ProjectName," ...");
		DUMPHEXIB("*ProjectName = ",*ProjectName,"\\");
a1208 3

		DUMPSTR("Before HandleSaveProject() sends ES_SaveProject with ");
		DUMPMSG(ProjectName);
a1209 1
		DUMPMSG("  After HandleSaveProject() sent ES_SaveProject");
d1212 4
d1220 28
@


2.67
log
@Fancy support for filtering requested file types.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.66 1994/07/15 18:25:23 pfrench Exp pfrench $
d5 3
d151 1
d191 1
d596 1
a596 1
		*All,*Delete,*Duplicate,*Save,*Pop;
d607 1
a607 1
	else Grid->Height = 180;
d624 2
d628 4
a631 2
	if (ArrangeEditGadgets(Edit)) {
		if (Edit->Location == EW_TOP) {
d645 5
@


2.66
log
@No longer hacks loading the hardcoded project name
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.65 1994/07/12 14:50:44 pfrench Exp pfrench $
d5 3
d147 2
d971 17
a987 1
		return((struct EditNode *)GetNode(&Edit->Special->EditList,A));
a1009 2
	struct EditNode *Next;

d1011 11
a1021 4
	if (Edit->Node.Type == EW_GRAZER) {
		Next = (struct EditNode *)Node->Node.MinNode.mln_Succ;
		if (Next->Node.MinNode.mln_Succ) return(Next);
		else return(NULL);
@


2.65
log
@Bottom project height was getting initialized too tall
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.64 94/07/11 13:57:22 pfrench Exp Locker: pfrench $
* $Log:	Project.c,v $
d789 8
a796 4
	if (PtrProject && Edit!=EditBottom) {
		((struct Project *)Edit->Special)->PtrPtr = PtrProject;
		InitProject((struct Project *)Edit->Special);
		Success = TRUE;
d798 1
a798 1
	else
a799 3
		if ( !SendSwitcherReply(ES_LoadProject,1,(LONG)"dh2:WorkProject",NULL) )
		{
		XtrProject = &PtrProject[1];
a802 1
		}
@


2.64
log
@More preliminary project/project support
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.63 94/07/07 17:02:29 CACHELIN4000 Exp Locker: pfrench $
d5 3
d492 1
a492 3
	} else if (	(Source->Node.Type == EW_PROJECT) &&
							(Dest->Location == EW_TOP) )

d514 16
a529 4
					if (Source == Dest)
					{	// Movement within project
						RemoveProjNode(Source,FG);
						InsertProjNode(Dest,(struct FastGadget *)DestNode,FG);
d532 3
a534 7
					{	// From bottom (read only) project to work proj
						struct FastGadget	*New;
						if (New = DupeProjNode(FG))
						{
							InsertProjNode(Dest,(struct FastGadget *)DestNode,New);
							New->FGDiff.FGNode.Status = EN_NORMAL;
						}
d588 7
a594 2
	if (Edit->Height == TOP_SMALL) Grid->Height = 200;
	else Grid->Height = 400;
d597 2
a598 1
	if (Edit->Location == EW_TOP) {
d608 3
@


2.63
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.62 94/07/07 11:29:00 pfrench Exp Locker: CACHELIN4000 $
d5 3
d451 2
a452 1
	if (Source->Node.Type == EW_GRAZER) {
d455 2
a456 1
		while (Next=(struct EditNode *)Node->Node.MinNode.mln_Pred) {
d467 1
a467 1
					if( (FG = AllocProj(GetCString(Item)) )  )
d474 2
a475 1
						} else { // insert at beginning
d489 4
a492 1
	} else if (Source->Node.Type == EW_PROJECT) {
d501 4
a504 2
		while (FG) {
			if (FG->FGDiff.FGNode.Status == EN_DRAGGING) {
d509 18
a526 6
			switch(DropMode) {
			case DROP_OVERWRITE:
			case DROP_INSERT:
				if (Source == Dest) {
					RemoveProjNode(Source,FG);
					InsertProjNode(Dest,(struct FastGadget *)DestNode,FG);
a528 1
			}
d541 1
a541 1
			*((struct Project *)Dest->Special)->PtrPtr = 
d616 1
a616 1
*   NAME   
d641 1
a641 1
#endif	
d773 3
a775 16
// should never happen
	else {
#ifndef OLDWAY
		struct FastGadget *New;
		DUMPMSG("GetLoadedProject() Loading into bottom");
 		if (New = SafeAllocMem(sizeof(struct FastGadget),MEMF_CLEAR))
      {
			  New->Flags2 = CR_VidEvent;
        NoSwitPtr=(struct FastGadget *)&New;
        ProjFGInit(New);
    		((struct Project *)Edit->Special)->PtrPtr = &NoSwitPtr;
		    Success = TRUE;
      }
#else
		DUMPSTR("Loading Project ... ");
		if ( !SendSwitcherReply(ES_LoadProject,1,(LONG)"Dev:WorkProject",NULL) )
a776 1
		DUMPSTR("got it");
d779 1
a781 2
	else DUMPSTR("err");
#endif
d993 1
a993 1
			if (FG->NextGadget == (struct FastGadget *)Node) 
@


2.62
log
@Whoops, bug fix.
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.61 94/07/07 11:25:34 pfrench Exp Locker: pfrench $
d5 3
d132 1
a132 1
#define SERDEBUG	1
a695 1
#ifndef SWIT_ONLY
a700 1
#endif
a705 1
#ifndef SWIT_ONLY
a706 1
#endif
@


2.61
log
@Added micro-hack to load a default project
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.60 94/07/04 18:40:38 CACHELIN4000 Exp Locker: pfrench $
d5 3
d755 1
a756 1
		struct FastGadget *New;
@


2.60
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.59 94/06/07 15:17:56 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d126 1
a126 1
// #define SERDEBUG	1
a742 1
	struct FastGadget *New;
d751 1
d753 1
d762 11
@


2.59
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.58 94/05/25 20:45:34 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d123 1
a123 1
#define SERDEBUG	1
@


2.58
log
@let NO FG be selected again
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.54 94/05/25 15:46:42 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 2
a6 2
*Revision 2.54  94/05/25  15:46:42  CACHELIN4000
**** empty log message ***
d149 3
d181 1
a181 5
		if( EDITOR_MODE )    // should check node->status instead
		{
			SendSwitcher(ES_SelectDefault,NULL,NULL,NULL);
			SKellFG=NULL;
		}
d211 2
a212 2
	struct FastGadget *FG,*Next,*New;
	BOOL Any = FALSE;
d218 3
a220 2
		if (FG->FGDiff.FGNode.Status == EN_SELECTED) {
			Any = TRUE;
d222 2
d225 11
d239 1
d241 1
a261 1
		DUMPMSG("Before ProjectDouble() sends ES_Select");
a268 1
			DUMPMSG("Before ProjectDouble() sends ES_Auto");
a269 1
			DUMPMSG("  After ProjectDouble() sent ES_Auto");
a272 1
		DUMPMSG("  After ProjectDouble() sent ES_Select");
d296 1
a300 1
			if(CurFG==FG) CurFG=NULL;
d306 7
a312 2
	if (Any) NewLengthUpdate(Edit);
	SendSwitcher(ES_SelectDefault,NULL,NULL,NULL); // could be within if(Any)
d445 3
d462 1
d799 1
a799 1
	SendSwitcher(ES_SelectDefault,NULL,NULL,NULL);
@


2.57
log
@*** empty log message ***
@
text
@d188 1
a188 1
				SendSwitcher(ES_Select,Node,NULL,NULL);
d190 1
a190 1
			SendSwitcher(ES_RENDER_SWIT,TRUE,0,0);
@


2.56
log
@*** empty log message ***
@
text
@d256 1
a256 1
			SendSwitcherReply(ES_Auto,(LONG)Node,NULL,NULL);
@


2.55
log
@*** empty log message ***
@
text
@d186 1
d188 2
@


2.54
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.53 94/05/12 08:31:57 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d168 1
a168 1
struct FastGadget *NoSwitPtr = NULL,*XtraProj=NULL;
d181 1
d185 2
a186 1
			SendSwitcher(ES_Select,(LONG)Node,NULL,NULL);
d244 2
a245 1
		if(CurFG==(struct FastGadget *)Node)
a249 1
		DUMPMSG("Before ProjectDouble() sends ES_Select");
d256 1
@


2.53
log
@add EDITORMODE logic, ES_DefaultSelect
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.52 94/04/22 14:45:53 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d175 2
a176 1
		if( EDITOR_MODE && (Node!= (struct EditNode *) CurFG) )    // should check node->status instead
d178 1
@


2.52
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.51 94/04/22 14:29:57 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d164 3
d170 5
a174 1
//		if(!EditBottom || (EditBottom->Node.Type==EW_EMPTY) )
a175 1
			DUMPMSG("Before ProjectSelect() sends ES_Select");
d177 1
a177 2
//			if(!EditBottom || (EditBottom->Node.Type==EW_EMPTY) )
//				SendSwitcher(ES_RENDER_SWIT,TRUE,0,0);
d180 1
d203 2
a204 1
	while (FG) {
d234 14
a247 3
		DUMPMSG("Before ProjectDouble() sends ES_Auto");
		SendSwitcherReply(ES_Auto,(LONG)Node,NULL,NULL);
		DUMPMSG("  After ProjectDouble() sent ES_Auto");
d282 1
d765 1
@


2.51
log
@Stop filtering FGC_SELECTs
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.50 94/04/20 17:32:59 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d168 2
a169 1
			SendSwitcher(ES_RENDER_SWIT,TRUE,0,0);
@


2.50
log
@Move Panel stuff to Panel.c
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.48 94/03/29 19:00:03 Kell Exp Locker: CACHELIN4000 $
d5 3
a126 8
// extern struct Gadget StringGadg;
// extern struct Gadget BoolGadg;
// extern struct StringInfo StrInf;
// extern struct BoolInfo BoolInf;
// extern char strbuf[],strubuf[];
// extern struct StringExtend StrExt;
// extern struct st_PopupRender PopUp;

a129 1

a136 5
//#define STRING_ID 1002	// Magic Number
//#define TEXT_BASELINE 9
//#define TEXT_X_SPACE 4
//#define TEXT_Y_SPACE 2

d161 1
a161 1
		if(!EditBottom || (EditBottom->Node.Type==EW_EMPTY) )
d250 1
d444 1
a444 1
			((struct FastGadget *)Node)->NextGadget = 
d446 1
a446 1
		else 
d596 1
a596 1
	FG = *(Project->PtrPtr);
@


2.49
log
@Panelling work...
@
text
@d124 1
a124 1
extern struct Gadget StringGadg;
d126 5
a130 5
extern struct StringInfo StrInf;
extern struct BoolInfo BoolInf;
extern char strbuf[],strubuf[];
extern struct StringExtend StrExt;
extern struct st_PopupRender PopUp;
a131 1
// struct BitMap *CurFGbm;
a133 3
struct PanelLine *CurPLine;
LONG	InOrOut=0,ft;
char Size[20],Name[120],Dir[120];
d143 4
a146 4
#define STRING_ID 1002	// Magic Number
#define TEXT_BASELINE 9
#define TEXT_X_SPACE 4
#define TEXT_Y_SPACE 2
d474 1
a474 1
*   NAME   
d866 1
a866 1
	if (Edit->Node.Type == EW_GRAZER) 
d974 1
a974 1
	else	
a1026 368
extern struct TagItem nw_ti[2];
struct ExtNewWindow ClipNW = {
	0,0,	/* window XY origin relative to TopLeft of screen */
	324,200,	/* window width and height */
	1,0,	/* detail and block pens */
	MOUSEBUTTONS+MOUSEMOVE+IDCMP_GADGETUP+IDCMP_GADGETDOWN+IDCMP_RAWKEY,	/* IDCMP flags */
	SIMPLE_REFRESH+BORDERLESS+ACTIVATE+RMBTRAP+NOCAREREFRESH+WFLG_NW_EXTENDED,	/* other window flags */
	NULL,	/* first gadget in gadget list */
	NULL,	/* custom CHECKMARK imagery */
	NULL,	/* window title */
	NULL,	/* custom screen pointer */
	NULL,	/* custom bitmap */
	5,5,	/* minimum width and height */
	656,400,	/* maximum width and height */
	CUSTOMSCREEN,	/* destination screen type */
	&nw_ti[0]
};
#define RAW_ENTER		0x43
#define RAW_RETURN	0x44
#define RAW_ESCAPE	0x45
#define RAW_HELP 		0x5f
#define RAW_IN 			0x5A // num-pad '('
#define RAW_OUT 		0x5B // num-pad ')'
#define RAW_DEL 		0x5D // num-pad '*'
#define RAW_LEN 		0x5C // num-pad '/'
#define RAW_UP 			0x4C
#define RAW_DOWN 		0x4D
#define RAW_RIGHT		0x4E
#define RAW_LEFT		0x4F

#define STRING_ID 1002
#define LINE_HEIGHT (TEXT_HEIGHT+4)
#define LSP 12
#define TEXT_BASE 9
#define NUM_VIEW 5

char Aud1[] = "Left & Right",Aud2[] = "None",
	Aud3[] = "Left only",Aud4[] = "Right only",Aud5[] = "Audio only";
char *AudNames[] = { Aud1,Aud2,Aud3,Aud4,Aud5 };
char RecMsg[] = "Record Clip";
WORD AudMode = 0;

// AAR -- frzl
char *NameFcnZ(void *frzl, int Entries)
{
	if (Entries < 0) Entries = 0;
	else if (Entries > (NUM_VIEW-1)) Entries = NUM_VIEW-1;
	return(AudNames[Entries]);
}

//*******************************************************************
VOID RedrawPopupTextZ(struct Window *Window)
{
	char *C;
	struct Gadget *Gadget;

	if (Gadget = FindGadget(Window->FirstGadget,ID_POPUP_DISP)) {
		C = NameFcnZ(NULL,AudMode);
		SetFont(Window->RPort,EditFont);
		AnyPopupText(Gadget,C,Window,20);
	}
}

//*******************************************************************
VOID AudioChoice(struct Window *Window,struct IntuiMessage *IntuiMsg)
{
	PopUpID ID;
	struct Gadget *Gadget;
	WORD A,X,Y;

	PUCDefaultRender(&PopUp);
	PopUp.drawBG = (DrawBGFunc *)DrawBG;
	Gadget = FindGadget(Window->FirstGadget,ID_POPUP_DISP);
	X = Gadget->LeftEdge + (Gadget->Width >> 1);
	Y = Gadget->TopEdge + (Gadget->Height >> 1);
	ID = PUCCreate((NameFunc *)NameFcnZ,NULL,&PopUp);
	PUCSetNumItems(ID,NUM_VIEW);
	PUCSetCurItem(ID,AudMode);

	Window->Flags |= WFLG_REPORTMOUSE;
	A = PUCActivate(ID,Window,X,Y,IntuiMsg->MouseX,IntuiMsg->MouseY);
	Window->Flags &= ~WFLG_REPORTMOUSE;
	PUCDestroy(ID);

	if (A >= 0) {
		if (A != AudMode) {
			AudMode = A;
		}
		RedrawPopupTextZ(Window);
	}
}

ULONG	DHD_Init(ULONG ,ULONG);
ULONG	DHD_Record(ULONG ,ULONG, ULONG, ULONG);
void	DHD_Abort(ULONG);
ULONG	DHD_Play(ULONG,ULONG,ULONG,ULONG);
void	DHD_Jump(ULONG,ULONG,ULONG);
void	Main2Blank();

// Return MaxBlocks
ULONG	DHD_InitRecord(ULONG Unit,ULONG Flags)
{
	DUMPUDECL("DHD_Init( ",Unit,",");
	DUMPHEXIL(" ",Flags," ); \\ ");
	SendSwitcher(ES_InitRecord,0,0,0);
	DUMPMSG("InitRecord() Done");
	return((ULONG)1);
}

// Return MaxBlocks
ULONG	DHD_InitPlay(ULONG Unit,ULONG Flags)
{
	DUMPUDECL("DHD_Init( ",Unit,",");
	DUMPHEXIL(" ",Flags," ); \\ ");
	SendSwitcher(ES_InitPlay,0,0,0);
	DUMPMSG("InitPlay() Done");
	return((ULONG)1);
}

void	DHD_Abort(ULONG Unit)
{
	DUMPUDECL("DHD_Abort( ",Unit,"); \\ ");
	SendSwitcher(ES_AbortRecord,0,0,0);
	return;
}

void	Main2Blank()
{
	DUMPMSG("Main2Blank");
	SendSwitcher(ES_Main2Blank,0,0,0);
	return;
}

ULONG	DHD_Record(ULONG Unit, ULONG Start, ULONG Stop, ULONG Flags)
{
	DUMPUDECL("DHD_Record( ",Unit,",");
	DUMPUDECL(" ",Start ,",");
	DUMPUDECL(" ",Stop,",");
	DUMPHEXIL(" ",Flags ," ); \\ ");
	return((ULONG)SendSwitcherReply(ES_Record,Start,Stop,0));
}

// Should return new position, or dist. from start.  This will be called
// on RMB Down, and it should watch for RMB up to stop
// use unit to specify whether in/out point
ULONG	DHD_Play(ULONG Unit, ULONG Start, ULONG Length, ULONG FG)
{
	DUMPUDECL("DHD_Play( ",Unit,",");
	DUMPUDECL(" ",Start ,",");
	DUMPUDECL(" ",Length,",");
	DUMPHEXIL(" ",FG ," ); \\ ");
	return( (ULONG)(SendSwitcherReply(ES_Shuttle,FG,Unit,0)>>1) ); // Fields->Frames
}

// Use unit to specify whether in/out point
void	DHD_Jump(ULONG Unit, ULONG Spot, ULONG FG)
{
	DUMPUDECL("DHD_Jump( ",Unit,",");
	DUMPUDECL(" ",Spot ,",");
	DUMPHEXIL(" ",FG ," ); \\ ");
	SendSwitcherReply(ES_Jog,FG,Unit,Spot);
	return;
}

LONG MaxBlock=0x7ff000,StartBlock=0x7b5000;

//*******************************************************************
struct EditWindow *HandleNewClip(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	struct Window *Window;
	struct Gadget *Gadget,*Cancel=NULL,*Record,*Stop,*Aud,*Max,*Start;
	struct RastPort *RP;
	char	*mx_val,*st_val;
	BOOL Going = TRUE, Expert=FALSE;
	WORD ID,A;
	int	mxid,stid;

	DHD_InitRecord(0,0xc0ded00d);
//	if(!DHD_InitRecord(0,0xc0ded00d)) goto ErrExit;

	if( IntuiMsg->Qualifier & (IEQUALIFIER_LSHIFT | IEQUALIFIER_RSHIFT) )
		Expert=TRUE;

	ClipNW.Screen = EditScreen;
	ClipNW.Width = 324;
	if(Expert)
		ClipNW.Height = 236;
	else
		ClipNW.Height = 180;

	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = (EditScreen->Height - ClipNW.Height)/2;
	ClipNW.FirstGadget = NULL;

//	Gadget = FindGadget(&Gadget1,ID_REQ_DARK_CANCEL);
	Gadget = FindGadget(&Gadget1,ID_DARK_CONTINUE);
	if (!(Cancel = AllocOneGadget(Gadget))) goto ErrExit;
	Cancel->TopEdge = (ClipNW.Height-Cancel->Height-6);
	Cancel->LeftEdge = (ClipNW.Width-Cancel->Width-6);
	Cancel->NextGadget = &StringGadg;

	StringGadg.TopEdge = 2 + (3*LINE_HEIGHT);
	StrExt.Font = EditFont;
	strbuf[0] = strubuf[0] = 0;
	StrInf.BufferPos = StrInf.DispPos = 0;
	strcat(strbuf,"Clip 1");
	StringGadg.Width = 160;
	StringGadg.LeftEdge = ((ClipNW.Width - StringGadg.Width)>>1);
	if(Expert)
	{
		if (!(Start = AllocOneGadget(&StringGadg))) goto ErrExit;
		StringGadg.NextGadget = Start;
		Start->Width=100;
		Start->Height=TEXT_HEIGHT;
		Start->LeftEdge = ((ClipNW.Width-Start->Width)>>1);
		Start->TopEdge = StringGadg.TopEdge + StringGadg.Height + 4 + LSP;
		st_val = ((struct StringInfo *)Start->SpecialInfo)->Buffer;
		stcl_h(st_val,StartBlock);
		stid=Start->GadgetID;

		if (!(Max = AllocOneGadget(&StringGadg))) goto ErrExit;
		Start->NextGadget = Max;
		Max->Width=100;
		Max->Height=TEXT_HEIGHT;
		Max->LeftEdge = ((ClipNW.Width-Max->Width)>>1);
		Max->TopEdge = Start->TopEdge + Start->Height + 4 + LSP;
		mx_val = ((struct StringInfo *)Max->SpecialInfo)->Buffer;
		stcl_h(mx_val,MaxBlock);
		mxid=Max->GadgetID;
	}
	else Max=&StringGadg;

	Gadget = FindGadget(&Gadget1,ID_REQ_RECORD);
	if (!(Record = AllocOneGadget(Gadget))) goto ErrExit;
	Max->NextGadget = Record;
	Record->LeftEdge = (ClipNW.Width>>1)-Record->Width;
	Record->TopEdge = Max->TopEdge + Max->Height + 4 + LSP;

	Gadget = FindGadget(&Gadget1,ID_REQ_STOP);
	if (!(Stop = AllocOneGadget(Gadget))) goto ErrExit;
	Stop->LeftEdge = (ClipNW.Width>>1);
	Stop->TopEdge = Record->TopEdge;
	Record->NextGadget = Stop;

	Gadget = FindGadget(Edit->Gadgets,ID_POPUP_DISP);
	if (!(Aud = AllocOneGadget(Gadget))) goto ErrExit;
	Aud->LeftEdge = ((ClipNW.Width-Aud->Width)>>1) + 48;
	Aud->TopEdge = Record->TopEdge+Record->Height + LSP;
	Aud->NextGadget = NULL;
	Stop->NextGadget = Aud;

	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	if (Window = OpenWindow((struct NewWindow *)&ClipNW)) {
		RP = Window->RPort;
		SetDrMd(RP,JAM2);
		if (Cancel) AddGList(Window,Cancel,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		NewBorderBox(RP,StringGadg.LeftEdge-4,StringGadg.TopEdge-6,
			StringGadg.LeftEdge+StringGadg.Width+4-1,
			StringGadg.TopEdge+StringGadg.Height+5-1,
			BOX_REV_BORDER);

		if(Expert)
		{
			NewBorderBox(RP,Max->LeftEdge-4,Max->TopEdge-6,
				Max->LeftEdge+Max->Width+4-1,
				Max->TopEdge+Max->Height+5-1,
				BOX_REV_BORDER);
			NewBorderBox(RP,Start->LeftEdge-4,Start->TopEdge-6,
				Start->LeftEdge+Start->Width+4-1,
				Start->TopEdge+Start->Height+5-1,
				BOX_REV_BORDER);
		}
		if (Cancel) RefreshGList(Cancel,Window,NULL,-1);
		RedrawPopupTextZ(Window);

		Move(RP,36,Aud->TopEdge+13);
		SetFont(RP,DarkFont);
		SafeColorText(RP,"Record audio:",13);

		SafeFitText(RP,RecMsg,strlen(RecMsg),ClipNW.Width,FALSE);
		Move(RP,(ClipNW.Width-LastExtent.te_Width)/2,LINE_HEIGHT+TEXT_BASE);
		SafeFitText(RP,RecMsg,strlen(RecMsg),ClipNW.Width,TRUE);
		if(Expert)
		{
			Move(RP,36,Max->TopEdge+8);
			SafeColorText(RP,"End: ",5);
			Move(RP,36,Start->TopEdge+8);
			SafeColorText(RP,"Start: ",7);
		}

		goto GetEm;
		while (Going) {
				WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
				switch(IntuiMsg->Class) {
				case IDCMP_GADGETUP:
					ID = ((struct Gadget *)IntuiMsg->IAddress)->GadgetID;
//					if ((ID == ID_REQ_DARK_CANCEL) || (ID == ID_REQ_STOP)) Going = FALSE;
						if(ID == ID_REQ_STOP) DHD_Abort(0);
						else if (ID == ID_REQ_RECORD) DHD_Record(0,StartBlock,MaxBlock,0xc0edbabe);
						else if(ID == ID_DARK_CONTINUE)
						{
							DHD_Abort(0);
							Going = FALSE;
						}
						else if(ID ==ID_DARK_CONTINUE)	Going = FALSE;
						else if(ID == stid) stch_l(st_val,&StartBlock);
						if(ID == mxid) stch_l(mx_val,&MaxBlock);
					break;

				case IDCMP_GADGETDOWN:
					ID = ((struct Gadget *)IntuiMsg->IAddress)->GadgetID;
					if (ID == ID_POPUP_DISP)
						AudioChoice(Window,IntuiMsg);
					break;

				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					if ((A == RAW_ENTER)||(A == RAW_RETURN)||
						(A == RAW_ESCAPE)||(A == RAW_HELP)) {
						Going = FALSE;
					}
				}
				ReplyMsg((struct Message *)IntuiMsg);
				}
		}
		CloseWindow(Window);
		WaitBlit();
	}
ErrExit:
	if (Cancel) {
		Cancel->NextGadget = NULL;
		FreeGadgets(Cancel);
	}
	if(Expert)
	{
		if (Max) {
			Max->NextGadget = NULL;
			FreeGadgets(Max);
		}
		if (Start) {
			Start->NextGadget = NULL;
			FreeGadgets(Start);
		}
	}
	if (Record) {
		Record->NextGadget = NULL;
		FreeGadgets(Record);
	}
	if (Stop) {
		Stop->NextGadget = NULL;
		FreeGadgets(Stop);
	}
	if (Aud) {
		Aud->NextGadget = NULL;
		FreeGadgets(Aud);
	}
	DUMPUDECL("Max Block   = ",MaxBlock,"\\");
	DHD_InitPlay(0,0xbadb00b1);
	DUMPUDECL("Start Block = ",StartBlock,"\\");
	return(Edit);
}

//*******************************************************************
d1032 1
a1050 1525

#define RAIL_H 7
LONG LRRailColor[] = { 4,4,5,5,5,2,2 };
//*******************************************************************
VOID InitLRKnobRail(struct RastPort *RP,struct Gadget *Prop)
{
	LONG X,Y,X2,Y2;

	X = Prop->LeftEdge;
	X2 = Prop->LeftEdge+Prop->Width-1;
	Y = Prop->TopEdge + ((Prop->Height - RAIL_H)>>1);
	Y2 = Y + RAIL_H - 1;

	SetAPen(RP,4);
	Move(RP,X-2,Y+1);
	Draw(RP,X-2,Y+5);
	Move(RP,X-1,Y);
	Draw(RP,X-1,Y+4);
	Move(RP,X2+1,Y+1);
	Draw(RP,X2+2,Y+1);
	SetAPen(RP,2);
	Move(RP,X-1,Y+5);
	Draw(RP,X-1,Y+6);
	Move(RP,X2+1,Y+2);
	Draw(RP,X2+1,Y+6);
	Move(RP,X2+2,Y+1);
	Draw(RP,X2+2,Y+5);
}

//*******************************************************************
VOID DrawLRKnobRail(struct RastPort *RP,struct Gadget *Prop)
{
	LONG X,Y,X2,Y2,KnobX,KnobX2,*L;

	Y = Prop->TopEdge + ((Prop->Height - RAIL_H)>>1);
	Y2 = Y + RAIL_H - 1;
	X = Prop->LeftEdge;
	X2 = ((struct Image *)Prop->GadgetRender)->Width; // X2 temp
	KnobX = Prop->Width - X2;
	KnobX = ((((struct PropInfo *)Prop->SpecialInfo)->HorizPot * KnobX)
		/ MAXPOT) + X;
	KnobX2 = KnobX + X2;
	X2 = Prop->LeftEdge + Prop->Width - 1;
	L = LRRailColor;

	Forbid();
	for (; Y <= Y2; Y++) {
		SetAPen(RP,*L++);
		if (X != KnobX) {
			Move(RP,X,Y);
			Draw(RP,KnobX,Y);
		}
		if (X2 != KnobX) {
			Move(RP,KnobX2,Y);
			Draw(RP,X2,Y);
		}
	}
	Permit();
	WaitBlit();
}

char *Pnls[] = { "Text","Time","Line","String","Toggle","PopUp"};

//*******************************************************************
struct PanelLine {
	UBYTE Type;
	UBYTE Align;
	char *Label;
	UWORD	Width;
	LONG *Param,*Param2;
	LONG PropStart,PropEnd;
	struct Gadget *StrGadg,*PropGadg,*IncGadg,*DecGadg;
	struct Gadget *G1,*G2,*G3,*G4,*G5;
};
enum {
	PNL_TEXT=1,
	PNL_TIME,			// Param2=FXSpeed PLine to set to V
	PNL_IN_TYPE, PNL_OUT_TYPE,
	PNL_CHOICE4, PNL_CHOICE5,
	PNL_DIFF,     // DIFF is (*(Param) - *(Param2)) as a time field
	PNL_TOGGLE,
	PNL_FXSPEED,  // Param2 is array of 4(ULONG) field counts: S,M,F,V for FXTIME
						// PropStart=0(for FXTime update) or address of a PNL_TIME to update
	PNL_FXTIME,  // Like a DIFF, but attached to an FXSPEED
	PNL_STRING,  // String gadget Param=str ptr, Param2=max len
	PNL_POPUP,	 // param=item, Param2=names[], propstart=max entries (NUM_VIEW)
	PNL_CROUTON,	 // good old 80x50 image.. param=BitMap, param2=f'n
	PNL_DIVIDE	// Just a line...
};

enum {
	PNL_LEFT=1, PNL_CENTER };

#define PNL_MAX	20

struct PanelLine MakePL[PNL_MAX] = {
{ PNL_TEXT,PNL_CENTER,"Panel Maker",0,0 },
{ PNL_STRING,PNL_LEFT,"Title",0 },
{ PNL_DIVIDE,PNL_LEFT,"",0 },
{ PNL_TEXT,PNL_CENTER,"<Title>",0,0 },
{ PNL_DIVIDE,PNL_LEFT,"",0 },
{ PNL_POPUP,PNL_LEFT,"Add Gadget",0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine FileInfoPL[] = {
{ PNL_TEXT,PNL_CENTER,"File Information",0,0 },
{ PNL_DIVIDE,PNL_LEFT,"",0 },
{ PNL_STRING,PNL_LEFT,"Name",0 },
{ PNL_TEXT,PNL_CENTER,"Type Unknown",0,0 },
{ PNL_TEXT,PNL_LEFT,"No Comment",0,0 },
{ PNL_TEXT,PNL_LEFT,"File Size",0,0 },
{ PNL_TEXT,PNL_LEFT,"",0,0 },  // date
{ PNL_TEXT,PNL_LEFT,"Attributes",0,0 },
{ PNL_TEXT,PNL_LEFT,"Protection",0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine FramePL[] = {
{ PNL_TEXT,PNL_LEFT,"Frame",0,0 },
{ PNL_CROUTON,PNL_LEFT,"",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_TIME,PNL_CENTER,"Length",0,0 },
// { PNL_IN_TYPE,PNL_LEFT,0,0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine VideoPL[] = {
{ PNL_TEXT,PNL_LEFT,"Video Input",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_TIME,PNL_CENTER,"Length",0,0 },
// { PNL_IN_TYPE,PNL_LEFT,0,0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine EffectPL[] = {
{ PNL_TEXT,PNL_LEFT,"Effect",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_FXSPEED,PNL_LEFT,"Speed",0,0 },
{ PNL_TIME,PNL_CENTER,"Length",0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine AnimFXPL[] = {
{ PNL_TEXT,PNL_LEFT,"Effect",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_FXSPEED,PNL_LEFT,"Speed",0,0 },
// { PNL_DIFF,PNL_LEFT,"Length:  ",0,0 },
{ PNL_FXTIME,PNL_LEFT,"Length:  ",0,0 },
{ 0,0,0,0,0 } // end of array marker
};

#define CLIP_TIME	5		// index of first time in gad..
struct PanelLine ClipPL[] = {
{ PNL_TEXT,PNL_LEFT,"Video Clip",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_CROUTON,PNL_LEFT,"",1,0 },
{ PNL_DIFF,PNL_LEFT,"Length: ",0,0 },
{ PNL_DIVIDE,PNL_LEFT,"",0 },
{ PNL_TIME,PNL_LEFT,"In",1,0 },  // Changing where these are in array will break UpdatePanStr()
{ PNL_TIME,PNL_LEFT,"Out",0,0 },
{ PNL_DIVIDE,PNL_LEFT,"",0 },
// { PNL_IN_TYPE,PNL_LEFT,"",1,0 },
//{ PNL_OUT_TYPE,PNL_LEFT,"",0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine AudClipPL[] = {
{ PNL_TEXT,PNL_LEFT,"Audio Clip",0,0 },
{ PNL_STRING,PNL_LEFT,"name",0,0 },
{ PNL_POPUP,PNL_LEFT,"Delay",0,0 },
{ PNL_TIME,PNL_LEFT,"In",0,0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0,0 },
{ PNL_TIME,PNL_LEFT,"Out",0,0 },
{ PNL_OUT_TYPE,PNL_LEFT,0,0,0 },
{ PNL_DIFF,PNL_LEFT,"Length: ",0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine KeyPL[] = {
{ PNL_TEXT,PNL_LEFT,"CG Key",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_TIME,PNL_LEFT,"Delay",0,0 },
{ PNL_TIME,PNL_LEFT,"Length",0,0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0,0 },
{ PNL_OUT_TYPE,PNL_LEFT,0,0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine CrawlPL[] = {
{ PNL_TEXT,PNL_LEFT,"CG Crawl",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_CHOICE4,PNL_LEFT,"Speed",0,0 },
{ 0,0,0,0,0 } // end of array marker
};
struct PanelLine ScrollPL[] = {
{ PNL_TEXT,PNL_LEFT,"CG Scroll",0,0 },
{ PNL_TEXT,PNL_LEFT,"name",0,0 },
{ PNL_CHOICE5,PNL_LEFT,"Speed",0,0 },
{ 0,0,0,0,0 } // end of array marker
};

struct PanelLine TestPL[] = {
{ PNL_TEXT,PNL_LEFT,"Would like to eat?",0,0 },
{ PNL_DIVIDE,PNL_LEFT,"",0,0 },
{ PNL_STRING,PNL_CENTER,"Name",0,0 },
{ PNL_POPUP,PNL_LEFT,"Cool Beverage:",0,0 },
{ PNL_TOGGLE,PNL_LEFT,"Rolls",0,0 },
{ PNL_TEXT, PNL_CENTER , "(Biscuits)" , 0 },
{ PNL_TOGGLE, PNL_LEFT, "Potatoes",0,0 },
{ PNL_TOGGLE,PNL_LEFT,"Chicken",0,0 },
{ PNL_TOGGLE,PNL_CENTER,"Gravy",0,0 },
{ 0,0,0,0,0 } // end of array marker
};


#define PNL_WIDTH 256 // 238
#define PNL_X1 10
#define PNL_Y1 0
#define PNL_DIV 4
#define PNL_YADD 12
#define PTEXT_H 23
#define PTEXT_YOFF 6
#define PTIME_W 181
#define PTIME_H 62
#define PTIME_POFF 32
#define PTIME_YOFF 15
#define PTIME_XOFF 80
#define PIN_H 40
#define PIN_YOFF 10
#define PCHOICE_H 54
#define PCHOICE_TOFF 6
#define PCHOICE_YOFF 24
#define MAX_PANEL_STR 32

ULONG	Yes=1,No=0;

//*******************************************************************
// converts MM:SS:FF to LONG # of FRAMEs
VOID TimeToLong(char *T,LONG *L)
{
	LONG A = 0,B = 0,Z[5] = {0,0,0,0,0},*P;
	char c;

	P = Z;
	while (c = *T) {
		T++;
		if ((c >= '0') && (c <= '9')) {
			B *= 10;
			B += (c - '0');
		}
		if ((!(*T)) || (c == ':') || (c == ';') || (c == ' ') || (c == '.')) {
			*P++ = B;
			A++;
			if (A > 4) break;
			B = 0;
		}
	}
	if (A == 1) *L = Z[0];
	else if (A == 2) *L = Z[0]*30 + Z[1];
	else if (A >= 3) *L = Z[0]*1800 + Z[1]*30 + Z[2];
}

//*******************************************************************
// Comvert # of frames to SMPTE string -- MM:SS:FF
VOID LongToTime(LONG *L,char *T)
{
	LONG A,B,C;

	A = *L;
	B = A / 1800;  // 60 secs/min * 30 frames/secs
	A %= 1800;
	C = A / 30;
	A %= 30;
	sprintf(T,"%02ld:%02ld:%02ld",B,C,A);
}

//*******************************************************************
// recalculates difference and prints it if changed, returns 0 if props need update
LONG UpdateDiff(struct RastPort *RP,struct PanelLine *PLine,struct Window *Window)
{
	LONG A,Y;
	char ch[32];

	A = *(PLine->Param) - *(PLine->Param2);
	if (A < 0)
	{
		A = 0;
		*(PLine->Param) = *(PLine->Param2) + 2; // 1 color-frame ahead
	}
	if (A != PLine->PropEnd) {
		PLine->PropEnd = (A==0 ? 2:A);
		ch[0] = 0;
		if (PLine->Label) strcpy(ch,PLine->Label);
		LongToTime(&PLine->PropEnd,&ch[strlen(ch)]);
		SetDrMd(RP,JAM2);
		SetAPen(RP,SCREEN_PEN);
		Y = PLine->PropStart+PCHOICE_TOFF;
		RectFill(RP,PNL_X1,Y,PNL_WIDTH-PNL_X1-6,Y+TEXT_HEIGHT);
		Move(RP,PNL_X1,PLine->PropStart+PCHOICE_TOFF+TEXT_BASE);
		SafeColorText(RP,ch,strlen(ch));
	}
	return(A);
}

//*******************************************************************
// checks all PNL_DIFF PLines for change
VOID UpdateAllDiff(struct RastPort *RP,struct PanelLine *PLine,struct Window *Window)
{
	LONG FixProp=1;
	while (PLine->Type) {
		if (PLine->Type == PNL_DIFF) FixProp*=UpdateDiff(RP,PLine,Window);
		else if ( (FixProp==0) && (PLine->Type==PNL_TIME) )
		{
			UpdatePanProp(PLine,Window);
			UpdatePanStr(PLine,Window);
		}
		PLine++;
	}
}

//*******************************************************************
// checks all PNL_DIFF PLines for change
VOID UpdateFXTime(struct RastPort *RP,struct PanelLine *PLine,LONG t,struct Window *Window)
{
	if(t)
		while (PLine->Type) {
			if (PLine->Type == PNL_FXTIME)
			{
				*PLine->Param=t;
				*PLine->Param2=0;
				UpdateDiff(RP,PLine,Window);
			}
			PLine++;
		}
}

// Set FXSpeed button ot given SMFV, return framecount
LONG UpdateFXSpeed(struct PanelLine *PLine,LONG t,struct Window *Window)
{
	struct Gadget **PPGadg;
	UWORD	A;
	if( t && (PLine->Type == PNL_FXSPEED) )
	{
		*PLine->Param=t;
		PPGadg = &PLine->G1;
		for (A=0;A<4;A++)
			if (*PPGadg)
				if(A!=t)	(*PPGadg++)->Flags &= (~GFLG_SELECTED);
				else (*PPGadg++)->Flags |= GFLG_SELECTED;
		RefreshGList(PLine->G1,Window,0,4);
		return(PLine->Param2[t]); // value to set time to
	}
	return(0);
}

//*******************************************************************
VOID AddPanelG(struct Gadget **First,struct Gadget **This,struct Gadget **New)
{
	if (!(*First)) *First = *This = *New;
	else {
		(*This)->NextGadget = *New;
		*This = *New;
	}
}

//*******************************************************************
// goes from *(PLine->Param) to StrGadg

#define ENDFUDGE	12

VOID UpdatePanStr(struct PanelLine *PLine,struct Window *Window)
{
	struct Gadget *ThisG;
	LONG A, MaxField;
	ULONG field;

	ThisG = PLine->StrGadg;
	if ( (PLine==&ClipPL[3]) || (PLine==&ClipPL[4]) ) {
		field = (ULONG)(*PLine->Param)<<1;
		MaxField=GetValue(CurFG,0x80000000|TAG_RecFields)-ENDFUDGE;

		if(field > MaxField) field=MaxField;
		if(field < 0) field = 0;

		DHD_Jump(InOrOut,field,(ULONG)CurFG);
	}

	A = RemoveGadget(Window,ThisG);
	LongToTime(PLine->Param,((struct StringInfo *)PLine->StrGadg->SpecialInfo)
		->Buffer);
	AddGadget(Window,ThisG,A);
	RefreshGList(ThisG,Window,NULL,1);
}

//*******************************************************************
// goes from prop position to *(PLine->Param)
VOID UpdateParam(struct PanelLine *PLine,struct Window *Window)
{
	LONG A;

	A = PLine->PropEnd-PLine->PropStart;
	A = (((struct PropInfo *)PLine->PropGadg->SpecialInfo)->HorizPot * A)
		 / MAXPOT;
	A += PLine->PropStart;
	*(PLine->Param) = A;
	UpdatePanStr(PLine,Window);
}

//*******************************************************************
// goes from *(PLine->Param) to prop position between PropStart/PropEnd
VOID UpdatePanProp(struct PanelLine *PLine,struct Window *Window)
{
	LONG A;

	A = *(PLine->Param);
	if (A > PLine->PropEnd) A = PLine->PropEnd;
	else if (A < PLine->PropStart) A = PLine->PropStart;
	A -= PLine->PropStart;
	SetPropHorizPot(PLine->PropGadg,Window,A,0,PLine->PropEnd-PLine->PropStart);
	if (Window) DrawLRKnobRail(Window->RPort,PLine->PropGadg);
}

//*******************************************************************

// Returns FALSE if Cancel was selected

BOOL __asm Panel(register __a0 struct EditWindow *Edit,register __a1 struct PanelLine *PLine)
{
	WORD H = PNL_Y1,ID,A,B,X1=0,Y1=0;
	struct PanelLine *Start,*temp,*LastTime;
	struct Gadget *FirstG=0,*ThisG=0,*NewG=0,*Down=0,
		**PPGadg,*In=NULL,*Out=NULL,*Del=NULL,*Len=NULL;
	struct Window *Window=0;
	struct RastPort *RP;
	BOOL Going = TRUE, Success = FALSE,Wide=FALSE;
	struct IntuiMessage *IntuiMsg;
	char *ch;
	LONG *L,Y;


	Start = PLine;
	while (PLine->Type && !Wide)
	{
		if(PLine->Width)
			Wide=TRUE;
		PLine++;
  }
// setup panel
	PLine=Start;
	while (PLine->Type)
	{
		switch(PLine->Type)
		{
	//****************
		case PNL_TIME:
			Y1=H;
			if (!(NewG = AllocOneGadget(&StringGadg))) goto ErrExit;
			PLine->StrGadg = NewG;
      InstallTCHook(NewG);

			NewG->LeftEdge = X1+PTIME_XOFF;
			NewG->TopEdge = H + PTIME_YOFF;
			NewG->Height = TEXT_HEIGHT;
			NewG->Width = 68;   // between 66 and 70...
			NewG->UserData = PLine;
			LongToTime(PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->Buffer);
			AddPanelG(&FirstG,&ThisG,&NewG);

			if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LR_KNOB))))
				goto ErrExit;
			PLine->PropGadg = NewG;
			NewG->LeftEdge = X1+PNL_X1;
			NewG->TopEdge = H + PTIME_POFF + 2;
			NewG->Height = 20;
			NewG->Width = PTIME_W;
			NewG->UserData = PLine;
			((struct PropInfo *)NewG->SpecialInfo)->HorizBody = MAXPOT / 7;
			AddPanelG(&FirstG,&ThisG,&NewG);

			if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID_LEFT))))
				goto ErrExit;
			PLine->DecGadg = NewG;
			NewG->LeftEdge = ThisG->LeftEdge+ThisG->Width+6;
			NewG->TopEdge = ThisG->TopEdge;
			NewG->UserData = PLine;
			AddPanelG(&FirstG,&ThisG,&NewG);

			if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID_RIGHT))))
				goto ErrExit;
			PLine->IncGadg = NewG;
			NewG->LeftEdge = ThisG->LeftEdge+ThisG->Width;
			NewG->TopEdge = ThisG->TopEdge;
			NewG->UserData = PLine;
			AddPanelG(&FirstG,&ThisG,&NewG);
			if(PLine->Width) X1=PNL_WIDTH;
			else
			{
				X1 = 0;
				H += PTIME_H;
			}
			if(!strnicmp(PLine->Label,"In",2))
				In=PLine->StrGadg;
			else if(!strnicmp(PLine->Label,"Out",3))
				Out=PLine->StrGadg;
			else if(!strnicmp(PLine->Label,"Len",3))
				Len=PLine->StrGadg;
			else if(!strnicmp(PLine->Label,"Del",3))
				Del=PLine->StrGadg;
		break;

	//****************
		case PNL_DIFF:
		case PNL_FXTIME:
			PLine->PropStart = H; // used to redraw text later
			PLine->PropEnd = -1; // flag so redrawn on first loop
		case PNL_TEXT:
			H += PTEXT_H;
		break;

	//****************
		case PNL_OUT_TYPE:
			A = ID_OUT_TYPE;
			goto DoType;

	//****************
		case PNL_IN_TYPE:
			A = ID_IN_TYPE;
		DoType:
			if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,A))))
				goto ErrExit;
			PLine->G1 = NewG;
			NewG->LeftEdge = X1 + ((PNL_WIDTH - NewG->Width) >> 1);
			NewG->TopEdge = H + PIN_YOFF;
			NewG->UserData = PLine;
			if (*(PLine->Param)==1) NewG->Flags |= GFLG_SELECTED;
			else NewG->Flags &= (~GFLG_SELECTED);
			AddPanelG(&FirstG,&ThisG,&NewG);
			if(PLine->Width) X1=PNL_WIDTH;
			else
			{
				X1 = 0;
				H += PIN_H;
			}
		break;

	//****************
		case PNL_CHOICE5:
			A = 5;
			goto DoCh;
	//****************
		case PNL_CHOICE4:
			A = 4;
		DoCh:
			ID = ID_1;
			PPGadg = &PLine->G1;
			for (B=0;B<A;B++) {
				if ((A == 5) && (B == 3)) ID++;
				if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID))))
					goto ErrExit;
				*PPGadg = NewG; // fill in G1..G(A)
				PPGadg++;
				NewG->LeftEdge = ((PNL_WIDTH - (A*40)) >> 1)
					+ (B*40); // hard code - last one is 41 wide
				NewG->TopEdge = H + PCHOICE_YOFF;
				NewG->UserData = PLine;
				if (B == *(PLine->Param)) NewG->Flags |= GFLG_SELECTED;
				AddPanelG(&FirstG,&ThisG,&NewG);
				ID++;
			}
			H += PCHOICE_H;
		break;
  //***************

		case PNL_FXSPEED:
			A = 4;
			ID = ID_S;
			PPGadg = &PLine->G1;
			for (B=0;B<A;B++)
			{
				if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID))))
					goto ErrExit;
				*PPGadg = NewG; // fill in G1..G(A)
				PPGadg++;
				NewG->LeftEdge = ((PNL_WIDTH - (A*40)) >> 1)
					+ (B*40); // hard code - last one is 41 wide
				NewG->TopEdge = H + PCHOICE_YOFF;
				NewG->UserData = PLine;
				if ((PLine->Param2)[B]==0) NewG->Flags |= GFLG_DISABLED;
				if (B == *(PLine->Param)) NewG->Flags |= GFLG_SELECTED;
				AddPanelG(&FirstG,&ThisG,&NewG);
				ID++;
			}
			H += PCHOICE_H;
		break;

  //***************
		case PNL_TOGGLE:
			if (!(NewG = AllocOneGadget( FindGadget(&Gadget1,ID_BOOL)  ))) goto ErrExit;
			PLine->G1 = NewG;
			NewG->LeftEdge = (PNL_WIDTH-80)>>1;
			NewG->TopEdge =H;
			NewG->UserData = PLine;
			if(PLine->Param==0) NewG->Flags &= (~GFLG_SELECTED);
			else NewG->Flags |= GFLG_SELECTED;
			AddPanelG(&FirstG,&ThisG,&NewG);
			H += PTEXT_H;
		break;

  //***************
		case PNL_POPUP:
			if (!(NewG = AllocOneGadget( FindGadget(&Gadget1,ID_POPUP_DISP)  ))) goto ErrExit;
			PLine->G1 = NewG;
			CurPLine=PLine;
			NewG->LeftEdge = X1 + (PNL_WIDTH-NewG->Width)>>1;
			NewG->TopEdge =H;
			NewG->UserData = PLine;
			AddPanelG(&FirstG,&ThisG,&NewG);
			if(PLine->Width) X1=PNL_WIDTH;
			else
			{
				X1 = 0;
				H += PTEXT_H;
			}
		break;

  //***************
		case PNL_STRING:
			H += 4;
			if (!(NewG = AllocOneGadget(&StringGadg))) goto ErrExit;
			PLine->StrGadg = NewG;
			NewG->Width=100;
			NewG->LeftEdge = (PNL_WIDTH-NewG->Width)>>1;
			NewG->TopEdge =H;
			NewG->UserData = PLine;
			strncpy( ((struct StringInfo *)NewG->SpecialInfo)->Buffer,(char *)PLine->Param,MAX_STRING_BUFFER);
			AddPanelG(&FirstG,&ThisG,&NewG);
			H += PTIME_H;
		break;

  //***************
		case PNL_DIVIDE:
			H += 8+PNL_DIV;
		break;

  //***************
		case PNL_CROUTON:
		//	H += 54;
		break;

		} // end Switch()
		PLine++;
	}
	DUMPMSG("... All Lines Added");

	if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID_DARK_CONTINUE))))
		goto ErrExit;
	H += PNL_YADD + NewG->Height;
	NewG->TopEdge = H - NewG->Height - 8;
	NewG->LeftEdge = PNL_WIDTH - NewG->Width - 8 + (Wide ? PNL_WIDTH:0);
	AddPanelG(&FirstG,&ThisG,&NewG);

	if (!(NewG = AllocOneGadget(FindGadget(&Gadget1,ID_REQ_DARK_CANCEL))))
		goto ErrExit;
	NewG->TopEdge = H - NewG->Height - 8;
	NewG->LeftEdge = 8; // PNL_WIDTH - NewG->Width - 8;
	AddPanelG(&FirstG,&ThisG,&NewG);

	ClipNW.Width = PNL_WIDTH + (Wide ? PNL_WIDTH:0);
	ClipNW.Height = H;
	ClipNW.Screen = EditScreen;
	ClipNW.LeftEdge = EditTop->Window->LeftEdge +
		((EditTop->Window->Width - ClipNW.Width)/2);
	ClipNW.TopEdge = (EditScreen->Height - ClipNW.Height)/2;
	ClipNW.FirstGadget = NULL;

	SaveBorder(&EditScreen->RastPort,ClipNW.LeftEdge,ClipNW.TopEdge,
		ClipNW.LeftEdge+ClipNW.Width-1,ClipNW.TopEdge+ClipNW.Height-1);
	if (Window = OpenWindow((struct NewWindow *)&ClipNW))
	{
		RP = Window->RPort;
		SetDrMd(RP,JAM2);
		AddGList(Window,FirstG,0,-1,NULL);
		NewBorderBox(RP,0,0,Window->Width-1,Window->Height-1,BOX_CP_BORDER);
		SetFont(RP,DarkFont);
		PLine = Start;
		X1 = 0;
		H = PNL_Y1;
		while (PLine->Type)
		{
			switch(PLine->Type)
			{
			case PNL_TIME:
				ThisG = PLine->StrGadg;
				NewBorderBox(RP,ThisG->LeftEdge-4,ThisG->TopEdge-5,
				ThisG->LeftEdge+ThisG->Width+4-1,
				ThisG->TopEdge+ThisG->Height+4-1,BOX_REV_BORDER);
				if (PLine->Label)
				{
					Move(RP,X1+PNL_X1,H+PTIME_YOFF+TEXT_BASE-1);
					SafeColorText(RP,PLine->Label,strlen(PLine->Label));
				}
				UpdatePanProp(PLine,NULL); // init knob before display
				if(PLine->Width) X1=PNL_WIDTH;
				else
				{
					X1 = 0;
					H += PTIME_H;
				}
				break;
			case PNL_STRING:
				H += 4;
				ThisG = PLine->StrGadg;
				NewBorderBox(RP,ThisG->LeftEdge-4,ThisG->TopEdge-5,
				ThisG->LeftEdge+ThisG->Width+4-1,
				ThisG->TopEdge+ThisG->Height+4-1,BOX_REV_BORDER);
				if (PLine->Label)
				{
					Move(RP,PNL_X1,H+TEXT_BASE-1);
					SafeColorText(RP,PLine->Label,strlen(PLine->Label));
				}
				H += PTIME_H;
				break;
			case PNL_TEXT: case PNL_TOGGLE:
				if (PLine->Label) {
					if (PLine->Align == PNL_LEFT) A = PNL_X1;
					else {
						B = strlen(PLine->Label);
						SafeFitText(RP,PLine->Label,B,PNL_WIDTH,FALSE);
						A = (PNL_WIDTH - LastExtent.te_Width) >> 1;
					}
					Move(RP,A,H+PTEXT_YOFF+TEXT_BASE);
					SafeColorText(RP,PLine->Label,strlen(PLine->Label));
				}
				H += PTEXT_H;
			break;

			case PNL_IN_TYPE:
			case PNL_OUT_TYPE:
				if(PLine->Width) X1=PNL_WIDTH;
				else
				{
					X1 = 0;
					H += PIN_H;
				}
			break;

			case PNL_CHOICE4:
			case PNL_CHOICE5:
				if (PLine->Label) {
					Move(RP,PNL_X1,H+PCHOICE_TOFF+TEXT_BASE);
					SafeColorText(RP,PLine->Label,strlen(PLine->Label));
				}
				H += PCHOICE_H;
			break;

			case PNL_FXSPEED:
				if (PLine->Label) {
					Move(RP,PNL_X1,H+PCHOICE_TOFF+TEXT_BASE);
					SafeColorText(RP,PLine->Label,strlen(PLine->Label));
				}
				H += PCHOICE_H;
			break;

			case PNL_FXTIME:
			case PNL_DIFF:
				UpdateDiff(RP,PLine,Window);
				H += PTEXT_H;
			break;

			case PNL_DIVIDE:
				NewBorderBox(RP,PNL_X1,H,ClipNW.Width-PNL_X1,H+PNL_DIV,BOX_REV);
				H += 8+PNL_DIV;
			break;

			case PNL_CROUTON:
				if(PLine->Param) CopyCrut((struct BitMap *)PLine->Param,RP->BitMap,
				ClipNW.LeftEdge + ClipNW.Width - 80 -3,
				ClipNW.TopEdge +4,Edit->RowSize-2);
				// H += 54;
			break;

			case PNL_POPUP:
				H += PTEXT_H;
			break;

			}
			PLine++;
		}
		RefreshGList(FirstG,Window,NULL,-1);
		PLine = Start;
		while(PLine->Type) {
			if (PLine->PropGadg) {
					InitLRKnobRail(RP,PLine->PropGadg);
					DrawLRKnobRail(RP,PLine->PropGadg);
			}
			if(PLine->Type==PNL_POPUP) {
				RedrawPopText(Window);
				SetFont(RP,DarkFont);
			}
			PLine++;
		}

// handle window events
		goto GetEm;
		while (Going) {
				WaitPort(Window->UserPort);
			GetEm:
			while (IntuiMsg = (struct IntuiMessage *)GetMsg(Window->UserPort)) {
				switch(IntuiMsg->Class) {
				case IDCMP_GADGETDOWN:
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					PLine = (struct PanelLine *)ThisG->UserData;
					// *PLine->Param=UpdateFXSpeed((struct PanelLine *)PLine->Param2,3,Window);
					LastTime=PLine;
					if( LastTime==&(ClipPL[CLIP_TIME]) ) InOrOut=0;
					else InOrOut=1;
					switch(ID) {
					case ID_LR_KNOB:
						Down = ThisG;
						DrawLRKnobRail(RP,Down);
						UpdateParam(PLine,Window);
						UpdateAllDiff(RP,Start,Window);
						break;
					case ID_LEFT:
						Y = *(PLine->Param) - 1;
						if (Y < 0) Y = 0;
						*(PLine->Param) = Y;
						UpdatePanProp(PLine,Window);
						UpdatePanStr(PLine,Window);
						UpdateAllDiff(RP,Start,Window);
						break;
					case ID_RIGHT:
						Y = *(PLine->Param) + 1;
						*(PLine->Param) = Y;
						UpdatePanProp(PLine,Window);
						UpdatePanStr(PLine,Window);
						UpdateAllDiff(RP,Start,Window);
						break;
					case ID_POPUP_DISP:
						HandlePopUp(Window,IntuiMsg,PLine);
						break;
					}
					break;

				case IDCMP_MOUSEMOVE:
					if (Down) {
						DrawLRKnobRail(RP,Down);
						UpdateParam((struct PanelLine *)Down->UserData,Window);
						UpdateAllDiff(RP,Start,Window);
					}
					break;

				case IDCMP_MOUSEBUTTONS:
					A = IntuiMsg->Code;
					if( (A==IECODE_RBUTTON))
						if(B=DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG))
							*LastTime->Param=B;
					if (Down) Down = NULL;
					PLine = (struct PanelLine *)ThisG->UserData;
					break;

				case IDCMP_GADGETUP:
					DUMPMSG	("GADGETUP");

					if (Down) Down = NULL;
					ThisG = (struct Gadget *)IntuiMsg->IAddress;
					ID = ThisG->GadgetID;
					PLine = (struct PanelLine *)ThisG->UserData;
					switch (ID) {
					case ID_DARK_CONTINUE:
						DUMPMSG	("CONTINUE");
						Success = TRUE;
					case ID_REQ_DARK_CANCEL:
						Going = FALSE;			//Success was initialized to FALSE
						break;
					case STRING_ID:
						if(PLine->Type == PNL_TIME)
						{
							ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
							L = PLine->Param;
							TimeToLong(ch,L); // update long & flush bogus values
							UpdatePanProp(PLine,Window);
							UpdatePanStr(PLine,Window);
							UpdateAllDiff(RP,Start,Window);
						}
						else if(PLine->Type == PNL_STRING)
						{
							ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
							strncpy((char *)PLine->Param,ch,(int)PLine->Param2);
						}
					break;
          case ID_BOOL:
						PLine->Param = (long *)( PLine->Param ? 0:1 ) ;  // invert value...
						break;
					case ID_1:
					case ID_2:
					case ID_3:
					case ID_4_END:
					case ID_4:
					case ID_5_END:
						PPGadg = &PLine->G1;
						for (A=0;A<5;A++) {
							if (*PPGadg) (*PPGadg)->Flags &= (~GFLG_SELECTED);
							PPGadg++;
						}
						ThisG->Flags |= GFLG_SELECTED;
						A = ID;
						if ((PLine->Type == PNL_CHOICE5) && (A >= ID_4)) A--;
						*(PLine->Param) = A;
						RefreshGList(PLine->G1,Window,0,5);
					break;

					case ID_S:
					case ID_M:
					case ID_F:
					case ID_V:
						// if(!PLine->Param2[(ID - ID_S)&0x0003]) break; // disable!
						PPGadg = &PLine->G1;
						for (A=0;A<4;A++) {
							if (*PPGadg)
								(*PPGadg)->Flags &= (~GFLG_SELECTED);
							PPGadg++;
						}
						ThisG->Flags |= GFLG_SELECTED;
						A = ID - ID_S ;
						*(PLine->Param) = A;
						if(temp=(struct PanelLine *)PLine->PropStart)
						{
							*temp->Param=PLine->Param2[A];
							UpdatePanProp(temp,Window);
							UpdatePanStr(temp,Window);
						}
						else UpdateFXTime(RP,Start,PLine->Param2[A],Window);
						RefreshGList(PLine->G1,Window,0,4);
					break;

					}
					break;

				case IDCMP_RAWKEY:
					A = IntuiMsg->Code;
					if(A<0x80)
					{
						B = IntuiMsg->Qualifier;
						DUMPHEXIB("Key Code: ",A,"\\");

						if(In && A==RAW_IN )
							ActivateGadget(In,Window,NULL);
						else if(Out && A==RAW_OUT )
							ActivateGadget(Out,Window,NULL);
						else if(Len && A==RAW_LEN )
							ActivateGadget(Len,Window,NULL);
						else if(Del && A==RAW_DEL )
							ActivateGadget(Del,Window,NULL);
					}
					if ((A == RAW_ENTER)||(A == RAW_RETURN)||(A == RAW_ESCAPE)||(A == RAW_HELP))
						Going = FALSE;
					break;
				}
				ReplyMsg((struct Message *)IntuiMsg);
				}
		}
		CloseWindow(Window);
		WaitBlit();

// update modified parameters
		PLine = Start;
		while (PLine->Type)
		{
			switch(PLine->Type) {
			case PNL_TIME:
				TimeToLong(((struct StringInfo *)PLine->StrGadg->SpecialInfo)->
					Buffer,PLine->Param);
			break;
			case PNL_STRING:
//			strncpy((char *)PLine->Param,((struct StringInfo *)ThisG->SpecialInfo)->Buffer,(int)PLine->Param2);
				break;
			case PNL_IN_TYPE:
			case PNL_OUT_TYPE:
				if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
				else *(PLine->Param) = 0;
			break;
			}
			PLine++;
		}
	}
ErrExit:
	if (FirstG) FreeGadgets(FirstG);
	return((BOOL)Success);
}

LONG GetValue(struct FastGadget *FG,ULONG TagID)
{
#ifdef SERDEBUG
	LONG	c;
	c=SendSwitcherReply(ES_GetValue,(LONG)FG,TagID,0);
	DUMPHEXIL("ES_GetValue( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID," ) =");
	DUMPSDECL(" ",c,"\\");
	return(c);
#else
	return(SendSwitcherReply(ES_GetValue,(LONG)FG,TagID,0));
#endif
}

LONG PutValue(struct FastGadget *FG,ULONG TagID,LONG Value)
{
#ifdef SERDEBUG
	LONG	c;

	c=SendSwitcherReply(ES_PutValue,(LONG)FG,TagID,Value);
	DUMPHEXIL("ES_PutValue( ",(LONG)FG,",");
	DUMPHEXIL(" ",TagID,",");
	DUMPSDECL(" ",Value," ) =");
	DUMPSDECL(" ",c,"\\");
	return(c);
#else
	return(SendSwitcherReply(ES_PutValue,(LONG)FG,TagID,Value));
#endif
}

UBYTE FCM[] = {3,0,1,2};  // convert between wacky FCountMode and gadget
UBYTE notFCM[] = {1,2,3,0};  // S,M,F,V -> 3,0,1,2 .. NotFCM[FCM[x]] == x

UBYTE	*Names[] = {"Please","Baby","Just","The","Head","Ooooh"};
UBYTE	*Pops[] = {"Paul","Mark","Daniel","Junior","Kiki","Robert","Wil",""};

//*******************************************************************
struct EditWindow *HandlePanel(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	LONG A=0,B=2,In,Out,type,Speed=1,Time,S,SP[20],DLay;
	struct FastGadget *FG,*Next;
	char Label[MAX_PANEL_STR]="";
	BOOL BagIt=FALSE;

	FG = *(((struct Project *)Edit->Special)->PtrPtr);

	DUMPHEXIL("Starting FG=",(LONG)FG,"\\");

	while (FG && !BagIt)
	{
//		DUMPHEXIL("while FG=",(LONG)FG,"\\");

		Next = FG->NextGadget;
		if (FG->FGDiff.FGNode.Status == EN_SELECTED)
		{
			type=((struct ExtFastGadget *)FG)->ObjectType;
			strncpy(Label,FilePart( ((struct ExtFastGadget *)FG)->FileName),MAX_PANEL_STR);
			DUMPHEXIL("FG->ObjectType= ",type,"\\");
      	CurFG=FG;

			switch (type)
			{
//--------------------------------------------------------
				case CT_FXILBM:
				case CT_FXALGO:
				case CT_FXCR:
				case CT_FXANIM:
					Speed=GetValue(FG,0x80000000|TAG_FCountMode);
					Speed&=0x00000003; // 3,0,1,2 == S,M,F,V
					B=notFCM[Speed];	 // B=gadget button SMFV=0123
					SP[0]=GetValue(FG,0x80000000|TAG_NumFramesSlow);
					SP[1]=GetValue(FG,0x80000000|TAG_NumFramesMedium);
					SP[2]=GetValue(FG,0x80000000|TAG_NumFramesFast);
					SP[3]=GetValue(FG,0x80000000|TAG_NumFramesVariable);
					In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
					S=SP[notFCM[Speed]];
					if( (type==CT_FXANIM) || (SP[3]==0) )
					{
						A=0;
						AnimFXPL[1].Label =Label;
						AnimFXPL[2].Param =&B;				// SMFV choice
						AnimFXPL[2].Param2 =SP;  // Array of speeds
						AnimFXPL[2].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME
						AnimFXPL[3].Param = &S;	// Time label
						AnimFXPL[3].Param2 = &A;
						if( Panel(Edit,AnimFXPL) && (B!=notFCM[Speed]) )
						{
							PutValue(FG,0x80000000|TAG_FCountMode,FCM[B]);
							SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
						}
						else BagIt=TRUE;
					}
          else
					{
						EffectPL[1].Label =Label;
						EffectPL[2].Param =&B;						// SMFV choice
						EffectPL[2].Param2 =SP;						// Array of field counts
						EffectPL[2].PropStart =(LONG)&EffectPL[3];	// PLine (time) to update
						EffectPL[3].Param = &S;	// Time slider
						EffectPL[3].Param2 = (LONG *)&EffectPL[2];	// FXSpeed gadg to set to V
						EffectPL[3].PropStart = 1;
						EffectPL[3].PropEnd = In;	// (In>=330 ? In:330);
						if( Panel(Edit,EffectPL) && ( (S!=SP[3]) || (B!=notFCM[Speed]) ) )
						{
							if(B!=notFCM[Speed])
								PutValue(FG,0x80000000|TAG_FCountMode,FCM[B]); // FCM[3]=2 = variable
							if( B==3 )
								PutValue(FG,0x80000000|TAG_VariableFCount,S<<1);   // Frames -> Fields
							SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
						}
						else BagIt=TRUE;
					}
					break;

//--------------------------------------------------------
				case CT_AUDIO :

// *-*-*-*-*-*-*-*-********-*-*-*-*-*-*-*-*--****-*-*-*-*-*-*-*
// PANEL TEST CODE !!! DANGER
// *-*-*-*-*-*-*-*-********-*-*-*-*-*-*-*-*--****-*-*-*-*-*-*-*

					TestPL[2].Param = (LONG *)"Kiki";
					TestPL[2].Param2 = (LONG *)80;

					TestPL[3].Param = (LONG *)Pops;
					TestPL[3].PropStart = 2;
					TestPL[3].PropEnd = 7;

					if(!Panel(Edit,TestPL))
						BagIt=TRUE;
					break;

// *-*-*-*-*-*-*-*-********-*-*-*-*-*-*-*-*--****-*-*-*-*-*-*-*
// *-*-*-*-*-*-*-*-********-*-*-*-*-*-*-*-*--****-*-*-*-*-*-*-*

					In	=	GetValue(FG,0x80000000|TAG_ClipStartField);
					Out	=	(In+GetValue(FG,0x80000000|TAG_Duration))>>1;
					In >>= 1;
					A		=	GetValue(FG,0x80000000|TAG_RecFields)>>1;
					S		=	GetValue(FG,0x80000000|TAG_FadeInVideo);
					S=((S!=0) ? 0:1);
//					B		=	GetValue(FG,0x80000000|TAG_FadeOutVideo);
					B=((B!=0) ? 0:1);
					SP[0]=In;
					SP[1]=Out;
					SP[2]=S;
					SP[3]=B;
					Time=(A=GetValue(FG,0x80000000|TAG_Duration));
					AudClipPL[1].Label = Label;
					AudClipPL[1].Param = (LONG *)Label;
					AudClipPL[1].Param2 = (LONG *)80;

					AudClipPL[2].Param = (LONG *)1;
					AudClipPL[2].Param2 = (LONG *)Names;
					AudClipPL[2].PropStart = 5;

//					AudClipPL[2].PropStart = 1;
//					AudClipPL[2].PropEnd = A-2;  // Min length= 1 colorframe
					AudClipPL[4].Param = &Out;
					AudClipPL[4].PropStart = 1;
					AudClipPL[4].PropEnd = A;
					AudClipPL[6].Param = AudClipPL[4].Param; // out
					AudClipPL[6].Param2 = AudClipPL[3].Param; // in
					AudClipPL[3].Param = &S;
					AudClipPL[5].Param = &B;
					if(Panel(Edit,AudClipPL) ) ;
					else BagIt=TRUE;
					break;

//--------------------------------------------------------
				case CT_VIDEO:
					In	=	GetValue(FG,0x80000000|TAG_ClipStartField);

	DUMPMSG("Before GetValue3");

					Out	=	(In+GetValue(FG,0x80000000|TAG_Duration))>>1;
		DUMPMSG("   after GetValue");
					In >>= 1;
					A		=	GetValue(FG,0x80000000|TAG_RecFields)>>1;
					B		=	GetValue(FG,0x80000000|TAG_FadeInVideo);
					B=((B!=0) ? 0:1);
					SP[0]=In;
					SP[1]=Out;
					SP[2]=B;

					SP[3]= GetValue(FG,0x8000000|TAG_ClipStartPoint);
					SP[4]= GetValue(FG,0x8000000|TAG_ClipEndPoint);
					SP[5]= GetValue(FG,0x8000000|TAG_ClipStartField);
					SP[6]= GetValue(FG,0x8000000|TAG_Duration);

					ClipPL[1].Label = Label;
					ClipPL[2].Param = (long *)FG->Data; // icon bitmap
					ClipPL[5].Param = &In;
					ClipPL[5].PropStart = 1;
					ClipPL[5].PropEnd = A-2; // Min length= 1 colorframe
					ClipPL[6].Param = &Out;
					ClipPL[6].PropStart = 1;
					ClipPL[6].PropEnd = A;
					ClipPL[3].Param = ClipPL[6].Param; // out
					ClipPL[3].Param2 = ClipPL[5].Param; // in
					ClipPL[8].Param=&B; // Fade In NOT

					DUMPMSG	("----- BEFORE Panel ----");

					if(Panel(Edit,ClipPL))
					{
						DUMPMSG("after panel");

						if(B!=SP[2]) PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);

						DUMPMSG("after put fadein");

						if(In!=SP[0]) PutValue(FG,0x80000000|TAG_ClipStartField,In<<1);

						DUMPMSG("after put clipstart");

						if(Out!=SP[1])	{
							DUMPMSG("Before PutValue4");

							DUMPUDECL("****** NEW DURATION=",(LONG)((Out-In)<<1),"\\");

						 	PutValue(FG,0x80000000|TAG_Duration,(Out-In)<<1);
							DUMPMSG("   after GetValue");
						}

					}
					else	{
// The Jog/Shuttle may have affected these values, so we restore them!!
							DUMPMSG("CANCEL WAS CLICKED");

							PutValue(FG,0x8000000|TAG_ClipStartPoint,SP[3]);
							PutValue(FG,0x8000000|TAG_ClipEndPoint,SP[4]);
							PutValue(FG,0x8000000|TAG_ClipStartField,SP[5]);
							PutValue(FG,0x8000000|TAG_Duration,SP[6]);
							BagIt=TRUE;
					}

					Main2Blank();

				DUMPMSG("before video break");

					break;

//--------------------------------------------------------
				case CT_CONTROL:

	DUMPMSG("Before GetValue5");

					Time=GetValue(FG,0x80000000|TAG_Duration)>>1; // Fields-->Frames
		DUMPMSG("   after GetValue");
					In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
					A=Time;
					B=GetValue(FG,0x80000000|TAG_FadeInVideo);
					B=((B!=0) ? 0:1);
					Out=B;
					VideoPL[1].Label =Label;
					VideoPL[2].Param = &Time;	// Time slider
					VideoPL[2].PropStart = 1;
					VideoPL[2].PropEnd = (In>=900 ? In:1800);
					VideoPL[3].Param = &B;
					if( Panel(Edit,VideoPL) )
					{
							if(A!=Time) {

							DUMPMSG("Before PutValue6");
							DUMPUDECL("****** NEW DURATION=",(LONG)(Time<<1),"\\");

								PutValue(FG,0x80000000|TAG_Duration,Time<<1);    // Frames -> Fields
		DUMPMSG("   after GetValue");
							}

							if(B!=Out)
								PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
					}
					else BagIt=TRUE;
					break;

//--------------------------------------------------------
				case CT_FRAMESTORE:

	DUMPMSG("Before GetValue8");
					Time=GetValue(FG,0x80000000|TAG_Duration)>>1; // Fields-->Frames
		DUMPMSG("   after GetValue");
					In=GetValue(FG,0x80000000|TAG_MaxDuration)>>1;
					A=Time;
					B=GetValue(FG,0x80000000|TAG_FadeInVideo);
					B=((B!=0) ? 0:1);
					Out=B;
					FramePL[2].Label =Label;
					FramePL[1].Param = (long *)FG->Data; // icon bitmap
					FramePL[3].Param = &Time;	// Time slider
					FramePL[3].PropStart = 1;
					FramePL[3].PropEnd = (In>=900 ? In:1800);
					FramePL[4].Param = &B;
					if( Panel(Edit,FramePL) )
					{
							if(A!=Time) {
	DUMPMSG("Before PutValue9");
						DUMPUDECL("****** NEW DURATION=",(LONG)(Time<<1),"\\");
			PutValue(FG,0x80000000|TAG_Duration,Time<<1);    // Frames -> Fields
		DUMPMSG("   after GetValue");
						}
						if(B!=Out) PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
					}
					else BagIt=TRUE;
					break;

//--------------------------------------------------------
				case CT_KEY:
	DUMPMSG("Before GetValue11");
					Time=(A=GetValue(FG,0x80000000|TAG_Duration));
		DUMPMSG("   after GetValue");

					DLay=(B=GetValue(FG,0x80000000|TAG_Delay));
					Speed=GetValue(FG,0x80000000|TAG_Speed); // bit0 =fade in, bit1=fade out
					KeyPL[2].Param = &Time;
					KeyPL[2].PropStart = 1;
					KeyPL[2].PropEnd = 3600;
					KeyPL[3].Param = &DLay;
					KeyPL[3].PropStart = 1;
					KeyPL[3].PropEnd = 600;
					In = (Speed&1); // set to crouton's 0=fade,1=cut
					KeyPL[4].Param = &In;
					Out = (Speed&2)>>1; // set to crouton's 0=fade,1=cut
					KeyPL[5].Param = &Out;
					if(Panel(Edit,KeyPL))
					{
						if(A!=Time)
						{
	DUMPMSG("Before PutValue12");
							PutValue(FG,0x80000000|TAG_Duration,Time);
		DUMPMSG("   after GetValue");
							SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
						}
					}
					else BagIt=TRUE;
					break;

//--------------------------------------------------------
				case CT_CRAWL:
					Speed=(A=GetValue(FG,0x80000000|TAG_Speed));
					CrawlPL[2].Param = &A;
					if(Panel(Edit,CrawlPL))
					{
						if(A!=Speed)
							PutValue(FG,0x80000000|TAG_Speed,A);
					}
					else BagIt=TRUE;
					break;

//--------------------------------------------------------
				case CT_SCROLL:
					Speed=(A=GetValue(FG,0x80000000|TAG_Speed));
					ScrollPL[2].Param = &A;
					if(Panel(Edit,ScrollPL))
					{
						if(A!=Speed)
							PutValue(FG,0x80000000|TAG_Speed,A);
					}
					else BagIt=TRUE;
					break;
			}

		DUMPMSG("after switch");


		}
		FG = Next;
	}
	DUMPMSG("before return edit");
	return(Edit);
}

BOOL __asm DoInfoPanel(
	register __a0 char *Path,
	register __a1 char *File,
	register __a2 struct EditWindow *Edit,
  register __d0 UWORD type )
{
	char *MPtr[5],*c;
	struct FileInfoBlock *fib;
	BPTR L;
	BOOL Success = FALSE,result=FALSE;
	WORD A,i=1;

	if(type<=GT_EFFECT) i=0;
	else  type-=GT_EFFECT;
	if (L = Lock(Path,ACCESS_READ))
	{
		if (fib = SafeAllocMem(sizeof(struct FileInfoBlock),MEMF_CLEAR))
		{
			if (Examine(L,fib))
			{
				strncpy(Name,fib->fib_FileName,MAX_STRING_BUFFER);
				strcpy(Size,"Size   ");
				FileInfoPL[2].Param=(LONG *)Name;
				FileInfoPL[2].Param2=(LONG *)MAX_STRING_BUFFER;
        FileInfoPL[3].Label = DTNames[type];
				FileInfoPL[4].Label = fib->fib_Comment;
				if (fib->fib_DirEntryType > 0) strcpy(Size,"Directory");
				else {
					stcl_d(&Size[5],fib->fib_Size);
					strcat(Size," bytes");
				}
				FileInfoPL[5].Label = Size;
				if (((ft=getft(Path)) != -1) && (strftime(&TempCh[7],60,"%A, %B %d, %Y %I:%M:%S %p",localtime(&ft))))
					FileInfoPL[6].Label =TempCh;

				strcpy(TempC2,"Attributes: ");
				if (fib->fib_Protection & FIBF_ARCHIVE)
					strcat(TempC2,"archived,");
				if (fib->fib_Protection & FIBF_PURE)
					strcat(TempC2,"reentrant,");
				if (fib->fib_Protection & FIBF_SCRIPT)
					strcat(TempC2,"script,");
				A = strlen(TempC2)-1;
				if (TempC2[A] == ',') TempC2[A] = 0;
				else strcat(TempC2,"none");
				FileInfoPL[7].Label = TempC2;

				strcpy(TempMem,"Protected from: ");
				if (fib->fib_Protection & FIBF_DELETE)
					strcat(TempMem,"deletion,");
				if (fib->fib_Protection & FIBF_EXECUTE)
					strcat(TempMem,"execution,");
				if (fib->fib_Protection & FIBF_WRITE)
					strcat(TempMem,"writing,");
				if (fib->fib_Protection & FIBF_READ)
					strcat(TempMem,"reading,");
				A = strlen(TempMem)-1;
				if (TempMem[A] == ',') TempMem[A] = 0;
				else strcat(TempMem,"nothing");
				FileInfoPL[8].Label = TempMem;

				if(result=Panel(Edit,FileInfoPL))
					if(strnicmp(Name,fib->fib_FileName,MAX_STRING_BUFFER) )
					{
						strncpy(Dir,Path,MAX_STRING_BUFFER);
						c=FilePart(Dir);
						*c=0;
								MPtr[0] = "Renaming";
								MPtr[1] = Path;
								MPtr[2] = " To ";
								MPtr[3] = Dir;
								MPtr[4] = Name;
						strncat(Dir,Name,119);
						if(SimpleRequest(Edit->Window,MPtr,4,REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,NULL))
							if ( !(Success=Rename(Path,Dir)) )
							{
								MPtr[0] = "Unable to rename";
								MPtr[1] = Path;
								MPtr[2] = IoErrToText(IoErr());
								SimpleRequest(Edit->Window,MPtr,3,REQ_CENTER|REQ_H_CENTER,NULL);
							}
							else
							{
								strncpy(Name,Path,119);
								strncat(Name,".i",119);
								strncat(Dir,".i",119);
								Rename(Name,Dir);
								strncat(Name,"nfo",119);
								strncat(Dir,".nfo",119);
								Rename(Name,Dir);
								DoAllNewDir(Edit);
							}
					}
				Success = TRUE;
			}
			FreeMem(fib,sizeof(struct FileInfoBlock));
		}
	UnLock(L);
	}
	return(result);
}


//*******************************************************************
//      Panel Specific Popup f'ns .. use global CurPLine

// AAR -- frzl 
char *NameFn(void *frzl, int Entries)
{
	char **PopUpNames=(char **)(CurPLine->Param);
	if (Entries < 0) Entries = 0;
	else if (Entries > ((CurPLine->PropEnd)-1)) Entries = (CurPLine->PropEnd)-1;
	return(PopUpNames[Entries]);
}

VOID RedrawPopText(struct Window *Window)
{
	char *C;
	struct Gadget *Gadget;

	if (Gadget = CurPLine->G1 ) {
		C = NameFn(NULL,( (int)CurPLine->PropStart ));
		SetFont(Window->RPort,EditFont);
		AnyPopupText(Gadget,C,Window,20);
	}
}

VOID HandlePopUp(struct Window *Window,struct IntuiMessage *IntuiMsg, struct PanelLine *PLine)
{
	PopUpID ID;
	struct Gadget *Gadget;
	WORD A,X,Y;

	CurPLine=PLine;
	PUCDefaultRender(&PopUp);
	PopUp.drawBG = (DrawBGFunc *)DrawBG;
//	Gadget = FindGadget(Window->FirstGadget,ID_POPUP_DISP);
	Gadget = CurPLine->G1;
	X = Gadget->LeftEdge + (Gadget->Width >> 1);
	Y = Gadget->TopEdge + (Gadget->Height >> 1);
	ID = PUCCreate((NameFunc *)NameFn,NULL,&PopUp);
	PUCSetNumItems(ID,CurPLine->PropEnd);
	PUCSetCurItem(ID,CurPLine->PropStart);

	Window->Flags |= WFLG_REPORTMOUSE;
	A = PUCActivate(ID,Window,X,Y,IntuiMsg->MouseX,IntuiMsg->MouseY);
	Window->Flags &= ~WFLG_REPORTMOUSE;
	PUCDestroy(ID);
	if (A >= 0)
	{
		if (A != ( (int)CurPLine->PropStart ))
		{
			CurPLine->PropStart = A;
		}
		RedrawPopText(Window);
	}
}


@


2.48
log
@Some error messages added.
HandlePanel and Panel modified trying to track down crashy NAB bug.
(NOTE! Please change Panel back to not using static variables).
@
text
@d3 4
a6 7
* $Id: project.c,v 2.47 94/03/19 17:54:13 CACHELIN4000 Exp Locker: Kell $
* $Log:	project.c,v $
*Revision 2.47  94/03/19  17:54:13  CACHELIN4000
**** empty log message ***
*
*Revision 2.46  94/03/19  17:36:17  CACHELIN4000
**** empty log message ***
d78 2
a79 1

d88 1
d121 2
d132 6
a137 3
struct BitMap *CurFGbm;
struct FastGadget *CurFG;
LONG	InOrOut=0;
d139 1
d164 1
a175 3
	{
		DUMPMSG("Before ProjectSelect() sends ES_Select");
		SendSwitcher(ES_Select,(LONG)Node,NULL,NULL);
d177 3
d181 2
a182 3
		DUMPMSG("  After ProjectSelect() sent ES_Select");
	}

d611 3
d1048 1
a1048 1
#define RAW_ENTER	0x43
d1051 10
a1060 1
#define RAW_HELP 	0x5f
d1065 1
a1065 1
#define NUM_VIEW 4
d1068 2
a1069 2
	Aud3[] = "Left only",Aud4[] = "Right only";
char *AudNames[] = { Aud1,Aud2,Aud3,Aud4 };
a1210 1
//	Expert=TRUE;
a1212 1
//		Expert=FALSE;
d1402 3
d1406 1
a1406 1
	if (SwitPort)
d1412 1
d1483 2
d1490 1
d1505 5
a1509 1
	PNL_FXTIME  // Like a DIFF, but attached to an FXSPEED
d1515 25
d1541 6
a1546 5
{ PNL_TEXT,PNL_LEFT,"Frame",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_TIME,PNL_CENTER,"Length",0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0 },
{ 0,0,0,0 } // end of array marker
d1550 5
a1554 5
{ PNL_TEXT,PNL_LEFT,"Video Input",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_TIME,PNL_CENTER,"Length",0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0 },
{ 0,0,0,0 } // end of array marker
d1558 5
a1562 5
{ PNL_TEXT,PNL_LEFT,"Effect",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_FXSPEED,PNL_LEFT,"Speed",0 },
{ PNL_TIME,PNL_CENTER,"Length",0 },
{ 0,0,0,0 } // end of array marker
d1566 6
a1571 6
{ PNL_TEXT,PNL_LEFT,"Effect",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_FXSPEED,PNL_LEFT,"Speed",0 },
// { PNL_DIFF,PNL_LEFT,"Length:  ",0 },
{ PNL_FXTIME,PNL_LEFT,"Length:  ",0 },
{ 0,0,0,0 } // end of array marker
d1574 1
d1576 1
a1576 1
{ PNL_TEXT,PNL_LEFT,"Video Clip",0 },
d1578 9
a1586 5
{ PNL_DIFF,PNL_LEFT,"Length: ",0 },
{ PNL_TIME,PNL_LEFT,"In",0 },  // Changing where these are in array will break UpdatePanStr()
{ PNL_TIME,PNL_LEFT,"Out",0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0 },
{ 0,0,0,0 } // end of array marker
d1590 9
a1598 9
{ PNL_TEXT,PNL_LEFT,"Audio Clip",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_TIME,PNL_LEFT,"Delay",0 },
{ PNL_TIME,PNL_LEFT,"In",0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0 },
{ PNL_TIME,PNL_LEFT,"Out",0 },
{ PNL_OUT_TYPE,PNL_LEFT,0,0 },
{ PNL_DIFF,PNL_LEFT,"Length: ",0 },
{ 0,0,0,0 } // end of array marker
d1602 7
a1608 7
{ PNL_TEXT,PNL_LEFT,"CG Key",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_TIME,PNL_LEFT,"Delay",0 },
{ PNL_TIME,PNL_LEFT,"Length",0 },
{ PNL_IN_TYPE,PNL_LEFT,0,0 },
{ PNL_OUT_TYPE,PNL_LEFT,0,0 },
{ 0,0,0,0 } // end of array marker
d1612 4
a1615 4
{ PNL_TEXT,PNL_LEFT,"CG Crawl",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_CHOICE4,PNL_LEFT,"Speed",0 },
{ 0,0,0,0 } // end of array marker
d1618 4
a1621 4
{ PNL_TEXT,PNL_LEFT,"CG Scroll",0 },
{ PNL_TEXT,PNL_LEFT,"name",0 },
{ PNL_CHOICE5,PNL_LEFT,"Speed",0 },
{ 0,0,0,0 } // end of array marker
d1625 5
a1629 3
{ PNL_TEXT,PNL_CENTER,"<victim's name>",0 },
{ PNL_TEXT,PNL_LEFT,"Would like to eat?",0 },
{ PNL_TOGGLE,PNL_LEFT,"Rolls",0 },
d1631 4
a1634 4
{ PNL_TOGGLE, PNL_LEFT, "Potatoes",0 },
{ PNL_TOGGLE,PNL_LEFT,"Chicken",0 },
{ PNL_TOGGLE,PNL_CENTER,"Gravy",0 },
{ 0,0,0,0 } // end of array marker
d1638 1
a1638 1
#define PNL_WIDTH 272 // 238
d1641 1
d1643 1
a1643 1
#define PTEXT_H 36 // 23
d1645 1
d1649 1
d1657 2
d1849 1
a1849 1
BOOL Panel(struct EditWindow *Edit,struct PanelLine *PLine)
d1851 1
a1851 2
/***********************
	WORD H = PNL_Y1,ID,A,B;
d1853 2
a1854 1
	struct Gadget *FirstG=0,*ThisG=0,*NewG=0,*Down=0,**PPGadg;
d1857 1
a1857 1
	BOOL Going = TRUE, Success = FALSE;
a1860 1
***********************/
a1861 18
	static struct Window *Window;
	static struct RastPort *RP;
	static WORD H,ID,A,B;
	static struct PanelLine *Start,*temp,*LastTime;
	static struct Gadget *FirstG,*ThisG,*NewG,*Down,**PPGadg;
	static BOOL Going, Success;
	static struct IntuiMessage *IntuiMsg;
	static char *ch;
	static LONG *L,Y;

	H = PNL_Y1;
	FirstG=0;
	ThisG=0;
	NewG=0;
	Down=0;
	Window=0;
	Going = TRUE;
	Success = FALSE;
d1863 7
d1871 2
a1872 2
	Start = PLine;
	while (PLine->Type) 
d1874 1
a1874 1
		switch(PLine->Type) 
d1878 1
d1881 3
a1883 1
			NewG->LeftEdge = (PNL_WIDTH-80)>>1;
d1886 1
a1886 1
			NewG->Width = 80;
d1888 1
a1888 2
			LongToTime(PLine->Param,((struct StringInfo *)NewG->SpecialInfo)->
				Buffer);
d1894 1
a1894 1
			NewG->LeftEdge = PNL_X1;
d1897 1
a1897 1
			NewG->Width = 181;
d1917 14
a1930 2

			H += PTIME_H;
d1954 1
a1954 1
			NewG->LeftEdge = (PNL_WIDTH - NewG->Width) >> 1;
d1960 6
a1965 1
			H += PIN_H;
d2000 1
a2000 1
			for (B=0;B<A;B++) 
d2025 2
a2026 2
      if(PLine->Param==0) NewG->Flags &= (~GFLG_SELECTED);
      else NewG->Flags |= GFLG_SELECTED;
d2031 41
d2075 1
a2076 1
// open window
d2081 1
a2081 1
	NewG->LeftEdge = PNL_WIDTH - NewG->Width - 8;
a2085 1
	// H += PNL_YADD + NewG->Height;
d2090 1
a2090 2

	ClipNW.Width = PNL_WIDTH;
d2100 2
a2101 1
	if (Window = OpenWindow((struct NewWindow *)&ClipNW)) {
a2105 3
		if(CurFGbm) CopyCrut(CurFGbm,RP->BitMap,
			ClipNW.LeftEdge + PNL_WIDTH - 80 -3,
			ClipNW.TopEdge +6,Edit->RowSize-2);
a2106 1

d2108 1
d2110 1
a2110 1
		while (PLine->Type) 
d2112 1
a2112 1
			switch(PLine->Type) 
d2119 1
a2119 1
				if (PLine->Label) 
d2121 1
a2121 1
					Move(RP,PNL_X1,H+PTIME_YOFF+TEXT_BASE-1);
d2125 18
a2144 1

d2161 6
a2166 1
				H += PIN_H;
d2192 16
d2218 4
d2238 1
a2238 1
					if( LastTime==&(ClipPL[3]) ) InOrOut=0;
d2262 3
d2300 14
a2313 6
						ch= ((struct StringInfo *)ThisG->SpecialInfo)->Buffer;
						L = PLine->Param;
						TimeToLong(ch,L); // update long & flush bogus values
						UpdatePanProp(PLine,Window);
						UpdatePanStr(PLine,Window);
						UpdateAllDiff(RP,Start,Window);
d2316 1
a2316 1
						*(PLine->Param) = ( *(PLine->Param) ? 0:1 ) ;  // invert value...
a2317 5
//					case ID_IN_TYPE:
//					case ID_OUT_TYPE:
//						if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
//						else *(PLine->Param) = 0;
//						break;
d2365 15
a2379 2
					if ((A == RAW_ENTER)||(A == RAW_RETURN)||
						(A == RAW_ESCAPE)||(A == RAW_HELP)) {
d2381 1
a2381 1
					}
a2385 3

		DUMPMSG	("Before closewindow");

a2386 4

		DUMPMSG	("Befoer waitblit");


a2388 3
	DUMPMSG	("update modified params");


d2390 18
a2407 12
	PLine = Start;
	while (PLine->Type) {
		switch(PLine->Type) {
		case PNL_TIME:
			TimeToLong(((struct StringInfo *)PLine->StrGadg->SpecialInfo)->
				Buffer,PLine->Param);
		break;
		case PNL_IN_TYPE:
		case PNL_OUT_TYPE:
			if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
			else *(PLine->Param) = 0;
		break;
a2408 1
		PLine++;
a2409 5

	}

	goto ErrExit2;	// Attempt at fixing some weird stack problem

a2410 4
	DUMPMSG	("befoer freegadgets");


ErrExit2:	// Attempt at fixing some weird stack problem
a2411 4
	
	DUMPMSG	("return from panel");


d2448 3
d2458 1
d2462 1
a2462 1
	DUMPHEXIL("Starting FG=",(LONG)FG,"\\");	
d2464 1
a2464 1
	while (FG)
d2466 1
a2466 1
		DUMPHEXIL("while FG=",(LONG)FG,"\\");	
a2474 1
      	CurFGbm=(struct BitMap *)FG->Data;
d2506 1
d2526 1
a2531 1
					In	=	GetValue(FG,0x80000000|TAG_ClipStartField);
d2533 3
a2535 1
		DUMPMSG("Before GetValue1");
d2537 10
a2546 3
					Out	=	(In+GetValue(FG,0x80000000|TAG_Duration))>>1;

		DUMPMSG("   after GetValue");
d2548 2
d2551 2
d2563 4
d2568 3
a2570 1
	DUMPMSG("Before GetValue2");
d2572 2
a2573 6
					Time=(A=GetValue(FG,0x80000000|TAG_Duration));
		DUMPMSG("   after GetValue");
					AudClipPL[1].Label = Label;
					AudClipPL[2].Param = &In;
					AudClipPL[2].PropStart = 1;
					AudClipPL[2].PropEnd = A-2;  // Min length= 1 colorframe
d2581 2
a2582 1
					Panel(Edit,AudClipPL);
d2607 10
a2616 9
					ClipPL[3].Param = &In;
					ClipPL[3].PropStart = 1;
					ClipPL[3].PropEnd = A-2; // Min length= 1 colorframe
					ClipPL[4].Param = &Out;
					ClipPL[4].PropStart = 1;
					ClipPL[4].PropEnd = A;
					ClipPL[2].Param = ClipPL[4].Param; // out
					ClipPL[2].Param2 = ClipPL[3].Param; // in
					ClipPL[5].Param=&B; // Fade In NOT
d2623 1
a2623 1
						
d2650 1
d2677 1
a2677 1
						{
d2689 2
a2690 1
						}
d2704 6
a2709 5
					FramePL[1].Label =Label;
					FramePL[2].Param = &Time;	// Time slider
					FramePL[2].PropStart = 1;
					FramePL[2].PropEnd = (In>=900 ? In:1800);
					FramePL[3].Param = &B;
a2717 1

d2720 1
d2742 1
d2750 2
d2759 1
d2762 2
d2771 1
d2774 2
d2778 1
a2778 1
			
d2785 135
d2921 10
a2930 1
	DUMPMSG("befoer return edit");
d2932 12
a2943 2
	
	return(Edit);
d2945 2
@


2.47
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.46 94/03/19 17:36:17 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d1110 1
d1139 7
d1726 3
d1732 2
a1733 1
	LONG A;
d1736 10
a1745 2
	if ( (PLine==&ClipPL[3]) || (PLine==&ClipPL[4]) )
		DHD_Jump(InOrOut,(ULONG)*PLine->Param,(ULONG)CurFG);
d1782 3
d1787 1
d1797 1
d1799 19
d1820 4
a1823 2
	while (PLine->Type) {
		switch(PLine->Type) {
d1929 2
a1930 1
			for (B=0;B<A;B++) {
d2002 4
a2005 2
		while (PLine->Type) {
			switch(PLine->Type) {
d2011 2
a2012 1
				if (PLine->Label) {
d2018 1
a2018 1
			break;
d2133 2
d2141 1
d2144 1
a2144 1
						Going = FALSE;
d2217 3
d2221 4
d2227 3
d2246 1
d2249 2
d2252 4
d2257 5
a2261 1
	return(Success);
d2301 1
a2301 1
	LONG A=0,B=2,In,Out,type,Speed=1,Time,S,SP[5],DLay;
d2306 3
d2311 2
d2319 3
a2321 2
      CurFG=FG;
      CurFGbm=(struct BitMap *)FG->Data;
d2324 1
d2373 2
d2377 3
d2381 4
d2396 2
d2399 1
d2413 2
d2417 3
d2421 1
d2429 6
d2445 3
d2450 2
d2453 3
d2457 27
a2483 2
						if(Out!=SP[1]) PutValue(FG,0x80000000|TAG_Duration,(Out-In)<<1);
					}
d2485 2
d2488 3
d2492 1
d2503 1
a2503 1
					if( Panel(Edit,FramePL) )
d2505 5
a2509 1
							if(A!=Time)
d2511 3
d2518 2
d2521 2
d2524 1
d2536 10
a2545 6
						{
							if(A!=Time)
								PutValue(FG,0x80000000|TAG_Duration,Time<<1);    // Frames -> Fields
							if(B!=Out)
								PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
						}
d2547 2
d2550 1
d2552 2
d2569 1
d2571 1
d2575 2
d2584 2
d2594 4
d2601 4
@


2.46
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.44 94/03/19 15:51:18 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d1113 3
a1115 1
	return((ULONG)SendSwitcherReply(ES_InitRecord,0,0,0));
d1123 3
a1125 1
	return((ULONG)SendSwitcherReply(ES_InitPlay,0,0,0));
d1180 1
a1180 1
	if(!(DHD_InitRecord(0,0xc0ded00d)==0) ) goto ErrExit;
@


2.45
log
@*** empty log message ***
@
text
@d1173 2
a1174 1
	if(!DHD_InitRecord(0,0xc0ded00d)) goto ErrExit;
@


2.44
log
@DHD Support, Expert mode record panel
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.43 94/03/19 15:40:27 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 2
d1359 1
a2309 1
					if(!DHD_InitPlay(0,0xbadb00b1)) break;
@


2.43
log
@DHD Support, Expert mode record panel
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.42 94/03/19 13:05:05 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 1
a8 6
*Revision 2.41  94/03/19  12:14:20  CACHELIN4000
**** empty log message ***
*
*Revision 2.40  94/03/19  09:11:05  Kell
**** empty log message ***
*
d1144 1
a1144 1
	return((ULONG)SendSwitcherReply(ES_Shuttle,FG,Unit,0));
d2062 2
a2063 1
						DHD_Play(InOrOut,(ULONG)*LastTime->Param,LastTime->PropEnd,(ULONG)CurFG);
@


2.42
log
@Fix Jr.s dumb parentheses bug in PNL_IN_TYPE
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.41 94/03/19 12:14:20 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d129 2
d1109 9
a1117 1
ULONG	DHD_Init(ULONG Unit,ULONG Flags)
d1121 1
a1121 1
	return(696969);
d1127 1
d1131 1
a1131 1
ULONG	DHD_Record(ULONG Unit, ULONG Start, ULONG Length, ULONG Flags)
d1135 1
a1135 1
	DUMPUDECL(" ",Length,",");
d1137 1
a1137 1
	return(696969);
d1142 2
a1143 1
ULONG	DHD_Play(ULONG Unit, ULONG Start, ULONG Length, ULONG Flags)
d1148 2
a1149 2
	DUMPHEXIL(" ",Flags ," ); \\ ");
	return(Start+Length>>1);
d1152 2
a1153 1
void	DHD_Jump(ULONG Unit, ULONG Spot, ULONG Flags)
d1157 2
a1158 1
	DUMPHEXIL(" ",Flags ," ); \\ ");
d1162 1
d1172 1
a1172 1
	BOOL Going = TRUE;
a1174 1
	LONG MaxBlocks=696969,StartBlock=714;
d1176 1
a1176 1
	if(!DHD_Init(0,0xc0ded00d)) goto ErrExit;
d1178 5
d1185 4
a1188 1
	ClipNW.Height = 236;
d1209 23
a1231 20

	if (!(Start = AllocOneGadget(&StringGadg))) goto ErrExit;
	StringGadg.NextGadget = Start;
	Start->Width=100;
	Start->Height=TEXT_HEIGHT;
	Start->LeftEdge = ((ClipNW.Width-Start->Width)>>1);
	Start->TopEdge = StringGadg.TopEdge + StringGadg.Height + 4 + LSP;
	st_val = ((struct StringInfo *)Start->SpecialInfo)->Buffer;
	stcl_d(st_val,StartBlock);
	stid=Start->GadgetID;

	if (!(Max = AllocOneGadget(&StringGadg))) goto ErrExit;
	Start->NextGadget = Max;
	Max->Width=100;
	Max->Height=TEXT_HEIGHT;
	Max->LeftEdge = ((ClipNW.Width-Max->Width)>>1);
	Max->TopEdge = Start->TopEdge + Start->Height + 4 + LSP;
	mx_val = ((struct StringInfo *)Max->SpecialInfo)->Buffer;
	stcl_d(mx_val,MaxBlocks);
	mxid=Max->GadgetID;
d1264 11
a1274 10
		NewBorderBox(RP,Max->LeftEdge-4,Max->TopEdge-6,
			Max->LeftEdge+Max->Width+4-1,
			Max->TopEdge+Max->Height+5-1,
			BOX_REV_BORDER);

		NewBorderBox(RP,Start->LeftEdge-4,Start->TopEdge-6,
			Start->LeftEdge+Start->Width+4-1,
			Start->TopEdge+Start->Height+5-1,
			BOX_REV_BORDER);

a1281 6
		Move(RP,36,Start->TopEdge+8);
		SafeColorText(RP,"Start: ",7);

		Move(RP,36,Max->TopEdge+8);
		SafeColorText(RP,"Total: ",7);

d1285 7
d1303 1
a1303 1
						else if (ID == ID_REQ_RECORD) DHD_Record(0,StartBlock,MaxBlocks,0xc0edbabe);
d1310 2
a1311 2
						else if(ID == stid) stcd_l(st_val,&StartBlock);
						if(ID == mxid) stcd_l(mx_val,&MaxBlocks);
a1315 3
//					DUMPMSG("Hey, GADGETDOWN does work!!!");
//					if (ID == ID_REQ_RECORD) DUMPMSG("Recording...");
//						DHD_Record(0,StartBlock,MaxBlocks,0xc0edbabe);
d1338 10
a1347 7
	if (Max) {
		Max->NextGadget = NULL;
		FreeGadgets(Max);
	}
	if (Start) {
		Start->NextGadget = NULL;
		FreeGadgets(Start);
d1361 2
a1362 2
	DUMPUDECL("Max Blocks = ",MaxBlocks,"\\");
	DUMPUDECL("Start = ",StartBlock,"\\");
d1480 8
d1716 1
a1716 1
		DHD_Jump(0,(ULONG)*PLine->Param,0xd00b1ed0);
d2029 2
d2067 1
a2067 1
						DHD_Play(0,(ULONG)*LastTime->Param,LastTime->PropEnd,0xf00dbead);
d2230 1
d2287 4
a2290 1
					B		=	GetValue(FG,0x80000000|TAG_FadeInVideo)^1;
d2293 2
a2294 1
					SP[2]=B;
a2296 1
					B=0;
d2298 1
a2298 1
					AudClipPL[2].Param = &Time;
d2300 2
a2301 2
					AudClipPL[2].PropEnd = 3600;
					AudClipPL[4].Param = &B;
d2303 1
a2303 1
					AudClipPL[4].PropEnd = 3600;
d2306 2
a2307 4
					In = 0; // set to crouton's 0=fade,1=cut
					AudClipPL[3].Param = &In;
					Out = 0; // set to crouton's 0=fade,1=cut
					AudClipPL[5].Param = &Out;
d2311 1
d2316 2
a2317 1
					B		=	GetValue(FG,0x80000000|TAG_FadeInVideo)^1;
d2324 1
a2324 1
					ClipPL[3].PropEnd = A;
d2327 1
a2327 1
					ClipPL[4].PropEnd = A+2;  // Add a colorframe
d2339 19
d2363 1
a2363 1
					B=((B!=0) ? 1:0);
a2371 2
//					DUMPUDECL	("out=",(LONG)Out,"\\");
//					DUMPUDECL	("b=",(LONG)B,"\\");
d2375 1
a2375 1
								PutValue(FG,0x80000000|TAG_FadeInVideo,B);
a2376 3

//					DUMPUDECL	("panel=",(LONG)foo,"\\");

@


2.41
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.40 94/03/19 09:11:05 Kell Exp Locker: CACHELIN4000 $
d5 3
d2054 5
a2058 5
					case ID_IN_TYPE:
					case ID_OUT_TYPE:
						if (PLine->G1->Flags & GFLG_SELECTED) *(PLine->Param) = 1;
						else *(PLine->Param = 0);
						break;
d2128 1
a2128 1
			else *(PLine->Param = 0);
d2314 1
a2314 1
								PutValue(FG,0x80000000|TAG_FadeInVideo,B^1);
@


2.40
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: project.c,v 2.39 94/03/19 03:12:10 CACHELIN4000 Exp Locker: Kell $
* $Log:	project.c,v $
d1477 1
d1521 1
a1521 1
#define PNL_WIDTH 288 // 238
d1525 1
a1525 1
#define PTEXT_H 42 // 23
d1538 1
a1538 1
// converts MM:SS:FF to LONG # of fields
d1543 1
a1543 1
	
d1796 1
d2049 7
a2055 2
						*(PLine->Param) ^= 0xFFFFFFFF ;  // invert value...
					break;
a2174 1
	BOOL	foo;
d2239 9
d2291 1
d2296 2
a2297 1
					B=GetValue(FG,0x80000000|TAG_FadeInVideo)^1;
d2302 1
a2302 1
					FramePL[2].PropEnd = In;		// (In>=900 ? In:1800);
d2304 1
a2304 1
					if(foo=Panel(Edit,FramePL))
a2350 10
					break;
				case CT_CONTROL:
					A = 0;
		      B = 1;
					TestPL[2].Param = &A;
					TestPL[5].Param = &B;
					TestPL[4].Param = &B;
					Panel(Edit,TestPL);
		      if(A==1) BoolRequest(Edit->Window,"Are you sure?, They're real good!");
						// check A value here, update crouton
@


2.39
log
@DHD TAG type support
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.38 94/03/19 00:55:08 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d1555 2
a1556 2
	else if (A == 2) *L = Z[0]*60 + Z[1];
	else if (A >= 3) *L = Z[0]*3600 + Z[1]*60 + Z[2];
d2165 1
d2192 1
a2192 1
					In=GetValue(FG,0x80000000|TAG_MaxDuration);
d2218 1
a2218 1
						EffectPL[3].PropEnd = (In>=330 ? In:330);
d2248 3
a2250 2
					In	=	GetValue(FG,0x80000000|TAG_ClipStartField)>>1;
					Out	=	GetValue(FG,0x80000000|TAG_ClipEndField)>>1;
d2252 1
a2252 1
					B		=	GetValue(FG,0x80000000|TAG_FadeInVideo);
d2255 1
a2255 1
					SP[1]=B;
d2268 1
a2268 1
						if(B!=SP[2]) PutValue(FG,0x80000000|TAG_FadeInVideo,B);
d2270 1
a2270 1
						if(Out!=SP[1]) PutValue(FG,0x80000000|TAG_ClipEndField,Out<<1);
d2275 1
a2275 1
					In=GetValue(FG,0x80000000|TAG_MaxDuration);
d2277 1
a2277 1
					B=GetValue(FG,0x80000000|TAG_FadeInVideo);
d2282 1
a2282 1
					FramePL[2].PropEnd = (In>=900 ? In:1800);;
d2284 1
a2284 2
					if(Panel(Edit,FramePL))
						if( (A!=Time) || (B!=Out) )
d2286 2
d2291 1
a2291 2
								PutValue(FG,0x80000000|TAG_FadeInVideo,B);
							SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
d2293 3
@


2.38
log
@Fix SMPTE string .
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.36 94/03/18 21:13:29 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d2188 1
a2210 1
						EffectPL[2].PropStart =(LONG)&EffectPL[3];	// PLine (time) to update
d2214 1
a2214 1
						EffectPL[3].PropEnd = 300;
d2244 7
a2250 2
					Time=GetValue(FG,0x80000000|TAG_Duration)>>1;
					B=0;
d2252 1
a2252 1
					ClipPL[3].Param = &B;
d2254 2
a2255 2
					ClipPL[3].PropEnd = 3600;
					ClipPL[4].Param = &Time;
d2257 1
a2257 1
					ClipPL[4].PropEnd = 3600;
d2260 1
a2260 1
					ClipPL[5].Param=0; // Fade In NOT
d2263 3
a2265 1
//						PutValue(FG,0x80000000|TAG_FadeIn,(ClipPL[5].Param)<<1);
d2270 1
d2272 2
a2273 1
					B=0;
d2277 1
a2277 1
					FramePL[2].PropEnd = 900;
d2280 1
a2280 1
						if(A!=Time)
d2282 4
a2285 2
							PutValue(FG,0x80000000|TAG_Duration,Time<<1);    // Frames -> Fields
//						PutValue(FG,0x80000000|TAG_FadeIn,FramePL[3].Param);
@


2.37
log
@Fix SMPTE string.
@
text
@d2241 1
a2241 1
					Time=(A=GetValue(FG,0x80000000|TAG_Duration));
d2255 1
a2255 1
//						PutValue(FG,0x80000000|TAG_FadeIn,ClipPL[5].Param);
d2270 1
a2270 1
							PutValue(FG,0x80000000|TAG_Duration,Time);
@


2.36
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.35 94/03/18 18:20:23 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d1554 1
d1560 4
a1563 4
	B = A / 3600;
	A %= 3600;
	C = A / 60;
	A %= 60;
a2173 22
				case CT_FXANIM:
					Speed=GetValue(FG,0x80000000|TAG_FCountMode);
					Speed&=0x00000003;
					B=notFCM[Speed];
					SP[0]=GetValue(FG,0x80000000|TAG_NumFramesSlow);
					SP[1]=GetValue(FG,0x80000000|TAG_NumFramesMedium);
					SP[2]=GetValue(FG,0x80000000|TAG_NumFramesFast);
					SP[3]=GetValue(FG,0x80000000|TAG_NumFramesVariable);
					S=SP[notFCM[Speed]];
					A=0;
					AnimFXPL[1].Label =Label;
					AnimFXPL[2].Param =&B;				// SMFV choice
					AnimFXPL[2].Param2 =SP;  // Array of speeds
					AnimFXPL[2].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME
					AnimFXPL[3].Param = &S;	// Time label
					AnimFXPL[3].Param2 = &A;
					if( Panel(Edit,AnimFXPL) && (B!=notFCM[Speed]) )
					{
						PutValue(FG,0x80000000|TAG_FCountMode,FCM[B]);
						SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
					}
					break;
d2177 1
d2180 1
a2180 1
					B=notFCM[Speed]; // B=gadget button SMFV=0123
d2186 16
a2201 10
					EffectPL[1].Label =Label;
					EffectPL[2].Param =&B;						// SMFV choice
					EffectPL[2].Param2 =SP;						// Array of field counts
					EffectPL[2].PropStart =(LONG)&EffectPL[3];	// PLine (time) to update
					EffectPL[2].PropStart =(LONG)&EffectPL[3];	// PLine (time) to update
					EffectPL[3].Param = &S;	// Time slider
					EffectPL[3].Param2 = (LONG *)&EffectPL[2];	// FXSpeed gadg to set to V
					EffectPL[3].PropStart = 1;
					EffectPL[3].PropEnd = 300;
					if( Panel(Edit,EffectPL) && ( (S!=SP[3]) || (B!=notFCM[Speed]) ) )
d2203 17
a2219 5
						if(B!=notFCM[Speed])
							PutValue(FG,0x80000000|TAG_FCountMode,FCM[B]); // FCM[3]=2 = variable
						if( B==3 )
							PutValue(FG,0x80000000|TAG_NumFramesVariable,S);
						SendSwitcherReply(ES_FGcommand,(LONG)FG,FGC_FCOUNT,0);
d2259 1
a2259 1
					Time=GetValue(FG,0x80000000|TAG_Duration);
@


2.35
log
@re-enable default project name if(*ProjectName==0)
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.34 94/03/18 17:14:29 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d1329 3
a1331 1
		if(*ProjectName==0) strcpy(ProjectName,DEF_PROJ_DIR DEF_PROJ_NAME);
d1430 1
a1430 1
{ PNL_TIME,PNL_LEFT,"Length",0 },
d1439 1
a1439 1
{ PNL_TIME,PNL_LEFT,"Length",0 },
d1508 1
a1508 1
#define PNL_WIDTH 256 // 238
d1512 1
a1512 1
#define PTEXT_H 23
@


2.34
log
@Add Icon to Panel
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.33 94/03/18 09:26:41 Kell Exp Locker: CACHELIN4000 $
d5 3
d1326 1
a1326 1
//		if(!ProjectName[0]) strcpy(ProjectName,DEF_PROJ_DIR DEF_PROJ_NAME);
d2253 3
a2255 2
// Enforcer hits from this tag
					Time=(A=GetValue(FG,0x80000000|TAG_Duration));
d2260 1
a2260 1
					FramePL[3].Param = 0;
@


2.33
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: project.c,v 2.32 94/03/18 06:11:34 Kell Exp Locker: Kell $
* $Log:	project.c,v $
d104 2
d1405 4
a1408 1
	PNL_TEXT=1, PNL_TIME, PNL_IN_TYPE, PNL_OUT_TYPE, PNL_CHOICE4, PNL_CHOICE5,
d1411 3
a1413 2
	PNL_FXSPEED,   // Param2 is array of 4(ULONG) field counts: S,M,F,V for FXTIME
	PNL_FXTIME
d1421 1
a1421 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1429 1
a1429 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1437 1
a1437 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1446 1
a1446 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1448 1
a1448 1
{ PNL_TIME,PNL_LEFT,"In",0 },
d1456 1
a1456 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1467 1
a1467 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1477 1
a1477 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1483 1
a1483 1
{ PNL_TEXT,PNL_CENTER,"name",0 },
d1500 1
a1500 1
#define PNL_WIDTH 238
d1615 19
d1652 2
a1653 1
	DHD_Jump(0,(ULONG)*PLine->Param,0xd00b1ed0);
d1875 3
d1963 1
d2062 1
a2062 1
							*temp->Param=PLine->Param2[A&0x0003];
d2066 2
a2067 2
						else UpdateFXTime(RP,Start,PLine->Param2[A&0x0003],Window);
						RefreshGList(PLine->G1,Window,0,5);
d2125 10
d2136 1
d2146 1
a2146 1
	LONG A=0,B=2,In,Out,type,Speed=1,Time,S,V,SP[5],DLay;
d2159 1
a2189 6
/*
					SP[0]=(S=GetValue(FG,0x80000000|TAG_SlowFCount));
					SP[1]=(M=GetValue(FG,0x80000000|TAG_MedFCount));
					SP[2]=(F=GetValue(FG,0x80000000|TAG_FastFCount));
					SP[3]=(V=GetValue(FG,0x80000000|TAG_VariableFCount));
*/
d2193 1
a2193 1
					SP[3]=(V=GetValue(FG,0x80000000|TAG_NumFramesVariable));
d2199 1
d2201 1
d2209 1
a2209 1
							PutValue(FG,0x80000000|TAG_VariableFCount,S);
d2250 1
@


2.32
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: project.c,v 2.31 94/03/18 05:04:48 CACHELIN4000 Exp Locker: Kell $
d5 3
@


2.31
log
@Video Clip support
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.30 94/03/17 21:28:11 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
@


2.30
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.29 94/03/17 09:53:38 Kell Exp Locker: CACHELIN4000 $
d5 3
d1065 49
d1119 1
a1119 1
	struct Gadget *Gadget,*Cancel=NULL,*Record,*Stop,*Aud;
d1121 1
d1124 4
d1131 1
a1131 1
	ClipNW.Height = 200;
d1138 2
a1139 1
	Gadget = FindGadget(&Gadget1,ID_REQ_DARK_CANCEL);
d1153 20
d1175 1
a1175 1
	StringGadg.NextGadget = Record;
d1177 1
a1177 1
	Record->TopEdge = StringGadg.TopEdge + StringGadg.Height + 4 + LSP;
d1203 11
d1220 7
d1239 11
a1249 2
					if ((ID == ID_REQ_DARK_CANCEL) || (ID == ID_REQ_STOP))
						Going = FALSE;
d1254 5
a1258 1
					if (ID == ID_POPUP_DISP) AudioChoice(Window,IntuiMsg);
d1279 8
d1299 2
d1408 1
d1435 1
d1541 2
a1542 2
// recalculates difference and prints it if changed
VOID UpdateDiff(struct RastPort *RP,struct PanelLine *PLine)
d1548 5
a1552 1
	if (A < 0) A = 0;
d1554 1
a1554 1
		PLine->PropEnd = A;
d1565 1
d1570 1
a1570 1
VOID UpdateAllDiff(struct RastPort *RP,struct PanelLine *PLine)
d1572 1
d1574 6
a1579 1
		if (PLine->Type == PNL_DIFF) UpdateDiff(RP,PLine);
d1586 1
a1586 1
VOID UpdateFXTime(struct RastPort *RP,struct PanelLine *PLine,LONG t)
d1594 1
a1594 1
				UpdateDiff(RP,PLine);
d1618 1
d1658 1
a1658 1
	struct PanelLine *Start,*temp;
d1897 1
a1897 1
				UpdateDiff(RP,PLine);
d1925 1
d1931 1
a1931 1
						UpdateAllDiff(RP,Start);
d1939 1
a1939 1
						UpdateAllDiff(RP,Start);
d1946 1
a1946 1
						UpdateAllDiff(RP,Start);
d1955 1
a1955 1
						UpdateAllDiff(RP,Start);
d1960 3
d1964 1
d1984 1
a1984 1
						UpdateAllDiff(RP,Start);
d2027 1
a2027 1
						else UpdateFXTime(RP,Start,PLine->Param2[A&0x0003]);
d2096 1
a2096 1
	LONG A=0,B=2,In,Out,type,Speed=1,Time,S,M,F,V,SP[5],DLay;
d2188 1
a2188 1
					ClipPL[3].Param = &Time;
d2191 1
a2191 1
					ClipPL[4].Param = &B;
d2196 5
a2200 1
					Panel(Edit,ClipPL);
d2208 1
d2213 1
@


2.29
log
@*** empty log message ***
@
text
@d3 3
a5 3
* $Id: project.c,v 2.28 94/03/16 19:33:58 CACHELIN4000 Exp Locker: Kell $
* $Log:	project.c,v $
*Revision 2.28  94/03/16  19:33:58  CACHELIN4000
d8 1
a8 20
*Revision 2.26  94/03/16  18:12:40  CACHELIN4000
**** empty log message ***
*
*Revision 2.25  94/03/16  17:30:35  CACHELIN4000
**** empty log message ***
*
*Revision 2.24  94/03/16  16:12:41  CACHELIN4000
**** empty log message ***
*
*Revision 2.23  94/03/16  13:26:02  CACHELIN4000
**** empty log message ***
*
*Revision 2.22  94/03/16  12:21:36  CACHELIN4000
**** empty log message ***
*
*Revision 2.21  94/03/16  00:58:03  CACHELIN4000
**** empty log message ***
*
*
*Revision 2.17  94/03/15  16:13:01  Kell
a13 3
*Revision 2.15  94/03/15  12:18:24  CACHELIN4000
**** empty log message ***
*
a22 3
*Revision 2.7  94/03/11  09:32:22  Kell
**** empty log message ***
*
a25 3
*Revision 2.5  94/03/09  02:05:22  CACHELIN4000
**** empty log message ***
*
d67 1
a67 1
//#define SERDEBUG	1
d1461 1
d1873 1
a1873 1
						if(!PLine->Param2[ID&0x0003]) break; // disable!
d1881 1
a1881 1
						A = ID;
d1934 8
d1943 1
d1951 2
a1952 1
UBYTE FCM[] = {3,0,1,2};
d1958 1
a1958 1
	LONG A=0,B=2,In,Out,type,Speed=1,Time,S,M,F,V,SP[4],DLay;
d1974 3
a1976 1
					Speed=(B=GetValue(FG,0x80000000|TAG_FCountMode));
d1981 1
d1984 1
a1984 1
					AnimFXPL[2].Param =&Speed;				// SMFV choice
d1987 1
a1987 1
					AnimFXPL[3].Param = &(SP[Speed]);	// Time slider
d1989 1
a1989 1
					if( Panel(Edit,AnimFXPL) && (B!=Speed) )
d1991 1
a1991 1
						PutValue(FG,0x80000000|TAG_FCountMode,FCM[Speed]);
d1998 3
a2000 1
					Speed=(B=GetValue(FG,0x80000000|TAG_FCountMode));
d2010 2
a2011 1
					SP[3]=GetValue(FG,0x80000000|TAG_NumFramesVariable);
d2013 1
a2013 1
					EffectPL[2].Param =&Speed;				// SMFV choice
d2016 1
a2016 1
					EffectPL[3].Param = &V;	// Time slider
d2019 1
a2019 1
					if( Panel(Edit,EffectPL) && ( (V!=SP[Speed]) || (Speed!=B) ) )
d2021 4
a2024 2
						PutValue(FG,0x80000000|TAG_FCountMode,FCM[Speed]); // FCM[3]=2 = variable
						PutValue(FG,0x80000000|TAG_VariableFCount,V);
@


2.28
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.26 94/03/16 18:12:40 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d95 1
a95 1
#define SERDEBUG	1
@


2.27
log
@*** empty log message ***
@
text
@d1997 2
a1998 2
					EffectPL[2].PropStart =0 ;	// PLine (time) to update, 0 for FXTIME
					AnimFXPL[3].Param = &(SP[*(AnimFXPL[2].Param)]);	// Time slider
d2010 1
d2015 5
@


2.26
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.25 94/03/16 17:30:35 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d2009 1
a2009 1
					Speed=3; //(B=GetValue(FG,0x80000000|TAG_FCountMode));
d2021 1
a2021 1
					if( Panel(Edit,EffectPL) && (V!=SP[Speed]) )
d2023 1
a2023 1
						PutValue(FG,0x80000000|TAG_FCountMode,FCM[3]); // FCM[3]=2 = variable
d2029 1
a2029 1
					Time=(A=GetValue(FG,0x80000000|TAG_NumFields));
d2047 1
a2047 1
					Time=(A=GetValue(FG,0x80000000|TAG_NumFields));
d2061 1
a2061 1
					Time=(A=GetValue(FG,0x80000000|TAG_NumFields));
d2069 1
a2069 1
							PutValue(FG,0x80000000|TAG_NumFields,Time);
d2074 1
a2074 1
					Time=(A=GetValue(FG,0x80000000|TAG_NumFields));
d2090 1
a2090 1
							PutValue(FG,0x80000000|TAG_NumFields,Time);
@


2.25
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.24 94/03/16 16:12:41 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d140 1
a140 1
UBYTE PjName[369] = "RAM:WorkProject";
a212 1

d1216 2
a1217 1
		DUMPMSG("Before HandleSaveProject() sends ES_SaveProject");
@


2.24
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.23 94/03/16 13:26:02 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d137 1
a137 1
UBYTE PjName[369];
d1213 1
a1213 1
		if(!ProjectName[0]) strcpy(ProjectName,DEF_PROJ_DIR DEF_PROJ_NAME);
d1997 1
a1997 1
						SendSwitcherReply(ES_FGcommand,FGC_FCOUNT,0,0);
d2019 1
a2019 1
						SendSwitcherReply(ES_FGcommand,FGC_FCOUNT,0,0);
d2061 5
a2065 1
						if(A!=Time) PutValue(FG,0x80000000|TAG_NumFields,Time);
d2085 1
a2085 1
							SendSwitcherReply(ES_FGcommand,FGC_FCOUNT,0,0);
@


2.23
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.22 94/03/16 12:21:36 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
@


2.22
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.21 94/03/16 00:58:03 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d1960 1
a1960 1
	LONG A=0,B=2,In,Out,type,Speed=1,Time,S,M,F,V,SP[4]; // DLay
d1977 4
a1980 4
					SP[0]=GetValue(FG,0x80000000|TAG_SlowFCount);
					SP[1]=GetValue(FG,0x80000000|TAG_MedFCount);
					SP[2]=GetValue(FG,0x80000000|TAG_FastFCount);
					SP[3]=GetValue(FG,0x80000000|TAG_VariableFCount);
d1989 1
d1991 2
d2013 1
d2059 2
d2064 1
a2064 1
					KeyPL[3].Param = &B;
d2066 2
a2067 2
					KeyPL[3].PropEnd = 3600;
					In = 0; // set to crouton's 0=fade,1=cut
d2069 1
a2069 1
					Out = 0; // set to crouton's 0=fade,1=cut
d2071 6
a2076 3
					Panel(Edit,KeyPL);
					if(A!=Time) PutValue(FG,0x80000000|TAG_NumFields,Time);
						// check In,Out values here, update crouton
d2079 1
a2079 1
					A = 0; // set to speed 0..3
d2081 3
a2083 2
					Panel(Edit,CrawlPL);
						// check A value here, update crouton
d2086 1
a2086 1
					A = 0; // set to speed 0..4
d2088 3
a2090 2
					Panel(Edit,ScrollPL);
					// check A value here, update crouton
@


2.21
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.20 94/03/15 22:56:07 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d1287 5
a1291 2
  PNL_TOGGLE,
  PNL_FXSPEED };
d1305 1
a1305 2
{ PNL_CHOICE4,PNL_LEFT,"Speed",0 },
//{ PNL_FXSPEED,PNL_LEFT,"Speed",0 },
d1314 2
a1315 1
{ PNL_DIFF,PNL_LEFT,"Length",0 },
d1328 11
d1468 1
a1468 1
			if (PLine->Type == PNL_DIFF)
d1534 1
a1534 1
	struct PanelLine *Start;
d1592 1
a1624 1
		case PNL_FXSPEED:
d1646 23
d1771 1
d1875 24
a1898 2
						if(PLine->Type == PNL_FXSPEED)
							UpdateFXTime(RP,Start,PLine->Param2[A&0x0003]);
d1901 1
d1968 1
a1968 1
			strncpy(Label,((struct ExtFastGadget *)FG)->FileName,MAX_PANEL_STR);
d1982 1
d1998 2
d2010 17
@


2.20
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.19 94/03/15 22:48:20 CACHELIN4000 Exp Locker: CACHELIN4000 $
a4 2
*Revision 2.19  94/03/15  22:48:20  CACHELIN4000
**** empty log message ***
a14 6
*Revision 2.14  94/03/14  21:55:53  CACHELIN4000
**** empty log message ***
*
*Revision 2.13  94/03/14  00:32:10  CACHELIN4000
**** empty log message ***
*
a17 3
*Revision 2.11  94/03/12  20:00:46  CACHELIN4000
**** empty log message ***
*
a23 3
*Revision 2.8  94/03/11  09:48:02  CACHELIN4000
**** empty log message ***
*
a32 9
*Revision 2.4  94/03/05  21:04:02  CACHELIN4000
**** empty log message ***
*
*Revision 2.3  94/02/23  14:52:13  Kell
**** empty log message ***
*
*Revision 2.2  94/02/19  14:30:32  CACHELIN4000
**** empty log message ***
*
d186 1
a186 1
*	
d1284 2
a1285 1
  PNL_TOGGLE };
d1300 1
d1308 1
a1308 1
{ PNL_CHOICE4,PNL_LEFT,"Speed",0 },
d1371 1
d1446 15
d1518 1
a1518 1
	struct Gadget *Cancel=NULL,*FirstG=0,*ThisG=0,*NewG=0,*Down=0,**PPGadg;
d1521 1
a1521 1
	BOOL Going = TRUE, Success = TRUE;
d1607 1
d1677 1
a1677 1
	
d1713 1
a1713 1
				
d1723 8
d1803 2
a1805 2
						Success = FALSE;
					case ID_DARK_CONTINUE:
d1834 2
d1887 1
a1887 1
#define MAX_PANEL_STR		40
d1893 1
a1893 1
	LONG A=0,B=2,In,Out,type,DLay,Speed=1,Time,S,M,F,V,SP[4];
a1902 1
			//if (FG->Flags2 == CR_VidEvent)
a1914 1
					// Time=GetValue(FG,0x80000000|TAG_NumFields);
d1917 1
d1920 2
a1921 2
					Panel(Edit,AnimFXPL);
					if(B!=Speed)PutValue(FG,0x80000000|TAG_FCountMode,Speed);
d1926 1
a1926 1
					Speed=(B=GetValue(FG,0x80000000|TAG_FCountMode));
a1930 1
					Time=GetValue(FG,0x80000000|TAG_NumFields);
d1933 1
a1933 1
					EffectPL[3].Param = &Time;	// Time slider
d1936 5
a1940 5
					Panel(Edit,EffectPL);
					PutValue(FG,0x80000000|TAG_SlowFCount,SP[0]);
					PutValue(FG,0x80000000|TAG_MedFCount,SP[1]);
					PutValue(FG,0x80000000|TAG_FastFCount,SP[2]);
					PutValue(FG,0x80000000|TAG_VariableFCount,SP[2]);
d1962 3
a1964 3
					FramePL[2].PropEnd = 3600;
					Panel(Edit,FramePL);
					if(A!=Time) PutValue(FG,0x80000000|TAG_NumFields,Time);
d1968 1
a1968 1
					KeyPL[2].Param = &FG->FieldCount;
@


2.19
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.17 94/03/15 16:13:01 Kell Exp Locker: CACHELIN4000 $
d5 3
d1659 1
a1659 1
	H += PNL_YADD + NewG->Height;
d1904 5
a1908 5
					Speed=(B=GetValue(FG,0x8000000|TAG_FCountMode));
					SP[0]=GetValue(FG,0x8000000|TAG_SlowFCount);
					SP[1]=GetValue(FG,0x8000000|TAG_MedFCount);
					SP[2]=GetValue(FG,0x8000000|TAG_FastFCount);
					SP[3]=GetValue(FG,0x8000000|TAG_VariableFCount);
d1910 1
a1910 1
					// Time=GetValue(FG,0x8000000|TAG_NumFields);
d1916 1
a1916 1
					if(B!=Speed)PutValue(FG,0x8000000|TAG_FCountMode,Speed);
d1921 6
a1926 6
					Speed=(B=GetValue(FG,0x8000000|TAG_FCountMode));
					SP[0]=(S=GetValue(FG,0x8000000|TAG_SlowFCount));
					SP[1]=(M=GetValue(FG,0x8000000|TAG_MedFCount));
					SP[2]=(F=GetValue(FG,0x8000000|TAG_FastFCount));
					SP[3]=(V=GetValue(FG,0x8000000|TAG_VariableFCount));
					Time=GetValue(FG,0x8000000|TAG_NumFields);
d1933 4
a1936 4
					PutValue(FG,0x8000000|TAG_SlowFCount,SP[0]);
					PutValue(FG,0x8000000|TAG_MedFCount,SP[1]);
					PutValue(FG,0x8000000|TAG_FastFCount,SP[2]);
					PutValue(FG,0x8000000|TAG_VariableFCount,SP[2]);
d1940 1
a1940 1
					Time=(A=GetValue(FG,0x8000000|TAG_NumFields));
d1954 1
a1954 1
					Time=(A=GetValue(FG,0x8000000|TAG_NumFields));
d1960 1
a1960 1
					if(A!=Time) PutValue(FG,0x8000000|TAG_NumFields,Time);
d1963 1
a1963 1
					Time=(A=GetValue(FG,0x8000000|TAG_NumFields));
d1975 1
a1975 1
					if(A!=Time) PutValue(FG,0x8000000|TAG_NumFields,Time);
@


2.18
log
@*** empty log message ***
@
text
@d1104 1
a1104 1
	ClipNW.LeftEdge = EditTop->Window->LeftEdge + 
d1516 1
a1516 1
VOID Panel(struct EditWindow *Edit,struct PanelLine *PLine)
d1520 1
a1520 1
	struct Gadget *FirstG=0,*ThisG=0,*NewG=0,*Down=0,**PPGadg;
d1523 1
a1523 1
	BOOL Going = TRUE;
d1654 8
d1796 2
d1800 2
a1801 2
					break;
					case STRING_ID: 
d1865 1
d1901 5
a1905 5
					Speed=(B=GetValue(FG,TAG_FCountMode));
					SP[0]=GetValue(FG,TAG_SlowFCount);
					SP[1]=GetValue(FG,TAG_MedFCount);
					SP[2]=GetValue(FG,TAG_FastFCount);
					SP[3]=GetValue(FG,TAG_VariableFCount);
d1907 1
a1907 1
					// Time=GetValue(FG,TAG_NumFields);
d1913 1
a1913 1
					if(B!=Speed)PutValue(FG,TAG_FCountMode,Speed);
d1918 6
a1923 6
					Speed=(B=GetValue(FG,TAG_FCountMode));
					SP[0]=(S=GetValue(FG,TAG_SlowFCount));
					SP[1]=(M=GetValue(FG,TAG_MedFCount));
					SP[2]=(F=GetValue(FG,TAG_FastFCount));
					SP[3]=(V=GetValue(FG,TAG_VariableFCount));
					Time=GetValue(FG,TAG_NumFields);
d1928 1
a1928 1
					EffectPL[3].PropEnd = 3600;
d1930 4
a1933 4
					PutValue(FG,TAG_SlowFCount,SP[0]);
					PutValue(FG,TAG_MedFCount,SP[1]);
					PutValue(FG,TAG_FastFCount,SP[2]);
					PutValue(FG,TAG_VariableFCount,SP[2]);
d1937 1
a1937 1
					Time=(A=GetValue(FG,TAG_NumFields));
d1951 1
a1951 1
					Time=(A=GetValue(FG,TAG_NumFields));
d1957 1
a1957 1
					if(A!=Time) PutValue(FG,TAG_NumFields,Time);
d1960 1
a1960 1
					Time=(A=GetValue(FG,TAG_NumFields));
d1972 1
a1972 1
					if(A!=Time) PutValue(FG,TAG_NumFields,Time);
@


2.17
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: project.c,v 2.16 94/03/15 14:22:03 CACHELIN4000 Exp Locker: Kell $
* $Log:	project.c,v $
d78 1
d1103 1
a1103 1
	
d1323 8
d1857 12
d1873 1
a1873 1
	LONG A=0,B=2,In,Out,type;
d1875 1
d1878 1
a1878 1
	while (FG) 
d1885 1
d1890 14
d1907 9
a1915 4
					A=2;
					EffectPL[1].Label =((struct ExtFastGadget *)FG)->FileName;	// Label
					EffectPL[2].Param =&A;				// SMFV choice
					EffectPL[3].Param = &FG->FieldCount;	// Time slider
d1918 5
a1922 1
					Panel(Edit,FramePL);
d1926 4
a1929 1
					ClipPL[3].Param = &FG->FieldCount;
d1940 3
a1942 2
					FramePL[1].Label =((struct ExtFastGadget *)FG)->FileName;	// Label
					FramePL[2].Param = &FG->FieldCount;	// Time slider
d1946 1
d1949 1
d1961 1
@


2.16
log
@Refresh Switcher after selecting croutons
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.15 94/03/15 12:18:24 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
@


2.15
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.14 94/03/14 21:55:53 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d150 2
d1218 1
@


2.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.13 94/03/14 00:32:10 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d135 2
a136 1
UBYTE		ProjectName[369]=DEF_PROJ_DIR DEF_PROJ_NAME;
@


2.13
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.12 94/03/13 07:49:32 Kell Exp Locker: CACHELIN4000 $
d5 3
d130 3
d158 1
a158 1
*	
d482 1
a482 1
			Clip->TopEdge = Control->TopEdge = 
d676 1
a676 1
*   NAME   
d701 1
a701 1
*   NAME   
d708 1
a708 1
*	
d1205 1
d1207 1
a1207 1
		SendSwitcher(ES_SaveProject,NULL,NULL,NULL);
d1298 8
d1854 6
a1859 3
					FramePL[2].Param = &FG->FieldCount;
					FramePL[2].PropStart = 1;
					FramePL[2].PropEnd = 3600;
d1875 7
@


2.12
log
@Deleted some unused variables
@
text
@d3 5
a7 2
* $Id: project.c,v 2.11 94/03/12 20:00:46 CACHELIN4000 Exp Locker: Kell $
* $Log:	project.c,v $
d78 1
a78 1
//#define SERDEBUG	1
a554 1
		DUMPSTR("  Entered ProjFGInit()");
@


2.11
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.10 94/03/12 13:38:32 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d75 1
a75 1
#define SERDEBUG	1
d247 1
a247 1
	UWORD X1,Y1,X2,Y2,Max;
d250 3
d255 1
@


2.10
log
@Add path name to crouton dropped into project
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.9 94/03/11 12:19:21 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d105 3
d240 1
d280 5
a284 5
			DUMPMEM("pj BM=",(APTR)BM,(LONG)sizeof(struct BitMap));
			DUMPMEM("pj RPBM=",(APTR)(RP->BitMap),(LONG)sizeof(struct BitMap));
			DUMPUDECL("pj X1=",(LONG)X1," ");
			DUMPUDECL("pj Y1=",(LONG)X1," ");
			DUMPUDECL("pj Rows=",(LONG)(Edit->RowSize),"\\");
d286 1
a286 1
			DUMPMSG("after Project copycunt");
d352 2
a353 5
				if ( (Item = DuplicateSmartString(Path)) &&
					(AppendToPath(Node->Node.Name,Item)) &&
					(FG = AllocProj(GetCString(Item))) )
				{
					if (DestNode)
d355 11
a365 6
						FG->NextGadget = ((struct FastGadget *)DestNode)->NextGadget;
						((struct FastGadget *)DestNode)->NextGadget = FG;
					} else { // insert at beginning
						Project = (struct Project *)Dest->Special;
						FG->NextGadget = *(Project->PtrPtr);
						*(Project->PtrPtr) = FG;
a366 1
				}
d545 1
d1812 1
a1812 1
	LONG A=0,B=2,In,Out;
a1813 1
	static LONG X = 0,type;;
d1816 2
a1817 1
	while (FG) {
d1819 65
a1883 65
		if (FG->FGDiff.FGNode.Status == EN_SELECTED) {
		//if (FG->Flags2 == CR_VidEvent)
		// X++;
    type=((struct ExtFastGadget *)FG)->ObjectType;
		// switch (X) {
		switch (type) {
		case CT_FXANIM:
		case CT_FXILBM:
		case CT_FXALGO:
		case CT_FXCR:
			FramePL[2].Param = &FG->FieldCount;
			FramePL[2].PropStart = 1;
			FramePL[2].PropEnd = 3600;
			Panel(Edit,FramePL);
			break;
		case CT_AUDIO :
		case CT_VIDEO:
			ClipPL[3].Param = &FG->FieldCount;
			ClipPL[3].PropStart = 1;
			ClipPL[3].PropEnd = 3600;
			ClipPL[4].Param = &B;
			ClipPL[4].PropStart = 1;
			ClipPL[4].PropEnd = 3600;
			ClipPL[2].Param = ClipPL[4].Param; // out
			ClipPL[2].Param2 = ClipPL[3].Param; // in
			Panel(Edit,ClipPL);
			break;
		case CT_FRAMESTORE:
			KeyPL[2].Param = &FG->FieldCount;
			KeyPL[2].PropStart = 1;
			KeyPL[2].PropEnd = 3600;
			KeyPL[3].Param = &B;
			KeyPL[3].PropStart = 1;
			KeyPL[3].PropEnd = 3600;
			In = 0; // set to crouton's 0=fade,1=cut
			KeyPL[4].Param = &In;
			Out = 0; // set to crouton's 0=fade,1=cut
			KeyPL[5].Param = &Out;
			Panel(Edit,KeyPL);
				// check In,Out values here, update crouton
			break;
		case CT_CRAWL:
			A = 0; // set to speed 0..3
			CrawlPL[2].Param = &A;
			Panel(Edit,CrawlPL);
				// check A value here, update crouton
			break;
		case CT_SCROLL:
			A = 0; // set to speed 0..4
			ScrollPL[2].Param = &A;
			Panel(Edit,ScrollPL);
				// check A value here, update crouton
			break;
		case CT_CONTROL:
			A = 0;
      B = 1;
			TestPL[2].Param = &A;
			TestPL[5].Param = &B;
			TestPL[4].Param = &B;
			Panel(Edit,TestPL);
      if(A==1) BoolRequest(Edit->Window,"Are you sure?, They're real good!");
				// check A value here, update crouton
			break;
		}
		if (X >= 6) X = 0;
@


2.9
log
@Re-Do ProjectRenderNode()
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.8 94/03/11 09:48:02 CACHELIN4000 Exp Locker: CACHELIN4000 $
d5 3
d326 1
a326 1
	struct SmartString *Path; // ,*Item;
d336 24
a359 30

// start of end of list so multiple selected stuff inserts correctly
	Node = (struct EditNode *)Source->Special->EditList.lh_TailPred;
	while (Next=(struct EditNode *)Node->Node.MinNode.mln_Pred) {
		if (Node->Status == EN_DRAGGING) {
			Node->Status = EN_NORMAL;
			Node->Redraw = TRUE;
			AnyDrop = TRUE;

		Path = ((struct Grazer *)Source->Special)->Path;

// temp!!! fully qualify pathname soon!
/*
		if ((Item = DuplicateSmartString(Path)) && free item!!
			(AppendToPath(Node->Node.Name,Item)) &&
			(FG = AllocProj(GetCString(Item)))) {
*/
		if (FG = AllocProj(GetCString(Node->Node.Name))) {

			// don't try to get imagery from grazer node anymore,
			// just let switcher routine load it
			// GetImageGrazer(FG,(struct GrazerNode *)Node);

			if (DestNode) {
				FG->NextGadget = ((struct FastGadget *)DestNode)->NextGadget;
				((struct FastGadget *)DestNode)->NextGadget = FG;
			} else { // insert at beginning
				Project = (struct Project *)Dest->Special;
				FG->NextGadget = *(Project->PtrPtr);
				*(Project->PtrPtr) = FG;
d361 1
a361 2
			}
			// if (Item) FreeSmartString(Item);
d363 2
a364 5
		Node = Next;
	}

// *******************
// project->project (may be same project)
@


2.8
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: Project.c,v 2.7 94/03/11 09:32:22 Kell Exp Locker: CACHELIN4000 $
d5 3
d91 7
d234 5
a238 2
	WORD oldgl=GrazerLayout;
	GrazerLayout=0;
d240 2
a241 5
       DUMPMSG("before GrazerRenderNode");
	GrazerRenderNode(Edit,Node,RP,TopEdge,LeftEdge);
       DUMPMSG("after GrazerRenderNode");

	GrazerLayout=oldgl;
d243 36
a278 65
#ifdef YUCKY_OLD_CODE_PLEASE
	WORD *WP,A,*P1,*P2;
	struct BitMap *SrcBM;
	struct FastGadget *FG;
	UBYTE *B;
	BOOL Ours = FALSE;
	struct BitMap BM;

	FG = (struct FastGadget *)Node;
	SrcBM = &FileBitMap; // default

// temp !!!

  if(((struct GrazerNode *)Node)->BitMap!=NULL) 
    SrcBM=((struct GrazerNode *)Node)->BitMap;
  else
	 if(FG->Data) {
		switch (FG->ModeType) {
//***********************
		case DISPLAYMODE5:
      DUMPMSG("Rendering Node with 'DISPLAYMODE5'... ");
			if (SrcBM = HelpAllocBitMap(CR_WIDTH,CR_HEIGHT,2,0)) {
			Ours = TRUE;

			A = 250;
			WP = (WORD *)FG->Data;
			P1 = (WORD *)SrcBM->Planes[0];
			P2 = (WORD *)SrcBM->Planes[1];
			while (A) {
				WP++;
				*P1++ = *WP++;
				*P2++ = *WP++;
				A--;
			}
			}
			break;

//***********************
		case DISPLAYMODE6:
      DUMPMSG("Rendering Node with 'DISPLAYMODE6'... ");
			SrcBM = &BM;
			SrcBM->Depth = DM6_DEPTH;
			goto Setup;

//***********************
		case DISPLAYMODE7:
      DUMPMSG("Rendering Node with 'DISPLAYMODE7'... ");
			SrcBM = &BM;
			SrcBM->Depth = DM7_DEPTH;
		Setup:
			SrcBM->BytesPerRow = CR_WIDTH >> 3;
			SrcBM->Rows = CR_HEIGHT;
			B = FG->Data;
			for (A=0; A < SrcBM->Depth; A++) {
				SrcBM->Planes[A] = B;
				B += CR_PLANE;
			}
		}
	}

// need to clear out any MS planes (make optimized later!!!!)
	SetAPen(RP,0);
	SetDrMd(RP,JAM2);
	RectFill(RP,LeftEdge,TopEdge,LeftEdge+(SrcBM->BytesPerRow<<3)-1,
		TopEdge+SrcBM->Rows-1);
a279 4
	CopyFastBitMap(SrcBM,0,0,RP->BitMap,LeftEdge,TopEdge,
		(SrcBM->BytesPerRow<<3),SrcBM->Rows);
	if (Ours) HelpFreeBitMap(SrcBM);
#endif
d324 1
d589 2
a590 1
		DUMPMSG("Before AllocProj() sends ES_LoadCrouton");
d593 1
a593 1
		DUMPMSG("  After AllocProj() sent ES_LoadCrouton");
d920 1
a920 1
	if (Edit->Node.Type == EW_GRAZER) 
@


2.7
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: project.c,v 2.6 94/03/10 18:15:54 CACHELIN4000 Exp Locker: Kell $
* $Log:	project.c,v $
@


2.6
log
@Fix ProjectRenderNode() to call GrazerRenderNode()
@
text
@d3 5
a7 2
* $Id: Project.c,v 2.5 94/03/09 02:05:22 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	Project.c,v $
d60 3
d107 1
a107 1
		DumpMsg("Before ProjectSelect() sends ES_Select");
d109 1
a109 1
		DumpMsg("  After ProjectSelect() sent ES_Select");
d164 1
a164 1
		DumpMsg("Before ProjectDouble() sends ES_Auto");
d166 1
a166 1
		DumpMsg("  After ProjectDouble() sent ES_Auto");
d223 2
d226 2
d250 1
a250 1
      DumpMsg("Rendering Node with 'DISPLAYMODE5'... ");
d269 1
a269 1
      DumpMsg("Rendering Node with 'DISPLAYMODE6'... ");
d276 1
a276 1
      DumpMsg("Rendering Node with 'DISPLAYMODE7'... ");
d522 1
a522 1
	DumpMsg("Before FreeProjectNode() sends ES_FreeCrouton");
d524 1
a524 1
	DumpMsg("  After FreeProjectNode() sent ES_FreeCrouton");
d608 1
a608 1
		DumpMsg("Before AllocProj() sends ES_LoadCrouton");
d611 1
a611 1
		DumpMsg("  After AllocProj() sent ES_LoadCrouton");
d636 1
a636 1
		DumpMsg("Before DupeProjNode() sends ES_DuplicateCrouton");
d639 1
a639 1
		DumpMsg("  After DupeProjNode() sent ES_DuplicateCrouton");
d662 1
a662 1
		DumpMsg("GetLoadedProject() Loading into bottom");
d1206 1
a1206 1
		DumpMsg("Before HandleSaveProject() sends ES_SaveProject");
d1208 1
a1208 1
		DumpMsg("  After HandleSaveProject() sent ES_SaveProject");
@


2.5
log
@*** empty log message ***
@
text
@Binary files Project.c and t:,RCSt1A70d4540 differ
@


2.4
log
@*** empty log message ***
@
text
@Binary files Project.c and t:,RCSt1A70d3798 differ
@


2.3
log
@*** empty log message ***
@
text
@Binary files Project.c and t:,RCSt1A710dc80 differ
@


2.2
log
@*** empty log message ***
@
text
@Binary files Project.c and t:,RCSt1A70c3480 differ
@


2.1
log
@*** empty log message ***
@
text
@Binary files project.c and t:,RCSt1A71319a0 differ
@


2.0
log
@FirstCheckIn
@
text
@Binary files Project.c and t:,RCSt1A70c0270 differ
@
