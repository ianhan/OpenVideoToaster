head	2.26;
access;
symbols;
locks; strict;
comment	@*@;


2.26
date	95.10.09.16.38.40;	author Flick;	state Exp;
branches;
next	2.25;

2.25
date	95.08.09.17.53.31;	author Flick;	state Exp;
branches;
next	2.24;

2.24
date	95.07.27.18.13.33;	author Flick;	state Exp;
branches;
next	2.23;

2.23
date	95.07.13.16.57.23;	author Flick;	state Exp;
branches;
next	2.22;

2.22
date	95.06.01.11.38.00;	author pfrench;	state Exp;
branches;
next	2.21;

2.21
date	94.12.30.21.05.33;	author pfrench;	state Exp;
branches;
next	2.20;

2.20
date	94.12.19.22.38.25;	author pfrench;	state Exp;
branches;
next	2.19;

2.19
date	94.11.11.11.54.33;	author pfrench;	state Exp;
branches;
next	2.18;

2.18
date	94.09.27.16.23.17;	author pfrench;	state Exp;
branches;
next	2.17;

2.17
date	94.09.20.22.49.37;	author pfrench;	state Exp;
branches;
next	2.16;

2.16
date	94.08.30.10.41.05;	author Kell;	state Exp;
branches;
next	2.15;

2.15
date	94.08.11.16.55.03;	author pfrench;	state Exp;
branches;
next	2.14;

2.14
date	94.07.31.14.43.36;	author pfrench;	state Exp;
branches;
next	2.13;

2.13
date	94.06.07.10.17.42;	author CACHELIN4000;	state Exp;
branches;
next	2.12;

2.12
date	94.03.19.00.05.00;	author CACHELIN4000;	state Exp;
branches;
next	2.11;

2.11
date	94.03.17.09.53.31;	author Kell;	state Exp;
branches;
next	2.10;

2.10
date	94.03.16.18.13.16;	author CACHELIN4000;	state Exp;
branches;
next	2.9;

2.9
date	94.03.16.17.30.14;	author CACHELIN4000;	state Exp;
branches;
next	2.8;

2.8
date	94.03.15.16.12.51;	author Kell;	state Exp;
branches;
next	2.7;

2.7
date	94.03.14.21.57.12;	author CACHELIN4000;	state Exp;
branches;
next	2.6;

2.6
date	94.03.14.00.30.52;	author CACHELIN4000;	state Exp;
branches;
next	2.5;

2.5
date	94.03.13.07.51.39;	author Kell;	state Exp;
branches;
next	2.4;

2.4
date	94.03.11.09.32.18;	author Kell;	state Exp;
branches;
next	2.3;

2.3
date	94.03.02.21.06.04;	author CACHELIN4000;	state Exp;
branches;
next	2.2;

2.2
date	94.02.23.14.52.36;	author Kell;	state Exp;
branches;
next	2.1;

2.1
date	94.02.19.09.34.21;	author Kell;	state Exp;
branches;
next	2.0;

2.0
date	94.02.17.16.24.15;	author Kell;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.26
log
@Finds popup.h in new home
@
text
@/********************************************************************
* $grazergadgets.c - EditWindow for looking at AmigaDOS hierarchy$
* $Id: GrazerGadgets.c,v 2.25 1995/08/09 17:53:31 Flick Exp Flick $
* $Log: GrazerGadgets.c,v $
*Revision 2.25  1995/08/09  17:53:31  Flick
*Had to add arg for new NiceCopy()
*
*Revision 2.24  1995/07/27  18:13:33  Flick
*Added "from drive:?" wording to GrazerDelete warning (and cleaned up code)
*Fixed stuck-hilite in GrazerNewFolder
*
*Revision 2.23  1995/07/13  16:57:23  Flick
*Made text more severe for delete files requester
*
*Revision 2.22  1995/06/01  11:38:00  pfrench
*Duplicate now will engage fast flyer copy on flyer drives
*
*Revision 2.21  1994/12/30  21:05:33  pfrench
*Now correctly redraws new folders in files/files mode
*
*Revision 2.20  1994/12/19  22:38:25  pfrench
*Modified for now shared-code proof.library.
*
*Revision 2.19  1994/11/11  11:54:33  pfrench
*Got Select All working correctly
*
*Revision 2.18  1994/09/27  16:23:17  pfrench
*Removed all calls to FreeDirCache as it is being
*handled automatically now.
*
*Revision 2.17  1994/09/20  22:49:37  pfrench
*Modified to work with dircache (Editwindow has ptr to list now)
*
*Revision 2.16  1994/08/30  10:41:05  Kell
*Changed SendSwitcherReply calls to work with new ESParams structures.
*
*Revision 2.15  1994/08/11  16:55:03  pfrench
*Disabled (temporarily, at least). Projects saving from
*within the grazer's path string gadget.
*
*Revision 2.14  1994/07/31  14:43:36  pfrench
*HandlePath() now supports creating files with the grazer.
*
*Revision 2.13  1994/06/07  10:17:42  CACHELIN4000
**** empty log message ***
*
*Revision 2.12  94/03/19  00:05:00  CACHELIN4000
**** empty log message ***
*
*Revision 2.11  94/03/17  09:53:31  Kell
**** empty log message ***
*
*Revision 2.10  94/03/16  18:13:16  CACHELIN4000
**** empty log message ***
*
*Revision 2.9  94/03/16  17:30:14  CACHELIN4000
*Fix Project Saving ??
*
*Revision 2.8  94/03/15  16:12:51  Kell
**** empty log message ***
*
*Revision 2.7  94/03/14  21:57:12  CACHELIN4000
**** empty log message ***
*
*Revision 2.6  94/03/14  00:30:52  CACHELIN4000
**** empty log message ***
*
*Revision 2.5  94/03/13  07:51:39  Kell
**** empty log message ***
*
*Revision 2.4  94/03/11  09:32:18  Kell
**** empty log message ***
*
*Revision 2.3  94/03/02  21:06:04  CACHELIN4000
**** empty log message ***
*
*Revision 2.2  94/02/23  14:52:36  Kell
**** empty log message ***
*
*Revision 2.1  94/02/19  09:34:21  Kell
**** empty log message ***
*
*Revision 2.0  94/02/17  16:24:15  Kell
*FirstCheckIn
*
*Revision 2.0  94/02/17  15:57:20  Kell
*FirstCheckIn
*
*Revision 2.0  94/02/17  14:44:33  Kell
*FirstCheckIn
*
*
* Copyright (c)1992 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
*	12-17-92	Steve H		Convert to use SmartStrings
*	10-12-93	Steve H		Last Update
*********************************************************************/
#include <exec/types.h>
#include <exec/memory.h>
#include <intuition/intuition.h>
#include <dos/dos.h>
#include <stdio.h>
#include <string.h>
#include <dos.h>
#include <crouton_all.h>

#include <editwindow.h>
#include <grazer.h>
#include <gadgets.h>
#include <filelist.h>
#include <doshelp.h>
#include <request.h>
#include <popup.h>
#include <editswit.h>

#ifndef PROOF_LIB_H
#include <proof_lib.h>
#endif

#include <croutongrid.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
#include <proto/diskfont.h>

#ifndef PROTO_PASS
#include <grazer.p>
#include <grazergadgets.p>
#include <grid.p>
#include <drag.p>
#include <doshelp.p>
#include <graphichelp.p>
#include <gadgethelp.p>
#include <editwindow.p>
#include <project.p>
#include <dircache.p>
#include <ToastSupport.p>
#endif
#ifdef PROTO_PASS
VOID DrawBG();
#endif

//#define SERDEBUG	1
#include <serialdebug.h>

#define MAX_FILE 30
char TempCh[80],TempC2[80];

extern struct Library *ProofBase;
extern struct st_PopupRender PopUp;
extern struct Gadget Gadget1;
extern WORD RootLeft,RootTop;
extern UBYTE *ProjectName;
extern struct EditWindow *EditTop;
extern LONG GrazerCopyMode;

extern struct ESParams2 ESparams2;

VOID DisplayWaitSprite(VOID);
VOID DisplayNormalSprite(VOID);

/****** GrazerGadgets/GrazerParent **********************************
*
*   NAME
*	GrazerParent
*
*   SYNOPSIS
*	struct EditWindow *GrazerParent(struct EditWindow *Edit,
*		struct IntuiMessage *IntuiMsg)
*
*   FUNCTION
*
*
*********************************************************************
*/
struct EditWindow *GrazerParent(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	struct SmartString *Path;

	Path = ((struct Grazer *)Edit->Special)->Path;
	if (!FindParent(Path,0)) EraseSmartString(Path);
	DoAllNewDir(Edit);
	return(Edit);
}

/****** GrazerGadgets/GrazerRoot **********************************
*
*   NAME
*	GrazerRoot
*
*   SYNOPSIS
*	struct EditWindow *GrazerRoot(struct EditWindow *Edit,
*		struct IntuiMessage *IntuiMsg)
*
*   FUNCTION
*
*
*********************************************************************
*/
#define NUM_TYPE 3
char Root1[] = "Volumes",Root2[] = "Devices",Root3[] = "Assigns",
	*RootNames[] = { Root1,Root2,Root3 };
// #define NUM_TYPE 2
// char Root1[] = "Volumes",Root2[] = "Assigns",
//	*RootNames[] = { Root1,Root2 };

// AAR -- FRZL 
char *NameFcn2(void *frzl, int Entries)
{
	if (Entries < 0) Entries = 0;
	else if (Entries > (NUM_TYPE-1)) Entries = NUM_TYPE-1;
	return(RootNames[Entries]);
}

//*******************************************************************
// update gadget to reflect new RootMode
VOID RedrawRootMode(struct EditWindow *Edit)
{
	struct Gadget *Gadget;
	WORD Mode;

	Mode = ((struct Grazer *)Edit->Special)->RootMode;
	if (!(Gadget = FindGadget(Edit->Gadgets,ID_ROOT_DEV)))
		if (!(Gadget = FindGadget(Edit->Gadgets,ID_ROOT_VOL)))
			Gadget = FindGadget(Edit->Gadgets,ID_ROOT_ASS);

	if (Gadget && ((Gadget->GadgetID-ID_ROOT_VOL) == Mode)) return;
	if (Gadget) {
		RemoveGadget(Edit->Window,Gadget);
		FreeGadget(Gadget);
	}
	Gadget = FindGadget(&Gadget1,Mode+ID_ROOT_VOL);
	if (Gadget = AllocOneGadget(Gadget)) {
		Gadget->LeftEdge = RootLeft;
		Gadget->TopEdge = RootTop;
		if (Edit->Window) {
			AddGadget(Edit->Window,Gadget,(UWORD)~0);
			RefreshGList(Gadget,Edit->Window,NULL,1);
		} else {
			Gadget->NextGadget = Edit->Gadgets->NextGadget;
			Edit->Gadgets->NextGadget = Gadget;
		}
	}
}

//*********************************************************************
struct EditWindow *GrazerRoot(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	struct SmartString *Path;

	Path = ((struct Grazer *)Edit->Special)->Path;
	EraseSmartString(Path);
	DoAllNewDir(Edit);
	return(Edit);
}

//*********************************************************************
struct EditWindow *GrazerChooseRoot(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	PopUpID ID;
	struct Gadget *Gadget;
	WORD A,X,Y;
	struct Grazer *Grazer;
	ULONG L;

	Grazer = (struct Grazer *)Edit->Special;
	PUCDefaultRender(&PopUp);
	PopUp.drawBG = (DrawBGFunc *)DrawBG;
	Gadget = FindGadget(Edit->Gadgets,ID_CHOOSE_ROOT);
	X = Gadget->LeftEdge + (Gadget->Width >> 1);
	Y = Gadget->TopEdge + (Gadget->Height >> 1);
	ID = PUCCreate((NameFunc *)NameFcn2,NULL,&PopUp);
	PUCSetNumItems(ID,NUM_TYPE);
	PUCSetCurItem(ID,Grazer->RootMode);

	Edit->Window->Flags |= WFLG_REPORTMOUSE;
	A = PUCActivate(ID,Edit->Window,X,Y,IntuiMsg->MouseX,IntuiMsg->MouseY);
	Edit->Window->Flags &= ~WFLG_REPORTMOUSE;
	PUCDestroy(ID);

	if (A >= 0) {
		if (A != Grazer->RootMode) {
			Grazer->RootMode = A;
			L = Grazer->ValidAttributes;
			L = L & (~(VALID_DEVICES|VALID_VOLUMES|VALID_ASSIGNS));
			switch(A) {
			case 0:
				L |= VALID_VOLUMES;
			break;
			case 1:
				L |= VALID_DEVICES;
			break;
			case 2:
				L |= VALID_ASSIGNS;
			break;
			}
			Grazer->ValidAttributes = L;
			RedrawRootMode(Edit);
			GrazerRoot(Edit,IntuiMsg); // show new root Mode
		}
	}
	return(Edit);
}

//*********************************************************************
struct SmartNode *__regargs SearchSmartNodeName(
	struct SmartNode *Node,
	char *Search)
{
	struct SmartNode *Next;

	if (Node) {
	while (Next = (struct SmartNode *)Node->MinNode.mln_Succ) {
		if (stricmp(Search,GetCString(Node->Name)) == 0) return(Node);
		Node = Next;
	}
	}
	return(Node);
}

/****** GrazerGadgets/GrazerNewFolder *******************************
*
*   NAME
*	GrazerNewFolder
*
*   SYNOPSIS
*	struct EditWindow *GrazerNewFolder(struct EditWindow *Edit,
*		struct IntuiMessage *IntuiMsg)
*
*   FUNCTION
*	Creates a new folder in the current folder
*
*********************************************************************
*/
//*********************************************************************
// creates "FirstPart XX" where XX is first unused number in Path (dir)
// returns NULL if can't allocate SmartString or Lock() FileName
struct SmartString *CreateFileName(struct SmartString *Path,char *FirstPart)
{
	struct SmartString *New=NULL;
	UWORD A = 1;
	char Num[12];
	BPTR OldDir,NewDir,L;

	if (Path && FirstPart && (NewDir = Lock(GetCString(Path),ACCESS_READ))) {
		OldDir = CurrentDir(NewDir);
		while (A < 1000) {
		if ((New = AllocSmartString(FirstPart,NULL)) &&
			(stcu_d(Num,A)) &&
			(AppendCSmartString(Num,New))) {
			if (L = Lock(GetCString(New),ACCESS_READ)) {
				UnLock(L);
				A++;
			} else { // success
				goto Exit;
			}
		}
		if (New) {
			FreeSmartString(New);
			New = NULL;
		}
		}
Exit:
		CurrentDir(OldDir);
		UnLock(NewDir);
	}
	return(New);
}

//*********************************************************************
// returns fully qualified pathname or NULL
struct SmartString *PromptFileName(struct SmartString *Path,
	char *FirstPart,char *FirstPrompt,struct Window *Window)
{
	struct SmartString *File,*Full=NULL;
	char *MPtr[1],*CPath,*CFile;

	CPath = GetCString(Path);
	if ((!CPath) || (!CPath[0])) return(NULL); // this should never happen
	if (File = CreateFileName(Path,FirstPart)) {
		MPtr[0] = FirstPrompt;
		CFile = &TempCh[0];
		strcpy(CFile,GetCString(File));
		if (SimpleRequest(Window,MPtr,1,
			REQ_STRING|REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,CFile)) {

// build full thing
			if ((!(Full = DuplicateSmartString(Path))) ||
				(!(AppendCToPath(CFile,Full)))) {
				ContinueRequest(Window,IoErrToText(ERROR_NO_FREE_STORE));
				if (Full) {
					FreeSmartString(Full);
					Full = NULL;
				}
			}
		}
		FreeSmartString(File);
	}
	return(Full);
}

//*********************************************************************
struct EditWindow *GrazerNewFolder(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	BPTR NewLock = NULL;
	char *MPtr[2];
	struct SmartString *Path,*NewDir = NULL;
	LONG Err = NULL;
//	struct EditNode *Node;

	Path = ((struct Grazer *)Edit->Special)->Path;
	if (NewDir = PromptFileName(Path,"Folder ","Enter name of new folder.",Edit->Window))
	{
		NewLock = CreateDir(GetCString(NewDir));
		if (NewLock)
		{
			UnLock(NewLock);
			DeselectOtherEdit(Edit);
			DoAllNewDir(Edit);
			CheckOtherSame(Edit);

//Took this out, as the highlite would get stuck until we reentered the dir
//			Node = (struct EditNode *)	SearchSmartNodeName((struct SmartNode *)
//				Edit->Special->pEditList->lh_Head,&TempCh[0]);
//			if (Node) ChangeStatusNode(Edit,Node,EN_SELECTED);
		}
		else
			Err = IoErr();
		FreeSmartString(NewDir);
	}
	if (Err)
	{
		MPtr[0] = "Unable to create folder.";
		MPtr[1] = IoErrToText(IoErr());
		SimpleRequest(Edit->Window,MPtr,2,
			REQ_CENTER|REQ_H_CENTER,NULL);
	}
	return(Edit);
}

//*********************************************************************
struct EditWindow *HandleNewProject(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	char *MPtr[2];
	struct SmartString *Path,*NewDir = NULL;
	struct EditNode *Node;
	LONG Err=NULL;

	Path = ((struct Grazer *)Edit->Special)->Path;
	if (NewDir = PromptFileName(Path,"Project ","Enter name of new project.",
		Edit->Window)) {
		strcpy(ProjectName,GetCString(NewDir));
		DUMPSTR("Before HandleNewProject() sends ES_NewProject with ");
		DUMPMSG(ProjectName);
		ESparams2.Data1=0;
		ESparams2.Data2=(LONG)ProjectName;
		Err=SendSwitcherReply(ES_NewProject,&ESparams2); // proj. ##, name
		DUMPMSG("  After HandleNewProject() sent ES_NewProject");
		FreeSmartString(NewDir);
		if (EditTop->Node.Type == EW_PROJECT) InitSetupProject(EditTop);

		DoAllNewDir(Edit);
		CheckOtherSame(Edit);
		DeselectOtherEdit(Edit);
		Node = (struct EditNode *)
			SearchSmartNodeName((struct SmartNode *)
			Edit->Special->pEditList->lh_Head,&TempCh[0]);
		if (Node) ChangeStatusNode(Edit,Node,EN_SELECTED);
	}
	if (Err) {
		MPtr[0] = "Unable to create project.";
		MPtr[1] = IoErrToText(Err);
		SimpleRequest(Edit->Window,MPtr,2,
			REQ_CENTER|REQ_H_CENTER,NULL);
	}
	return(Edit);
}

/****** GrazerGadgets/GrazerDelete **********************************
*
*   NAME
*	GrazerDelete
*
*   SYNOPSIS
*	struct EditWindow *GrazerDelete(struct EditWindow *Edit)
*
*   FUNCTION
*	Deletes any selected files or directories
*
*********************************************************************
*/
BOOL GrazerDelete(struct EditWindow *Edit)
{
	struct SmartString *Path,*Item=NULL;
	struct GrazerNode *Node,*Next;
	WORD Dirs=0,Files=0;
	struct SmartString *FirstDir=NULL,*FirstFile=NULL;
	char *MPtr[3],*Ch;
	BOOL NormSprite = TRUE;

	Path = ((struct Grazer *)Edit->Special)->Path;

// count # of dir,files to be deleted
	Node = (struct GrazerNode *)Edit->Special->pEditList->lh_Head;
	while (Next = (struct GrazerNode *)Node->EditNode.Node.MinNode.mln_Succ) {
		if (Node->EditNode.Status == EN_SELECTED) {
			switch (Node->DOSClass) {
			case EN_DIRECTORY:
				if (!Dirs) FirstDir = Node->EditNode.Node.Name;
				Dirs++;
				break;
			case EN_FILE:
				if (!Files) FirstFile = Node->EditNode.Node.Name;
				Files++;
				break;
			default:
				MPtr[0] = "Unable to delete";
				MPtr[1] = GetCString(Node->EditNode.Node.Name);
				MPtr[2] = "Only files and folders can be deleted.";
				SimpleRequest(Edit->Window,MPtr,3,
					REQ_CENTER|REQ_H_CENTER,NULL);
				goto Exit;
			}
		}
		Node = Next;
	}

// if anything to delete, warn user

// Are you sure you want to delete
// 00 files, 00 folders (and their contents)?
	if (Dirs || Files)
	{
		MPtr[0] = "WARNING: Are you sure you want to delete";
		Ch = TempCh;

// if just one thing, print its name
		if (((Dirs==1) && (!Files)) || ((Files==1) && (!Dirs)))
		{
			if (Files)
				strcpy(Ch,GetCString(FirstFile));
			else
			{
				strcpy(Ch,GetCString(FirstDir));
				strcat(Ch," (and its contents)");
			}
		} else
		{
// else just print number/type of items
			if (Files)
			{
				stci_d(Ch,Files);
				if (Files > 1)
					strcat(Ch," files");
				else
					strcat(Ch," file");
				Ch = TempCh + strlen(TempCh);
			}
			if (Dirs)
			{
				if (Files)
				{
					strcat(Ch,", ");
					Ch += 2;
				}
				stci_d(Ch,Dirs);
				if (Dirs > 1)
					strcat(Ch," folders (and their contents)");
				else
					strcat(Ch," folder (and its contents)");
			}
		}
//		strcat(Ch,"?");
		MPtr[1] = TempCh;

		Ch = TempC2;
		strcpy(Ch,"from ");
		strcat(Ch,GetCString(Path));
		strcat(Ch,"?");
		MPtr[2] = TempC2;

		if (SimpleRequest(Edit->Window,MPtr,3,REQ_OK_CANCEL|REQ_CENTER|REQ_H_CENTER,NULL))
		{
			if (Dirs || (Files > 10))
			{
				NormSprite = FALSE;
				DisplayWaitSprite();
			}

// go through list until all items accounted for
			Node = (struct GrazerNode *)Edit->Special->pEditList->lh_Head;
			while (Next = (struct GrazerNode *)Node->EditNode.Node.MinNode.mln_Succ)
			{
				if (Node->EditNode.Status == EN_SELECTED)
				{
					if ((Item=DuplicateSmartString(Path))
					&&	(AppendToPath(Node->EditNode.Node.Name,Item)))
					{
// if directory, try to delete all its contents first
						if (Node->DOSClass == EN_DIRECTORY)
						{
							if (!DeleteDirectory(Item)) goto DErr;
						}

// now delete file/directory
						if ((Node->DOSClass == EN_DIRECTORY)
						||	(Node->DOSClass == EN_FILE))
						{
							if (!CrDeleteFile(GetCString(Item)))
							{
DErr:
								if (!NormSprite)
								{
									NormSprite = TRUE;
									DisplayNormalSprite();
								}
								strcpy(TempCh,"Unable to delete ");
								strcat(TempCh,GetCString(Item));
								MPtr[0] = TempCh;
								MPtr[1] = IoErrToText(IoErr());
								SimpleRequest(Edit->Window,MPtr,2,
									REQ_CENTER|REQ_H_CENTER,NULL);
								break;
							}
						}
					}
					if (Item)
					{
						FreeSmartString(Item);
						Item = NULL;
					}
				}
				Node = Next;
			}

			DoAllNewDir(Edit);
			CheckOtherSame(Edit);

			if (Item)	 // if err condition
			{
				FreeSmartString(Item);
				Item = NULL;
			}
		}
	}

Exit:
	if (!NormSprite) {
		NormSprite = TRUE;
		DisplayNormalSprite();
	}
	return(FALSE);

}

/****** GrazerGadgets/GrazerDuplicate **********************************
*
*   NAME
*	GrazerDuplicate
*
*   SYNOPSIS
*	struct EditWindow *GrazerDuplicate(struct EditWindow *Edit)
*
*   FUNCTION
*	Duplicates any selected files or directories
*
*********************************************************************
*/
BOOL GrazerDuplicate(struct EditWindow *Edit)
{
	struct GrazerNode *Node,*Next;
	char *MPtr[3],*CSrc,*DC;
	struct SmartString *Src=NULL,*Dest=NULL,*SrcName,*Path;
	LONG Err,Count=0;
	BOOL Update = FALSE,Started = FALSE;

	Path = ((struct Grazer *)Edit->Special)->Path;

	{
		BPTR	lock;

		if ( lock = Lock( GetCString(Path),ACCESS_READ) )
		{
			struct InfoData	*id;

			if ( id = AllocMem( sizeof(struct InfoData),MEMF_PUBLIC|MEMF_CLEAR) )
			{
				if ( Info(lock,id) )
				{
					if ( !(strncmp( (char *)&id->id_DiskType,"FLY",3)) )
					{
						/* Duplicate on flyer file system drive */
						GrazerCopyMode = 2;
					}
				}

				FreeMem(id,sizeof(*id));
			}

			UnLock(lock);
		}
	}

// count # of items
	Node = (struct GrazerNode *)Edit->Special->pEditList->lh_Head;
	while (Next = (struct GrazerNode *)Node->EditNode.Node.MinNode.mln_Succ) {
		if (Node->EditNode.Status == EN_SELECTED) Count++;
		Node = Next;
	}

// for all selected items, allow user to enter new name
	Node = (struct GrazerNode *)Edit->Special->pEditList->lh_Head;
	while (Next = (struct GrazerNode *)Node->EditNode.Node.MinNode.mln_Succ) {
		if (Node->EditNode.Status == EN_SELECTED) {
			SrcName = Node->EditNode.Node.Name;
			CSrc = GetCString(SrcName);

// cannot duplicate devices or folders
		if ((Node->DOSClass != EN_FILE) && (Node->DOSClass != EN_DIRECTORY)) {
			MPtr[0] = "Unable to duplicate";
			MPtr[1] = CSrc;
			MPtr[2] = "Only files and folders can be duplicated.";
			SimpleRequest(Edit->Window,MPtr,3,
				REQ_CENTER|REQ_H_CENTER,NULL);
			break;

		} else {
			MPtr[0] = TempCh;
			strcpy(TempCh,"Enter name for copy of ");
			strcat(TempCh,CSrc);
			strcpy(TempC2,CSrc);
			if (!stcpm(TempC2,"Copy",&DC)) strcat(TempC2,"Copy");
			if (SimpleRequest(Edit->Window,MPtr,1,
				REQ_STRING|REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,TempC2)) {

			if ((Src=DuplicateSmartString(Path)) &&
				(AppendToPath(SrcName,Src)) &&
				(Dest=DuplicateSmartString(Path)) &&
				(AppendCToPath(TempC2,Dest))) {

				Update = TRUE;
				if (!Started) {
					Started = TRUE;
					if ((Count > 1) || (FileOrDirectory(Src)!=A_FILE)
						|| (FileSize(GetCString(Src))) > 50000)
						StartNiceCopy(Edit->Window,TRUE,TRUE);
					else
						StartNiceCopy(Edit->Window,FALSE,TRUE);
				}

				// Copy file and its .i/.info file
				if (Err = NiceCopy(GetCString(Src),GetCString(Dest),TempC2,TRUE))
				{
					if (Err < ERROR_USER_ABORT) {
					MPtr[0] = "Unable to create";
					MPtr[1] = GetCString(Dest);
					MPtr[2] = IoErrToText(Err);
					SimpleRequest(Edit->Window,MPtr,3,
						REQ_CENTER|REQ_H_CENTER,NULL);
					}
					break;
				}

			}
			if (Src) {
				FreeSmartString(Src);
				Src = NULL;
			}
			if (Dest) {
				FreeSmartString(Dest);
				Dest = NULL;
			}

// if ever cancel, exit (forget about any remaining selected items)
			} else break;
		}
		}
		Node = Next;
	}

	/* Clear copymode to default (just in case) */
	GrazerCopyMode = 0;

	if (Src) {
		FreeSmartString(Src);
		Src = NULL;
	}
	if (Dest) {
		FreeSmartString(Dest);
		Dest = NULL;
	}
	if (Update)
	{
		DoAllNewDir(Edit);
		CheckOtherSame(Edit);
	}
	if (Started) EndNiceCopy();
	return(FALSE);
}

/****** Grazer/HandleRename ************************************
*
*   NAME
*	HandleRename
*
*   SYNOPSIS
*	struct EditWindow *HandleRename(struct EditWindow *Edit,
*		struct IntuiMessage *IntuiMsg)
*
*   FUNCTION
*
*
*********************************************************************
*/
struct EditWindow *HandleRename(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	struct GrazerNode *Node,*Next;
	char *MPtr[3],*CSrc;
	struct SmartString *Src=NULL,*Dest=NULL,*SrcName,*Path;
	LONG Err,L;
	BOOL Update = FALSE,Label,Success;

	Path = ((struct Grazer *)Edit->Special)->Path;
// for all selected items, allow user to enter new name
	Node = (struct GrazerNode *)Edit->Special->pEditList->lh_Head;
	while (Next = (struct GrazerNode *)Node->EditNode.Node.MinNode.mln_Succ) {
		if (Node->EditNode.Status == EN_SELECTED) {
			SrcName = Node->EditNode.Node.Name;
			CSrc = GetCString(SrcName);

// cannot rename devices or folders
		if ((Node->DOSClass != EN_FILE) && (Node->DOSClass != EN_DIRECTORY) &&
			(Node->DOSClass != EN_VOLUME)) {
			MPtr[0] = "Unable to rename";
			MPtr[1] = CSrc;
			MPtr[2] = "Only files, folders and volumes can be renamed.";
			SimpleRequest(Edit->Window,MPtr,3,
				REQ_CENTER|REQ_H_CENTER,NULL);
			break;

		} else {
			Label = TRUE;
			if ((Node->DOSClass == EN_FILE) || (Node->DOSClass == EN_DIRECTORY))
				Label = FALSE;

			MPtr[0] = TempCh;
			strcpy(TempCh,"Enter new name for ");
			strcat(TempCh,CSrc);
			strcpy(TempC2,CSrc);
			if (SimpleRequest(Edit->Window,MPtr,1,
				REQ_STRING|REQ_CENTER|REQ_H_CENTER|REQ_OK_CANCEL,TempC2)) {

		// max AmigaDOS len
				if (strlen(TempC2) > MAX_FILE) TempC2[MAX_FILE] = 0;
		// do not include ":" in volume names
				L = strlen(TempC2);
				if (TempC2[L-1] == ':') TempC2[L-1] = 0;

			if ((Src=DuplicateSmartString(Path)) &&
				(AppendToPath(SrcName,Src)) &&
				(Dest=DuplicateSmartString(Path)) &&
				(AppendCToPath(TempC2,Dest))) {

				if (Label)
					Success = Relabel(GetCString(Src),GetCString(Dest));
				else
					Success = Rename(GetCString(Src),GetCString(Dest));
				if (!Success) {
					Err = IoErr();
					MPtr[0] = "Unable to rename";
					MPtr[1] = GetCString(Src);
					MPtr[2] = IoErrToText(Err);
					SimpleRequest(Edit->Window,MPtr,3,
						REQ_CENTER|REQ_H_CENTER,NULL);
				}
        else
        {
          Update = TRUE;
  				if (Label)
            if( AppendCSmartString(".i",Src) && AppendCSmartString(".i",Dest) )
            {
              Rename(GetCString(Src),GetCString(Dest));
              if( AppendCSmartString("nfo",Src) && AppendCSmartString("nfo",Dest) )
                Rename(GetCString(Src),GetCString(Dest));
            }
        }
			}
			if (Src) {
				FreeSmartString(Src);
				Src = NULL;
			}
			if (Dest) {
				FreeSmartString(Dest);
				Dest = NULL;
			}

// if ever cancel, exit (forget about any remaining selected items)
			} else break;
		}
		}
		Node = Next;
	}

	if (Src) {
		FreeSmartString(Src);
		Src = NULL;
	}
	if (Dest) {
		FreeSmartString(Dest);
		Dest = NULL;
	}
	if (Update) {
		DoAllNewDir(Edit);
		CheckOtherSame(Edit);
	}
	return(Edit);
}

/****** Grazer/HandlePath ************************************
*
*   NAME
*	HandlePath
*
*   SYNOPSIS
*	struct EditWindow *HandlePath(struct EditWindow *Edit,
*		struct IntuiMessage *IntuiMsg)
*
*   FUNCTION
*	Goes from SI->Buffer to Grazer->Path
*
*********************************************************************
*/
struct EditWindow *HandlePath(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
	struct Gadget *Gadget;
	struct Grazer *Grazer;

	Gadget = FindGadget(Edit->Gadgets,ID_PATH);
	Grazer = (struct Grazer *)Edit->Special;
	EraseSmartString(Grazer->Path);
	AppendCSmartString(((struct StringInfo *)Gadget->SpecialInfo)->Buffer,
		Grazer->Path);
	DoAllNewDir(Edit);
	return(Edit);
}

/****** GrazerGadgets/GrazerAll **********************************
*
*   NAME
*	GrazerAll
*
*   SYNOPSIS
*	BOOL GrazerAll(struct EditWindow *Edit)
*
*   FUNCTION
*
*
*********************************************************************
*/
BOOL GrazerAll(struct EditWindow *Edit)
{
	if ( Edit->ew_cg )
	{
		ob_DoMethod( Edit->ew_cg,CRGRIDM_SelectCrouton,
			CROUTONNUM_ALL,GRIDSELECT_NORMAL,CROUTONSELECT_SELECTED);

		Edit->ew_OptRender = TRUE;
		Edit->RedrawSelect = TRUE;
		Edit->DisplayGrid = TRUE;
	}
	else
	{
		ChangeStatusList(Edit,EN_NOT_STATUS,EN_SELECTED);
	}
	return(TRUE);
}

// end of grazergadgets.c
@


2.25
log
@Had to add arg for new NiceCopy()
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.24 1995/07/27 18:13:33 Flick Exp Flick $
d5 3
d114 1
a114 1
#include <edit:popup/popup.h>
@


2.24
log
@Added "from drive:?" wording to GrazerDelete warning (and cleaned up code)
Fixed stuck-hilite in GrazerNewFolder
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.23 1995/07/13 16:57:23 Flick Exp Flick $
d5 4
d749 4
a752 2
				if (Err = NiceCopy(GetCString(Src),GetCString(Dest),
					TempC2)) {
@


2.23
log
@Made text more severe for delete files requester
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.22 1995/06/01 11:38:00 pfrench Exp Flick $
d5 3
d404 1
a404 1
	struct EditNode *Node;
d407 2
a408 2
	if (NewDir = PromptFileName(Path,"Folder ","Enter name of new folder.",
		Edit->Window)) {
d410 2
a411 1
		if (NewLock) {
d416 8
a423 5
			Node = (struct EditNode *)
				SearchSmartNodeName((struct SmartNode *)
				Edit->Special->pEditList->lh_Head,&TempCh[0]);
			if (Node) ChangeStatusNode(Edit,Node,EN_SELECTED);
		} else Err = IoErr();
d426 2
a427 1
	if (Err) {
d527 2
a528 1
	if (Dirs || Files) {
d533 6
a538 3
		if (((Dirs==1) && (!Files)) || ((Files==1) && (!Dirs))) {
			if (Files) strcpy(Ch,GetCString(FirstFile));
			else {
d542 2
a543 2
		} else {

d545 21
a565 10
		if (Files) {
			stci_d(Ch,Files);
			if (Files > 1) strcat(Ch," files");
			else strcat(Ch," file");
			Ch = TempCh + strlen(TempCh);
		}
		if (Dirs) {
			if (Files) {
				strcat(Ch,", ");
				Ch += 2;
a566 3
			stci_d(Ch,Dirs);
			if (Dirs > 1) strcat(Ch," folders (and their contents)");
			else strcat(Ch," folder (and its contents)");
d568 6
a573 1
		}
d575 1
a575 3
		MPtr[1] = TempCh;
		if (SimpleRequest(Edit->Window,MPtr,2,
			REQ_OK_CANCEL|REQ_CENTER|REQ_H_CENTER,NULL)) {
d577 7
a583 4
		if (Dirs || (Files > 10)) {
			NormSprite = FALSE;
			DisplayWaitSprite();
		}
d586 8
a593 7
	Node = (struct GrazerNode *)Edit->Special->pEditList->lh_Head;
	while (Next = (struct GrazerNode *)Node->EditNode.Node.MinNode.mln_Succ) {
		if (Node->EditNode.Status == EN_SELECTED) {

			if ((Item=DuplicateSmartString(Path)) &&
				(AppendToPath(Node->EditNode.Node.Name,Item))) {

d595 4
a598 3
			if (Node->DOSClass == EN_DIRECTORY) {
				if (!DeleteDirectory(Item)) goto DErr;
			}
d601 5
a605 3
			if ((Node->DOSClass == EN_DIRECTORY) ||
				(Node->DOSClass == EN_FILE)) {
				if (!CrDeleteFile(GetCString(Item))) {
d607 20
a626 11
		if (!NormSprite) {
			NormSprite = TRUE;
			DisplayNormalSprite();
		}
					strcpy(TempCh,"Unable to delete ");
					strcat(TempCh,GetCString(Item));
					MPtr[0] = TempCh;
					MPtr[1] = IoErrToText(IoErr());
					SimpleRequest(Edit->Window,MPtr,2,
						REQ_CENTER|REQ_H_CENTER,NULL);
					break;
d628 10
a639 15
		if (Item) {
			FreeSmartString(Item);
			Item = NULL;
		}
		}
		Node = Next;
	}

	DoAllNewDir(Edit);
	CheckOtherSame(Edit);
	if (Item) { // if err condition
		FreeSmartString(Item);
		Item = NULL;
	}
	}
@


2.22
log
@Duplicate now will engage fast flyer copy on flyer drives
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.21 1994/12/30 21:05:33 pfrench Exp pfrench $
d5 3
d520 1
a520 1
		MPtr[0] = "Are you sure you want to delete";
@


2.21
log
@Now correctly redraws new folders in files/files mode
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.20 1994/12/19 22:38:25 pfrench Exp pfrench $
d5 3
d81 1
a81 1
* Confidental and Proprietary. All rights reserved. 
d145 1
d154 1
a154 1
*   NAME   
d162 1
a162 1
*	
d178 1
a178 1
*   NAME   
d312 1
a312 1
*   NAME   
d570 1
a570 1
			if ((Node->DOSClass == EN_DIRECTORY) || 
d616 1
a616 1
*   NAME   
d637 25
d705 1
a705 1
					else 
d719 1
a719 1
		
d727 1
a727 1
				Dest = NULL;	
d737 3
d746 1
a746 1
		Dest = NULL;	
d759 1
a759 1
*   NAME   
d767 1
a767 1
*	
d866 1
a866 1
		Dest = NULL;	
d877 1
a877 1
*   NAME   
d905 1
a905 1
*   NAME   
d912 1
a912 1
*	
@


2.20
log
@Modified for now shared-code proof.library.
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.19 1994/11/11 11:54:33 pfrench Exp pfrench $
d5 3
d402 1
a404 1
			DeselectOtherEdit(Edit);
@


2.19
log
@Got Select All working correctly
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.18 1994/09/27 16:23:17 pfrench Exp pfrench $
d5 3
d98 4
a101 1
#include <object.h>
d133 1
@


2.18
log
@Removed all calls to FreeDirCache as it is being
handled automatically now.
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.17 1994/09/20 22:49:37 pfrench Exp pfrench $
d5 4
d95 3
d876 13
a888 1
	ChangeStatusList(Edit,EN_NOT_STATUS,EN_SELECTED);
@


2.17
log
@Modified to work with dircache (Editwindow has ptr to list now)
@
text
@d3 5
a7 2
* $Id: grazergadgets.c,v 2.16 1994/08/30 10:41:05 Kell Exp pfrench $
* $Log: grazergadgets.c,v $
a384 6
			/* FLUSH the DirCache here */
			if ( Edit->Special->dircache )
			{
				FreeDirCache(Edit->Special->dircache);
				Edit->Special->dircache = NULL;
			}
a424 6
		/* FLUSH the DirCache here */
		if ( Edit->Special->dircache )
		{
			FreeDirCache(Edit->Special->dircache);
			Edit->Special->dircache = NULL;
		}
a574 7
	/* FLUSH the DirCache here */
	if ( Edit->Special->dircache )
	{
		FreeDirCache(Edit->Special->dircache);
		Edit->Special->dircache = NULL;
	}

a700 6
		/* FLUSH the DirCache here */
		if ( Edit->Special->dircache )
		{
			FreeDirCache(Edit->Special->dircache);
			Edit->Special->dircache = NULL;
		}
a819 6
		/* FLUSH the DirCache here */
		if ( Edit->Special->dircache )
		{
			FreeDirCache(Edit->Special->dircache);
			Edit->Special->dircache = NULL;
		}
@


2.16
log
@Changed SendSwitcherReply calls to work with new ESParams structures.
@
text
@d3 1
a3 1
* $Id: grazergadgets.c,v 2.15 1994/08/11 16:55:03 pfrench Exp Kell $
d5 3
d104 1
d382 6
d393 1
a393 1
				Edit->Special->EditList.lh_Head,&TempCh[0]);
d428 6
d439 1
a439 1
			Edit->Special->EditList.lh_Head,&TempCh[0]);
d476 1
a476 1
	Node = (struct GrazerNode *)Edit->Special->EditList.lh_Head;
d545 1
a545 1
	Node = (struct GrazerNode *)Edit->Special->EditList.lh_Head;
d584 7
d633 1
a633 1
	Node = (struct GrazerNode *)Edit->Special->EditList.lh_Head;
d640 1
a640 1
	Node = (struct GrazerNode *)Edit->Special->EditList.lh_Head;
d715 8
a722 1
	if (Update) {
d754 1
a754 1
	Node = (struct GrazerNode *)Edit->Special->EditList.lh_Head;
d842 6
@


2.15
log
@Disabled (temporarily, at least). Projects saving from
within the grazer's path string gadget.
@
text
@d3 6
a8 2
* $Id: GrazerGadgets.c,v 2.14 1994/07/31 14:43:36 pfrench Exp pfrench $
* $Log: GrazerGadgets.c,v $
d119 2
d411 3
a413 1
		Err=SendSwitcherReply(ES_NewProject,0,(LONG)ProjectName,NULL); // proj. ##, name
@


2.14
log
@HandlePath() now supports creating files with the grazer.
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.13 1994/06/07 10:17:42 CACHELIN4000 Exp pfrench $
d5 3
a834 7

	if ( global_gr && (global_gr->gr_Flags & GRAZREQ_VALIDFILENAME) )
	{
		EndGrazerRequest(TRUE);
		Edit = NULL;
	}
		
@


2.13
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: GrazerGadgets.c,v 2.12 94/03/19 00:05:00 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	GrazerGadgets.c,v $
d832 7
@


2.12
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.11 94/03/17 09:53:31 Kell Exp Locker: CACHELIN4000 $
d5 3
d153 3
@


2.11
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: grazergadgets.c,v 2.10 94/03/16 18:13:16 CACHELIN4000 Exp Locker: Kell $
* $Log:	grazergadgets.c,v $
@


2.10
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: GrazerGadgets.c,v 2.9 94/03/16 17:30:14 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	GrazerGadgets.c,v $
d91 1
a91 1
#define SERDEBUG	1
@


2.9
log
@Fix Project Saving ??
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.8 94/03/15 16:12:51 Kell Exp Locker: CACHELIN4000 $
d5 3
a383 2
		DUMPMSG("Before HandleNewProject() sends ES_NewProject");
		Err=SendSwitcherReply(ES_NewProject,0,(LONG)GetCString(NewDir),NULL); // proj. ##, name
d385 3
d411 1
a411 1
*   NAME   
@


2.8
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: grazergadgets.c,v 2.7 94/03/14 21:57:12 CACHELIN4000 Exp Locker: Kell $
* $Log:	grazergadgets.c,v $
d383 1
@


2.7
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: GrazerGadgets.c,v 2.6 94/03/14 00:30:52 CACHELIN4000 Exp Locker: CACHELIN4000 $
* $Log:	GrazerGadgets.c,v $
@


2.6
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: GrazerGadgets.c,v 2.5 94/03/13 07:51:39 Kell Exp Locker: CACHELIN4000 $
d5 3
d88 1
a88 1

d128 1
a128 1
*	
d376 1
a376 1
		Err=SendSwitcherReply(ES_NewProject,(LONG)GetCString(NewDir),NULL,NULL);
@


2.5
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: grazergadgets.c,v 2.4 94/03/11 09:32:18 Kell Exp Locker: Kell $
* $Log:	grazergadgets.c,v $
d76 1
a76 1
//#define SERDEBUG	1
@


2.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: grazergadgets.c,v 2.3 94/03/02 21:06:04 CACHELIN4000 Exp Locker: Kell $
d5 3
d73 1
a73 1
#define SERDEBUG	1
@


2.3
log
@*** empty log message ***
@
text
@d3 5
a7 2
* $Id: GrazerGadgets.c,v 2.2 94/02/23 14:52:36 Kell Exp Locker: CACHELIN4000 $
* $Log:	GrazerGadgets.c,v $
d70 3
d366 1
a366 1
		DumpMsg("Before HandleNewProject() sends ES_NewProject");
d368 1
a368 1
		DumpMsg("  After HandleNewProject() sent ES_NewProject");
@


2.2
log
@*** empty log message ***
@
text
@Binary files GrazerGadgets.c and t:,RCSt1A7195c18 differ
@


2.1
log
@*** empty log message ***
@
text
@Binary files GrazerGadgets.c and t:,RCSt1A70c3480 differ
@


2.0
log
@FirstCheckIn
@
text
@Binary files GrazerGadgets.c and t:,RCSt1A70c0270 differ
@
