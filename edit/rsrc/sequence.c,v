head	2.136;
access;
symbols;
locks; strict;
comment	@*@;


2.136
date	97.02.04.00.09.51;	author Holt;	state Exp;
branches;
next	2.135;

2.135
date	96.11.20.16.09.34;	author Holt;	state Exp;
branches;
next	2.134;

2.134
date	96.11.18.18.42.43;	author Holt;	state Exp;
branches;
next	2.133;

2.133
date	96.07.19.14.54.15;	author Holt;	state Exp;
branches;
next	2.132;

2.132
date	96.07.15.18.30.11;	author Holt;	state Exp;
branches;
next	2.131;

2.131
date	96.06.26.10.30.12;	author Holt;	state Exp;
branches;
next	2.130;

2.130
date	96.06.25.17.10.08;	author Holt;	state Exp;
branches;
next	2.129;

2.129
date	96.04.29.10.32.45;	author Holt;	state Exp;
branches;
next	2.128;

2.128
date	96.03.19.17.34.10;	author Holt;	state Exp;
branches;
next	2.127;

2.127
date	96.03.01.13.22.37;	author Holt;	state Exp;
branches;
next	2.126;

2.126
date	95.12.26.18.18.23;	author Holt;	state Exp;
branches;
next	2.125;

2.125
date	95.12.20.15.34.04;	author Holt;	state Exp;
branches;
next	2.124;

2.124
date	95.11.27.16.53.34;	author Flick;	state Exp;
branches;
next	2.123;

2.123
date	95.11.16.14.41.05;	author Flick;	state Exp;
branches;
next	2.122;

2.122
date	95.11.15.18.33.54;	author Flick;	state Exp;
branches;
next	2.121;

2.121
date	95.11.14.18.25.16;	author Flick;	state Exp;
branches;
next	2.120;

2.120
date	95.11.10.04.38.26;	author Flick;	state Exp;
branches;
next	2.119;

2.119
date	95.11.09.17.53.46;	author Flick;	state Exp;
branches;
next	2.118;

2.118
date	95.10.17.17.26.15;	author Flick;	state Exp;
branches;
next	2.117;

2.117
date	95.10.09.16.48.34;	author Flick;	state Exp;
branches;
next	2.116;

2.116
date	95.10.06.16.13.59;	author Flick;	state Exp;
branches;
next	2.115;

2.115
date	95.10.05.18.41.36;	author Flick;	state Exp;
branches;
next	2.114;

2.114
date	95.10.02.15.30.30;	author Flick;	state Exp;
branches;
next	2.113;

2.113
date	95.09.28.10.19.10;	author Flick;	state Exp;
branches;
next	2.112;

2.112
date	95.09.25.12.41.32;	author Flick;	state Exp;
branches;
next	2.111;

2.111
date	95.09.19.12.18.38;	author Flick;	state Exp;
branches;
next	2.110;

2.110
date	95.09.13.13.10.49;	author Flick;	state Exp;
branches;
next	2.109;

2.109
date	95.08.31.16.16.40;	author Flick;	state Exp;
branches;
next	2.108;

2.108
date	95.08.28.16.41.31;	author Flick;	state Exp;
branches;
next	2.107;

2.107
date	95.08.28.11.58.49;	author Flick;	state Exp;
branches;
next	2.106;

2.106
date	95.08.23.13.29.32;	author Flick;	state Exp;
branches;
next	2.105;

2.105
date	95.08.18.17.17.10;	author Flick;	state Exp;
branches;
next	2.104;

2.104
date	95.08.18.17.12.05;	author Flick;	state Exp;
branches;
next	2.103;

2.103
date	95.08.16.10.50.46;	author Flick;	state Exp;
branches;
next	2.102;

2.102
date	95.08.09.18.07.14;	author Flick;	state Exp;
branches;
next	2.101;

2.101
date	95.08.09.14.13.25;	author Flick;	state Exp;
branches;
next	2.100;

2.100
date	95.08.02.15.11.35;	author Flick;	state Exp;
branches;
next	2.99;

2.99
date	95.07.28.16.34.59;	author Flick;	state Exp;
branches;
next	2.98;

2.98
date	95.07.20.16.39.35;	author Flick;	state Exp;
branches;
next	2.97;

2.97
date	95.07.14.10.56.54;	author Flick;	state Exp;
branches;
next	2.96;

2.96
date	95.07.13.13.11.10;	author Flick;	state Exp;
branches;
next	2.95;

2.95
date	95.07.07.19.25.15;	author Flick;	state Exp;
branches;
next	2.94;

2.94
date	95.07.06.18.24.49;	author Flick;	state Exp;
branches;
next	2.93;

2.93
date	95.07.06.18.22.38;	author Flick;	state Exp;
branches;
next	2.92;

2.92
date	95.07.05.14.59.16;	author Flick;	state Exp;
branches;
next	2.91;

2.91
date	95.06.28.18.11.52;	author Flick;	state Exp;
branches;
next	2.90;

2.90
date	95.06.26.17.19.46;	author Flick;	state Exp;
branches;
next	2.89;

2.89
date	95.06.20.23.48.24;	author Flick;	state Exp;
branches;
next	2.88;

2.88
date	95.04.28.09.31.18;	author pfrench;	state Exp;
branches;
next	2.87;

2.87
date	95.04.21.14.10.03;	author Flick;	state Exp;
branches;
next	2.86;

2.86
date	95.04.21.02.05.34;	author Flick;	state Exp;
branches;
next	2.85;

2.85
date	95.04.20.22.00.44;	author Flick;	state Exp;
branches;
next	2.84;

2.84
date	95.04.20.17.49.37;	author Holt;	state Exp;
branches;
next	2.83;

2.83
date	95.04.19.14.03.40;	author pfrench;	state Exp;
branches;
next	2.82;

2.82
date	95.04.18.16.51.50;	author Flick;	state Exp;
branches;
next	2.81;

2.81
date	95.03.16.16.02.07;	author CACHELIN4000;	state Exp;
branches;
next	2.80;

2.80
date	95.03.09.18.02.11;	author CACHELIN4000;	state Exp;
branches;
next	2.79;

2.79
date	95.02.23.15.20.56;	author CACHELIN4000;	state Exp;
branches;
next	2.78;

2.78
date	95.02.19.18.19.06;	author Kell;	state Exp;
branches;
next	2.77;

2.77
date	95.02.19.01.19.20;	author Kell;	state Exp;
branches;
next	2.76;

2.76
date	95.02.18.23.49.01;	author Kell;	state Exp;
branches;
next	2.75;

2.75
date	95.02.10.20.26.38;	author Kell;	state Exp;
branches;
next	2.74;

2.74
date	95.02.09.21.36.50;	author Kell;	state Exp;
branches;
next	2.73;

2.73
date	95.02.09.20.44.57;	author Kell;	state Exp;
branches;
next	2.72;

2.72
date	95.02.09.20.22.28;	author pfrench;	state Exp;
branches;
next	2.71;

2.71
date	95.02.09.19.47.00;	author pfrench;	state Exp;
branches;
next	2.70;

2.70
date	95.02.09.18.51.51;	author Kell;	state Exp;
branches;
next	2.69;

2.69
date	95.02.09.09.33.19;	author Kell;	state Exp;
branches;
next	2.68;

2.68
date	95.02.06.14.41.30;	author pfrench;	state Exp;
branches;
next	2.67;

2.67
date	95.01.12.12.04.59;	author CACHELIN4000;	state Exp;
branches;
next	2.66;

2.66
date	95.01.06.22.19.48;	author Kell;	state Exp;
branches;
next	2.65;

2.65
date	95.01.06.22.12.13;	author Kell;	state Exp;
branches;
next	2.64;

2.64
date	95.01.06.21.23.59;	author Kell;	state Exp;
branches;
next	2.63;

2.63
date	95.01.06.21.11.02;	author Kell;	state Exp;
branches;
next	2.62;

2.62
date	95.01.06.20.44.36;	author Kell;	state Exp;
branches;
next	2.61;

2.61
date	95.01.06.20.33.20;	author Kell;	state Exp;
branches;
next	2.60;

2.60
date	95.01.04.23.28.21;	author Kell;	state Exp;
branches;
next	2.59;

2.59
date	95.01.04.16.34.59;	author Kell;	state Exp;
branches;
next	2.58;

2.58
date	94.12.31.10.22.09;	author Kell;	state Exp;
branches;
next	2.57;

2.57
date	94.12.31.10.08.22;	author Kell;	state Exp;
branches;
next	2.56;

2.56
date	94.12.31.06.35.53;	author Kell;	state Exp;
branches;
next	2.55;

2.55
date	94.12.30.13.38.37;	author Kell;	state Exp;
branches;
next	2.54;

2.54
date	94.12.29.19.33.32;	author CACHELIN4000;	state Exp;
branches;
next	2.53;

2.53
date	94.12.28.18.01.16;	author Kell;	state Exp;
branches;
next	2.52;

2.52
date	94.12.27.22.35.38;	author Kell;	state Exp;
branches;
next	2.51;

2.51
date	94.12.23.07.18.52;	author Kell;	state Exp;
branches;
next	2.50;

2.50
date	94.12.16.20.02.58;	author pfrench;	state Exp;
branches;
next	2.49;

2.49
date	94.12.06.18.59.53;	author Kell;	state Exp;
branches;
next	2.48;

2.48
date	94.12.05.22.23.45;	author Kell;	state Exp;
branches;
next	2.47;

2.47
date	94.12.03.06.08.22;	author Kell;	state Exp;
branches;
next	2.46;

2.46
date	94.11.18.10.47.31;	author Kell;	state Exp;
branches;
next	2.45;

2.45
date	94.11.11.14.37.28;	author pfrench;	state Exp;
branches;
next	2.44;

2.44
date	94.11.10.17.04.20;	author pfrench;	state Exp;
branches;
next	2.43;

2.43
date	94.11.09.20.11.57;	author Kell;	state Exp;
branches;
next	2.42;

2.42
date	94.11.09.14.50.09;	author Kell;	state Exp;
branches;
next	2.41;

2.41
date	94.11.09.14.37.34;	author Kell;	state Exp;
branches;
next	2.40;

2.40
date	94.11.04.16.33.18;	author Kell;	state Exp;
branches;
next	2.39;

2.39
date	94.11.04.03.08.12;	author Kell;	state Exp;
branches;
next	2.38;

2.38
date	94.11.03.15.51.44;	author Kell;	state Exp;
branches;
next	2.37;

2.37
date	94.11.02.05.37.23;	author Kell;	state Exp;
branches;
next	2.36;

2.36
date	94.10.26.14.59.40;	author Kell;	state Exp;
branches;
next	2.35;

2.35
date	94.10.23.16.32.01;	author CACHELIN4000;	state Exp;
branches;
next	2.34;

2.34
date	94.10.12.18.16.09;	author Kell;	state Exp;
branches;
next	2.33;

2.33
date	94.10.05.02.42.20;	author Kell;	state Exp;
branches;
next	2.32;

2.32
date	94.09.29.15.39.28;	author Kell;	state Exp;
branches;
next	2.31;

2.31
date	94.09.28.18.50.47;	author Kell;	state Exp;
branches;
next	2.30;

2.30
date	94.09.25.16.40.45;	author Kell;	state Exp;
branches;
next	2.29;

2.29
date	94.09.23.19.35.59;	author Kell;	state Exp;
branches;
next	2.28;

2.28
date	94.09.23.10.47.49;	author Kell;	state Exp;
branches;
next	2.27;

2.27
date	94.09.22.05.08.12;	author Kell;	state Exp;
branches;
next	2.26;

2.26
date	94.08.30.10.49.20;	author Kell;	state Exp;
branches;
next	2.25;

2.25
date	94.08.27.15.56.56;	author CACHELIN4000;	state Exp;
branches;
next	2.24;

2.24
date	94.08.26.21.49.10;	author Kell;	state Exp;
branches;
next	2.23;

2.23
date	94.06.04.02.28.58;	author Kell;	state Exp;
branches;
next	2.22;

2.22
date	94.03.29.18.48.30;	author Kell;	state Exp;
branches;
next	2.21;

2.21
date	94.03.20.04.00.41;	author CACHELIN4000;	state Exp;
branches;
next	2.20;

2.20
date	94.03.19.13.16.02;	author Kell;	state Exp;
branches;
next	2.19;

2.19
date	94.03.19.09.10.49;	author Kell;	state Exp;
branches;
next	2.18;

2.18
date	94.03.18.18.08.17;	author Kell;	state Exp;
branches;
next	2.17;

2.17
date	94.03.18.09.26.53;	author Kell;	state Exp;
branches;
next	2.16;

2.16
date	94.03.18.04.44.47;	author Kell;	state Exp;
branches;
next	2.15;

2.15
date	94.03.17.09.49.24;	author Kell;	state Exp;
branches;
next	2.14;

2.14
date	94.03.16.17.36.32;	author Kell;	state Exp;
branches;
next	2.13;

2.13
date	94.03.16.16.56.17;	author Kell;	state Exp;
branches;
next	2.12;

2.12
date	94.03.16.16.36.30;	author Kell;	state Exp;
branches;
next	2.11;

2.11
date	94.03.16.14.19.37;	author Kell;	state Exp;
branches;
next	2.10;

2.10
date	94.03.16.11.49.55;	author Kell;	state Exp;
branches;
next	2.9;

2.9
date	94.03.16.11.48.19;	author Kell;	state Exp;
branches;
next	2.8;

2.8
date	94.03.16.11.46.39;	author Kell;	state Exp;
branches;
next	2.7;

2.7
date	94.03.16.11.38.44;	author Kell;	state Exp;
branches;
next	2.6;

2.6
date	94.03.15.22.17.40;	author Kell;	state Exp;
branches;
next	2.5;

2.5
date	94.03.13.07.48.56;	author Kell;	state Exp;
branches;
next	2.4;

2.4
date	94.03.11.09.32.28;	author Kell;	state Exp;
branches;
next	2.3;

2.3
date	94.03.05.21.03.53;	author CACHELIN4000;	state Exp;
branches;
next	2.2;

2.2
date	94.02.23.14.52.43;	author Kell;	state Exp;
branches;
next	2.1;

2.1
date	94.02.19.09.34.30;	author Kell;	state Exp;
branches;
next	2.0;

2.0
date	94.02.17.16.24.43;	author Kell;	state Exp;
branches;
next	;


desc
@RCS Controlled file
@


2.136
log
@turned off debugging.
@
text
@/********************************************************************
* $sequence.c$
* $Id: sequence.c,v 2.135 1996/11/20 16:09:34 Holt Exp Holt $
* $Log: sequence.c,v $
*Revision 2.135  1996/11/20  16:09:34  Holt
*Fixed EditTo_FollowUp problem that was turning
*framestores and still into framestorestills.
*
*Revision 2.134  1996/11/18  18:42:43  Holt
*added more support for envelope key downloading.
*may have broken edit to music. seems to trash tags or somthing.
*
*Revision 2.133  1996/07/19  14:54:15  Holt
*finished up cfx.
*
*Revision 2.132  1996/07/15  18:30:11  Holt
*made many change to make cfx work in sequenceing.
*
*Revision 2.131  1996/06/26  10:30:12  Holt
*comment out defines for audio envelope struct
*they are defined in switcher/sinc/flyer.h
*
*Revision 2.130  1996/06/25  17:10:08  Holt
*made many changes to support audio envelopes
*
*Revision 2.129  1996/04/29  10:32:45  Holt
*fixed problem with fixupafter cutto(again!!!)
*
*Revision 2.128  1996/03/19  17:34:10  Holt
*now keeps extra len for all type of video
*
*Revision 2.127  1996/03/01  13:22:37  Holt
*fixed BExtra of an Effect causing audio to be off after an audio clip
*locked to the in point of the video after the effect.
*
*Revision 2.126  1995/12/26  18:18:23  Holt
*fixed cut to music so it will aline it points on colorframe boundrys.
*
*Revision 2.125  1995/12/20  15:34:04  Holt
*fixed problem with duration of flyer stills comming out 0.
*
*Revision 2.124  1995/11/27  16:53:34  Flick
*Added catch-all error for non-decoded sequencing errors
*
*Revision 2.123  1995/11/16  14:41:05  Flick
*Improved SCSI error trapping to be able to pinpoint the SCSI drive for
*missing drives and for incomplete transfers, too.
*
*Revision 2.122  1995/11/15  18:33:54  Flick
*Added trap/display for FERR_BADPARAM (4)
*
*Revision 2.121  1995/11/14  18:25:16  Flick
*Now traps/displays nice errors for Flyer SCSI errors 64 & 67
*
*Revision 2.120  1995/11/10  04:38:26  Flick
*Now uses Flyer's GetClrSeqError method to get drive # for SCSI problem error
*
*Revision 2.119  1995/11/09  17:53:46  Flick
*Added error message for 65 (bad status), including possible drive pinpointing
*
*Revision 2.118  1995/10/17  17:26:15  Flick
*Auto-trim overlapping with locked crouton now detects when cannot trim, fails to play
*
*Revision 2.117  1995/10/09  16:48:34  Flick
*Now passing FG to all GetEvent(), although as it turns out I don't need this (yet?)
*Fixed TimeBetweenFGs to know about Lost Croutons (CT_ERROR type)
*Sequencer tries to insert black for these, will warn user when playing that some exist.
*
*Revision 2.116  1995/10/06  16:13:59  Flick
*When unlocking croutons, now recalculates Current Time display too (as well as Project Time)
*
*Revision 2.115  1995/10/05  18:41:36  Flick
*2 new sequencing errors for A/B head problems
*Auto insert message more informative
*
*Revision 2.114  1995/10/02  15:30:30  Flick
*Sequences TakeFrames that are not 50%, support for StopOnErr option during sequencing
*Calculates Currrent & Project time correctly for FX that have non-overlapping A/B sources
*Supports Automatic audio ramping w/ effects
*Sequence processing is now abortable (puts up a requester now while processing)
*
*Revision 2.113  1995/09/28  10:19:10  Flick
*Now support TakeOffset tag in sequencing, removed crouton.lib hack, now navigates error croutons
*into view properly on "inserted black" and "croutons overlap" errors.
*
*Revision 2.112  1995/09/25  12:41:32  Flick
*Added seq error for playing video clip from non-video drive
*
*Revision 2.111  1995/09/19  12:18:38  Flick
*FX sequencing now supports A/BSourceLen tags
*
*Revision 2.110  1995/09/13  13:10:49  Flick
*Added GetPrevGadget for putting up prev source on preview
*Fixed bug when locking/unlocking multiple audio croutons from hotkeys
*
*Revision 2.109  1995/08/31  16:16:40  Flick
*Added error panel when Flyer detects a bad A/V head for a clip w/effect
*Also does cleanup if user wishes
*
*Revision 2.108  1995/08/28  16:41:31  Flick
*Reworked Audio Under split builder to support multiple inserts, optional hilite
*of both ends ensures we grab all video between
*
*Revision 2.107  1995/08/28  11:58:49  Flick
*Supports cuts-only under Scrolls/crawls/keys/overlays now! (Flyer stuff only)
*New Audio-Under generator, switcher collision detection error reporting
*
*Revision 2.106  1995/08/23  13:29:32  Flick
*Added CTRL-stop panic hook into Flyer reset as insurance policy for 4.05
*
*Revision 2.105  1995/08/18  17:17:10  Flick
*Oh yeah! Forgot that all tags reads are bypasses ES system now -- Much faster!
*
*Revision 2.104  1995/08/18  17:12:05  Flick
*Fixed sequencing of framestores/main w/FX just before play-from point
*Added support for Flyer sequencing error detection (crippled at this point)
*Added f'n to calc total sequence time (for the running time display)
*Added ability to unlock audio crouton from outside panel (figures rel inpoint)
*Editing2 now puts temporary lock symbol on audio croutons until done
*Play buttons now stop an Editing2 session if stop not already pressed
*Status message stays at top now throughout Editing2 session
*
*Revision 2.103  1995/08/16  10:50:46  Flick
*Smarter queueing of keys so that any start time should work
*No "ready to play" requester from ARexx PlayProject
*
*Revision 2.102  1995/08/09  18:07:14  Flick
*Added support for sequencing non-transitional/overlay effects (+looping)
*Fixed bug in TimeBetweenFGs: multiple scrawls/overlays in one clip -- was wrong
*
*Revision 2.101  1995/08/09  14:13:25  Flick
*Sequencing errors are now highlighted and then navigated into visible area
*Sequencer now supports key options to fade or pop in/out
*Fixed Stills bug in Flyer downloading code (was requesting >4 fields)
*
*Revision 2.100  1995/08/02  15:11:35  Flick
*Handle error when Flyer can't locate a clip (with nice error panel now)
*Added error detection for two video clips locked out of order
*Added busy pointer on Lock/Unlock function (not on "live" version)
*Fixed bug where "Processing..." stayed up after aborting a "fix this" req
*
*Revision 2.99  1995/07/28  16:34:59  Flick
*Fixed play-from on video to play from inpoint (not adjusted point) -- this
*effectively removes any transition on that inpoint.  Also fixed which Flyer
*channel is punched up on a play-from (logic was not quite right).
*
*Revision 2.98  1995/07/20  16:39:35  Flick
*Fixed bug - was not including trailing split audio in total program time
*Would get trimmed off if ran past end of last video in project
*
*Revision 2.97  1995/07/14  10:56:54  Flick
*Now does (optional) auto-fixup after editing to music/video
*
*Revision 2.96  1995/07/13  13:11:10  Flick
*HandleLockDown() now works, even if no CurFG (dropped crtn or select all)
*HandlePlay() aborts unless EditTop is of type EW_PROJECT
*Uses EditTop everywhere, rather than Edit (is sometimes bottom window)
*
*Revision 2.95  1995/07/07  19:25:15  Flick
*Editing foley to video uses TIMEMODE_RELINPT, no longer locks to PROG TIME
*Corrected wording on ready window when ready to edit to video (not music)
*Now navigates hilite +1 when starting editing to an audio/video clip
*
*Revision 2.94  1995/07/06  18:24:49  Flick
*Disabled debugging (oops!)
*
*Revision 2.93  1995/07/06  18:22:38  Flick
*Fixed potential redraw problem with multiple croutons w/ HandleLockDown()
*
*Revision 2.92  1995/07/05  14:59:16  Flick
*Editing to music working better, got editing foley to video working
*
*Revision 2.91  1995/06/28  18:11:52  Flick
*Improved play-from to get actual time of highlighted event (after build)
*Play-from a transition backs up 2 seconds if possible
*Improved error reporting (especially for A/B full and no audio drive)
*Cutting to Music finished and working quite well
*
*Revision 2.90  1995/06/26  17:19:46  Flick
*Overhauled Play-From, builds entire project then trims it down
*
*Revision 2.89  1995/06/20  23:48:24  Flick
*Total overhaul!  Separate Switcher/Flyer/Audio tracks, downloads Flyer & Audio
*tracks to Flyer to run in parallel.  Have lock-down and black insertion,
*double-punch keys, dangling effects, and "prog time" audio all working well.
*
*Revision 2.88  1995/04/28  09:31:18  pfrench
*Added Wait4RMB message so queued play works
*
*Revision 2.87  1995/04/21  14:10:03  Flick
*Fixed play audio bug (audlength), more HandlePlay() cleanup
*
*Revision 2.86  1995/04/21  02:05:34  Flick
*Fixed pre-Q audio alignment bug for "play from crouton".  Improved Flyer head
*error handling.  More improvements to HandlePlay() for ARexx
*
*Revision 2.85  1995/04/20  22:00:44  Flick
*Cleaned up event table allocation, removed 12 field audio minimum
*
*Revision 2.84  1995/04/20  17:49:37  Holt
**** empty log message ***
*
*Revision 2.83  1995/04/19  14:03:40  pfrench
*Fixed enforcer hits in strange create/play/drop/play seq
*
*Revision 2.82  1995/04/18  16:51:50  Flick
*Re-added SHIFT-TAB hotkey, fixed hit when using ARexx PROJ_PLAY
*
*Revision 2.81  1995/03/16  16:02:07  CACHELIN4000
*Support keys, attempt at ChromaFX
*
*Revision 2.80  1995/03/09  18:02:11  CACHELIN4000
*Remove RecFields check on flyerstills
*
*Revision 2.79  1995/02/23  15:20:56  CACHELIN4000
*Reverse logic in test of PART_PLAY button
*
*Revision 2.78  1995/02/19  18:19:06  Kell
*Support for putting up a Key, FlyerStills, ToasterMain, ChromaFX, ARexx, Stop, Delay vs StartTime
*
*Revision 2.77  1995/02/19  01:19:20  Kell
*Changed CT_FLYERSTILL to CT_STILL
*
*Revision 2.76  1995/02/18  23:49:01  Kell
*Support of FlyerStills in sequencing.
*
*Revision 2.75  1995/02/10  20:26:38  Kell
*Now sequencing checks to make sure clips have not been deleted or re-recored since the project was loaded/created.
*
*Revision 2.74  1995/02/09  21:36:50  Kell
*Scrolls now have a Tolerance value on wait4time().
*
*Revision 2.73  1995/02/09  20:44:57  Kell
**** empty log message ***
*
*Revision 2.72  1995/02/09  20:22:28  pfrench
*fixed redraw bug when sequence ends or is aborted.
*
*Revision 2.71  1995/02/09  19:47:00  pfrench
*removed references to flyerstill file type as croutonlib
*doesn't support it anywhere.
*
*Revision 2.70  1995/02/09  18:51:51  Kell
*Now reports errors from sequences that failed during run time.
*
*Revision 2.69  1995/02/09  09:33:19  Kell
*Added various new types of content.  Got Scrawls to sort of work.
*
*Revision 2.68  1995/02/06  14:41:30  pfrench
*Fixed tiny bug in determining play/continue ("=" vs. "==")
*
*Revision 2.67  1995/01/12  12:04:59  CACHELIN4000
*Add support for PLAY_PART button in HAndlePlay()
*
*Revision 2.66  1995/01/06  22:19:48  Kell
*Flyer preroll now 20 fields
*
*Revision 2.65  1995/01/06  22:12:13  Kell
*Don't require addional Flyer preroll if long FX loading is required.
*
*Revision 2.64  1995/01/06  21:23:59  Kell
**** empty log message ***
*
*Revision 2.63  1995/01/06  21:11:02  Kell
*Now hilites correct crouton before sequence errors are reported.
*
*Revision 2.62  1995/01/06  20:44:36  Kell
*Fixed bug involving preload time of 1st video event.
*
*Revision 2.61  1995/01/06  20:33:20  Kell
*Fixed Qing previous audio during sequence from any point.
*New error checking that forces minimum load/Q times for clips/frames/anims/ilbm/algos.
*
*Revision 2.60  1995/01/04  23:28:21  Kell
*Using signed integers for most things now, to avoid sign mistakes on unsigned numbers.
*
*Revision 2.59  1995/01/04  16:34:59  Kell
*Fixed missing Left Audio during seqencing bug.
*Now crops unused audio (beyond sequence end) before making heads.
*
*Revision 2.58  1994/12/31  10:22:09  Kell
**** empty log message ***
*
*Revision 2.57  1994/12/31  10:08:22  Kell
*Re-enabled the 20 field clip check.  Removed their short heads though.
*Now supports MATTE at end of flyerclips at end of Sequence only.
*Now can pre-Q audio that happens before sequence point.
*
*Revision 2.56  1994/12/31  06:35:53  Kell
**** empty log message ***
*
*Revision 2.55  1994/12/30  13:38:37  Kell
*New QuickSort.  Re-anabled heads on cuts only.
*
*Revision 2.54  1994/12/29  19:33:32  CACHELIN4000
*Add Wrapper f'n HandlePlay() for renamed SeqHandlePlay(), FirstFG is CurFG or NULL
*depending hwether full or partial sequence is desired (shift-Play)
*
*Revision 2.53  1994/12/28  18:01:16  Kell
*Now goes to Matte black at sequence start if necessary.
*Doesn't now recalculate SeqeunceVideoStartTime over and over and over.
*
*Revision 2.52  1994/12/27  22:35:38  Kell
*New split audio stuff calculations.  Works better in "Seq. from any point"
*
*Revision 2.51  1994/12/23  07:18:52  Kell
*Now aborts Flyer stuff before making any heads.
*
*Revision 2.50  1994/12/16  20:02:58  pfrench
*Had to rename function with same name as flyer lvo
*
*Revision 2.49  1994/12/06  18:59:53  Kell
*Removed 4 field head for cuts only.  Now video clips must be >= 20 fields long.
*
*Revision 2.48  1994/12/05  22:23:45  Kell
*Fixed Enforcer hit.
*
*Revision 2.47  1994/12/03  06:08:22  Kell
*Now supports Split Audio.  Has more than one event table.
*Also, some Event items are now stored as Tag items.
*
*Revision 2.46  1994/11/18  10:47:31  Kell
*Work on error messages.
*
*Revision 2.45  1994/11/11  14:37:28  pfrench
*Moved refreshedit call to after last fastgadget selection
*
*Revision 2.44  1994/11/10  17:04:20  pfrench
*Made for quicker highlighting of next crouton (proof)
*
*Revision 2.43  1994/11/09  20:11:57  Kell
*New sequence error messages, using the errors.c file.
*
*Revision 2.42  1994/11/09  14:50:09  Kell
**** empty log message ***
*
*Revision 2.41  1994/11/09  14:37:34  Kell
*Most ReportSequenceError messages disabled !!!!!!
*New stand alone audio stuff which uses it's own event table.
*Stuff to sort the audio event table.
*Now has fields in the event table to indicated crouton position.
*
*Revision 2.40  1994/11/04  16:33:18  Kell
*Added initial support for stand alone audio clips when sequencing.
*
*Revision 2.39  1994/11/04  03:08:12  Kell
*Beginnings of CT_AUDIO handling.
*
*Revision 2.38  1994/11/03  15:51:44  Kell
*Error checking on MakeClipHead.
*
*Revision 2.37  1994/11/02  05:37:23  Kell
*Fixed bugs with errors during Sequence analysis or during sequencing or abort showing more than one crouton hilited.  And it now does a select default before and after sequencing.
*
*Revision 2.36  1994/10/26  14:59:40  Kell
**** empty log message ***
*
*Revision 2.35  1994/10/23  16:32:01  CACHELIN4000
*Change line 438 over phone from skell....get rid of FXAdvance
*
*Revision 2.34  94/10/12  18:16:09  Kell
*Now doesn't make video heads unless same volume on both clips.
*
*Revision 2.33  1994/10/05  02:42:20  Kell
*Better Sequencing Debugs
*
*Revision 2.32  1994/09/29  15:39:28  Kell
*First time actually doing true A/B with heads.
*
*Revision 2.31  1994/09/28  18:50:47  Kell
*Some debugs added for sequencing.
*
*Revision 2.30  1994/09/25  16:40:45  Kell
*Changed ES_StopSeq to ES_Stop
*
*Revision 2.29  1994/09/23  19:35:59  Kell
*More work to Sequence generation code.
*
*Revision 2.28  1994/09/23  10:47:49  Kell
*More frame accurate.  Better error reporting.
*
*Revision 2.27  1994/09/22  05:08:12  Kell
*Reworked the Sequencing code that creates the event commands.
*
*Revision 2.26  1994/08/30  10:49:20  Kell
*Changed SendSwitcherReply calls to work with new ESParams structures.
*
*Revision 2.25  1994/08/27  15:56:56  CACHELIN4000
*Add HandleStop function for Project Stop Gadget
*
*Revision 2.24  94/08/26  21:49:10  Kell
*Removed working with some obsolete Flyer tag items
*
*Revision 2.23  1994/06/04  02:28:58  Kell
*Now using FGC_SELECT and FGC_TOMAIN (instead of SELECTQ / AUTO) when sequencing.
*
*Revision 2.22  94/03/29  18:48:30  Kell
*Sequencing fixed for NAB.
*
*Revision 2.21  94/03/20  04:00:41  CACHELIN4000
*Select Error crouton... see ChangeStatusList()
*
*Revision 2.20  94/03/19  13:16:02  Kell
*New sequences the new Control crouton type.
*
*Revision 2.19  94/03/19  09:10:49  Kell
**** empty log message ***
*
*Revision 2.18  94/03/18  18:08:17  Kell
*Now supports lenthening clips for duration of transitions
*
*Revision 2.17  94/03/18  09:26:53  Kell
*Better timing on DHD clips.
*
*Revision 2.16  94/03/18  04:44:47  Kell
*Renamed Flier to Flyer
*
*Revision 2.15  94/03/17  09:49:24  Kell
*Working logic for sequencing Frames and FX.
*
*Revision 2.14  94/03/16  17:36:32  Kell
**** empty log message ***
*
*Revision 2.13  94/03/16  16:56:17  Kell
**** empty log message ***
*
*Revision 2.11  94/03/16  14:19:37  Kell
*New code.  Total rewrite.
*
*Revision 2.10  94/03/16  11:49:55  Kell
**** empty log message ***
*
*Revision 2.9  94/03/16  11:48:19  Kell
**** empty log message ***
*
*Revision 2.7  94/03/16  11:38:44  Kell
**** empty log message ***
*
*Revision 2.6  94/03/15  22:17:40  Kell
**** empty log message ***
*
*Revision 2.5  94/03/13  07:48:56  Kell
**** empty log message ***
*
*Revision 2.4  94/03/11  09:32:28  Kell
**** empty log message ***
*
*Revision 2.3  94/03/05  21:03:53  CACHELIN4000
**** empty log message ***
*
*Revision 2.2  94/02/23  14:52:43  Kell
**** empty log message ***
*
*Revision 2.1  94/02/19  09:34:30  Kell
**** empty log message ***
*
*Revision 2.0  94/02/17  16:24:43  Kell
*FirstCheckIn
*
*Revision 2.0  94/02/17  15:57:55  Kell
*FirstCheckIn
*
*Revision 2.0  94/02/17  14:45:01  Kell
*FirstCheckIn
*
*
* Copyright (c)1993 NewTek, Inc.
* Confidental and Proprietary. All rights reserved.
*
*	12-7-93	Steve H		Created this file
*	12-7-93	Steve H		Last Update
*********************************************************************/
#include <exec/types.h>
#include <exec/memory.h>
#include <graphics/gfxmacros.h>
#include <graphics/gfxbase.h>
#include <graphics/text.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <edit.h>
#include <editwindow.h>
#include <project.h>
#include <gadgets.h>
#include <editswit.h>
#include <tags.h>
#include <project.h>
#include <crouton_all.h>
#include <seqerrors.h>
#include <flyerlib.h>
#include <flyer.h>

#include <proto/exec.h>
#include <proto/dos.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
#include <proto/diskfont.h>

#ifndef PROTO_PASS
#include <proto.h>
#endif

//#define SERDEBUG	1
#include <serialdebug.h>


/*** External functions ***/
//extern BOOL Wait4LRMB(void);	/* toastsupport.a */
extern BPTR __asm GetBootLock(register __a0 struct ToasterBase *);
extern VOID DisplayWaitSprite(VOID);
extern VOID DisplayNormalSprite(VOID);
extern VOID __asm FlyerChanOnMain(register __d0 UBYTE channel);
extern ULONG __asm TimeFGselect(register __a0 struct ExtFastGadget *);
extern void  __asm ReadySeq(register __a0 struct PlaySeqInfo *);
extern BOOL  __asm PlaySeq(register __a0 struct PlaySeqInfo *);
LONG __asm GetCurProgTime(void);
extern LONG ew_QuickSelect(struct EditWindow *Edit, LONG nodenum);
extern LONG ew_MultiSelect(struct EditWindow *Edit, LONG nodenum);
extern LONG ew_ForceRedraw(struct EditWindow *Edit, LONG nodenum);
extern void	Main2Blank();

#define	TM_TEMP_LOCKED		0x10000000			/* Marker for croutons just edited live */

//*** Definitions ****************************************************

//
// Because I can't do an FX immediately after a Take, and because some FX
// may need a ChangeIS(), or require other setup/load time, and because some
// FX need some cleanup time, I won't allow FX to be butted together.
// And even takes can only occur at 15 times/sec.
// I don't need to check for takes any faster, because we won't support
// video durations of < 4 fields.

#define FXPREROLLFUDGE 	   8	// For AlgoFX, (ANIMs & ILBMs require much more time!)
#define ANIMPREROLLFUDGE  90  // Used for ANIMFX, KeyedANIMs and VideoANIMs
#define ILBMPREROLLFUDGE  45	// Used by ILBMfx, Scrolls, Crawls
#define FRAMEPREROLLFUDGE 90	// Used by FrameStores, ChromaFX & Keyed Stills
#define RGBPREROLLFUDGE   120	// Used by Images
#define VIDEOPREROLLFUDGE 4	// Used for clips & flyerstills
#define CRFXPREROLLFUDGE	240	// Used by Chromafx croutons


#define SCRAWLKEYANIMTOLERANCE	4	//allow for some error on keyed things
#define AREXXTOLERANCE				8	//allow for some error on keyed things
#define CONTROLTOLERANCE			4	
#define CRFXTOLERANCE				32	

//*******************************************************************
// These constants represent the amount of internal delay required
// just to setup certain switcher events.  This is not including
// disk loading and other SELECT delays, but represent the lead time
// required for a TOMAIN, for example, to setup and go
#define	OVERLAY_SETUP		20			// Strange but true, needs 20 fields!
#define	KEY_SETUP			6

//*******************************************************************

#define ROUNDUPTOFRAME(n)		(((n)+3) & ~3)
#define ROUNDDOWNTOFRAME(n)	((n) & ~3)


//----- STRUCTURES FOR AUDIO ENVELOPES -----
// One AudEnv_Key
/* Defined in "switcher/sinc/flyer.h"
struct AEKey {
	ULONG	GoTime;
	ULONG	NumOfFlds;
	UWORD	Flags;
	UWORD VOL1;
	UWORD VOL2;
	WORD PAN1;
	WORD PAN2;
};


struct AudioEnv {
	UWORD	Flags;
	UWORD	 Keysused;
	struct AEKey AEKeys[16];
};
*/


//------------------------
struct Event {
	struct	MinNode	Node;			//
	struct	ExtFastGadget *FG;	//->the crouton, NULL if last Event
	WORD		FGCcommand;				//FGC_SELECT, FGC_QUEUE or FGC_TOMAIN
	WORD	 	CurrentPosition;		//Current Position within sequence
	LONG 		Time;						//On FGC_ToMain, this is the time this FGC
											//should occur, but on FGC_Selects its time
							 				//Qed items should occur.
											//On last Event = total time if last Event
	UWORD		TimeTolerance;			//How late can the event occur and still be OK
	LONG		StartField;				//1st field of Video or Audio (Not used by PlaySeq())
	LONG		Duration;				//Duration in fields
	LONG		AudStart;				//Audio start field
	LONG		AudLength;				//Audio duration in fields
	UBYTE		Flags1;
	UBYTE		Flags2;
	UBYTE		Channel;					//Used for Flyer video effects and takes
	UBYTE		pad;
	UWORD		AudAttack,AudDecay;	//Manual ramp rates
	LONG		extra;					//offset created by aextra,bextra
	struct 	AudioEnv AE;			//AudioEnv for Event.  //struct def in switcher/sinc/flyer.h
};

#define FLAGS1B_WAIT4TIME	0		/* Wait for a program time */
#define FLAGS1B_SETCHAN		1		/* Set preview channel before TAKE/AUTO */
#define FLAGS1B_WAIT4GPI	2		/* Unused */
#define FLAGS1B_LOOP			3		/* ??? */
#define FLAGS1B_DOTAKE		4		/* UNUSED??? */
#define FLAGS1B_LOOPTIME	5		/* Plant a stop time for looping effects */
#define FLAGS2B_MATTE		0		/* System-inserted matte */
#define FLAGS2B_FXIN			1		/* Video will transition in using FX */
#define FLAGS2B_SKIP			2		/* Process but do not play this crouton */
#define FLAGS2B_MISC			7		/* Misc flag for use during processing */

#define FLAGS1F_WAIT4TIME	(1<<FLAGS1B_WAIT4TIME)
#define FLAGS1F_SETCHAN		(1<<FLAGS1B_SETCHAN)
#define FLAGS1F_WAIT4GPI	(1<<FLAGS1B_WAIT4GPI)
#define FLAGS1F_LOOP			(1<<FLAGS1B_LOOP)
#define FLAGS1F_LOOPTIME	(1<<FLAGS1B_LOOPTIME)
#define FLAGS2F_MATTE		(1<<FLAGS2B_MATTE)
#define FLAGS2F_FXIN			(1<<FLAGS2B_FXIN)
#define FLAGS2F_SKIP			(1<<FLAGS2B_SKIP)
#define FLAGS2F_MISC			(1<<FLAGS2B_MISC)


// VideoEvents also include Transitions, Scrawls, SolidANIMs & KeyedANIMs,
// because these are mutually exclusive.  No new video sources are allowed
// while the transition/scrawls/allANIMs are occuring.
// They take over the machine.

// Also we're including non-transitional, don't take over the machine &
// may exist over takes e.g. ChromaFX

// Also we have Keyed frames.
// Cuts to somethings are allowed, though on tall keys it may not be
// possible to load a new still.



//--- Structure for communication to/from assembly sequence player ---------------------
struct PlaySeqInfo
{
//	struct Event *CurVideoEvent;
	struct Event *CurSwitcherEvent;
	ULONG	TimeAtSequenceEnd;

// returned values (you should clear these before the cmd is sent)
	struct ExtFastGadget *AbortedFG;	// Last FG that was processed
	struct Event	*ErrorEvent;		// Event that errored out
	ULONG				ErrorNum;
	STRPTR 			ErrorMsg;			//not usually used

	ULONG				FlyerError;			//Comes from Flyer sequencer
	ULONG				FlyerUserID;		//Passed back from Flyer sequencer
	ULONG				FlyerMoreInfo;		//More info about specific error
	UBYTE				StopOnError;		//Stop sequence on timing error
};


#define	TRACK_SWITCHER		0	// Switcher video, effects, and control
#define	TRACK_FLYVID		1	// Flyer video
#define	TRACK_AUDIO			2	// Flyer audio tracks

struct Track {
	struct List	EventList;
	UWORD	EventCount;
};

//------------------------
// The following are used to index into the CroutonCount structure
// and are used to define types of croutons.
#define CRTN_NONE			0	// marks no previous crouton (start of sequence)
#define CRTN_FLYVID		1  // main video output = CLIP, MAIN, FRAM, VIDA, RGBA, STIL These have video time.
#define CRTN_VIDEO		2  // main video output = CLIP, MAIN, FRAM, VIDA, RGBA, STIL These have video time.
#define CRTN_AUDIO		3  // audio event
#define CRTN_TRANS		4	// transitional effects ANIM/ILBM/ALGO (can only be followed by a video event)
#define CRTN_EFFECT		5  // non-transition effects that don't take over the machine, e.g. ChromaFX
#define CRTN_KEY			6  // overlayed video track for Keyed Frames, don't take over machine
#define CRTN_CRFX			7  // ChromaFX
#define CRTN_SCRAWL		8  // Keyed Things that take over the machine, SCROLL/CRAWL/KEYA
#define CRTN_AREXX		9
#define CRTN_CONTROL		10	// Sequence & Switcher control
#define CRTN_TAKES		11	// Implied takes
#define CRTN_OVERLAY		12	// non-transitional effects/overlays

#define EFFECT_TAKE		0	// marks previous effect as a take
#define EFFECT_TRANS		1	// marks previous effect as a transition

// Used to tabulate the number of various types of croutons in a project
//struct CroutonCount {
//	ULONG	Start;	// ignored for now
//	ULONG	FlyVid;	// main video output = CLIP, STIL - These have video time.
//	ULONG	Video;	// main video output = MAIN, FRAM, VIDA, RGBA - These have video time.
//	ULONG	Audio;	// audio event
//	ULONG	Trans;	// transitional effects ANIM/ILBM/ALGO (can only be followed by a video event)
//	ULONG	Effect;	// non-transition effects that don't take over the machine, e.g. ChromaFX
//	ULONG	Key;		// overlayed video track for Keyed Frames, don't take over machine
//	ULONG	CrFX;		// ChromaFX
//	ULONG	Scrawl;	// Keyed Things that take over the machine, SCROLL/CRAWL/KEYA
//	ULONG	ARexx;	// ARexx
//	ULONG	Control;	// Sequence & Switcher control
//	ULONG	Takes;	// Implied takes between 2 video croutons
//};


//--- Structure for sequencing control ---------------------
struct SeqVars {
//	struct EditWindow *Edit;
	struct EditWindow *EditTop;
	struct Track VideoTrack;			// Flyer video and stills
	struct Track AudioTrack;			// All Flyer audio
	struct Track SwitcherTrack;		// All other croutons
	struct ExtFastGadget	*ScanStart;	// First crouton to analyze for play
	ULONG	AuxError;
	struct ExtFastGadget	*FailFG;		// FG at which something failed (during download)
	LONG	StartTime;						// Program time of start of sequence
	LONG	EndTime;							// Program time of end
	WORD	InsMattes;						// Count of inserted black mattes
//	WORD	TrimToFits;						// Count of video trimmed to fit
	WORD	Pos;								// Crouton position as we process
	WORD	FlyChan;							// Flyer channel to use next (0,1)
	LONG	SeqTotalTime;					// Time of entire project
	LONG	SeqPlayTime;					// Time of portion to play
	BOOL	partial;							// Playing partial sequence
	BOOL	cut2music;						// Editing to music
	BOOL	waitplaystart;					// Put up "ready to play" requester?
	UBYTE	firstflychan;					// First channel coming from Flyer
//	LONG	EndOfEffect;
//	LONG	EndOfPrevEffect;
//	UWORD	PreviousEffect;
	ULONG	SwitcherBusyTil;				// Time to which switcher is taking over machine
	struct	Event	*LastSwitEvent;	// And the event, for more info (i.e. error messages)
	BOOL	CutUnder;						// Flyer doing a cut for Switcher when it's busy
	UWORD	LostCroutons;					// Number of lost croutons in project when built
	char	scratch[80];					// Used to build messages
};



//------------------------
/*** External Structures ***/

extern struct ExtFastGadget **PtrProject;
extern struct Library 	 *ToasterBase;
extern struct Library 	 *FlyerBase;
extern struct FastGadget *CurFG;				// Global - currently selected FG
extern struct FastGadget *SKellFG;			// ???
extern struct EditWindow *EditTop;
extern struct EditPrefs UserPrefs;		// User preferences live here

extern UBYTE *FlyerDrives[];
extern LONG FlyerDriveCount;

extern struct ESParams1 ESparams1;
extern struct ESParams2 ESparams2;
extern struct ESParams3 ESparams3;
extern struct ESParams5 ESparams5;

extern char **ErrMsgs[];
extern char ErrorDetails[];
extern char pstr[];			// Useful temp area for error msgs

extern ULONG	FlyerOpts;


/*** Global Data ***/

static struct ExtFastGadget *SeqStartFG=NULL;	// Start of "active" sequence
//static struct ExtFastGadget *FirstFG=NULL;		// Where to start sequence
BOOL	EditingLive = FALSE;					// Editing other events to a playing clip
BOOL	Editing2Video;							// Live foley or video edits to video clip
LONG	MasterVideoTime;						// Ref time when editing to video
LONG	MusicBaseTime;
LONG	ParentVideoTime;						// TimeBetweenFGs sets this for target child FG


char	E2Mproc_message[] = "Editing to music -- press ESC or STOP to end";
char	E2Vproc_message[] = "Editing to video -- press ESC or STOP to end";

/*** Prototypes ***/

//static LONG __regargs GetSimpleTagS(struct ExtFastGadget *FG, LONG tag);
//static ULONG __regargs GetSimpleTagU(struct ExtFastGadget *FG, LONG tag);
static LONG __regargs GetRefTime(LONG reftime, struct ExtFastGadget *FGlastVid,
	struct ExtFastGadget *FG);
static BOOL __regargs PutVolatileTag(struct ExtFastGadget *FG, LONG tag, LONG value);
static void HiliteNewFG(struct EditWindow *Edit, struct ExtFastGadget *FG, LONG fgpos, BOOL first);
static BOOL ReportSequenceError(struct SeqVars *sv, struct ExtFastGadget *FG,
	LONG fgpos, UWORD error, BOOL ignorable);
static void ReportSequenceDualError(struct SeqVars *sv, struct ExtFastGadget *FG1,
	LONG fgpos1, struct ExtFastGadget *FG2, LONG fgpos2, UWORD error);
static BOOL ReportSeqErrCore(struct SeqVars *sv, UWORD error, BOOL ignorable);
static BOOL SeqRequest(	struct SeqVars *sv, char **msg, int lines);
static BOOL HasAudio(struct ExtFastGadget *FG);
static BOOL IsVideoSource(struct ExtFastGadget *FG);
static BOOL IsSuperVideo(struct ExtFastGadget *fg);
static BOOL IsStop(struct ExtFastGadget *FG);
static BOOL IsWait(struct ExtFastGadget *FG);
static BOOL IsOverlay(struct ExtFastGadget *FG);
static struct ExtFastGadget *GetNextGadget(struct ExtFastGadget *FG);
static LONG TimeBetweenFGs(struct ExtFastGadget *StartFG, struct ExtFastGadget *EndFG);
//static LONG SequenceTotalTime(struct ExtFastGadget *fg);
static struct ExtFastGadget *StartingSequenceEvent(struct ExtFastGadget *hilitedFG);
//static struct ExtFastGadget *StartingVideoEvent(struct ExtFastGadget *firstFG);
static BOOL BuildSeq(struct SeqVars *sv, struct ExtFastGadget *buildFG);
static void PlayCurSeq(struct SeqVars *sv);
static UBYTE TrimToPlayWindow(struct SeqVars *sv, struct ExtFastGadget *firstFG);
static BOOL DoWarnings(struct SeqVars *sv);
static void DeleteEventsForFG(struct SeqVars *sv, struct ExtFastGadget *fg);
static BOOL HandleTransition(struct SeqVars *sv, LONG cuttime, struct Event *V1event,
	struct ExtFastGadget *FXFG, WORD FXpos, struct Event *V2event);
static BOOL MaybeInsertBlack(struct SeqVars *sv, struct Event *V1event, LONG time);
static struct Event *CreateBlack(struct SeqVars *sv, LONG time, WORD flychan);
static UBYTE AppendBlack(struct SeqVars *sv, LONG time, WORD flychan);
static void PrepareTrack(struct Track *track,UBYTE tracktype);
static void FreeTrack(struct Track *track);
#ifdef	SERDEBUG
static void ListTrack(struct Track *track, UBYTE tracktype);
#endif
static struct Event * GetEvent(struct ExtFastGadget *FG);
static void SortIntoTrack(struct Track *track, struct Event *newevent);
static void AppendToTrack(struct Track *track, struct Event *newevent);
static BYTE AppendSelect(struct Track *track, struct Event *newevent);
static void InsertSelect(struct Track *track, struct Event *newevent);
static struct Event * DoAudioCrouton(struct SeqVars *sv,	struct ExtFastGadget *fg, 
	LONG gotime,WORD croutonpos);
static ULONG DownLoadFlyerTrack(struct SeqVars *sv,struct Track *track,UBYTE tracktype,BOOL abortable);
static struct Event *FindFlyerEventFromID(struct SeqVars *sv, ULONG userID);
static UWORD	FXunderErrors(struct	Event	*event);
static BOOL DetectSwitcherCollision(struct SeqVars *sv, LONG time);
static UWORD	SwitCollisionErrors(struct	Event	*event, struct ExtFastGadget *FG2);


extern __asm ULONG GetLongValue(
	register __a0 struct ExtFastGadget *fg,
	register __d0 ULONG tag);


//=============================================================
// GetSimpleTagS
//		Read a tag's value (signed longs)
//=============================================================
//static LONG __regargs GetSimpleTagS(struct ExtFastGadget *FG, LONG tag)
//{
//	ESparams2.Data1=(LONG)FG;
//	ESparams2.Data2=0x80000000 | tag;
//
//	return((LONG)SendSwitcherReply(ES_GetValue,&ESparams2));

//	return((LONG)GetLongValue(FG,tag | 0x80000000));
//}


//=============================================================
// GetSimpleTagU
//		Read a tag's value (ULONG's)
//=============================================================
//static ULONG __regargs GetSimpleTagU(struct ExtFastGadget *FG, LONG tag)
//{
//	ESparams2.Data1=(LONG)FG;
//	ESparams2.Data2=0x80000000 | tag;
//
//	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));

////	return((ULONG)GetLongValue(FG,tag | 0x80000000));
//}

/*** Tag readers that return unsigned values ***/
#define	GetCroutonType(fg)		(GetLongValue(fg,TAG_CroutonType))
#define	GetTimeMode(fg)			(GetLongValue(fg,TAG_TimeMode))
#define	GetAudioOn(fg)				(GetLongValue(fg,TAG_AudioOn))
#define	GetAudioVolume1(fg)		(GetLongValue(fg,TAG_AudioVolume1))
#define	GetAudioVolume2(fg)		(GetLongValue(fg,TAG_AudioVolume2))
#define	GetAudioPan1(fg)			(GetLongValue(fg,TAG_AudioPan1))
#define	GetAudioPan2(fg)			(GetLongValue(fg,TAG_AudioPan2))
#define	GetAsrcLen(fg)				(GetLongValue(fg,TAG_ASourceLen))
#define	GetBsrcLen(fg)				(GetLongValue(fg,TAG_BSourceLen))
#define	GetTakeOffset(fg)			(GetLongValue(fg,TAG_TakeOffset))
#define	GetAudioFadeFlags(fg)	(GetLongValue(fg,TAG_AudioFadeFlags))

/*** Tag readers that return signed values ***/
#define	GetRecFields(fg)			((LONG)GetLongValue(fg,TAG_RecFields))
#define	GetNumFields(fg)			((LONG)GetLongValue(fg,TAG_NumFields))
#define	GetStartField(fg)			((LONG)GetLongValue(fg,TAG_ClipStartField))
#define	GetDuration(fg)			((LONG)GetLongValue(fg,TAG_Duration))
#define	GetDelay(fg)				((LONG)GetLongValue(fg,TAG_Delay))
#define	GetHoldFields(fg)			((LONG)GetLongValue(fg,TAG_HoldFields))
#define	GetAdjVideoStart(fg)		((LONG)GetLongValue(fg,TAG_AdjustedVideoStart))
#define	GetAdjVideoDuration(fg)	((LONG)GetLongValue(fg,TAG_AdjustedVideoDuration))
#define	GetFadeInDuration(fg)	((LONG)GetLongValue(fg,TAG_FadeInDuration))
#define	GetFadeOutDuration(fg)	((LONG)GetLongValue(fg,TAG_FadeOutDuration))
#define	GetFadeInVideo(fg)		((LONG)GetLongValue(fg,TAG_FadeInVideo))
#define	GetAudioStart(fg)			((LONG)GetLongValue(fg,TAG_AudioStart))
#define	GetAudioDuration(fg)		((LONG)GetLongValue(fg,TAG_AudioDuration))
#define	GetAudioAttack(fg)		((LONG)GetLongValue(fg,TAG_AudioAttack))
#define	GetAudioDecay(fg)			((LONG)GetLongValue(fg,TAG_AudioDecay))
#define	GetSpeed(fg)				((LONG)GetLongValue(fg,TAG_Speed))
#define	GetButtonLogic(fg)		((LONG)GetLongValue(fg,TAG_ButtonELHlogic))
#define	GetLoopFlag(fg)			((LONG)GetLongValue(fg,TAG_LoopAnims))


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#define	GetAudioEnv16(ev,fg)				((LONG)GetTable(fg,TAG_AudEnv16,&ev,324))


//=============================================================
//=============================================================
//struct FlyerVolumes * __regargs GetVolumeTable()
//{
//	ESparams1.Data1=0;
//	return((struct FlyerVolumes *)SendSwitcherReply(ES_BuildVolumeTable,&ESparams1));
//}


//=============================================================
// GetRefTime
//		Calculate start time for a relative (non-video) crouton
//=============================================================
static LONG __regargs GetRefTime(	LONG reftime,
												struct ExtFastGadget *FGlastVid,
												struct ExtFastGadget *FG)
{
	LONG delay,time;

	delay = GetDelay(FG);		// Default: ref from inpoint time

	switch (GetTimeMode(FG))
	{
		case TIMEMODE_RELCLIP:			// Reference to prev clip start
			if (FGlastVid)
				time = reftime + delay - GetStartField(FGlastVid);
			else
				time = reftime;			// Isn't a valid time, but at least prevents crash
			break;
		case TIMEMODE_RELINPT:			// Reference to prev clip in-point
			time = reftime + delay;
			//DUMPUDECL("reftime = ",reftime,"");
			//DUMPUDECL("  delay = ",delay,"\\");
			break;
		case TIMEMODE_ABSTIME:			// Reference to none -- absolute time
			time = delay;
			break;
	}
	return(time);
}


//=============================================================
// PutVolatileTag
//		Modify a tag value, and mark it as unsavable
//=============================================================
static BOOL __regargs PutVolatileTag(struct ExtFastGadget *FG, LONG tag, LONG value)
{
	BOOL	result;

	ESparams2.Data1 = ESparams3.Data1 = (LONG)FG;
	ESparams2.Data2 = ESparams3.Data2 = 0x80000000 | tag;
							ESparams3.Data3 = value;

	result = (BOOL)SendSwitcherReply(ES_PutValue,&ESparams3);
	SendSwitcherReply(ES_UnSavable,&ESparams2);
	return(result);
}


//=============================================================
// PutSavableTag
//		Modify a tag value, and mark it as savable
//=============================================================
static BOOL __regargs PutSavableTag(struct ExtFastGadget *FG, LONG tag, LONG value)
{
	BOOL	result;

	ESparams2.Data1 = ESparams3.Data1 = (LONG)FG;
	ESparams2.Data2 = ESparams3.Data2 = 0x80000000 | tag;
							ESparams3.Data3 = value;

	result = (BOOL)SendSwitcherReply(ES_PutValue,&ESparams3);
//	SendSwitcherReply(ES_UnSavable,&ESparams2);
	return(result);
}


#define	PutAdjVideoDuration(fg,val)	(PutVolatileTag(fg,TAG_AdjustedVideoDuration,val))
#define	PutAdjVideoStart(fg,val)		(PutVolatileTag(fg,TAG_AdjustedVideoStart,val))
#define	PutTimeMode(fg,val)				(PutSavableTag(fg,TAG_TimeMode,val))
#define	PutDelay(fg,val)					(PutSavableTag(fg,TAG_Delay,val))
#define	PutStartField(fg,val)			(PutSavableTag(fg,TAG_ClipStartField,val))
#define	PutDuration(fg,val)				(PutSavableTag(fg,TAG_Duration,val))
#define	PutAudioDuration(fg,val)		(PutSavableTag(fg,TAG_AudioDuration,val))
#define	PutAudioStart(fg,val)			(PutSavableTag(fg,TAG_AudioStart,val))
#define	PutAudioAttack(fg,val)			(PutSavableTag(fg,TAG_AudioAttack,val))
#define	PutAudioDecay(fg,val)			(PutSavableTag(fg,TAG_AudioDecay,val))



//=============================================================
// HiliteNewFG
//		Hilites the given FG (and brings it into view)
//		fgpos is negative if crouton number is unknown
//		Can support multiple hiliting
//=============================================================
static void HiliteNewFG(struct EditWindow *Edit,
								struct ExtFastGadget *FG,
								LONG fgpos,
								BOOL first)
{
	if (FG && (fgpos < 0))
		fgpos = GetProjNodeOrder(Edit,(struct FastGadget *)FG);

	if (!first)
	{
		Edit->ew_OptRender = TRUE;
		ew_MultiSelect(Edit,fgpos);			// Hilites crouton
	}
	else
	{
		ew_QuickSelect(Edit,fgpos);			// Hilites crouton

		ew_NavigateNodeNum(Edit,fgpos);		// Navigates to it so it's visible

		SendSwitcherReply(ES_SelectDefault,(SKellFG=NULL));
		CurFG=(struct FastGadget *)FG;

		Edit->ew_OptRender = FALSE;
	}

	UpdateAllDisplay();
}


//=============================================================
// ReportSequenceError
//		Hilite and bring into view specified crouton (or not if FG is NULL)
//		Then put up error requester with given text array
//		Returns TRUE if "ignorable" set and user clicks "OK"
//=============================================================
static BOOL ReportSequenceError(	struct SeqVars *sv,
											struct ExtFastGadget *FG,
											LONG fgpos,
											UWORD error,
											BOOL ignorable)
{
	BOOL	okay;

	// FG may be NULL of we don't want any hilited,
	// and fgpos might = -1 if we want the code to find the crouton
	HiliteNewFG(sv->EditTop,FG,fgpos,TRUE);

	okay = ReportSeqErrCore(sv,error,ignorable);

	return(okay);
}


//=============================================================
// ReportSequenceDualError
//		Hilite and bring into view two croutons
//		Then put up error requester with given text array
//=============================================================
static void ReportSequenceDualError(	struct SeqVars *sv,
													struct ExtFastGadget *FG1,
													LONG fgpos1,
													struct ExtFastGadget *FG2,
													LONG fgpos2,
													UWORD error)
{
	// FG's may be NULL if we don't want any hilited,
	// and fgpos might = -1 if we want the code to find the crouton
	HiliteNewFG(sv->EditTop,FG1,fgpos1,TRUE);		// Hilite 1st one
	HiliteNewFG(sv->EditTop,FG2,fgpos2,FALSE);	// Hilite 2nd one

	ReportSeqErrCore(sv,error,FALSE);
}


static BOOL ReportSeqErrCore(	struct SeqVars *sv,
										UWORD error,
										BOOL ignorable)
{
	BOOL	okay;

	//DUMPUDECL ("~~~~~~~~ ERROR ",error," ~~~~~~~~\\");

	// For "internal" errors, create detailed number info line
	if ((error == SEQERR_Internal) || (error == SEQERR_InternalFlyer))
		sprintf(ErrorDetails,"   Meditation Number %d",sv->AuxError);

	DisplayMessage(NULL);			// Remove any message at top of screen
//	DisplayRunningTime();
	DisplayNormalSprite();			// Remove busy pointer

	if (ignorable)
	{
		// Put up error message (OK, CANCEL)
		okay = ErrorMessageBoolRequest(sv->EditTop->Window,ErrMsgs[error-1]);	// Skip 0
		if (okay)
			DisplayWaitSprite();
	}
	else
	{
		// Put up error message (CONTINUE)
		ErrorMessageRequest(sv->EditTop->Window,ErrMsgs[error-1]);	// Skip 0 which is okay
		okay = FALSE;
	}

	SetRunningTime(-1L);		// Invalidate the total project time (display "???")

	return(okay);
}


//=============================================================
// SeqRequest
//		Put up boolean requester (OK/cancel)
//=============================================================
static BOOL SeqRequest(	struct SeqVars *sv, char **msg, int lines)
{
	BOOL	okay;
	char	*MPtr[7];
	int	i;

	// Make copy of string array, and NULL-terminate it
	for (i=0 ; i<lines ; i++)
	{
		MPtr[i] = *msg++;
	}
	MPtr[i] = NULL;

//	DisplayMessage(NULL);			// Remove any message at top of screen
//	DisplayRunningTime();
	DisplayNormalSprite();			// Remove busy pointer

	// Put up requester, check okay/cancel
//	okay = (BOOL)SimpleRequest(sv->EditTop->Window,msg,lines,REQ_OK_CANCEL | /* REQ_CENTER | */ REQ_H_CENTER,NULL);
	okay = ErrorMessageBoolRequest(sv->EditTop->Window,MPtr);
	if (okay)
		DisplayWaitSprite();

//	SetRunningTime(-1L);

	return(okay);
}



//=============================================================
// HasAudio
//		Returns TRUE if either audio channel of clip is
//		enabled and has a non-zero volume
//=============================================================
static BOOL HasAudio(struct ExtFastGadget *FG)
{
	ULONG	AudioOnBits;

	AudioOnBits = GetAudioOn(FG);

	//DUMPMSG("---------------------------");
	//DUMPSTR(FG->FileName);
	//DUMPMSG(" ");
	//DUMPHEXIL("AudioOnBits=",(LONG)AudioOnBits,"\\");
//	DUMPHEXIL("AUDF_Channel1Recorded=",(LONG)(AUDF_Channel1Recorded & AudioOnBits),"\\");
//	DUMPHEXIL("AUDF_Channel2Recorded=",(LONG)(AUDF_Channel2Recorded & AudioOnBits),"\\");
//	DUMPHEXIL("AUDF_Channel1Enabled=",(LONG)(AUDF_Channel1Enabled & AudioOnBits),"\\");
//	DUMPHEXIL("AUDF_Channel2Enabled=",(LONG)(AUDF_Channel2Enabled & AudioOnBits),"\\");
	//DUMPUDECL("Volume1=",(LONG)GetAudioVolume1(FG),"\\");
	//DUMPUDECL("Volume2=",(LONG)GetAudioVolume2(FG),"\\");
	//DUMPMSG("---------------------------");

	return((BOOL)
	(
		(
			(AUDF_Channel1Recorded & AudioOnBits) && (AUDF_Channel1Enabled & AudioOnBits) 
			&& GetAudioVolume1(FG)
		)
	|| (
			(AUDF_Channel2Recorded & AudioOnBits) && (AUDF_Channel2Enabled & AudioOnBits)
			&& GetAudioVolume2(FG)
		)
	));
}


//=============================================================
// IsVideoSource
//		Returns TRUE if the FG type is a video source crouton
//=============================================================
static BOOL IsVideoSource(struct ExtFastGadget *FG)
{
	ULONG objtype;

	objtype = FG->ObjectType;

	switch (objtype)
	{
		case CT_VIDEO:
		case CT_FRAMESTORE:
		case CT_IMAGE:
		case CT_VIDEOANIM:
		case CT_MAIN:
		case CT_STILL:
			return(TRUE);
		default:
			return(FALSE);
	}
}


//=============================================================
// IsSuperVideo
//		Returns TRUE if the FG type is a scroll/crawl/key/overlay
//=============================================================
static BOOL IsSuperVideo(struct ExtFastGadget *fg)
{
	ULONG objtype;
	BOOL	flag;

	if (fg)
		objtype = fg->ObjectType;
	else
		fg = 0;

	switch (objtype)
	{
		case CT_FXANIM:
		case CT_FXALGO:
		case CT_FXILBM:
			if (IsOverlay(fg))
				flag = TRUE;
			else
				flag = FALSE;
			break;
		case CT_SCROLL:
		case CT_CRAWL:
		case CT_KEY:
			flag = TRUE;
			break;
		default:
			flag = FALSE;
	}

	return(flag);
}


//=============================================================
// IsStop
//		Is this FG a stop/restart control crouton?
//=============================================================
static BOOL IsStop(struct ExtFastGadget *FG)
{
	ULONG	type;

	if (FG->ObjectType == CT_CONTROL)
	{
		type = GetCroutonType(FG);

		if ((type==CROUTONTYPE_STOP) || (type==CROUTONTYPE_RESTART))
			return(TRUE);
	}

	return(FALSE);
}


//=============================================================
// IsWait
//		Is this FG a wait control crouton?
//=============================================================
static BOOL IsWait(struct ExtFastGadget *FG)
{
	ULONG	type;

	if (FG->ObjectType == CT_CONTROL)
	{
		type = GetCroutonType(FG);

		if ((type==CROUTONTYPE_WAIT4GPI) || (type==CROUTONTYPE_WAIT4ANYKEY))
			return(TRUE);
	}

	return(FALSE);
}



//=============================================================
// IsOverlay
//		Is this FG a non-transitional effect/overlay?
//=============================================================
static BOOL IsOverlay(struct ExtFastGadget *FG)
{
	LONG	type,blogic;

	type = FG->ObjectType;

	if ((type == CT_FXILBM)
	||  (type == CT_FXANIM)
	||  (type == CT_FXALGO))		// Include this???
	{
		blogic = GetButtonLogic(FG);					// Get effects button logic

		if ((blogic == AFXT_Logic_EncoderAlpha)	// Graphic overlay
		||  (blogic == AFXT_Logic_TDEfx)				// Non-transitional effects
		||  (GetLoopFlag(FG)))							// Looping ILBM/ANIM
		{
			return(TRUE);									// ...all are considered overlays
		}
	}

	return(FALSE);
}


//=============================================================
// GetNextGadget
//		Get next FG in project, given the current FG
//=============================================================
static struct ExtFastGadget *GetNextGadget(struct ExtFastGadget *FG)
{
	struct ExtFastGadget *nextfg;

	nextfg = (struct ExtFastGadget *)FG->FG.NextGadget;

	if (nextfg)
	{
		if (IsStop(nextfg))			// If we hit a stop/restart, return NULL
			nextfg = NULL;

	}

	return(nextfg);
}

//=============================================================
// GetPrevGadget
//		Get previous FG in project, given the current FG
//=============================================================
struct ExtFastGadget *GetPrevGadget(struct ExtFastGadget *FG)
{
	struct ExtFastGadget *pfg,*nextfg;

	if (FG && PtrProject)
	{
		for (pfg= *PtrProject; pfg; pfg=nextfg)
		{
			nextfg = (struct ExtFastGadget *)pfg->FG.NextGadget;
			if (nextfg == FG)
				return(pfg);
		}
	}

	return(NULL);
}


//=============================================================
// TimeBetweenFGs
//		Find the total video between two FG's (from StartFG up to EndFG)
//		If EndFG=NULL, then it returns the total duration from StartFG to end
//=============================================================
static LONG TimeBetweenFGs(	struct ExtFastGadget *StartFG,
										struct ExtFastGadget *EndFG)
{
	struct ExtFastGadget *fg, *PrevVidFG;
	ULONG	timemode,objtype;
	LONG	vidtime,lastvidtime,abstime,maxtime,duration,maxend,start;

	PrevVidFG = NULL;

	lastvidtime = vidtime = maxtime = 0;

	for (fg=StartFG ; fg ; fg = GetNextGadget(fg))
	{
		timemode = GetTimeMode(fg);

		objtype = fg->ObjectType;
		//DUMPHEXIL("---------- Type ",objtype," ---------\\");

		if (objtype == CT_ERROR)
		{
			objtype = fg->LocalData;		// Pick out ACTUAL type from "lost crouton"
			//DUMPHEXIL("*** Actual type is ",objtype," ***\\");
		}

		//DUMPUDECL("   TimeMode ",timemode,"\\");

		/*** Get this crouton's correct start time ***/
		switch (objtype)
		{
			case CT_VIDEO:
			case CT_FRAMESTORE:
			case CT_STILL:
				// Is this crouton locked to a particular program time?
				if (timemode==TIMEMODE_ABSTIME)
				{
					abstime = GetDelay(fg);
// Always return locked time, even if previous guy is too long
//					if (abstime > vidtime)			// Skip time forward to locked crouton?
						vidtime = abstime;
				}
			case CT_MAIN:
			case CT_IMAGE:
			case CT_VIDEOANIM:
				start = vidtime;
				PrevVidFG = fg;
				break;

			case CT_AUDIO:
			case CT_FXCR:
			case CT_REXX:
			case CT_SCROLL:
			case CT_CRAWL:
			case CT_KEYEDANIM:
			case CT_KEY:
				start = GetRefTime(lastvidtime,PrevVidFG,fg);
				break;

			case CT_FXILBM:
			case CT_FXANIM:
			case CT_FXALGO:
				if (IsOverlay(fg))
					start = GetRefTime(lastvidtime,PrevVidFG,fg);
				else
				{
					LONG	takefld,fxlen,Alen,Blen;

//OLD WAY:	start = vidtime - GetNumFields(fg)/2;	// Improve when asym. FX supported!!!

					fxlen = GetNumFields(fg);					// Length of effect
					Alen = ((GetAsrcLen(fg) >>16) * fxlen + 0x8000) >>16;
					Blen = ((GetBsrcLen(fg) >>16) * fxlen + 0x8000) >>16;

					if ((Alen + Blen) >= fxlen)			// Sources overlap?
					{
						// Calculate offset into FX where take will be placed
						takefld = ((GetTakeOffset(fg) >>16) * fxlen + 0x8000) >>16;
					}
					else
						takefld = Alen;					// Time into FX at which A source will end

					start = vidtime - takefld;			// Calc time before end of previous clip
				}
				break;

			case CT_CONTROL:
				start = vidtime;
				//DUMPMSG	("***************** CONTROL *****************\n");
				break;

			default:
				start = 0;		//!!!
		}

		// Break here if on terminating crouton
		if (fg == EndFG)
		{
			// Keep this in case we want to relate the "target" crouton to its parent's time
			ParentVideoTime = lastvidtime;

			//DUMPUDECL("*** Final Time ",start,"\\");
			return(start);			// Start time of FG
		}

//		lastvidtime = vidtime;

		switch (objtype)
		{
			case CT_VIDEO:
			case CT_FRAMESTORE:
			case CT_STILL:
			case CT_MAIN:
			case CT_IMAGE:
				duration = GetDuration(fg);
				lastvidtime = vidtime;
				vidtime += duration;

				// Take back split audio into account for max running time
				if (HasAudio(fg))
				{
					maxend = start+GetAudioStart(fg)-GetStartField(fg)+GetAudioDuration(fg);
					if (maxend > maxtime)
						maxtime = maxend;
				}
				break;

			case CT_VIDEOANIM:
				duration = GetNumFields(fg);
				lastvidtime = vidtime;
				vidtime += duration;
				break;

			case CT_AUDIO:
				duration = GetAudioDuration(fg);
				break;

			case CT_FXCR:
				duration = GetDuration(fg);
				break;

			case CT_REXX:
				duration = 0;			// ???
				break;

			case CT_SCROLL:
			case CT_CRAWL:
			case CT_KEYEDANIM:
				duration = 0;			// Where is the length??
				break;

			case CT_KEY:
				duration = GetDuration(fg);
				break;

			case CT_FXILBM:
			case CT_FXANIM:
			case CT_FXALGO:
				if (IsOverlay(fg))
					duration = GetNumFields(fg);		// Or GetDuration(fg) ???
				else
				{
					LONG	fxlen,Alen,Blen;

					fxlen = GetNumFields(fg);				// Length of effect
					Alen = ((GetAsrcLen(fg) >>16) * fxlen + 0x8000) >>16;
					Blen = ((GetBsrcLen(fg) >>16) * fxlen + 0x8000) >>16;

					if ((Alen + Blen) >= fxlen)			// Sources overlap?
						duration = 0;							// Does not insert any video time
					else
						duration = fxlen-Alen-Blen;		// Inserts this much video time (from FX)

					vidtime += duration;						// CAN add video time!
				}
				break;
			
			case CT_CONTROL:
				duration = 0;
				//DUMPMSG	("-----------------  Control -----------------\n");
				break;

			default:
				duration = 0;
				break;
		}

		// Record latest event as total program time
		maxend = start+duration;
		if (maxend > maxtime)
			maxtime = maxend;

		//DUMPUDECL("   Start ",start,"   ");
		//DUMPUDECL("   Duration ",duration,"\\");
		//DUMPUDECL("   VidTime ",vidtime,"   ");
		//DUMPUDECL("   MaxTime ",maxtime,"\\");
	}

	// Falls to here if EndFG is NULL
	//DUMPUDECL("*** Final MaxTime ",maxtime,"\\");
	return(maxtime);		// Total program time
}


//=============================================================
// FindCroutonStartTime
//		Look thru the currently built project and attempt to
//		determine the exact start time of the given crouton
//=============================================================
static LONG FindCroutonStartTime(struct SeqVars *sv, struct ExtFastGadget *fg)
{
	struct Track	*track;
	struct Event	*event;
	ULONG objtype;
	LONG	time,adj;
	int	trktype;

	objtype = fg->ObjectType;

	adj = 0;

	switch (objtype)
	{
		case CT_AUDIO:
			track = &sv->AudioTrack;
			trktype = TRACK_AUDIO;
			break;

		case CT_VIDEO:
			adj = GetStartField(fg) - GetAdjVideoStart(fg);		// Makes a + adj


		case CT_STILL:
			track = &sv->VideoTrack;
			trktype = TRACK_FLYVID;

			break;

		case CT_FXANIM:
		case CT_FXILBM:
		case CT_FXALGO:
			if (IsOverlay(fg))
				adj = 0;					// Overlay effects (non-transitional)
			else							
				adj = -2*60;			// Extra 2 seconds before transition

		default:
			track = &sv->SwitcherTrack;
			trktype = TRACK_SWITCHER;
			break;
	}

	//DUMPUDECL ("Looking thru track ",trktype," for FG start time\\");

	time = 0;

	// Walk track list and look for this crouton
	for (event = (struct Event *)track->EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		if (event->FG == fg)
		{
			// Flyer audio/video tracks just have 1 select for each event, at the proper time
			if (trktype != TRACK_SWITCHER)
			{
				time = event->Time;
				break;
			}

			// For switcher events, collect up any of these, return last one
			if ((event->FGCcommand == FGC_SELECT) || (event->FGCcommand == FGC_TOMAIN))
				time = event->Time;
		}
	}

	//DUMPUDECL ("cliptime = ",time,"\\");
	//DUMPSDECL ("adj = ",adj,"\\");

	// Try to start early when requested
	if ((time + adj) >= 0)
		time += adj;
	else
		time = 0;

	//DUMPUDECL ("cliptime = ",time,"\\");

	return(time);
}

 
//=============================================================
// GetStartTimeInSequence()
//		Video Duration from start of sequence to current crouton.
//		This is used to calculate the time to put in the panel's CurrentTime indicator
//=============================================================
LONG GetStartTimeInSequence(struct FastGadget *FG)
{
//	struct ExtFastGadget	*first;

//	if (first=SeqStartFG)	//GLOBAL
	if (PtrProject && (*PtrProject))
		return(TimeBetweenFGs(*PtrProject, (struct ExtFastGadget *)FG));
	else
		return(NULL);
}

//=============================================================
// GetTotalSequenceTime()
//		Calculate duration of entire project
//		This is used to calculate the running time indicator
//=============================================================
LONG GetTotalSequenceTime(void)
{
	if (PtrProject && (*PtrProject))
		return(TimeBetweenFGs(*PtrProject, NULL));
	else
		return(NULL);
}


//=============================================================
// SequenceTotalTime
//		Duration from current crouton upto end of Sequence.
//		This is used to calculate the time to put in the ProgramTime indicator.
//=============================================================
//static LONG SequenceTotalTime(struct ExtFastGadget *fg)
//{
//	LONG	time;
//
//	time = TimeBetweenFGs(SeqStartFG,NULL) - TimeBetweenFGs(SeqStartFG,fg);
//
//	return(time);
//}


//=============================================================
// StartingSequenceEvent
//		Finds 1st previous event after any STOPs/LOOPs
//=============================================================
static struct ExtFastGadget *StartingSequenceEvent(struct ExtFastGadget *hilitedFG)
{
	struct ExtFastGadget *startFG, *fg, *initialFG=NULL;

	// Start from previous video event (if not currently on one)
	if (PtrProject && (initialFG = *PtrProject))
	{
		if (hilitedFG)
			startFG = hilitedFG;
		else
			startFG = initialFG;

		// Scan from start of project up to (but not including) start crouton
		for (fg=initialFG ; (fg && (fg!=startFG)) ; fg=(struct ExtFastGadget *)(fg->FG.NextGadget))
		{
			if (!initialFG)		// Keep 1st FG we find
				initialFG=fg;

			if (IsStop(fg))		// If we hit stop/reset, look for new 1st FG
				initialFG=NULL;
		}
	}
	return(initialFG);
}


//=============================================================
// StartingVideoEvent
//		Finds the most recent video event at or before the start crouton
//=============================================================
//static struct ExtFastGadget *StartingVideoEvent(struct ExtFastGadget *firstFG)
//{
//	struct ExtFastGadget *StartFG, *FG, *VidFG=NULL;
//
///*** Start from previous video event (if not currently on one) ***/
//	if (SeqStartFG)	//GLOBAL
//	{
//		if (firstFG)
//			StartFG=(struct ExtFastGadget *)firstFG;
//		else
//			StartFG = SeqStartFG;
//
//		FG = SeqStartFG;
//		while (FG && (FG!=StartFG))
//		{
//			if (IsVideoSource(FG))			// Remember 1st video FG
//				VidFG = FG;
//			else if (IsStop(FG))				// If stop/reset, look again for 1st FG
//				VidFG=NULL;
//
//			FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
//		}
//
//		if (IsVideoSource(FG))
//			VidFG = FG;
//
//		return(VidFG);
//		return(StartFG);
//	}
//	return(NULL);
//}


//=============================================================
// BuildSeq
//		Analyze project and turn into a playable sequence
//		Does error checking as well
//=============================================================
static BOOL BuildSeq(	struct SeqVars *sv,
								struct ExtFastGadget *buildFG)
{
	struct Event *event;

	struct ExtFastGadget *FG, *PrevVidFG, *EffectFG;
	struct Event *PrevVidEvent=NULL, *CurVidEvent;	//*KeyKill
	LONG ProgTime, gotime, reftime,seltime,refdur;
	LONG EndOfVideo, fudge;
//	LONG vstartfld, audlength, astartfld;
	UWORD error, PreviousTrack=CRTN_NONE;
	WORD EffectPos;
//	BOOL	flag;
//	BOOL	takeneeded;
//	char *MPtr[3];
	BYTE	setchan;
	ULONG objtype,FGtype;

//	SetRunningTime(-1L);		// assume unable to calculate program time

	error = 0;			// No error yet
	sv->Pos = 0;
	sv->LostCroutons = 0;		// None found yet

	/*** If no sequence, just quit ***/
	if (!buildFG)
		return(FALSE);


//	/*** Locate the most recent video event at or before start crouton ***/
//	if (!(FG=StartingVideoEvent(buildFG)))
//	{
//		// Can't sequence, no previous video events
//		error = SEQERR_NeedsPrevVideo;
//		FG = (struct ExtFastGadget *)CurFG;
//		sv->Pos = -1;									// Find it for me
//		goto Failed;
//	}

	//DUMPMSG	("-------------- DoSeqPlay ----------------");

	DisplayMessage("Processing Sequence");
	DisplayWaitSprite();

//	// Do a take right at the beginning
//	if ((event = GetEvent(FG))==NULL)
//	{
//		error = SEQERR_OutOfMemory;
//		goto Failed;
//	}
//	event->FG = buildFG;
//	event->CurrentPosition = 0;
//	event->FGCcommand = FGC_TOMAIN;
//	event->Time = 0;
//	AppendToTrack(&sv->SwitcherTrack,event);		// Tack on end of track

	sv->FlyChan = 0;


//****************************************************************
//********* Q events that occured at or after Sequence point
//****************************************************************

	ProgTime = 0;
	PrevVidFG = NULL;

	// Signify that we'll need a take to start sequence, unless we get an effect
	EffectFG = NULL;
	EffectPos = -1;
//	takeneeded = TRUE;

	sv->LastSwitEvent = 0;			// No switcher events yet for collision checks

	for (FG=buildFG ; FG ; FG=GetNextGadget(FG))
	{
		//DUMPMSG("--------------------------------------");
		//DUMPUDECL("Crouton #",sv->Pos," = ");

		fudge = 0;					// None yet
		sv->CutUnder = FALSE;	// Unless special things happen, we won't be doing this

		FGtype = FG->ObjectType;
//Had tried substituting correct type in for processing, but works better skipping
//during processing too
//		if (FGtype == CT_ERROR)					// Sequencing with "lost crouton"s still present
//		{
//			FGtype = ((struct ExtFastGadget *)FG)->LocalData;	// Pick out REAL type
//			sv->LostCroutons++;					// Count these
//			//DUMPHEXIL("*** Actual type is ",FGtype," ***\\");
//		}

		switch(FGtype)
		{

// **
		case CT_FXCR:
			//DUMPMSG("ChromaFX CROUTON");

			//DUMPUDECL("**CRFX Durr: ",GetDuration(FG)," \\");

			// Funny, this only does a select, no TOMAIN, and it -of course- doesn't
			// have any remove
			//	DEH070596>This isn't funny at all it's just broken! 


			if (PreviousTrack==CRTN_NONE)
			{
				error = SEQERR_CrFXAtStart;	// Can't start with ChromaFX
				break;
			}

			if (PreviousTrack==CRTN_TRANS)
			{
				error = SEQERR_CrFXAfterEffect;	// ChromaFX can't follow Effects croutons
				break;
			}

			if (PrevVidEvent)
			{	
				reftime = PrevVidEvent->Time;
				refdur = PrevVidEvent->Duration;
			}
			else
			{
				reftime = 0;		// Meaningless, but at least consistent
				refdur = 0;

				if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
				{
					error = SEQERR_CrtnNeedsVideo;	// Needs video to ref to
					break;
				}
			}

			if(GetTimeMode(FG)==TIMEMODE_ABSTIME)
			{
				gotime = reftime;
			}
			else
			{	
				// Calculate when ChromaFX should start
				gotime = GetRefTime(reftime,PrevVidFG,FG);
				//DUMPUDECL("**CRFX: at ",gotime," \\");
			}

			if (DetectSwitcherCollision(sv,gotime))
			{
				error = SwitCollisionErrors(sv->LastSwitEvent,FG);
				break;
			}


			// Get event for SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}

			seltime = gotime - CRFXPREROLLFUDGE;		//this is realy just a test.
			
			if (seltime<0) seltime = 0;	//ho no!, it's really close to the start.

			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_SELECTQ;
			event->Time = seltime; 						
			if((seltime == 0)|(gotime == PrevVidEvent->Time))											//need to add more cond.			
			{	
				if(gotime != PrevVidEvent->Time)
				{
					event->FGCcommand = FGC_SELECT;
					InsertSelect(&sv->SwitcherTrack,event);

					if ((event = GetEvent(FG))==NULL)
					{
						error = SEQERR_OutOfMemory;
						break;
					}
					event->FG = FG;
					event->CurrentPosition = sv->Pos;
					event->FGCcommand = FGC_TOMAIN;
					event->Time = gotime; 						
					AppendToTrack(&sv->SwitcherTrack,event);			// Tack on end of track
				}
				else
				{
					event->FGCcommand = FGC_TOPRVW;
					InsertSelect(&sv->SwitcherTrack,event);
				}
			}
			else
			{
				event->FGCcommand = FGC_SELECT;
				AppendToTrack(&sv->SwitcherTrack,event);			// we'er loading 			
				// Get event for TOMAIN									// after the clip started
				if ((event = GetEvent(FG))==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv->Pos;
				event->FGCcommand = FGC_TOMAIN;
				event->Time = gotime; 									// when to come to main.
				event->TimeTolerance = CRFXTOLERANCE;				// allow for some error !!!
				AppendToTrack(&sv->SwitcherTrack,event);			// Tack on end of track
			}



			// Get event for REMOVEQ
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
//			event->FG = PrevVidEvent->FG;
//			event->CurrentPosition=PrevVidEvent->CurrentPosition;
////		event->FG = FG;
////		event->CurrentPosition=sv->Pos;
//			event->FGCcommand = FGC_TAKE;
//			event->Time = GetRefTime(reftime,PrevVidFG,FG);
//			//DUMPUDECL("**CRFX Take: at ",event->Time," \\");

			// Remove Key Event, this MUST have its time adjusted if another event
			// happens before it is due to end... AC
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_REMOVEQ;
			// Set default duration, though should be shortened if another event steps on it

			if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)			
				event->Time = GetRefTime(reftime,PrevVidFG,FG) + GetDuration(FG);
			else
				event->Time = refdur+gotime;
				
			event->TimeTolerance = CRFXTOLERANCE;				// allow for some error !!!

			//DUMPUDECL("**CRFX Durr: ",GetDuration(FG)," \\");

			event->extra = 0;		//no extra time yet	
			
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

			//DUMPUDECL("**CRFX Remove: at ",event->Time," \\");
//			KeyKill = event;	OBSOLETE

//			Keep these to detect switcher event overlaps (CRFX)
			sv->SwitcherBusyTil = event->Time;		// Time of REMOVE
			sv->LastSwitEvent = event;

//			PreviousFG = FG;
//			PreviousPos = sv->Pos;
			PreviousTrack = CRTN_KEY;
			break;

// **

//----------------------------------------------------------------------
		case CT_REXX:
			//DUMPMSG("ARexx CROUTON");

			if (PreviousTrack==CRTN_NONE)
			{
				error = SEQERR_ARexxAtStart;		// Can't start with Arexx
				break;
			}

			if (PreviousTrack==CRTN_TRANS)
			{
				error = SEQERR_ARexxAfterEffect;	// Arexx cannot follow Effects croutons
				break;
			}

			if (PrevVidEvent)
				reftime = PrevVidEvent->Time;
			else
			{
				reftime = 0;		// Meaningless, but at least consistent

				if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
				{
					error = SEQERR_CrtnNeedsVideo;	// Needs video to ref to
					break;
				}
			}

			// Get event for SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_SELECT;
			// ARexx will start at this time
			event->Time = GetRefTime(reftime,PrevVidFG,FG);
			event->TimeTolerance = AREXXTOLERANCE;		// Allow for some error !!!
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

//			PreviousFG = FG;
//			PreviousPos = sv->Pos;
			PreviousTrack = CRTN_AREXX;
			break;

//----------------------------------------------------------------------
		case CT_AUDIO:
			//DUMPMSG("AUDIO CROUTON");

			if (HasAudio(FG))		// Audio Volume might be zero
			{
				if (!FlyerBase)
				{
					error = SEQERR_AudioNeedsFlyer;	// Can't play audio without a Flyer
					break;
				}

//				if (PreviousTrack==CRTN_NONE)
//				{
//					error = SEQERR_AudioAtStart;		// Can't start with audio clip
//					break;
//				}

//				if (PreviousTrack==CRTN_TRANS)
//				{
//					error = SEQERR_AudioAfterEffect;	// Audio Clips cannot follow Effects
//					break;
//				}

				if (PrevVidEvent)
				{
					//DUMPMSG("ADD IN EXTRA");
					reftime = PrevVidEvent->Time+PrevVidEvent->extra;	//newDEH030196
//					reftime = PrevVidTime;
				}
				else
				{
					reftime = 0;		// Meaningless, but at least consistent

					if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
					{
						error = SEQERR_AudioNeedsVideo;	// Needs video to ref to
						break;
					}
				}

				// Calculate when the audio should start

				gotime = GetRefTime(reftime,PrevVidFG,FG);

				//DUMPUDECL("AudioStart = ",gotime,"\\");

				// Add to audio track
				event = DoAudioCrouton(
					sv,
					FG,				// FastGadget
					gotime,			// Desired start time
					sv->Pos				// Crouton position
				);

				if (event)
				{
					// Keep user's audio ramp rates
					event->AudAttack = GetAudioAttack(FG);
					event->AudDecay = GetAudioDecay(FG);
					if(GetAudioOn(FG)&AUDF_AudEnvEnabled)
						GetAudioEnv16(event->AE,FG);	//DEH Maybe put keep for AudEnv Here!
				}

//				if (event)
//				{
//					if (event->Time < PreviousEndOfEffect)
//					{
//						//Please put this clip after an earlier video event
///*?*/				error = SEQERR_AudioUnsorted;
//						break;
//					}

//***!! This check isn't really important unless we want to keep the croutons in order!
//					if (event->Time < PreviousAudioStartTime)
//					{
//						//Audio crouton should be moved earlier in the project
///*?*/				error = SEQERR_AudioUnsorted;
//						break;
//					}

//					PreviousAudioStartTime = event->Time;	// NOT CURRENTLY USED!
//				}

//				PreviousFG = FG;
//				PreviousPos = sv->Pos;
				PreviousTrack = CRTN_AUDIO;
			}

			break;

//----------------------------------------------------------------------
		case CT_SCROLL:
		case CT_CRAWL:
		case CT_KEYEDANIM:
			//DUMPMSG("SCROLL/CRAWL CROUTON");

			if (PreviousTrack==CRTN_NONE)
			{
				error = SEQERR_KeyAtStart;		// Can't start with a CG page
				break;
			}

			if (PreviousTrack==CRTN_TRANS)
			{
				error = SEQERR_KeyAfterEffect;	// CG pages cannot follow Effects croutons
				break;
			}

			if (PrevVidEvent)
				reftime = PrevVidEvent->Time;
			else
			{
				reftime = 0;		// Meaningless, but at least consistent

				if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
				{
					error = SEQERR_CrtnNeedsVideo;	// Needs video to ref to
					break;
				}
			}

			// Find desired scroll/crawl/keyanim start time
			gotime = GetRefTime(reftime,PrevVidFG,FG);

			//DUMPUDECL("RefTime = ",reftime," ");
			//DUMPUDECL("GoTime = ",gotime," \\");

			if (DetectSwitcherCollision(sv,gotime))
			{
				error = SwitCollisionErrors(sv->LastSwitEvent,FG);
				break;
			}

			// Get event for SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_SELECT;
			event->Time = 0;								//as soon as possible

//			// Wants a double-punch (take and scrawl at same time)?
//			// THIS DOESN'T WORK YET, AS FX CODE ONLY DOES A "TAKE" FOR FGC_TAKE,
//			// IT DOES NOT CHANGE SOURCES AND PUT UP THE EFFECT.  COULD WE ADD A
//			// NEW FGC THAT WOULD DO THIS (CAN'T BREAK THE WAY 'TAKE' WORKS)
//			if (gotime == reftime)
//			{
//				setchan = AppendSelect(&sv->SwitcherTrack,event);	// Replace TOMAIN w/scrawl TAKE
//				// If fails (due to ineligibility to replace a TAKE, maybe allow 2nd
//				// strategy below (insert SELECT) a chance???
//			}
//			else
			if (gotime < (reftime+ILBMPREROLLFUDGE))					// Not enough pre-load?
			{
				InsertSelect(&sv->SwitcherTrack,event);				// Do before TOMAIN
				setchan = -1;													// Not a double-punch
			}
			else
			{
				AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track
				setchan = -1;
			}

			// Get event for TAKE/TOMAIN
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->Duration = GetDuration(FG);			// Just used internally (not switcher)
			//DUMPUDECL("Scroll/Crawl duration = ",event->Duration," ");

			if (setchan >= 0)
			{
				event->Channel = setchan;
				event->Flags1 |= FLAGS1F_SETCHAN;
			}

			if (setchan >= 0)
				event->FGCcommand = FGC_TAKE;
			else
				event->FGCcommand = FGC_TOMAIN;

			event->TimeTolerance = SCRAWLKEYANIMTOLERANCE;		//allow for some error !!!
			// 1st field of scroll/crawl/key will start at this time
			event->Time = gotime;
			AppendToTrack(&sv->SwitcherTrack,event);			// Tack on end of track

//			Keep these to detect switcher event overlaps (Scrolls/crawls)
			sv->SwitcherBusyTil = event->Time + event->Duration + GetHoldFields(FG);
			sv->LastSwitEvent = event;

//			PreviousFG = FG;
//			PreviousPos=sv->Pos;
			PreviousTrack=CRTN_SCRAWL;

			break;

//----------------------------------------------------------------------
		case CT_KEY:

///*?*/	error = SEQERR_KeyedUnsorted;			// Keyed crouton in wrong order.  Move earlier in the project.
///*?*/	error = SEQERR_KeyedDuringEffect;	// Keyed crouton can't start until previous Effect has finshed.
///*?*/	error = SEQERR_KeyedTooSoon;			// Keyed crouton can't start before the clip.  Use a later start time.
///*?*/	error = SEQERR_KeyedStartBad;			// Keyed crouton can't start after the clip.  Use an earlier start time.
///*?*/	error = SEQERR_KeyedOverlapsKey;		// Keyed crouton can't start until previous Key has finished.

			//DUMPMSG("KEY CROUTON or CRFX");

			if (PreviousTrack==CRTN_NONE)
			{
				error = SEQERR_KeyedAtStart;	// Can't start with key
				break;
			}

			if (PreviousTrack==CRTN_TRANS)
			{
				error = SEQERR_KeyedAfterEffect;	// Key pages cannot follow effects
				break;
			}


			if (PrevVidEvent)
				reftime = PrevVidEvent->Time;
			else
			{
				reftime = 0;		// Meaningless, but at least consistent

				if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
				{
					error = SEQERR_CrtnNeedsVideo;	// Needs video to ref to
					break;
				}
			}

			// Find desired key start time
			gotime = GetRefTime(reftime,PrevVidFG,FG);

			//DUMPUDECL("RefTime = ",reftime," ");
			//DUMPUDECL("GoTime = ",gotime," \\");

			if (DetectSwitcherCollision(sv,gotime))
			{
				error = SwitCollisionErrors(sv->LastSwitEvent,FG);
				break;
			}

			// Get event for SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_SELECT;
			event->Time = 0;	//as soon as possible

			// If wants a fade-in with a start time of < 6f, coerce start time so will work
			if ((GetSpeed(FG) & 1) && (gotime < (reftime+KEY_SETUP)))
				gotime = reftime + KEY_SETUP;

			// Wants a double-punch (take and key at same time)?
			if (gotime == reftime)
				setchan = AppendSelect(&sv->SwitcherTrack,event);	// Replace TOMAIN w/Key TAKE
			else if (gotime < (reftime+FRAMEPREROLLFUDGE))			// Not enough pre-load?
			{
				InsertSelect(&sv->SwitcherTrack,event);				// Do before TOMAIN
				setchan = -1;													// Not a double-punch
			}
			else
			{
				AppendToTrack(&sv->SwitcherTrack,event);				// Tack on end of track
				setchan = -1;													// Not a double-punch
			}

			// Get event for TAKE/AUTO/TOMAIN
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			if (setchan >= 0)							// Special FGC for double-punch
			{
				event->Channel = setchan;
				event->Flags1 |= FLAGS1F_SETCHAN;
			}

			if (setchan >= 0)
				event->FGCcommand = FGC_TAKE;			// Take new source with key (no fade)
			else if (GetSpeed(FG) & 1) 	// && GetFadeInDuration(FG))
				event->FGCcommand = FGC_AUTO;
			else
				event->FGCcommand = FGC_TOMAIN;

			// 1st field of key will start at this time
			event->Time = gotime;
			event->Duration = GetDuration(FG);			// Just used internally (not switcher)
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

			//DUMPUDECL("**Key ToMain: at ",event->Time," \\");

			// Get event for REMOVE
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			// Remove Key Event, this MUST have its time reset, if another event happens
			// before it is due to end
			event->FG = FG;
			event->CurrentPosition = sv->Pos;

			if (GetSpeed(FG) & 2) 	// && GetFadeOutDuration(FG))
				event->FGCcommand = FGC_AUTO;
			else
				event->FGCcommand = FGC_REMOVE;		//Why not using this???
//				event->FGCcommand = FGC_AUTO;
			event->Time = GetRefTime(reftime,PrevVidFG,FG) + GetDuration(FG);
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

			//DUMPUDECL("**Key Remove: at ",event->Time," \\");

//			KeyKill = event;		OBSOLETE

//			Keep these to detect switcher event overlaps (Key -- is this required???)
			sv->SwitcherBusyTil = event->Time + event->Duration;
			sv->LastSwitEvent = event;

//			PreviousFG = FG;
//			PreviousPos = sv->Pos;
			PreviousTrack = CRTN_KEY;

			break;

//----------------------------------------------------------------------
// Transitional and non-transition+overlay effects
// Someday, might be nice to make new types for these other things
		case CT_FXANIM:
		case CT_FXILBM:
		case CT_FXALGO:

			if (!IsOverlay(FG))
			{
				//DUMPMSG("FX TRANSITION CROUTON");

//				takeneeded = FALSE;			// No implied TAKE on next video

// This error is bogus if it's a solid ANIM
//				if (!GetNextGadget(FG))
//				{
//					error = SEQERR_EffectAtEnd;	// Can't end sequence with an Effect.
//					break;
//				}

// This error is bogus if it's a solid ANIM
//				if (PreviousTrack==CRTN_NONE)
//				{
//					error = SEQERR_EffectAtStart;	// Can't start with an effect
//					break;
//				}

// FALL THRU
// 			case CT_VIDEOANIM:

				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_EffectAfterEffect;	// Can't sequence two Effects in a row
					break;
				}

/*?*/			//	error = SEQERR_EffectDuringKeying;	// Effect not allowed during keying.

				EffectFG = FG;
				EffectPos = sv->Pos;

//				PreviousFG = FG;
//				PreviousPos = sv->Pos;
				PreviousTrack = CRTN_TRANS;  //**!! NOT REALLY IF VIDEOANIM
			}
			else
			{
				//DUMPMSG("EFFECT/OVERLAY CROUTON");

//				if (PreviousTrack==CRTN_NONE)
//				{
//					error = SEQERR_OverlayAtStart;	// Can't start with overlay
//					break;
//				}

				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_OlayAfterEffect;	// Overlays cannot follow transitional effects
					break;
				}

				if (PrevVidEvent)
					reftime = PrevVidEvent->Time;
				else
				{
					reftime = 0;		// Meaningless, but at least consistent

					if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
					{
						error = SEQERR_CrtnNeedsVideo;	// Needs video to ref to
						break;
					}
				}

				// Find desired overlay start time
				gotime = GetRefTime(reftime,PrevVidFG,FG);

				//DUMPUDECL("RefTime = ",reftime," ");
				//DUMPUDECL("GoTime = ",gotime," \\");

				if (DetectSwitcherCollision(sv,gotime))
				{
					error = SwitCollisionErrors(sv->LastSwitEvent,FG);
					break;
				}

				/*** Determine worst-case load times for each ***/
				switch(FGtype)
				{
					case CT_FXILBM:
						fudge = ILBMPREROLLFUDGE;
						break;
					case CT_FXANIM:
						fudge = ANIMPREROLLFUDGE;
						break;
					case CT_FXALGO:
						fudge = FXPREROLLFUDGE;
						break;
					default:		// What other types fall to here???
						fudge = FXPREROLLFUDGE;
						break;
				}

				// Get event for SELECT
				if ((event = GetEvent(FG))==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv->Pos;
				event->FGCcommand = FGC_SELECT;
				event->Time = 0;	//as soon as possible

//				// Wants a double-punch (take and overlay at same time)?
//				// THIS DOESN'T WORK YET, AS FX CODE ONLY DOES A "TAKE" FOR FGC_TAKE,
//				// IT DOES NOT CHANGE SOURCES AND PUT UP THE EFFECT.  COULD WE ADD A
//				// NEW FGC THAT WOULD DO THIS (CAN'T BREAK THE WAY 'TAKE' WORKS)
//				if (gotime == reftime)
//				{
//					setchan = AppendSelect(&sv->SwitcherTrack,event);	// Replace TOMAIN w/Olay TAKE
//					// If fails (due to ineligibility to replace a TAKE, maybe allow 2nd
//					// strategy below (insert SELECT) a chance???
//				}
//				else
				if (gotime < (reftime+fudge))							// Not enough pre-load?
				{
					InsertSelect(&sv->SwitcherTrack,event);				// Do before TOMAIN
					setchan = -1;													// Not a double-punch
				}
				else
				{
					AppendToTrack(&sv->SwitcherTrack,event);				// Tack on end of track
					setchan = -1;													// Not a double-punch
				}

				/*** Check that we have enough setup time to do our tomain ***/
				if (gotime < (reftime+OVERLAY_SETUP))
				{
					error = SEQERR_OlayPreroll;	// Overlay needs more time
					break;
				}

				// Get event for TAKE/TOMAIN
				if ((event = GetEvent(FG))==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv->Pos;

				if (setchan >= 0)							// Special FGC for double-punch
				{
					event->Channel = setchan;
					event->Flags1 |= FLAGS1F_SETCHAN;
				}

				if (setchan >= 0)
					event->FGCcommand = FGC_TAKE;			// Take new source with overlay
				else
					event->FGCcommand = FGC_TOMAIN;		// Just bring overlay to main

//				event->FGCcommand = FGC_TOMAIN;
				event->Time = gotime;							// When to appear
				event->Duration = GetDuration(FG);			// How long to stay up
				event->Flags1 |= FLAGS1F_LOOPTIME;			// Stop after "duration"
				AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

				//DUMPUDECL("**Olay ToMain: at ",event->Time," \\");

//				Keep these to detect switcher event overlaps (overlays)
				sv->SwitcherBusyTil = event->Time + event->Duration;
				sv->LastSwitEvent = event;

				PreviousTrack = CRTN_OVERLAY;
			}
			break;


//----------------------------------------------------------------------
		case CT_VIDEO:
		case CT_STILL:

			//DUMPSTR("VIDEO OR FLYERSTILL CROUTON  ");
			//DUMPMSG((char *)FG->FileName);

			if (!FlyerBase)
			{
				// Can't play video clips without a Flyer
				error = SEQERR_VideoNeedsFlyer;
				break;
			}

			// If this is locked down, move to that time
			if (GetTimeMode(FG) == TIMEMODE_ABSTIME)
			{
				ProgTime = GetDelay(FG);

				// If previous video does not reach here, insert black
				if (PrevVidEvent)
				{
					if (!MaybeInsertBlack(sv,PrevVidEvent,ProgTime))
						goto Failed;
				}
			}

			// Get event for video SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}

			// Okay, if this clip/still is slated to start before a switcher scroll/crawl
			// will be finished, we must use the same Flyer channel as previous source,
			// so that it will look correct even though switcher cannot do a take.
			// For this to work requires that the previous source be a clip/still as well
			if (DetectSwitcherCollision(sv,ProgTime))
			{
				// Eligible for special cuts-under handling?
				if (PrevVidEvent)
					objtype = PrevVidEvent->FG->ObjectType;
				else
					objtype = 0;
				if ((objtype!=CT_VIDEO) && (objtype!=CT_STILL))		// Wrong previous type
				{
					error = SEQERR_OverlaysOverNonFlyer;
					if (PrevVidEvent)
						FG = PrevVidEvent->FG;
					break;
				}
				if (EffectFG)			// Cannot do effect under scroll/crawl
				{
					error = FXunderErrors(sv->LastSwitEvent);
					FG = EffectFG;
					sv->Pos = EffectPos;
					break;
				}

				//DUMPMSG("Cut under scroll/crawl!");
				sv->FlyChan = 1-sv->FlyChan;				// Reverse back to other channel
				sv->CutUnder = TRUE;							// Special case for this one guy
			}
			else
			{
				event->Flags1 = FLAGS1F_SETCHAN;	// Indicate we need FX to this to set chan
				// Assign alternating channels to each clip/still
			}

			event->Channel = sv->FlyChan;
			//DUMPUDECL("Assigned to channel ",sv->FlyChan,"\\");
			sv->FlyChan = 1-sv->FlyChan;

			if (FGtype == CT_VIDEO)
			{
				event->StartField = GetStartField(FG);
				PutAdjVideoStart(FG,event->StartField);

//				//DUMPUDECL	("Assume InPoint=",event->StartField,"\\");

				// Keep user's audio ramp rates (may or not be any audio)
				event->AudAttack = GetAudioAttack(FG);
				event->AudDecay = GetAudioDecay(FG);

				if(GetAudioOn(FG)&AUDF_AudEnvEnabled)
					GetAudioEnv16(event->AE,FG);		//DEHMaybe keep audio envelope data here too.
			}

			fudge = VIDEOPREROLLFUDGE;

//			FinalClip=event;		// UNUSED NOW

			// This assumes a Take to bring in this video.  If this actually transitions
			// in, then some values must be adjusted.

			goto VideoMerge;		// Continue with logic for FrameStores et.al.


		case CT_FRAMESTORE:
			// If this is locked down, move to that time
			if (GetTimeMode(FG) == TIMEMODE_ABSTIME)
			{
				ProgTime = GetDelay(FG);

				// If previous video does not reach here, insert black
				if (PrevVidEvent)
				{
					if (!MaybeInsertBlack(sv,PrevVidEvent,ProgTime))
						goto Failed;
				}
			}

		case CT_VIDEOANIM:		//**!! DOES THIS REALLY BELONG HERE????
		case CT_IMAGE:

			fudge = FRAMEPREROLLFUDGE;

		case CT_MAIN:

			//DUMPMSG("FRAMESTORE/VIDEOANIM/MAIN/IMAGE CROUTON");

//TAG_AdjustedVideoStart=event->StartField=0 for FRAMSTORE/VIDEOANIM/MAIN/IMAGE/FLYERSTILL croutons

			// Get event for SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}

			if (DetectSwitcherCollision(sv,ProgTime))
			{
				error = SwitCollisionErrors(sv->LastSwitEvent,FG);
				break;
			}

VideoMerge:

			// 1st field of video will start at this time (assuming Cut)
			event->Time = ProgTime;
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_SELECT;

//			CurVidFG = FG;

			// This assumed value can be altered later if there are video transitions
			event->Duration = GetDuration(FG);
			PutAdjVideoDuration(FG,event->Duration);

			if ((FGtype==CT_VIDEO) || (FGtype==CT_STILL))
				SortIntoTrack(&sv->VideoTrack,event);		// Flyer: Sort by time into track
			else
				AppendToTrack(&sv->SwitcherTrack,event);	// Switcher: Tack on end of track

			CurVidEvent = event;
			EndOfVideo = ProgTime + GetDuration(FG);  // Field after the video


//OBSOLETE!!!
//			// Can't do takes under keys, so kill key when next event comes up (AC)
//			if (PreviousTrack==CRTN_KEY)
//			{
//				//DUMPUDECL("Prev Key End: ",KeyKill->Time,"  ");
//				//DUMPUDECL("ProgTime: ",ProgTime,"  ");
//
//				if (KeyKill && KeyKill->Time > (ProgTime-fudge))
//				{
//					// Could this mess with event sort???
//					KeyKill->Time=ProgTime-fudge; // a little margin.. necessary???
//				}
//			}


/*~~~~~~~~~~~~~~~ Handle natural audio ~~~~~~~~~~~~~~~~~~~~~~~~~~*/

// This test should do a regular call to DoAudioCrouton() if the video portion was
// entirely clipped out

			if ((FGtype==CT_VIDEO) && (HasAudio(FG)))	// Has natural audio enabled?
			{
				// Just plug in natural audio parameters
				// Will trim to play window when downloaded to Flyer
				CurVidEvent->AudStart = GetAudioStart(FG);
				CurVidEvent->AudLength = GetAudioDuration(FG);

//				astartfld = GetAudioStart(FG);
//				audlength = GetAudioDuration(FG);
//				vstartfld = CurVidEvent->StartField;
//
//				// Calculate when the audio should start
//				gotime = CurVidEvent->Time + astartfld-vstartfld;
//
//				// Ensure natural audio does not fall outside sequencing time period
//				if ((gotime + audlength) <= sv->StartTime)		// No audio reaches start time?
//					audlength = 0;
//				else if (gotime >= sv->EndTime)					// No audio begins in time?
//					audlength = 0;
//				else
//				{
//					// If audio starts before start time, crop off front
//					if (gotime < sv->StartTime)
//					{
//						astartfld += sv->StartTime - gotime;		// crop audio to starttime
//						audlength -= sv->StartTime - gotime;		// shorten by same amount
//						gotime = sv->StartTime;						// Start immediately
//					}
//
//					// If audio extends past end of sequence, crop off rear
//					if ((gotime+audlength) > sv->EndTime)
//						audlength = sv->EndTime - gotime;
//				}
//
//				// Stash trimmed natural audio parameters
//				CurVidEvent->AudStart = astartfld;
//				CurVidEvent->AudLength = audlength;
			}


/*~~~~~~~~~~~~~~~ Prepare Transition/Cut ~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if (!HandleTransition(
				sv,
				ProgTime,				// CutTime
				PrevVidEvent,			// V1
				EffectFG,				// FXFG (will be NULL for cut)
				EffectPos,				// FXpos (or -1 for cut)
				CurVidEvent))			// V2
					goto Failed;

/*~~~~~~~~~~~~~~~ Prepare Transition/Cut ~~~~~~~~~~~~~~~~~~~~~~~~~*/

//			if (FGtype==CT_VIDEO)					// Special tests for Flyer video
//			{
//This makes no sense, since clips should never have a length of 0
//				/*** Check for minimum Video clip length ***/
//				if (GetAdjVideoDuration(FG) < 4)
//				{
//					error = SEQERR_ShortVideo;		// Can't sequence clips this short
//					FG = FG;
//					break;
//				}
//			}


			//DUMPUDECL	("VIDEO time=",CurVidEvent->Time,"\\");
			//DUMPUDECL	("Assume duration=",GetAdjVideoDuration(FG),"\\");

			ProgTime = EndOfVideo;

			PrevVidEvent	= CurVidEvent;
			PrevVidFG		= FG;

//			PreviousFG		= FG;
//			PreviousPos		= sv->Pos;
			PreviousTrack	= CRTN_VIDEO;

			// Destroy knowledge of effect, implies we need a take if no effect appears
			EffectFG = NULL;
			EffectPos = -1;
//			takeneeded = TRUE;			// If no effect comes along, imply a TAKE

			break;

//----------
		case CT_CONTROL:
			//DUMPMSG("Control CROUTON");

			if (PreviousTrack==CRTN_TRANS)
			{
				error = SEQERR_ARexxAfterEffect;	// Arexx cannot follow Effects croutons
				break;
			}

			if (PrevVidEvent)
				reftime = PrevVidEvent->Time;
			else
			{
				reftime = 0;		// Meaningless, but at least consistent

				if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
				{
					error = SEQERR_CrtnNeedsVideo;	// Needs video to ref to
					break;
				}
			}

			// Get event for SELECT
			if ((event = GetEvent(FG))==NULL)
			{
				error = SEQERR_OutOfMemory;
				break;
			}
			event->FG = FG;
			event->CurrentPosition = sv->Pos;
			event->FGCcommand = FGC_SELECT;
			// ARexx will start at this time
			event->Time = GetRefTime(reftime,PrevVidFG,FG);
			event->TimeTolerance = CONTROLTOLERANCE;		// Allow for some error !!!
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

//			PreviousFG = FG;
//			PreviousPos = sv->Pos;
			PreviousTrack = CRTN_CONTROL;			


			break;

//----------
		case CT_ERROR:		// Playing a sequence with "lost croutons" still in it
			//DUMPMSG	("*** LOST ***");

			sv->LostCroutons++;					// Count these

			switch (((struct ExtFastGadget *)FG)->LocalData)
			{
			case CT_VIDEO:
			case CT_STILL:
			case CT_FRAMESTORE:
				// If this is locked down, move to that time
				if (GetTimeMode(FG) == TIMEMODE_ABSTIME)
					ProgTime = GetDelay(FG);

				ProgTime += GetDuration(FG);

				if (PrevVidEvent)
				{
					if (!MaybeInsertBlack(sv,PrevVidEvent,ProgTime))
						break;
				}

				break;
			default:
				// Do nothing???
				break;
			}
			break;

		default:
			//DUMPMSG("Unrecognized Crouton Type!");

			//	Don't recognize this content in a sequence.
			break;

		} // END OF SWITCH

		// If an error code was reported, stop analyzing
		if (error)
			break;

		sv->Pos++;
	} // FOR

	if (error)
		goto Failed;


//	/*** Warn user if sequencer inserted black anywhere ***/
//	if ((!error) && (sv->InsMattes > 0))
//	{
//		sprintf(sv->scratch," Warning!  Sequencer inserted black at %d place(s) ",sv->InsMattes);
//		MPtr[0] = sv->scratch;
//		MPtr[1] = " in this project due to locked video.";
//		MPtr[2] = " Select \"cancel\" to abort and highlight each";
//
//		// Put up warning requester, check proceed or cancel
//		if (!SeqRequest(sv,MPtr,3))
//		{
//			// User cancelled
//
//			flag = FALSE;
//
//			/*** Walk thru list of events and hilite each that caused black insertion ***/
//			for (event = (struct Event *)sv->VideoTrack.EventList.lh_Head
//			; event->Node.mln_Succ
//			; event = (struct Event *)event->Node.mln_Succ)
//			{
//				if ((FLAGS2F_MATTE & event->Flags2) && (event->CurrentPosition >= 0))
//				{
//					DUMPUDECL("Hiliting ",event->CurrentPosition,"\\");
//					// Hilite this crouton
//					if (!flag)
//					{
//						ew_QuickSelect(sv->EditTop,event->CurrentPosition);		// First one
//						flag = TRUE;
//					}
//					else
//						ew_MultiSelect(sv->EditTop,event->CurrentPosition);		// all others
//				}
//			}
//
//			if (flag)
//			{
//				sv->Edit->ew_OptRender = FALSE;
//				UpdateAllDisplay();
//			}
//
//			goto Failed;
//		}
//	}


	// Unless an error occurred, put final transition at end
	if (!error)
	{
		// Okay, if this final black is slated to start before a switcher scroll/crawl
		// will be finished, we must use the same Flyer channel as previous source,
		// so that it will look correct even though switcher cannot do a take.
		// For this to work requires that the previous source be a clip/still as well
		if (DetectSwitcherCollision(sv,ProgTime))
		{
			// Eligible for special cuts-under handling?
			if (PrevVidEvent)
				objtype = PrevVidEvent->FG->ObjectType;
			else
				objtype = 0;
			if ((objtype!=CT_VIDEO) && (objtype!=CT_STILL))		// Wrong previous type
			{
				error = SEQERR_OverlaysOverNonFlyer;
				if (PrevVidEvent)
					FG = PrevVidEvent->FG;
				goto Failed;
			}
			if (EffectFG)			// Cannot do effect under scroll/crawl
			{
				error = FXunderErrors(sv->LastSwitEvent);		// Error for switcher object type
				FG = EffectFG;
				sv->Pos = EffectPos;
				goto Failed;
			}
			objtype = sv->LastSwitEvent->FG->ObjectType;
			if ((objtype == CT_SCROLL) || (objtype == CT_CRAWL))
			{
				error = SEQERR_ScrawlPastEnd;
				FG = sv->LastSwitEvent->FG;
				sv->Pos = -1;		// Don't know
				goto Failed;
			}

			//DUMPMSG("Cut under key/overlay!");
			sv->FlyChan = 1-sv->FlyChan;				// Reverse back to other channel
			sv->CutUnder = TRUE;							// Special case for this one guy
		}
		else
			sv->CutUnder = FALSE;

		// Create a black event to cut/transition to
		event = CreateBlack(sv,ProgTime,sv->FlyChan);
		sv->InsMattes--;			// Don't count this as a black insertion

		if ((event) && (!sv->CutUnder))		// Switcher not a participant for cuts under
		{
			sv->FlyChan = 1-sv->FlyChan;					// Alternate channels

			if (!HandleTransition(
				sv,
				ProgTime,			// CutTime
				PrevVidEvent,			// V1
				EffectFG,				// FXFG (will be NULL for cut)
				EffectPos,				// FXpos (or -1 for cut)
				event))					// V2 (has no FG associated with it!)
			{
				goto Failed;
			}
		}
	}

	/*** Calculate total running time from start crouton to end ***/
	sv->SeqTotalTime = TimeBetweenFGs(SeqStartFG,NULL);

	/*** Make "wait" event to take us to the end of the total project ***/
	if (!error)
	{
		if ((event = GetEvent(FG))==NULL)
			error = SEQERR_OutOfMemory;
		else
		{
			event->FG = NULL;
			event->Flags1 = FLAGS1F_WAIT4TIME;		// Control event = wait for time
//			event->Time = ProgTime;						// Time = end of project
			event->Time = sv->SeqTotalTime;			// Time = end of project
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track
		}
	}

// Was coming to here first, but I moved it higher up
//	if (error)
//		goto Failed;

//	if (FinalClip)
//		FinalClip->Flags1 |= FLAGS1F_LASTEVENT;


#ifdef	SERDEBUG

	// Dump contents of each track

	ListTrack(&sv->SwitcherTrack,TRACK_SWITCHER);
	ListTrack(&sv->VideoTrack,TRACK_FLYVID);
	ListTrack(&sv->AudioTrack,TRACK_AUDIO);

	//DUMPMSG("******************************************");
#endif

	return(TRUE);					// Built sequence successfully


Failed:

	// If stopped due to some error, put up the requester now
	if ((error == SEQERR_SwitcherCollision) || (error == SEQERR_OverlaysOverNonFlyer))
		ReportSequenceDualError(sv,FG,sv->Pos,sv->LastSwitEvent->FG,-1,error);
	else if (error)
		ReportSequenceError(sv,FG,sv->Pos,error,FALSE);


	DisplayMessage(NULL);			// Remove any message at top of screen
	DisplayRunningTime();			// Put other info back up

	return(FALSE);
}


//=============================================================
// PlayCurSeq
//		Play the currently built sequence
//=============================================================
static void PlayCurSeq(	struct SeqVars *sv)
{
	struct PlaySeqInfo SeqInfo;
	struct ExtFastGadget *FG = NULL;
	char	*MPtr[2];
	UWORD error = 0;

	struct FlyerVolume	fv;
	struct ClipAction		act;

	/* MUST Be initialized to zeroes */
	memset(&act,0,sizeof(act));
	memset(&fv,0,sizeof(fv));


	// Select internal default effect (fade)
	SendSwitcherReply(ES_SelectDefault,NULL);

	// Put up matte black if showing a Flyer video output
	// This is no longer needed, as the sequence processing glitch is gone
//	Main2Blank();

	EditingLive = FALSE;

	// Send abort to Flyer to abort any clips that are playing
	SendSwitcherReply(ES_Stop,NULL);

//**********************************************************
//************** Start of post processing ******************
//**********************************************************

//*** No longer instruct Flyer about Head definition/creation, we let it do that now ***
//	sv->AuxError = SendSwitcherReply(ES_EndHeadList,NULL);
//	DUMPHEXIL("EndHeadList error=",sv->AuxError,"\\");
//	if(sv->AuxError == 9)		// Tie into FERR_NOAUDIOCHAN!
//	{
//		// Unable to create heads of strip audio
//		error = SEQERR_NoAudioDrive;
//		FG = (struct ExtFastGadget *)CurFG;
//		sv->Pos = -1;							// Find it for me
//		goto Abort;
//	}
//	else if (sv->AuxError)		// Will be FERR_FULL ($21) when full, handle any other non-0 as well!
//	{
//		// Unable to create heads of strip audio
//		error = SEQERR_ABrollFull;
//		FG = (struct ExtFastGadget *)CurFG;
//		sv->Pos = -1;					// Find it for me
//		goto Abort;
//	}

//	if (sv->AudioTrack.EventList)
//	{
//		sv->AudioTrack.EventPtr->FG = NULL;		// Put an end on it
//
#ifdef	SERDEBUG
//		DUMPMSG("---- Unsorted AudEvents ----");
//		for (sv->Pos=0 ; sv->Pos<sv->AudioTrack.EventCount ; sv->Pos++)
//		{
//			DUMPMEM("AudEvent",(UBYTE *)(sv->AudioTrack.EventList+sv->Pos),sizeof(struct Event));
//		}
//		DUMPMSG("**************************************");
#endif
//
//		// Sort events by time
//		SortEvents(sv->AudioTrack.EventList,(ULONG)sv->AudioTrack.EventCount);
//
//
#ifdef	SERDEBUG
//		DUMPMSG("---- Sorted AudEvents ----");
//		for (sv->Pos=0 ; sv->Pos<sv->AudioTrack.EventCount ; sv->Pos++)
//		{
//			DUMPMEM("AudEvent",(UBYTE *)(sv->AudioTrack.EventList+sv->Pos),sizeof(struct Event));
//		}
//		DUMPMSG("**************************************");
#endif
//	}

	// Download Flyer events to Flyer
	if (FlyerBase)
	{
		ClearFlyerStatus();		// Clear "done" flag and any errors

		sv->AuxError = NewSequence(0);				// Prepare Flyer for sequence download
		//DUMPUDECB("NewSeq err = ",sv->AuxError,"\\");
		if (sv->AuxError==FERR_OKAY)					// Can we proceed to download?
		{
			MPtr[0] = "Flyer is processing sequence...";
			OpenNoticeWindow(sv->EditTop->Window,MPtr,1,TRUE);
//			DisplayWaitSprite();

			//DUMPMSG("Downloading video track...");
			sv->AuxError = DownLoadFlyerTrack(sv,&sv->VideoTrack,TRACK_FLYVID,TRUE);	// Send video events
			if (sv->AuxError==FERR_OKAY)
			{
				//DUMPMSG("Downloading audio track...");
				sv->AuxError = DownLoadFlyerTrack(sv,&sv->AudioTrack,TRACK_AUDIO,TRUE);	// Send audio events
			}

			// Should we allow Flyer to process the sequence?
			if (sv->AuxError == FERR_OKAY)
			{
				act.Volume = &fv;
				act.ReturnTime = RT_IMMED;

				//DUMPSTR("Flyer is processing sequence...");
				sv->AuxError = EndSequenceNew(&act,1);		// Just BEGIN processing...
				//DUMPUDECL ("(start=",sv->AuxError,") ");
				if (sv->AuxError == FERR_OKAY)
				{
					//DUMPSTR("Waiting...");
					do
					{
						if (CheckNoticeCancel())				// If CANCEL button pressed...
						{
							//DUMPSTR("Aborting...");
							AbortAction(&act);					// ...abort processing
							//DUMPMSG("Aborted");
							sv->AuxError = FERR_ABORTED;
						}
						else
							sv->AuxError = CheckAction(&act);	// Still processing?
					} while (sv->AuxError == FERR_BUSY);			// Loop until done
				}
				//DUMPUDECB("done (",sv->AuxError,")\\");
			}
			else
				EndSequence(0,0);					// Abort download

//			DisplayNormalSprite();
			CloseNoticeWindow();
		}

		if (sv->AuxError == FERR_FULL)			// Can't move data necessary?
		{
			// Unable to create A/B video heads (or stripped audio)
			error = SEQERR_ABrollFull;
			FG = NULL;		// Highlight none
			goto Abort;
		}
		else if (sv->AuxError == FERR_NOAUDIOCHAN)	// Need audio drive to move data to?
		{
			// No audio drive for stripped/split audio
			error = SEQERR_NoAudioDrive;
			FG = NULL;		// Highlight none
			goto Abort;
		}
		else if (sv->AuxError == FERR_NO_BROLLDRIVE)	// Need B-roll drive to do FX?
		{
			// No video drive for overlapping video during FX
			error = SEQERR_NoBrollDrive;
			FG = NULL;		// Highlight none
			goto Abort;
		}
		else if (sv->AuxError == FERR_HEADFAILED)		// A/B head failure?
		{
			// A/B head failure
			error = SEQERR_ABfailure;
			FG = NULL;		// Highlight none
			goto Abort;
		}
		else if (sv->AuxError == FERR_OBJNOTFOUND)	// Clip not found?
		{
			// Could not find named clip
			error = SEQERR_FlyerClipMissing;
			FG = sv->FailFG;		// Highlight offender
			goto Abort;
		}
		else if (sv->AuxError == FERR_LISTCORRUPT)	// Head problem?
		{
			if (ReportSeqErrCore(sv,SYSERR_HeadsBad,TRUE))
			{
				DisplayMessage("Cleaning up A/V temps...");	// Let them know what's going on
				StartHeadList(0);			// Do nice, graceful cleanup of heads first
				EndHeadList(0,1);
				VoidCardHeads(0);			// Now get nasty and clean EVERYTHING up
				DisplayMessage(NULL);	// Remove any message at top of screen
			}
			error = 0;				// No other error to report (took care of it)
			goto Abort;
		}
		else if (sv->AuxError == FERR_DRIVEINCAPABLE)	// Video from slow drive?
		{
			// Can't play video from this drive
			error = SEQERR_NonVideoDrive;
			FG = sv->FailFG;		// Highlight offender
			goto Abort;
		}
		else if (sv->AuxError == FERR_BADPARAM)	// Bad clip parameter?
		{
			error = SEQERR_BadParam;
			FG = sv->FailFG;		// Highlight offender
			goto Abort;
		}
		else if ((sv->AuxError == FERR_SELTIMEOUT)	// Missing drive?
				|| (sv->AuxError == FERR_BADSTATUS)		// Some SCSI error?
				|| (sv->AuxError == FERR_INCOMPLETE))	// Transfer not completed?
		{
			UBYTE	done;
			ULONG	drive;

			switch (sv->AuxError)
			{
				case FERR_SELTIMEOUT:
					error = SYSERR_SCSItimeout;
					break;
				case FERR_BADSTATUS:
					error = SYSERR_SCSIproblem;
					break;
				case FERR_INCOMPLETE:
					error = SYSERR_SCSIincomp;
					break;
			}

			if (GetClrSeqError(0,0,&done,&drive,NULL) == sv->AuxError)
			{
				GetClrSeqError(0,1,NULL,NULL,NULL);					// Clear status
				sprintf(ErrorDetails,"   (Possibly related to drive F%c%d:)",'A'+(drive/8),drive%8);
			}
			else
				sprintf(ErrorDetails,"   (Unable to pinpoint the specific drive)");
			FG = NULL;		// Highlight none
			goto Abort;
		}
		else if (sv->AuxError == FERR_ABORTED)
		{
			error = 0;		// This is not an error
			goto Abort;		// But don't play sequence
		}
		else if (sv->AuxError != FERR_OKAY)
		{
			error = SEQERR_InternalFlyer;
			FG = sv->FailFG;		// Highlight offender
			goto Abort;
		}
	}


	// Show correct Flyer output (so FX from black to 1st video will work)
	if (sv->partial)
	{
		//DUMPUDECL ("Punched up first clip on ",sv->firstflychan,"\\");
		FlyerChanOnMain(sv->firstflychan);
	}
	else
	{
		//DUMPUDECL ("Punched up opposite of ",sv->firstflychan,"\\");
		FlyerChanOnMain(1-sv->firstflychan);
	}


	/*********************************************
	*** Prepare the SeqInfo structure for play ***
	*********************************************/

	// Clear all fields of this structure
	memset(&SeqInfo, 0, sizeof(struct PlaySeqInfo));

	// Stop on sequence timing error?
	SeqInfo.StopOnError = (UserPrefs.SeqFlags & SFF_STOPONERR)?1:0;

	SeqInfo.CurSwitcherEvent = (struct Event *)sv->SwitcherTrack.EventList.lh_Head;
	SeqInfo.TimeAtSequenceEnd = sv->SeqPlayTime;


	/*************************************************************
	*** If first switcher events are SELECTs, preroll them now ***
	*** Then put interface back up and wait for start          ***
	*************************************************************/

	if (((sv->SwitcherTrack.EventCount) && (SeqInfo.CurSwitcherEvent->FGCcommand == FGC_SELECT)) |
		((sv->SwitcherTrack.EventCount) && (SeqInfo.CurSwitcherEvent->FGCcommand == FGC_TOPRVW)))
	{
		//DUMPMSG("*** Before ES_StartSeq1 ***");
		SendSwitcherReply(ES_StartSeq,NULL);

		//DUMPMSG("*** ReadySeq ***");
		ReadySeq(&SeqInfo);			// Get ready to play (do 1st switcher select)

		//DUMPMSG("*** Before ES_Stop1 ***");
		SendSwitcherReply(ES_Stop,NULL);
		UpdateAllDisplay();
	}
	else
	{
		//DUMPMSG	("No pre-SELECT's required");
	}

	DisplayMessage(NULL);		// Remove message from strip
	DisplayRunningTime();		// Restore running time

	if (sv->waitplaystart)		// Wants us to put up requester to start play?
	{
		DisplayNormalSprite();
		if (!BoolRequest(sv->EditTop->Window,">>> The project is ready to play <<<"))
			goto Abort;
		DisplayWaitSprite();
	}

//	//DUMPMSG	("Play Sequence ...............");
//	//DUMPMEM("Sequence=",(UBYTE *)Sequence,VidTrack.TrackMemSize);


	// Get ready to start sequence.  This does some toaster setup and syncs
	// The toaster clock to the Flyer field clock.
	// Also sets bit 4 of TB_DisplayRenderMode (how intuitive!)
//	//DUMPMSG("Before ES_StartSeq2");
	SendSwitcherReply(ES_StartSeq,NULL);

	/* succ = */
		PlaySeq(&SeqInfo);		// Returns success flag

	//DUMPMSG(">>>>>>>>>>>>>>>>>>>> Done <<<<<<<<<<<<<<<<<<<<<");

//	//DUMPMSG("Before ES_Stop");
	SendSwitcherReply(ES_Stop,NULL);		//Clr bit 4 of TB_DisplayRenderMode


// some effects leave us with a bogus lock
#ifndef FINAL_CODE
	if (ToasterBase)
#endif
		CurrentDir(GetBootLock((struct ToasterBase *)ToasterBase));

//	//DUMPHEXIL("&SeqInfo=",(LONG)(&SeqInfo),"\\");

	if (SeqInfo.ErrorEvent)			// A local (Switcher) event failed?
	{
		// Does this if there was a Switcher timing error during the sequence.
		//DUMPHEXIL("ErrorEvent=",(LONG)(SeqInfo.ErrorEvent),"\\");
		//DUMPHEXIL("FG=",(LONG)(SeqInfo.ErrorEvent->FG),"\\");
		//DUMPHEXIL("ErrorMsg=",(LONG)(SeqInfo.ErrorMsg),"\\");

		switch(SeqInfo.ErrorNum)
		{
		case	1:
			// Queue error, time already passed.
			error = SEQERR_EventLate;
			FG = SeqInfo.ErrorEvent->FG;
			sv->Pos = -1;							// Find it for me (don't know)
			break;

		default:
			break;
		}
		// Goes to "Abort"
	}
	else if (SeqInfo.FlyerError)		// A Flyer event failed?
	{
		struct Event	*event;

		// Does this if there was an error during the sequence.
		switch (SeqInfo.FlyerError)
		{
		case FERR_CLIPLATE:
			error = SEQERR_FlyerLate;
			break;
		case FERR_DROPPEDFLDS:
			error = SEQERR_FlyerDropped;
			break;
		default:
			error = SEQERR_FlyerOther;
		}

		FG = NULL;

		// Turn UserID code sent to Flyer back into sequencer event ptr
		if (error != SEQERR_FlyerOther)
		{
			event = FindFlyerEventFromID(sv, SeqInfo.FlyerUserID);
			if (event)
				FG = event->FG;
		}

		sv->Pos = -1;							// Find it for me (don't know)
		// Goes to "Abort"
	}
	else
	{
		// If PlaySeq returned no FG (success or aborted before any processed)
		// then keep the same crouton hilited as when we started
		FG = SeqInfo.AbortedFG;		// Get FG for error/abort (or NULL)
		if (!FG)
			FG = (struct ExtFastGadget *)CurFG;

		HiliteNewFG(sv->EditTop,FG,-1,TRUE);	//Hilite initially selected or abort crouton
	}

Abort:

	// If stopped due to some error, put up the requester now
	if (error)
		ReportSequenceError(sv,FG,-1,error,FALSE);
}


//=============================================================
// EditToAllAudio
//		Interactive lock-down's to music (full sequence)
//=============================================================
static void EditToAllAudio(struct SeqVars *sv)
{
	struct PlaySeqInfo SeqInfo;

	EditingLive = FALSE;

	// Send abort to Flyer to abort any clips that are playing
	SendSwitcherReply(ES_Stop,NULL);

	// Download audio events to Flyer
	if (FlyerBase)
	{
		ClearFlyerStatus();		// Clear "done" flag and any errors

		sv->AuxError = NewSequence(0);				// Prepare Flyer for sequence download
		if (sv->AuxError==FERR_OKAY)					// Can we proceed to download?
		{
			//DUMPMSG("Downloading audio track...");
			sv->AuxError = DownLoadFlyerTrack(sv,&sv->AudioTrack,TRACK_AUDIO,FALSE);	// Send audio events

			// Should we allow Flyer to process the sequence?
			if (sv->AuxError == FERR_OKAY)
			{
				//DUMPSTR("Flyer is processing sequence...");
				sv->AuxError = EndSequence(0,1);				// Let Flyer grind on this for a while...
				//DUMPUDECB("done (",sv->AuxError,")\\");
			}
			else
				EndSequence(0,0);					// Abort download
		}

		if (sv->AuxError != FERR_OKAY)
		{
			ReportSequenceError(sv,NULL,-1,SEQERR_InternalFlyer,FALSE);
			return;
		}
	}


	FreeTrack(&sv->SwitcherTrack);			// Empty switcher list


	/*********************************************
	*** Prepare the SeqInfo structure for play ***
	*********************************************/

	// Clear all fields of this structure
	memset(&SeqInfo, 0, sizeof(struct PlaySeqInfo));

	SeqInfo.StopOnError = 0;		// No stopping

	SeqInfo.CurSwitcherEvent = (struct Event *)sv->SwitcherTrack.EventList.lh_Head;
	SeqInfo.TimeAtSequenceEnd = sv->SeqPlayTime;


	DisplayMessage(NULL);		// Remove message from strip
	DisplayRunningTime();		// Restore running time

	DisplayNormalSprite();
	if (!BoolRequest(sv->EditTop->Window,">>> Ready to edit to music <<<"))
		return;
	DisplayWaitSprite();

	DisplayMessage(E2Mproc_message);

	// Sync the Toaster/Flyer field clocks
//	SendSwitcherReply(ES_SyncClocks,NULL);		// WILL HAVE TO ADD THIS TO PECOMM.a

	// Start music and come right back (stash base time of the sequence)
	PlaySeq(&SeqInfo);		// Returns success flag


	//	DUMPMSG("Before ES_Stop");
//	SendSwitcherReply(ES_Stop,NULL);		//Clr bit 4 of TB_DisplayRenderMode

	//////////////// Return to interface gadgets and keys active //////////////
	// New lock-down hotkey (enabled when EditingLive == TRUE;
	// time = GetCurProgTime() + sv->StartTime;
	// Use absolute 'time' value
	//////////////////////////////////////////////////////////////////////////

	EditingLive = TRUE;
	Editing2Video = FALSE;

	MusicBaseTime = sv->StartTime;		// Offset to get us to real program time

	//DUMPUDECL ("MusicBaseTime(FULL) = ",MusicBaseTime,"\\");
}


//=============================================================
// EditToClip
//		Interactive lock-down's to music (one clip)
//=============================================================
static void EditToClip(struct SeqVars *sv, struct ExtFastGadget *fg)
{
//	struct PlaySeqInfo SeqInfo;

	//DUMPMSG("11111111  Cut2Music  111111111");

	EditingLive = FALSE;

	Editing2Video = (fg->ObjectType == CT_VIDEO)?TRUE:FALSE;

	// Send abort to Flyer to abort any clips that are playing
	SendSwitcherReply(ES_Stop,NULL);

//
//	SeqInfo.CurSwitcherEvent = (struct Event *)sv->SwitcherTrack.EventList.lh_Head;
//	SeqInfo.TimeAtSequenceEnd = sv->SeqPlayTime;
//
//
//	DisplayMessage(NULL);		// Remove message from strip
//	DisplayRunningTime();		// Restore running time
//
//	DisplayNormalSprite();

	if (!BoolRequest(sv->EditTop->Window,
		Editing2Video?">>> Ready to edit to video <<<":">>> Ready to edit to music <<<"))
	{
		return;
	}

	DisplayWaitSprite();
	DisplayMessage(Editing2Video ? E2Vproc_message : E2Mproc_message);

//	// Sync the Toaster/Flyer field clocks
//	SendSwitcherReply(ES_SyncClocks,NULL);		// WILL HAVE TO ADD THIS TO PECOMM.a

	if (Editing2Video)
	{
		MasterVideoTime = GetStartTimeInSequence((struct FastGadget *)fg);
		//DUMPUDECL ("MasterVidTime = ",MasterVideoTime,"\\");
	}

	// Just play the clip...
	ESparams1.Data1=(LONG)fg;
	SendSwitcherReply(ES_Auto,&ESparams1);


	//////////////// Return to interface gadgets and keys active //////////////
	// New lock-down hotkey (enabled when EditingLive == TRUE;
	// time = MusicBaseTime + GetCurProgTime()
	// Use absolute 'time' value
	//////////////////////////////////////////////////////////////////////////

	EditingLive = TRUE;

	NavigateRight(sv->EditTop,0);				// Jump to next crouton for them (aint I nice)

//	MusicBaseTime = sv->StartTime;		// Offset to get us to real program time
}


//=============================================================
// HandleLockDown
//		Lock/unlock crouton program time (also during cut2music)
//=============================================================
void HandleLockDown(struct EditWindow *Edit)
{
	struct ExtFastGadget *curfg,*fg;
	LONG	time;
	BOOL	lockem,redraw = FALSE;

	//DUMPMSG("LockDown");

	curfg=(struct ExtFastGadget *)CurFG;		// Hilited crouton (if any)
	if (!curfg)
	{
		curfg = FindFirstHilited(Edit);		// If none, pick first hilited as "curfg"
//		//DUMPHEXIL("FirstHilite=",(LONG)curfg,"\\");
	}

	if (curfg)							// Must have at least one crouton hilited, or we bail out
	{
		if (EditingLive)						// Always lock, and just this crouton (if possible)
		{
			//DUMPUDECL("MusicBaseTime = ",MusicBaseTime," ");
			//DUMPUDECL("CurProgTime = ",GetCurProgTime()," ");
			time = (((GetCurProgTime() + MusicBaseTime)/2)*2);	//Hack time even.DEH
			//DUMPUDECL("(time ",time,")\\");

			switch(curfg->ObjectType)
			{
			case CT_AUDIO:
				if (Editing2Video)
				{
					//DUMPMSG("Rel!");

					PutDelay(curfg,time-MasterVideoTime);		// Set relative start time
					PutTimeMode(curfg,TIMEMODE_RELINPT);		// Relative to video inpoint
//					curfg->SymbolFlags &= ~SYMF_LOCKED;
					curfg->SymbolFlags |= SYMF_LOCKED;		// Go ahead and show as locked
																		// (Will cleanup when done)
				}
				else
				{
					//DUMPMSG("Locked!");

					PutDelay(curfg,time);							// Set absolute start time
					PutTimeMode(curfg,TIMEMODE_ABSTIME);		// Lock video

					curfg->SymbolFlags |= SYMF_LOCKED;
				}
				redraw = TRUE;
				break;
			case CT_VIDEO:
			case CT_STILL:
			case CT_FRAMESTORE:
			case CT_VIDEOANIM:
			case CT_IMAGE:
			case CT_MAIN:
				//DUMPMSG("Locked!");

				PutDelay(curfg,time);							// Set absolute start time

				// Set lock as well as marker for our follow-up pass (we splice things up)
				PutTimeMode(curfg,TM_TEMP_LOCKED | TIMEMODE_ABSTIME);		// Lock video

				curfg->SymbolFlags |= SYMF_LOCKED;
				redraw = TRUE;
				break;
			}
			if (redraw)
				ew_ForceRedraw(Edit,GetProjNodeOrder(Edit,(struct FastGadget *)curfg));
		}
		else	// else manually locking/unlocking
		{									// Lock/unlock (multiple) in project window

			// First, decide (based on last hilited) whether to lock or unlock all hilited
			if (GetTimeMode(curfg) == TIMEMODE_ABSTIME)
				lockem = FALSE;
			else
				lockem = TRUE;

			DisplayWaitSprite();

			// Since "next" pointer is first LONG of the FastGadget,
			// we just substitute the Address of the FG list head
			fg = (struct ExtFastGadget *)((struct Project *)Edit->Special)->PtrPtr;

			while (fg = (struct ExtFastGadget *)GetNextEditNode(Edit,(struct EditNode *)fg))
			{
				redraw = FALSE;

				if (fg->FG.FGDiff.FGNode.Status == EN_SELECTED)
				{
					switch(fg->ObjectType)
					{
					case CT_AUDIO:
						if (!lockem)		// Unlock (from ProgTime to InPoint)
						{
							ParentVideoTime = 0;		// In case this guys related to no one
							time = GetStartTimeInSequence((struct FastGadget *)fg);	// Current lock time

							PutDelay(fg,time-ParentVideoTime);		// Set relative start time
							PutTimeMode(fg,TIMEMODE_RELINPT);		// Relative to video inpoint
							fg->SymbolFlags &= ~SYMF_LOCKED;		// No longer locked
							redraw = TRUE;
							
							break;
						}

//						if (lockem)
//						{
//							time = GetStartTimeInSequence((struct FastGadget *)fg);	// Lock where it's at now
//							//DUMPUDECL("(locked at ",time,")\\");
//							PutDelay(fg,time);		// Set absolute start time
//							PutTimeMode(fg,TIMEMODE_ABSTIME);
//							fg->SymbolFlags |= SYMF_LOCKED;
//							redraw = TRUE;
//						}
//						break;



					case CT_STILL:
					case CT_VIDEO:
					case CT_FRAMESTORE:
					case CT_VIDEOANIM:
					case CT_IMAGE:
					case CT_MAIN:
						if (lockem)
						{
							//DUMPMSG("Locked!");
							time = GetStartTimeInSequence((struct FastGadget *)fg);	// Lock where it's at now
							//DUMPUDECL("(locked at ",time,")\\");
							PutDelay(fg,time);						// Set absolute start time
							PutTimeMode(fg,TIMEMODE_ABSTIME);		// Lock video

							fg->SymbolFlags |= SYMF_LOCKED;
							redraw = TRUE;
						}
						else
						{
							//DUMPMSG("Unlocked!");
							PutTimeMode(fg,TIMEMODE_RELCLIP);		// Unlock video
							fg->SymbolFlags &= ~SYMF_LOCKED;
							redraw = TRUE;
						}
						break;
					}
				}

				if (redraw)
					ew_ForceRedraw(Edit,GetProjNodeOrder(Edit,(struct FastGadget *)fg));
			}
			DisplayNormalSprite();

			if (lockem == FALSE)				// When unlocking things, better...
			{
				CalcRunningTime();			// re-calculate sequence running time
				if (CurFG)
					CalcCurrentTime(CurFG);	// re-calculate time for the guy we're on
			}
		}
	}

}


//=============================================================
// EditTo_FollowUp
//		Optional cleanup work following editing to music or video
//=============================================================
static void EditTo_FollowUp(struct EditWindow *Edit)
{
	struct ExtFastGadget *fg,*lastvid=NULL;
	BOOL	okayed = FALSE,denied=FALSE;
	LONG	overlap,dur,maxdur;
	char *MPtr[3];
	ULONG	timemode;

	DisplayWaitSprite();

	//DUMPMSG("Fixing put seq?");

	// Since "next" pointer is first LONG of the FastGadget,
	// we just substitute the address of the FG list head
	fg = (struct ExtFastGadget *)((struct Project *)Edit->Special)->PtrPtr;

	while (fg = (struct ExtFastGadget *)GetNextEditNode(Edit,(struct EditNode *)fg))
	{
		//DUMPHEXIL("fg=",(LONG)fg,"\\");

		switch (fg->ObjectType)
		{
			case CT_AUDIO:
				// Look for audio croutons that artificially have the locked indicator lit.
				// This happens when editing audio to video: the lock appears even though
				// the time mode is really "in-point".  Now that we're done editing,
				// remove all the audio padlocks that aren't "real"
				if ((SYMF_LOCKED & fg->SymbolFlags)
				&&  (GetTimeMode(fg) != TIMEMODE_ABSTIME))
				{
					fg->SymbolFlags &= ~SYMF_LOCKED;
					ew_ForceRedraw(Edit,GetProjNodeOrder(Edit,(struct FastGadget *)fg));
				}
				break;
	
			case CT_STILL:
			case CT_VIDEO:
			case CT_FRAMESTORE:
			case CT_VIDEOANIM:
			case CT_IMAGE:
			case CT_MAIN:
				timemode = GetTimeMode(fg);
				if (timemode & TM_TEMP_LOCKED)		// Just locked this one?
				{
					PutTimeMode(fg,timemode & ~TM_TEMP_LOCKED);		// Remove marker!!!

					if (!denied)		// If user denied us permission, still remove all markers
					{
						// Does previous video need fixed to line up with me?
						if (lastvid)
						{
							dur = GetDuration(lastvid);

							// Calc error (+ means overlap, - means a gap)
							overlap = (GetStartTimeInSequence((struct FastGadget *)lastvid) + dur)
								- GetDelay(fg);
						}
						else
							overlap = 0;

						if (overlap != 0)			// Problem with this one I'd like to fix?
						{
							// If we do not yet have permission to fix things, get it now
							if (!okayed)
							{
								MPtr[0] = "   Shall I fix the out-points necessary to";
								MPtr[1] = "   accommodate the croutons just edited?";
								MPtr[2] = NULL;
								okayed = ErrorMessageBoolRequest(Edit->Window,MPtr);
								if (!okayed)
									denied = TRUE;			// Skip further tests, but still remove markers
							}

							if (okayed)
							{
								//Okay, let's fix the previous video's outpoint to match (trim/extend)
								if (overlap < dur)			// Ensure we don't make a duration <= 0
								{
									//DUMPUDECL("Fixing video from ",dur,"");
									dur -= overlap;
							
									if ((fg->ObjectType==CT_STILL) || (fg->ObjectType==CT_FRAMESTORE))
										maxdur = 999000; //fix for fixup!							 	
									else	
									{
										maxdur = GetRecFields(lastvid) - GetStartField(lastvid);
										//DUMPUDECL(" using GetRecFields(lastvid) - GetStartField(lastvid) ",maxdur,"\\");
										//DUMPUDECL(" fg->ObjectType ",fg->ObjectType,"\\");
									}
									// Ya, right mr.M but with stills rec and start fields
									// are both 0 so then is maxdur!!! Realy it can be infinite.
									//	DEH122095	
									// DEH112096 - Really maxdur will be 0 or 4 in either case 
									//             it can be maxed out inf. it a still of fs.
									if (maxdur <= 4) maxdur=999000; //? is this close to inf.
									

									//DUMPUDECL(" GetRecFields ",GetRecFields(lastvid),"\\");
									//DUMPUDECL(" GetStartField ",GetStartField(lastvid),"\\");
									//DUMPUDECL(" Taking max dur into account ",maxdur,"\\");


									if (dur > maxdur)			// Keep outpoint legal
										dur = maxdur;
									PutDuration(lastvid,dur);
									//DUMPUDECL(" to ",dur,"\\");
								}

								// Maybe fix natural audio too (Flyer clips only)
								if ((lastvid->ObjectType==CT_VIDEO) && (HasAudio(lastvid)))
								{
									dur = GetAudioDuration(lastvid);

									// Calc error (+ means overlap, - means a gap)
									overlap =
										(GetStartTimeInSequence((struct FastGadget *)lastvid) + dur
										+ GetAudioStart(lastvid) - GetStartField(lastvid))
										- GetDelay(fg);
										// This next term accounts for difference in A/V start times

									if ((overlap > 0)			// Only trim audio, don't extend
									&& (overlap < dur))		// Ensure we don't make a duration <= 0
									{
										//DUMPUDECL("Fixing audio from ",dur,"");
										dur -= overlap;
										PutAudioDuration(lastvid,dur);
										//DUMPUDECL(" to ",dur,"\\");
									}
								}
							}
						}
					}
				}
				lastvid = fg;
				break;

			default:
				break;
		}
	}

	DisplayNormalSprite();			// Remove busy pointer
}


//=============================================================
// FindFirstHilited
//		Find first crouton (if any) in project that is hilited
//=============================================================
struct ExtFastGadget *FindFirstHilited(struct EditWindow *Edit)
{
	struct FastGadget *FG;

	if (Edit->Node.Type != EW_PROJECT)		// Only works in Project window
		return(NULL);

//	// Since "next" pointer is first LONG of the FastGadget,
//	// we just substitute the Address of the FG list head
//	fg = (struct ExtFastGadget *)((struct Project *)Edit->Special)->PtrPtr;

	FG = *((struct Project *)Edit->Special)->PtrPtr;

//	while (fg = (struct ExtFastGadget *)GetNextEditNode(Edit,(struct EditNode *)fg))
//	{
//		if (fg->FG.FGDiff.FGNode.Status == EN_SELECTED)
//			return(fg);
//	}

	while (FG)
	{
//		//DUMPHEXIL("FG=",(LONG)FG,"\\");
		if (FG->FGDiff.FGNode.Status == EN_SELECTED)
			return((struct ExtFastGadget *)FG);
		FG = FG->NextGadget;
	}

	return(NULL);
}


//=============================================================
// TrimToPlayWindow
//		Pare down switcher events to play only a portion of the total project
//=============================================================
static UBYTE TrimToPlayWindow(struct SeqVars *sv, struct ExtFastGadget *firstFG)
{
	struct Event	*event, *nextevent, *newevent;
	WORD		cmd;
	BOOL		killit,fromFX=FALSE;	//firstfg;
	LONG		trim;

	if ((firstFG->ObjectType==CT_FXANIM)
	||  (firstFG->ObjectType==CT_FXALGO)
	||  (firstFG->ObjectType==CT_FXILBM))
	{
		if (!IsOverlay(firstFG))
			fromFX = TRUE;									// Doing a play-from from an transition
	}
	//DUMPMSG("Trimming sequence...");

	// Walk video list and trim any unnecessary insblack flags
	for (event = (struct Event *)sv->VideoTrack.EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
//		//DUMPUDECL("t1=",event->Time," ");
//		//DUMPUDECL("t2=",sv->StartTime," ");
//		//DUMPUDECL("fl=",event->Flags2,"\\");

		// If starting right on a locked video crouton, remove black insertion before it
		if ((event->Time <= sv->StartTime) && (FLAGS2F_MATTE & event->Flags2))
		{
			event->Flags2 &= ~FLAGS2F_MATTE;
			sv->InsMattes--;			// Dec black insertion count

			//DUMPMSG("Trimmed black");
		}
	}

	// Free those out of window + any previous associated SELECTS
	// Adjust those that straddle window boundary (for types that we can do this)
	// For others, free them + prev assoc. SELECTS

//	firstfg = TRUE;

ReWalk:
	//DUMPMSG("re-walk...");

	// Walk switcher list
	for (event = (struct Event *)sv->SwitcherTrack.EventList.lh_Head
	; event->Node.mln_Succ
	; event = nextevent)
	{
		nextevent = (struct Event *)event->Node.mln_Succ;		// Get now, as we may free it

		if (FLAGS2F_MISC & event->Flags2)		// Already processed this one?
			continue;

//		// Only do this for first event in switcher track...
//		// If we start with a TOMAIN, destroy it and just punch up that channel pre-play
//		if (firstfg)
//		{
//			firstfg = FALSE;
//		}

		event->Flags2 |= FLAGS2F_MISC;			// Don't look at this one again

		//DUMPUDECL("t1=",event->Time," ");
		//DUMPUDECL("t2=",sv->StartTime," ");
		//DUMPUDECL("fl=",event->Flags2,"\\");

		if (event->Time < sv->StartTime)		// Need to maybe trim/delete?
		{ // At least partly (if not wholly) outside play window - crop or delete it
			trim = sv->StartTime - event->Time;

			killit = FALSE;

//			if (FLAGS2F_MATTE & event->Flags2)		// Matte black insertions
//			{
//				// Each Flyer channel starts out black, so we can always delete these,
//				// even if it appears we need a partial
//				killit = TRUE;
//				sv->InsMattes--;			// Dec black insertion count
//			}
//			else
			if (event->FG)							// All events except control events
			{
				cmd = event->FGCcommand;

				switch (event->FG->ObjectType)
				{
				case CT_FXCR:		// SELECT, REMOVE
					// Do all or none (if REMOVE is in play, will do a partial)

					if (cmd != FGC_SELECT)
						killit = TRUE;

					break;

				case CT_REXX:		// SELECT
					// Do all or none (test SELECT time in window!)

					killit = TRUE;

					break;

				case CT_SCROLL:
				case CT_CRAWL:
				case CT_KEYEDANIM:	// SELECT,  TAKE/TOMAIN
					// Do all or none

					if (cmd != FGC_SELECT)
						killit = TRUE;

					break;

				case CT_KEY:	// SELECT, TAKE/AUTO/TOMAIN, REMOVE/AUTO
					// Do all, partial, or none

					if (cmd != FGC_SELECT)
					{
						if ((event->Time + event->Duration) <= sv->StartTime)		// remove all?
							killit = TRUE;
						else
						{
							if (cmd != FGC_REMOVE)
							{
								event->Time += trim;
								event->Duration -= trim;	// Not used by switcher (FGC_REMOVE/AUTO)
							}
						}
					}

					break;

				case CT_FXANIM:
				case CT_FXILBM:
				case CT_FXALGO:	// SELECT, TOMAIN
					// Do all or none, whether they are transitional or non-trans

					if (cmd != FGC_SELECT)
						killit = TRUE;

					break;

				case CT_VIDEO:
				case CT_STILL:		// (Flyer SELECT) TAKE/TOMAIN
					// Do all, part, or none -- FGC's of this type always implies a cut
					// So advance cut to window start

					if ((event->Time + event->Duration) <= sv->StartTime)		// remove all?
						killit = TRUE;
					else
					{
						event->Time += trim;
						event->Duration -= trim;	// Sequencer use only
					}

					break;

				case CT_FRAMESTORE:
				case CT_VIDEOANIM:
				case CT_IMAGE:				// Cut: SELECT, TOMAIN
				case CT_MAIN:				// FX:  SELECT, fxSELECT, fxTOMAIN
					// partials

					if ((event->Time + event->Duration) <= sv->StartTime)		// remove all?
						killit = TRUE;
					else
					{
						if (fromFX)
						{
							if (FLAGS2F_FXIN & event->Flags2)
							{
								//	Insert a TOMAIN for crouton at window start time (assume FX will be deleted)
								//DUMPMSG("Inserting a cut for trimmed-out FX");

								// Get event for take's TAKE/TOMAIN
								if (newevent = GetEvent(event->FG))
								{
									newevent->FG = event->FG;
									newevent->CurrentPosition = event->CurrentPosition;										// If V1pos or V2pos
									newevent->FGCcommand = FGC_TOMAIN;
									newevent->Time = sv->StartTime;
									newevent->Duration = event->Duration - trim;
									newevent->Flags2 |= FLAGS2F_MISC;		// Don't trim this!

////								AppendToTrack(&sv->SwitcherTrack,newevent);	// Tack on end of track
									Insert(&sv->SwitcherTrack.EventList,
										(struct Node *)newevent,		// my new node to insert
										(struct Node *)event);			// AFTER this node
								}
							}
							else		// Cut to video, just move cut time to window
							{
								event->Time += trim;
								event->Duration -= trim;	// Sequencer use only
							}
						}
						else
							killit = TRUE;		// If play-from non-FX, no partials (doesn't work!)
					}

					break;
				}
			}

			if (killit)
			{
				// This remembers the Flyer channel punched up by the last switcher
				// event I remove.  I'll punch this up just prior to playing partial
				if (FLAGS1F_SETCHAN & event->Flags1)
				{
					sv->firstflychan = event->Channel;
					//DUMPUDECL("++++++++FFC = ",event->Channel,"++++++++\\");
				}

				// Kill all FGC's we can find associated with this crouton
				DeleteEventsForFG(sv,event->FG);

				goto ReWalk;
			}

		}
	}


	// Walk switcher list, adjust start times for partial play
	for (event = (struct Event *)sv->SwitcherTrack.EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		if (event->Time >= sv->StartTime)		// Completely inside play window?
			event->Time -= sv->StartTime;				// Adjust start time for partial play
	}

#ifdef	SERDEBUG
	//DUMPMSG("******** TRIMMED SWITCHER LIST ***************");

	ListTrack(&sv->SwitcherTrack,TRACK_SWITCHER);

	//DUMPMSG("******************************************");
#endif

	return(0);
}


//=============================================================
// DoWarnings
//		Warn user of any possible problems with sequence
//		(just before we play it)
//=============================================================
static BOOL DoWarnings(struct SeqVars *sv)
{
	struct Event *event;
	BOOL	litone;
	char *MPtr[3];


	/*** Warn user if sequencer detected missing (lost) croutons ***/
	if (sv->LostCroutons > 0)
	{
		sprintf(sv->scratch," Warning!  project contains %d \"lost\" crouton(s).  Project will",sv->LostCroutons);
		MPtr[0] = sv->scratch;
		MPtr[1] = " not play properly until they are replaced with good croutons.";
		MPtr[2] = " Select \"cancel\" to abort";

		// Put up warning requester, check proceed or cancel
		if (!SeqRequest(sv,MPtr,3))
		{
			// User cancelled
			return(FALSE);
		}
	}


	/*** Warn user if sequencer inserted black anywhere ***/
	if (sv->InsMattes > 0)
	{
		sprintf(sv->scratch," Warning!  Sequencer inserted black at %d place(s) ",sv->InsMattes);
		MPtr[0] = sv->scratch;
		MPtr[1] = " in this project due to locked video.";
		MPtr[2] = " Select \"cancel\" to abort and highlight each";

		// Put up warning requester, check proceed or cancel
		if (!SeqRequest(sv,MPtr,3))
		{
			// User cancelled

			litone = FALSE;

			/*** Walk thru list of events and hilite each that caused black insertion ***/
			for (event = (struct Event *)sv->VideoTrack.EventList.lh_Head
			; event->Node.mln_Succ
			; event = (struct Event *)event->Node.mln_Succ)
			{
				if ((FLAGS2F_MATTE & event->Flags2) && (event->CurrentPosition >= 0))
				{
					//DUMPUDECL("Hiliting ",event->CurrentPosition,"\\");
					// Hilite this crouton
					if (!litone)
					{
						ew_QuickSelect(sv->EditTop,event->CurrentPosition);		// First one
						ew_NavigateNodeNum(sv->EditTop,event->CurrentPosition);	// Navigates to it
						litone = TRUE;
					}
					else
						ew_MultiSelect(sv->EditTop,event->CurrentPosition);		// all others
				}
			}

			if (litone)
			{
				CurFG=NULL;		// We've really messed with hilites, so can't guarantee this
				sv->EditTop->ew_OptRender = FALSE;
				UpdateAllDisplay();
			}

			return(FALSE);
		}
	}


//	/*** Warn user if sequencer trimmed any video anywhere ***/
//	if (sv->TrimToFits > 0)
//	{
//		sprintf(sv->scratch," Warning!  Sequencer trimmed video at %d place(s) ",sv->TrimToFits);
//		MPtr[0] = sv->scratch;
//		MPtr[1] = " in this project due to locked video.";
////		MPtr[2] = " Select \"cancel\" to abort and highlight each";
//
//		// Put up warning requester, check proceed or cancel
//		if (!SeqRequest(sv,MPtr,2))
//		{
//			// User cancelled
//			return(FALSE);
//		}
//	}

	return(TRUE);
}


//=============================================================
// DeleteEventsForFG
//		Delete any events in switcher track that point to spec'd FG
//=============================================================
static void DeleteEventsForFG(struct SeqVars *sv, struct ExtFastGadget *fg)
{
	struct Event	*event, *nextevent;

	// Walk switcher list
	for (event = (struct Event *)sv->SwitcherTrack.EventList.lh_Head
	; event->Node.mln_Succ
	; event = nextevent)
	{
		nextevent = (struct Event *)event->Node.mln_Succ;		// Get now, as we may free it

		if (event->FG == fg)				// Kill this one?
		{
			Remove((struct Node *)event);					// Unlink from track
			FreeMem(event, sizeof(struct Event));		// Throw it away
		}
	}
}


//======================================================================
// HandleTransition -- do transition:
// 	video --> video
//		      --> video
// 	video -->      
//======================================================================
static BOOL HandleTransition(	struct SeqVars *sv,
										LONG cuttime,
										struct Event *V1event,			// May be NULL
										struct ExtFastGadget *FXFG,	// NULL for cut
										WORD	FXpos,
										struct Event *V2event)			// May be NULL
{
	static LONG EndOfEffect=0,EndOfPrevEffect;
	static UWORD PreviousEffect = EFFECT_TAKE;

	struct Event *event;
	struct ExtFastGadget	*V1FG,*V2FG;
	LONG	fxlen, takefld, fudge, V2end, temp, aextra=0, bextra=0;
	ULONG	error,alen,blen;
	UWORD fgc;
	WORD	V1pos,V2pos;
	BOOL	overlap;

	EndOfPrevEffect = EndOfEffect;

	V1FG = V2FG = NULL;
	V1pos = V2pos = -1;

	if (V1event)
	{
		V1FG = V1event->FG;
		V1pos = V1event->CurrentPosition;
	}

	if (V2event)
	{
		V2FG = V2event->FG;						// May be NULL for black at end of seq
		V2pos = V2event->CurrentPosition;
	}

	/***********************************/
	/*** Video/Transition/Video Code ***/
	/***********************************/

	if (FXFG)
	{
		// Need to prepare a transition, so do an AUTO  ( V1 --> V2 )
		// Must handle all three scenarios: // Black->Video, Video->Black, Video->Video


		// Get event for effect's SELECT
		if ((event = GetEvent(FXFG))==NULL)
		{
			ReportSequenceError(sv,FXFG,FXpos,SEQERR_OutOfMemory,FALSE);
			return(FALSE);
		}
		event->FG = FXFG;
		event->CurrentPosition = FXpos;
		event->FGCcommand = FGC_SELECT;
		event->Time = 0;								//as soon as possible
		AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track


		// Get event for effect's TOMAIN
		if ((event = GetEvent(FXFG))==NULL)
		{
			ReportSequenceError(sv,FXFG,FXpos,SEQERR_OutOfMemory,FALSE);
			return(FALSE);
		}
		event->FG = FXFG;
		event->CurrentPosition = FXpos;
		event->FGCcommand = FGC_TOMAIN;

		// If have V2 and it's Flyer video - set preview to Flyer output just before the AUTO
		if (V2event)
		{
			if (FLAGS1F_SETCHAN & V2event->Flags1)		// Needs us to set channel before trans?
			{
				event->Flags1 |= FLAGS1F_SETCHAN;
				event->Channel = V2event->Channel;		// Get channel assigned to it
			}
		}

		fxlen = GetNumFields(FXFG);					// Length of effect
		alen = blen = fxlen;								// Default is both sources for entire FX
		//DUMPSDECL("FX len=",fxlen,"\\");

		/*** Calculate AUTO time based on surrounding video presences ***/
		if (V1event && V2FG)			// V1 ---> V2
		{
			alen = GetAsrcLen(FXFG);
			blen = GetBsrcLen(FXFG);
//			/***** HACK! UNTIL CROUTONDEFS.a SETS THESE AS DEFAULTS!!!! *******/
//			if ((alen == 0) && (blen == 0))
//				alen = blen = 0xFFFFFFFF;
			//DUMPHEXIL("Alen=",alen," ");
			//DUMPHEXIL("Blen=",blen,"\\");

			alen = ((alen>>16) * fxlen + 0x8000) >>16;
			blen = ((blen>>16) * fxlen + 0x8000) >>16;

			//DUMPHEXIL("Aflds=",alen," ");
			//DUMPHEXIL("Bflds=",blen,"\\");

			if ((alen+blen) >= fxlen)			// Sources overlap?
			{
				//DUMPMSG("(overlap)");
				overlap = TRUE;

//				// Find offset into the effect to place the cut point
//				fxadvance = fxlen * (32767 - GetDelay(FXFG))/65534;		// SKell' old way
//				takefld = fxlen/2;													// Old default 50%

				takefld = ((GetTakeOffset(FXFG) >>16) * fxlen + 0x8000) >>16;


				//DUMPSDECL("Take@@ ",takefld,"\\");

				// ***!!! This time is bogus if it's a solid ANIM because it isn't centered on
				// a cut!!! Solid ANIMs have video time!!!

				if (alen > takefld)
					aextra = alen-takefld;

				if ((fxlen-blen) < takefld)
					bextra = takefld - (fxlen-blen);

				event->Time = cuttime - takefld;		//Start early so cut point hits cuttime
			}
			else
			{
				//DUMPMSG("(non-overlap)");
				overlap = FALSE;

				// No aextra or bextra, have all we need!

				event->Time = cuttime - alen;		//Start early so A src ends on out point
				// Start V2 later, since there is some FX with no source showing
				V2event->Time += (fxlen-blen) - alen;
				cuttime = V2event->Time;			// All error checks below must know about this
			}
		}
		else if (V2FG)								/* Black --> V2 */
		{
			event->Time = cuttime;				//Start effect right at V2
		}
		else											/* V1 --> Black */
		{
			event->Time = cuttime-fxlen;		//Start effect so it ends with V1
		}

		AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

		//DUMPSDECL("Auto Effect at ",event->Time,"\\");


		/*** Check for sufficient FX/video load time ***/
		if (V1event)				// Unlimited load time if first thing in sequence
		{
			// Prevent this transition from occuring too close to previous takes/autos

			/* Allow time for this effect to load */
			switch (FXFG->ObjectType)
			{
				case	CT_FXILBM:
					fudge = ILBMPREROLLFUDGE;
					break;

				case	CT_FXANIM:
					fudge = ANIMPREROLLFUDGE;
					break;

				case	CT_FXALGO:
					fudge = FXPREROLLFUDGE;
					break;

				default:		// What other types fall to here???
					fudge = FXPREROLLFUDGE;
					break;
			}

			if (V2FG)						// Add in V2 load time if we have a V2
			{
				/* Also allow time for V2 to load/queue */
				switch (V2FG->ObjectType)
				{
					case	CT_FRAMESTORE:

// If any following ChromaFX (can't transition in VideoANIMs, Scrawls, Keys etc...)
// have a Delay of 0, then we need to add these load times also!! ****!!!

					case CT_KEY:
					case CT_FXILBM:
					case CT_FXCR:
						fudge += FRAMEPREROLLFUDGE;
						break;

					case CT_IMAGE:
						fudge += RGBPREROLLFUDGE;
						break;

					case CT_VIDEO:
					case CT_STILL:
						fudge += 0;		// Flyer runs in parallel, takes no Amiga time
						break;

					default:
						break;
				}
			}

			// Okay, we know the load time now.  Will it fit?
			if (event->Time < (EndOfPrevEffect + fudge))
			{
				//DUMPUDECL("Here's why: EndOfPrevFX=",EndOfPrevEffect," ");
				//DUMPUDECL("Fudge=",fudge," ");
				//DUMPUDECL("EventTime=",event->Time,"\\");

				if (PreviousEffect==EFFECT_TAKE)
					error = SEQERR_EffectStartsEarly;	// Effect starts too early
				else
					error = SEQERR_EffectNearEffect;		// Effect starts too soon after previous effect

				if (!ReportSequenceError(sv,FXFG,FXpos,error,TRUE))
					return(FALSE);
			}
		}

		EndOfEffect = event->Time + fxlen;		// Effect AUTO time + duration

//		Keep these to detect switcher event overlaps
		sv->SwitcherBusyTil = EndOfEffect;		// Effect takes over machine
		sv->LastSwitEvent = event;

		/*** Check if effect runs past end of V2 ***/
		if (V2event)
		{
			V2event->Flags2 |= FLAGS2F_FXIN;		// Will bring in with transition
			V2end = cuttime + GetDuration(V2FG);	// Field after the video
			if (EndOfEffect > V2end)
			{
				ReportSequenceError(sv,FXFG,FXpos,SEQERR_EffectEndsLate,FALSE);
				return(FALSE);
			}
		}

		/*** Adjust V1/V2 in/out points to provide overlap needed for effect to occur ***/
		if (V1event && V2FG)			// (Wont do this on black at end)
		{
			if (aextra>0)
			{
				aextra = ROUNDUPTOFRAME(aextra);
				//DUMPSDECL("Adding ",aextra," Aextra\\");

				// Flyer clips: Extend V1's audio outpoint (only if user enabled "auto ramp" and not split-audio)
				if (V1FG && (V1FG->ObjectType==CT_VIDEO)
				&& (GetAudioFadeFlags(V1FG) & AUDFADEF_AutoOut)
				&& ((V1event->StartField+V1event->Duration)==(V1event->AudStart+V1event->AudLength)))
				{
					V1event->AudLength += aextra;
					V1event->AudDecay = alen;			// Decay for entire A source period
				}

				// Extend V1's outpoint (round up to color frame)
				V1event->Duration = GetAdjVideoDuration(V1FG) + aextra;	//ROUNDUPTOFRAME(fxlen-fxadvance);
				PutAdjVideoDuration(V1FG, V1event->Duration);
				//DUMPUDECL("Previous duration changed to ",V1event->Duration,"\\");

				// For Flyer video clips, check to see if V1 had enough video to make overlap
				if (V1FG->ObjectType==CT_VIDEO)
				{
					//DUMPSDECL("Start@@ ",V1event->StartField," ");
					//DUMPSDECL("AdjVdur=",GetAdjVideoDuration(V1FG)," ");
					//DUMPSDECL("RecFlds=",GetRecFields(V1FG),"\\");

					// Calculate how many fields short we are on trailing video
					temp = (V1event->StartField + GetAdjVideoDuration(V1FG)) - GetRecFields(V1FG);
					if (temp>0)
					{
						// Not enough trailing video. Effect ends after video
						sprintf(ErrorDetails,"   (Needs %d more frames)",temp/2);
						ReportSequenceError(sv,FXFG,FXpos,SEQERR_FXtrailingVideo,FALSE);
						return(FALSE);
					}
				}
			}

			if (bextra>0)
			{
				bextra = ROUNDUPTOFRAME(bextra);			// Do this for non-flyer video too?
				V2event->extra	= bextra;					// New added on 030196DEH
																	// keep extra on hand for audio lock

				//DUMPSDECL("Adding ",bextra," Bextra\\");

//				fxadvance = ROUNDUPTOFRAME(fxadvance);		// Do this for non-Flyer video too?

				//DUMPSDECL("V2sf ",V2event->StartField," ");
				//DUMPSDECL("V2ad ",V2event->AudStart,"\\");

				// Flyer clips: Extend V2's audio inpoint (if user enabled "auto ramp" and not split-audio)
				if ((V2FG->ObjectType==CT_VIDEO)
				&& (GetAudioFadeFlags(V2FG) & AUDFADEF_AutoIn)
				&& (V2event->StartField == V2event->AudStart))
				{
					V2event->AudStart -= bextra;
					V2event->AudLength += bextra;
					V2event->AudAttack = blen;			// Ramp up for entire B source period
					//DUMPMSG("Did it!");
				}

				// Flyer clips: extend V2's inpoint (round down to color frame)
				if (V2FG->ObjectType==CT_VIDEO)
				{
					V2event->StartField -= bextra;
					V2event->extra	= bextra;					// New added on 030196DEH
																		// keep extra on hand for audio lock
	
					PutAdjVideoStart(V2FG, V2event->StartField);

					//DUMPUDECL("InPoint changed to ",V2event->StartField,"\\");

					// Check to see if V2 had enough video to make overlap
					if ((V2event->StartField) < 0)
					{
						// Not enough leading video -- effect starts before video
						sprintf(ErrorDetails,"   (Needs %d more frames)",(-V2event->StartField)/2);
						ReportSequenceError(sv,FXFG,FXpos,SEQERR_FXleadingVideo,FALSE);
						return(FALSE);
					}
				}

				if (V2FG->ObjectType==CT_STILL)
				{
					/*** Used to make a head if V1FG->FileName & V2FG->FileName came from same drive ***/
				}

				// Start V2 earlier in sequence
				V2event->Time -= bextra;		// Could un-sort Flyer video events
				V2event->extra	= bextra;		// New added on 030196DEH
														// keep extra on hand for audio lock


				// Extend V2's duration because of the early start
				V2event->Duration = GetAdjVideoDuration(V2FG) + bextra;
				PutAdjVideoDuration(V2FG, V2event->Duration);
			}
		}
		else if (V1event && V2event)			// Make adjustments for video --> black
		{
			// Start V2 earlier in sequence
			V2event->Time -= fxlen;		// Could un-sort Flyer video events
		}

		PreviousEffect = EFFECT_TRANS;
	}

	/******************************/
	/*** Video/Video (Cut) Code ***/
	/******************************/
	else if (!sv->CutUnder)				// CutsUnder require no switcher participation
	{
		// Need to prepare a cut
		// Prevent this Take from occuring too close to previous takes/autos.
		// Allow time for this new video source to load and/or the Flyer to queue
		// Must handle all three scenarios: // Black->Video, Video->Black, Video->Video???


		// Check if V2 has sufficient load time (unlimited if no V1 -- at start of sequence)
		if (V1event && V2FG)
		{
			switch(V2FG->ObjectType)
			{
				case CT_FRAMESTORE:

				// If any following Scrolls, Crawls, KeyedANIMs, KeyedStills,
				// or ChromaFX have a Delay of 0, then we need to add these
				// load times also!! ****!!!
				case CT_FXILBM:
				case CT_FXCR:
				case CT_KEY:

					fudge = FRAMEPREROLLFUDGE;
					break;

				case CT_IMAGE:
					fudge = RGBPREROLLFUDGE;
					break;

				case CT_VIDEOANIM:
					fudge = ANIMPREROLLFUDGE;
					break;

				case CT_VIDEO:
				case CT_STILL:
					fudge = 0;				// Flyer runs in parallel to Amiga
					break;

				default:
					fudge = 0;
					break;
			}

			// Enough time to load V2?
			if (cuttime < (EndOfEffect+fudge))
			{
				// Not enough preroll time to start video
				if (!ReportSequenceError(sv,V2FG,-1,SEQERR_VideoPreroll,TRUE))
					return(FALSE);
			}
		}

//******************** DISABLE THIS CODE *****************
//// Sending out minimal 4 to 20 field Head
//// This code needs to also respect FlyerStills!
//		if ((V2FG->ObjectType==CT_VIDEO) && V1event &&
//			 (V1FG->ObjectType == CT_VIDEO) &&
//			 SameFlyerVolumes((char *)(V1FG->FileName),(char *)(V2FG->FileName)))
//		{
//			if((fxlen=GetAdjVideoDuration(V2FG))>20) fxlen=20;
//
//			vstartfld=V2event->StartField;
//			astartfld=audlength=0;
//
//			if(HasAudio(V2FG))
//			{
//				astartfld=vstartfld;
//				audlength=fxlen;
//			}
//
//			if(MakeClipHeadR((char *)V2FG->FileName, vstartfld, fxlen, astartfld, audlength))
//			{
///*?*/		error = SEQERR_CantMakeCut;	// Unable to do cut. Not enough Flyer space.
//				break;
//			}
//		}
//******************************************************

		// For rest of code, prefer V2 crouton, but use V1 if at end (no V2)
		if (V2FG == NULL)
		{
			V2FG = V1FG;
			V2pos = V1pos;
			fgc = FGC_TAKE;
		}
		else
			fgc = FGC_TOMAIN;

		// Get event for take's TAKE/TOMAIN
		if ((event = GetEvent(V2FG))==NULL)
		{
			// Hilite V2 crouton (unless at end, then hilite V1)
			ReportSequenceError(sv,V2FG,V2pos,SEQERR_OutOfMemory,FALSE);	// hilites V1 or V2
			return(FALSE);
		}
		event->FG = V2FG;															// Is V1FG or V2FG
		event->CurrentPosition = V2pos;										// If V1pos or V2pos
		event->FGCcommand = fgc;
		event->Time = cuttime;
		event->Duration = 0;

		// Setup preview to Flyer input just before the TAKE
		if (V2event)
		{
			event->Duration = V2event->Duration;		// For sequencing use

			if (FLAGS1F_SETCHAN & V2event->Flags1)		// Needs us to set channel before cut?
			{
				event->Flags1 |= FLAGS1F_SETCHAN;
				event->Channel = V2event->Channel;		// Get channel assigned to it
			}
		}

		AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track

		//DUMPSDECL("Take VIDEO at ",event->Time,"\\");

		EndOfEffect = cuttime;
		PreviousEffect = EFFECT_TAKE;
	}

	return(TRUE);
}


//======================================================================
// MaybeInsertBlack -- Handle gaps between video
//======================================================================
static BOOL MaybeInsertBlack(struct SeqVars *sv,
										struct Event *V1event,			// May be NULL???
										LONG	time)
{
	struct ExtFastGadget	*V1FG;
	struct Event *event;
	LONG	endofprev,overlap;
	UWORD error;
	char *MPtr[3];
	BOOL	fixit;

	V1FG = (V1event ? V1event->FG : NULL);

	endofprev = V1event->Time + V1event->Duration;

	error = 0;

	// Need black inserted here?
	if (endofprev < time)
	{
		//DUMPMSG("Need to insert black here");

		if ((V1FG) && ((V1FG->ObjectType==CT_VIDEO) || (V1FG->ObjectType==CT_STILL)))
		{
			// Tack black onto end of previous clip (same channel)
			AppendBlack(sv,endofprev,1 - sv->FlyChan);
		}
		else
		{
			// Create a black still on next Flyer channel (switch next time)
			event = CreateBlack(sv,endofprev,sv->FlyChan);
			if (!event)
				error = SYSERR_CantCreateBlack;
			else
			{

				sv->FlyChan = 1 - sv->FlyChan;

				if (!HandleTransition(
					sv,
					endofprev,				// CutTime
					V1event,			// V1
//					(PreviousTrack==CRTN_TRANS) ? PreviousFG:NULL,	// FXFG (NULL for cut)
					NULL,
//					PreviousPos,			// FXpos
					-1,
					event))					// V2 (has no FG associated with it!)
				{
					return(FALSE);
				}
			}
		}
		if (error)
			ReportSequenceError(sv,V1FG,-1,error,FALSE);		// May/may not hilite a crouton

	}
	else if (V1event->Time > time)	// Video croutons out of order?
	{
		ReportSequenceError(sv,V1FG,V1event->CurrentPosition,SEQERR_OutOfOrder,FALSE);
		return(FALSE);		// Abort!
	}
	else if (endofprev > time)			// Need to trim previous event to fit?
	{
		overlap = endofprev - time;

		fixit = FALSE;

		if (V1FG)
		{
			ew_QuickSelect(sv->EditTop,V1event->CurrentPosition);			// Hilite offender
			ew_NavigateNodeNum(sv->EditTop,V1event->CurrentPosition);	// Navigates to it

//	Need these???
			sv->EditTop->ew_OptRender = FALSE;
			UpdateAllDisplay();
			CurFG=(struct FastGadget *)V1FG;			// Keep this current!

			MPtr[0] =           " This crouton overlaps the following locked video";
			sprintf(sv->scratch," by %d frames.  Select \"okay\" for me to fix this",overlap/2);
			MPtr[1] = sv->scratch;
//			MPtr[2] =           " or \"cancel\" to leave it alone";
			MPtr[2] =           " or \"cancel\" to abort";

			// Put up warning requester, check fix or not
			if (SeqRequest(sv,MPtr,3))
				fixit = TRUE;
			else
				return(FALSE);		// Abort!
		}

		V1event->Duration -= overlap;									// Fix this build
		if (fixit)
		{
			if (V1event->Duration > 0)
			{
				PutDuration(V1FG,V1event->Duration);					// Permanent fix
				PutAdjVideoDuration(V1FG,V1event->Duration);			// Permanent fix
			}
			else
			{
				// Fail to fix, fail to play!
				DisplayNormalSprite();
				ContinueRequest(sv->EditTop->Window,"Cannot trim clip enough to fix this overlap");
				return(FALSE);		// Abort!
			}
		}

		// Now check natural audio portion
		if ((V1FG) && (V1FG->ObjectType==CT_VIDEO) && (HasAudio(V1FG)))
		{
			endofprev = V1event->Time+V1event->AudStart-V1event->StartField+V1event->AudLength;
			overlap = endofprev - time;
			if (overlap > 0)
			{
				V1event->AudLength -= overlap;						// Fix this build
				if (fixit)
					PutAudioDuration(V1FG,V1event->AudLength);	// Permanent fix
			}
//	time - (V1event->Time + V1event->AudStart - V1event->StartField);
//
//	sv->TrimToFits++;										// Should we warn?

		}
	}

	return(TRUE);
}


//======================================================================
// CreateBlack -- Create black video still event
//======================================================================
static struct Event *CreateBlack(	struct SeqVars *sv,
												LONG	time,
												WORD	flychan)
{
	struct Event *event = NULL;

	if (FlyerBase)							// Have Flyer do black matte
	{
		// Get event for video SELECT
		if ((event = GetEvent(NULL))==NULL)
		{
			ReportSequenceError(sv,NULL,-1,SEQERR_OutOfMemory,FALSE);	// No crouton to hilite
			return(NULL);
		}

		//DUMPMSG("--- Creating Black ---");

		event->FG = NULL;								// No crouton!
		event->CurrentPosition = sv->Pos;		// Crouton near here to hilite
		event->FGCcommand = FGC_SELECT;
		event->Time = time;
		event->Duration = 0;							// Signify black matte
		event->StartField = 0;
		event->Channel = flychan;					// Channel to use
		event->Flags1 = FLAGS1F_SETCHAN;			// Flyer needs channels set
		event->Flags2 = FLAGS2F_MATTE;			// Seq created this

		SortIntoTrack(&sv->VideoTrack,event);		// Tack on end of Flyer video track
	}
	else
	{
		// Need to have toaster do black on non-Flyer systems!!!
	}

	sv->InsMattes++;			// Bump black insertion count

	return(event);
}


//======================================================================
// AppendBlack -- append black video to end of video event
//======================================================================
static UBYTE AppendBlack(	struct SeqVars *sv,
									LONG	time,
									WORD	flychan)
{
	struct Event	*event;

	event = CreateBlack(sv,time,flychan);
	if (event)
		return(SEQERR_Okay);
	else
		return(SYSERR_CantCreateBlack);
}


//======================================================================
// HandlePlay
//		Wrapper for DoSeqPlay() so that Shift will do play from any point
//======================================================================
struct EditWindow *HandlePlay(struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
//	struct EditWindow *RetEdit;
	struct ExtFastGadget *firstFG;
	struct SeqVars sv;

	//DUMPMSG("---HandlePlay---");

	StopLiveEditing(TRUE);			// If still editing to music/video, wrap it up!

	if (EditTop->Node.Type != EW_PROJECT)
	{
		//DUMPMSG("Improper view to play seq");
		return(Edit);
	}

	// Setup SeqVars structure
	memset(&sv, 0, sizeof(struct SeqVars));
//	sv.Edit = Edit;
	sv.EditTop = EditTop;

//	//DUMPHEXIL("Edit=",(LONG)Edit,"  ");
//	//DUMPHEXIL("EditTop=",(LONG)EditTop,"\\");

	sv.cut2music = sv.partial = FALSE;			// Assume (normal) play entire sequence

	/* If no CurFG hilited, skip all this logic, just act like PLAY */
	/* ARexx "Play project" doesn't provide an IntuiMsg, so it acts like PLAY too */
	if (IntuiMsg)
	{
		sv.waitplaystart = TRUE;		// Not from ARexx, so wait for ENTER on "ready" panel

		//DUMPHEXIL("Qual = ",IntuiMsg->Qualifier,"\\");

		// SHIFT indicates "play-from"
		if (IntuiMsg->Qualifier&(IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
			sv.partial = TRUE;

		// ALT indicates "edit-to-music" (ALT+SHIFT for edit-to-music-from)
		if (IntuiMsg->Qualifier&(IEQUALIFIER_LALT|IEQUALIFIER_RALT))
			sv.cut2music = TRUE;

		// If clicked on a button (as opposed to hot-keys), override SHIFT key status
		if ((IntuiMsg->Class == IDCMP_GADGETUP) || (IntuiMsg->Class == IDCMP_GADGETDOWN))
		{
			//DUMPMSG("(Button)");

			if (((struct Gadget *)IntuiMsg->IAddress)->GadgetID == ID_PLAY_PART)
				sv.partial = TRUE;
			else
				sv.partial = FALSE;
		}
	}

	if (CurFG==NULL)			// If no crouton is highlited, do a full play anyway
		sv.partial = FALSE;

	//DUMPUDECB("Partial = ",sv.partial," ");
	//DUMPUDECB("Cut2Music = ",sv.cut2music,"\\");

	// Is this really necessary? Just trims off part of sequence before stop/reset croutons
	// If not, is equivalent to *PtrProject -- (SeqStartFG might be NULL if none)
	SeqStartFG = StartingSequenceEvent((struct ExtFastGadget *)CurFG);

	if (sv.partial)
		firstFG = (struct ExtFastGadget *)CurFG;
	else
		firstFG = SeqStartFG;

	//DUMPMSG("HandlePlay ---------------------------");
	//DUMPHEXIL("CurFG=",(LONG)CurFG,"\\");
	//DUMPHEXIL("SeqStartFG=",(LONG)SeqStartFG,"\\");
	//DUMPHEXIL("FirstFG=",(LONG)firstFG,"\\");


	Edit->ew_OptRender = TRUE;    // ???

//	// Calculate times to clip our play within (SeqStartFG = time 0)
//	if (sv.partial)
//		sv.StartTime = TimeBetweenFGs(SeqStartFG, firstFG);
//	else
//		sv.StartTime = 0;
//	sv.EndTime = 0x7FFFFFFF;		// Don't clip end times
//
//	//DUMPUDECL ("starttime = ",sv.StartTime,"\\");
//	//DUMPUDECL ("endtime = ",sv.EndTime,"\\");
//


//	/*** Calculate total running time from start crouton to end ***/
//	sv.SeqTotalTime = TimeBetweenFGs(SeqStartFG,NULL);
//	sv.SeqPlayTime = sv.SeqTotalTime - sv.StartTime;

	/*** Setup and clear all tracks ***/
	PrepareTrack(&sv.SwitcherTrack,TRACK_SWITCHER);  //doing NewList, ect.
	PrepareTrack(&sv.VideoTrack,TRACK_FLYVID);
	PrepareTrack(&sv.AudioTrack,TRACK_AUDIO);

	if (sv.partial && sv.cut2music)			// Cutting to music? (1 clip version)
	{
		MusicBaseTime = TimeBetweenFGs(SeqStartFG, firstFG);

		//DUMPUDECL ("MusicBaseTime(1) = ",MusicBaseTime,"\\");

		EditToClip(&sv, firstFG);
	}
	else if (BuildSeq(&sv,SeqStartFG))		// Build entire project
	{
		// Calculate times to clip our play within (SeqStartFG = time 0)
		if (sv.partial)
			sv.StartTime = FindCroutonStartTime(&sv, firstFG);
		else
			sv.StartTime = 0;
		sv.EndTime = 0x7FFFFFFF;		// Don't clip end times

		//DUMPUDECL ("starttime = ",sv.StartTime,"\\");
		//DUMPUDECL ("endtime = ",sv.EndTime,"\\");

		/*** Calculate actual running time to end ***/
		sv.SeqPlayTime = sv.SeqTotalTime - sv.StartTime;

		SetRunningTime(sv.SeqPlayTime);				// Put total time up (of part to play)

		if (sv.partial)
			TrimToPlayWindow(&sv,firstFG);			// Play-from stripping

		if (!sv.cut2music)
		{
			if (DoWarnings(&sv))
				PlayCurSeq(&sv);

			DisplayMessage(NULL);			// Remove any message at top of screen
		}
		else
		{
			EditToAllAudio(&sv);
		}
	}

	//DUMPMSG("Before FreeMems");

	FreeTrack(&sv.SwitcherTrack);
	FreeTrack(&sv.VideoTrack);
	FreeTrack(&sv.AudioTrack);

	//DUMPMSG("After FreeMems");

	DisplayNormalSprite();

	return(Edit);
}


////*******************************************************************
//BOOL DriveType(char *name1)
//{
////	UBYTE *OurFlyerDrives;
//
//	return(TRUE);
//}


//=============================================================
//=============================================================
struct EditWindow *HandleRewind(	struct EditWindow *Edit,
											struct IntuiMessage *IntuiMsg)
{
	return(Edit);
}

//=============================================================
//=============================================================
struct EditWindow *HandleStop(	struct EditWindow *Edit,
											struct IntuiMessage *IntuiMsg)
{
	WORD	qual;

	//DUMPMSG("HandleStop()");

	if (IntuiMsg)
		qual = IntuiMsg->Qualifier;
	else
		qual = 0;

	if (FlyerBase
	&& (qual & IEQUALIFIER_CONTROL)
	&& (qual & IEQUALIFIER_LSHIFT)
	&& (qual & IEQUALIFIER_LALT))
		RebootFlyer();
	else if (FlyerBase && (qual & IEQUALIFIER_CONTROL))
		ResetFlyer(0,1);		// A more serious reset
	else
	{
		//DUMPMSG("Before HandleStop() sends ES_Stop");
		SendSwitcherReply(ES_Stop,NULL);	//clr bit 4 of TB_DisplayRenderMode
		//DUMPMSG("  After HandleStop() sent ES_Stop");

		StopLiveEditing(FALSE);			// Handle wrap-up after editing to music/video
	}

	return(Edit);
}


void StopLiveEditing(BOOL dostop)
{
	if (EditingLive)
	{
		if (dostop)
			SendSwitcherReply(ES_Stop,NULL);	//clr bit 4 of TB_DisplayRenderMode

		EditTo_FollowUp(EditTop);		// Patch things up (optional)

		EditingLive = FALSE;

		DisplayMessage(NULL);			// Refresh access window
	}
}



//=============================================================
// PrepareTrack
//		Prepare track structure
//=============================================================
static void PrepareTrack(	struct Track *track,
									UBYTE tracktype)
{
	//DUMPUDECB("Preparing track type ",tracktype,"\\");

	track->EventCount = 0;

	NewList(&track->EventList);		// Clear list
}


//=============================================================
// FreeTrack
//		Free all resources associated with the specified track
//=============================================================
static void FreeTrack(struct Track *track)
{
	struct Event	*event;

	while (event = (struct Event *)RemHead(&track->EventList))
	{
		FreeMem(event, sizeof(struct Event));
	}

	track->EventCount = 0;
}


#ifdef	SERDEBUG

//=============================================================
// ListTrack
//		//DUMP contents of track (debugging only)
//=============================================================
static void ListTrack(struct Track *track, UBYTE tracktype)
{
	struct Event	*event;

	//DUMPMSG("******************************************");
	switch (tracktype)
	{
	case TRACK_SWITCHER:
		//DUMPMSG("Switcher Track ==============================");
		break;
	case TRACK_FLYVID:
		//DUMPMSG("Video Track ==============================");
		break;
	case TRACK_AUDIO:
		//DUMPMSG("Audio Track ==============================");
		break;
	}

	for (event = (struct Event *)track->EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		if (event->FG)
			DUMPUDECB("#",(UBYTE)(event->CurrentPosition)," ");
		else if (FLAGS1F_WAIT4TIME & event->Flags1)
			DUMPSTR("Wait ");
		else
			DUMPUDECB("Black>>> [",event->Channel,"] ");
//			//DUMPSTR("Black>>> ");

		//DUMPUDECW("t=",event->Time," ");

		if (event->FG)
		{
			switch (event->FGCcommand)
			{
				case FGC_TAKE:		DUMPSTR("TAKE");	break;
				case FGC_SELECT:	DUMPSTR("SEL ");	break;
				case FGC_TOMAIN:	DUMPSTR("TOMN");	break;
				case FGC_AUTO:		DUMPSTR("AUTO");	break;
				case FGC_REMOVE:	DUMPSTR("REMV");	break;
				case FGC_REMOVEQ:	DUMPSTR("REMQ");	break;
				case FGC_TOPRVW:	DUMPSTR("PRVW");	break;
				default:				DUMPSTR("????");	break;
			}
			if (FLAGS1F_SETCHAN & event->Flags1)
				DUMPUDECB(" (",event->Channel,") ");
			else if (tracktype==TRACK_FLYVID)
				DUMPUDECB(" [",event->Channel,"] ");
			else
				DUMPSTR("       ");

//			DUMPUDECB("FGC=",event->FGCcommand," ");
			DUMPUDECW("Fld=",(UWORD)(event->StartField)," ");
			DUMPUDECW("Dur=",(UWORD)(event->Duration)," ");
			DUMPSTR(event->FG->FileName);

			//if (tracktype == TRACK_FLYVID)
			//{
				DUMPMSG(" ");
				DUMPUDECW("AFld=",(UWORD)(event->AudStart)," ");
				DUMPUDECW("ADur=",(UWORD)(event->AudLength)," ");
				DUMPUDECW("Atk=",event->AudAttack," ");
				DUMPUDECW("Dcy=",event->AudDecay," ");
			//}
		}

//		if (FLAGS1F_SETCHAN & event->Flags1)
//			DUMPUDECB(" Chan=",event->Channel," ");

		if (FLAGS2F_SKIP & event->Flags2)
			DUMPSTR("(SKIP!) ");

		DUMPMSG(" ");
	}
}
#endif


//=============================================================
// GetEvent
//		Allocate an event structure
//=============================================================
static struct Event * GetEvent(struct ExtFastGadget *FG)
{
	struct Event *event;

	DUMPMSG("GetEvent");

	event = SafeAllocMem(sizeof(struct Event),MEMF_CLEAR);		// Try to allocate

	if (event)
	{
//Don't have to skip yet, because I don't process "lost" croutons now (will I ever??)
//		if (FG && (FG->ObjectType == CT_ERROR))		// This is for a "lost crouton"?
//			event->Flags2 |= FLAGS2F_SKIP;	// If so, do not actually play this
	}
	else		// Failed
	{
		DUMPMSG("No mem for event!");
	}

	return(event);
}


//=============================================================
// SortIntoTrack
//		Sort new event into track, based on start times
//=============================================================
static void SortIntoTrack(struct Track *track, struct Event *newevent)
{
	struct Event	*event,*prev;

	DUMPMSG("SortIntoTrack");

	prev = NULL;

	for (event = (struct Event *)track->EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		if (newevent->Time < event->Time)
			break;

		prev = event;
	}

	// Insert new event just after 'prev' that was found
	Insert(&track->EventList, (struct Node *)newevent, (struct Node *)prev);

	track->EventCount++;
}


//=============================================================
// AppendToTrack
//		Tack event onto end of track
//=============================================================
static void AppendToTrack(struct Track *track, struct Event *newevent)
{
	DUMPMSG("AppendToTrack");

	AddTail(&track->EventList, (struct Node *)newevent);

	track->EventCount++;
}


//=============================================================
// AppendSelect
//		Tack SELECT event onto end of track, with possible
//		insertion before previous last event
//=============================================================
static BYTE AppendSelect(struct Track *track, struct Event *newevent)
{
	struct Event	*event;
	BYTE	setchan=-1;

	DUMPMSG("AppendSelect");

//	AddTail(&track->EventList, (struct Node *)newevent);
//
//	track->EventCount++;

	event = (struct Event *)RemTail(&track->EventList);
	if (event)
	{
		// Must only replace a TOMAIN on a Flyer event
		if ((event->FGCcommand == FGC_TOMAIN) && (FLAGS1F_SETCHAN & event->Flags1))
		{
			track->EventCount--;				// Killed previous event
			setchan = event->Channel;		// Get channel to take to
			FreeMem(event, sizeof(struct Event));
		}
		else
		{
			// Oops! Add back in
			AddTail(&track->EventList, (struct Node *)event);
		}
	}

//	if (setchan >= 0)
//	{
//		newevent->Channel = setchan;
//		newevent->Flags1 |= FLAGS1F_SETCHAN;
//	}

	AppendToTrack(track,newevent);

	return(setchan);
}


//=============================================================
// InsertSelect
//		Insert  a SELECT event before the last event, if possible
//		The last event must qualify for this type of action
//=============================================================
static void InsertSelect(struct Track *track, struct Event *newevent)
{
	struct Event	*event;

	DUMPMSG("InsertSelect");

	event = (struct Event *)RemTail(&track->EventList);	// Remove specimen
	if (event)
	{
		// Must only insert before a TOMAIN on a Flyer event
		if ((event->FGCcommand == FGC_TOMAIN) && (FLAGS1F_SETCHAN & event->Flags1))
		{
			// Okay, it's removed (temporily only, as the event count is wrong)
		}
		else
		{
			// Oops! Add back in
			AddTail(&track->EventList, (struct Node *)event);
			event = NULL;						// (Don't add back in again later)
		}
	}

	AppendToTrack(track,newevent);		// Tack on our new one

	if (event)
		AddTail(&track->EventList, (struct Node *)event);	// Add prev tail back in, if removed
}


//=============================================================
// DoAudioCrouton
//		Process audio crouton into audio track
//=============================================================
static struct Event * DoAudioCrouton(	struct SeqVars *sv,
													struct ExtFastGadget *fg,
													LONG	gotime,
													WORD	croutonpos)
{
	struct Event *event;
	LONG	astartfld, audlength;

	DUMPMSG("DoAudioCrouton");

	event = NULL;

	astartfld = GetAudioStart(fg);
	audlength = GetAudioDuration(fg);

	// Any audio that we should play?
	if (audlength > 0)
	{
// Don't do this test. This lets them replace a clip.  If new one is too short, Flyer will
// complain on download and then we can put up an error
//		if(!(ci=DHD_ClipInfo((char *)fg->FileName)) || (ci->Fields != GetValue((struct FastGadget *)fg,TAG(RecFields))))
//		{
//			error = SEQERR_FlyerClipMissing;				// File not found!
//			break;
//		}

		event = GetEvent(fg);
		if (event)							// Allocation succeeded?
		{
			event->FG = fg;
			event->Time = gotime;		// When to roll
			event->StartField	= event->AudStart		= astartfld;		// First field to hear
			event->Duration	= event->AudLength	= audlength;		// Duration
			event->FGCcommand = FGC_SELECT;
			event->CurrentPosition = croutonpos;
			event->TimeTolerance = 0;					// Do it perfect!

			SortIntoTrack(&sv->AudioTrack,event);	// Sort by time into track
		}
		else
		{
		
			DUMPMSG("Out of space in audio track!");
			fg = fg;
		}
	}

	return(event);
}


//=============================================================
// DownLoadFlyer
//		Download Flyer track to Flyer sequencer
//		Also skips/trims events to desired play window
//=============================================================
static ULONG DownLoadFlyerTrack(	struct SeqVars *sv,
											struct Track *track,
											UBYTE tracktype,
											BOOL abortable)
{
	struct FlyerVolume volume;
	struct ClipAction	 action;
	struct Event	*event;
	struct ExtFastGadget *fg;
	ULONG	audiobits,err,userID;
	LONG	gotime,trim,len;
	BOOL	first;

	err = FERR_OKAY;

	first = TRUE;

	userID = (tracktype==TRACK_AUDIO)?0x8000:0;

	for (event = (struct Event *)track->EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		userID++;

		if (abortable)
		{
			if (CheckNoticeCancel())		// If CANCEL button pressed...
				return(FERR_ABORTED);
		}

		if (FLAGS2F_SKIP & event->Flags2)	// Skip a "lost crouton"?
			continue;

		fg = event->FG;
		if (fg)
		{
			// Note channel of first video event (used for playback preparation)
			if (first)
			{
				// Remember Flyer channel of first clip downloaded
				// Don't do this for partial (play-from), as logic
				// that trims Switcher list will figure this better
				if ((tracktype == TRACK_FLYVID) && (!sv->partial))
					sv->firstflychan = event->Channel;
				first = FALSE;
			}

			volume.Board = 0;
			volume.Flags = 0;			// Not FVF_USENUMS, since we don't know drive numbers !
			volume.SCSIdrive = 0;	// We let Flyer worry about silly things like drive #'s
			volume.Path = fg->FileName;		// Name of Flyer file

			// Clear all fields of this structure
			memset(&action, 0, sizeof(struct ClipAction));

			action.UserID = userID;			// Shows us who failed for sequencing errors
			action.GoClock = event->Time;			// Time to start
			action.Channel = event->Channel;		// Video channel (NC for audio at this time)

//			action.PermissFlags = /* CAPF_STEALOURVIDEO | */ CAPF_KILLOTHERVIDEO | CAPF_USEHEADS;

			action.Flags = 0;							// Default flags

			if (tracktype == TRACK_FLYVID)
			{
				action.Flags |= CAF_VIDEO;
//				action.Flags |= CAF_USEMATTE;
			}

			audiobits = GetAudioOn(fg);

			// Left audio active?
			if ((AUDF_Channel1Recorded & audiobits)
			&&  (AUDF_Channel1Enabled & audiobits)) 
			{
				action.Flags |= CAF_AUDIOL;
				action.VolSust1 = GetAudioVolume1(fg);
				action.AudioPan1 = GetAudioPan1(fg);
			}

			// Right audio active?
			if ((AUDF_Channel2Recorded & audiobits)
			&&  (AUDF_Channel2Enabled & audiobits)) 
			{
				action.Flags |= CAF_AUDIOR;
				action.VolSust2 = GetAudioVolume2(fg);
				action.AudioPan2 = GetAudioPan2(fg);
			}

			// Use audio envelope?
			if (AUDF_AudEnvEnabled & audiobits)
				action.Flags |= CAF_AUDENV;
         else
				action.Flags &= ~CAF_AUDENV;
             
   

			if (fg->ObjectType == CT_STILL)
			{
				action.VidStartField = 0;
				action.VidFieldCount = 4;
			}
			else
			{
				action.VidStartField = event->StartField;
				action.VidFieldCount = event->Duration;
			}
			action.AudStartField = event->AudStart;
			action.AudFieldCount = event->AudLength;

//			action.VolAttack = GetAudioAttack(fg);
//			action.VolDecay  = GetAudioDecay(fg);

			action.VolAttack = event->AudAttack;
			action.VolDecay  = event->AudDecay;

//~~~~~~~~~~~~~~~~~~ Trim to Play Window ~~~~~~~~~~~~~~~~~~~~~

			/**********************/
			/*** Audio Trimming ***/
			/**********************/
			if ((CAF_AUDIOL | CAF_AUDIOR) & action.Flags)
			{
				gotime = action.GoClock;

				// If video w/natural audio, get gotime of audio portion
				if (tracktype == TRACK_FLYVID)
					gotime += action.AudStartField-action.VidStartField;

				if ((gotime+action.AudFieldCount) <= sv->StartTime)		// Trim off all?
				{
					action.Flags &= ~(CAF_AUDIOL | CAF_AUDIOR);				// (no audio)
				}
				else if (gotime < sv->StartTime)									// Trim some?
				{
					trim = sv->StartTime - gotime;							// Amount to trim off

					action.AudStartField += trim;								// crop audio to starttime

					len = action.AudFieldCount;
					len -= trim;													// Shorten duration

					if (len <= 0)													// Trimmed away everything?
						action.Flags &= ~(CAF_AUDIOL | CAF_AUDIOR);		// (no audio)
					else
					{
						action.AudFieldCount = len;							// Save shortened

						if (tracktype == TRACK_AUDIO)
							action.GoClock = sv->StartTime;		// Audio: Start immediately
																			// Video: don't adjust start time

						// Adjust attack ramp for trimmed audio
						if (trim < action.VolAttack)				// Do partial ramp?
						{
#ifdef FLYER_PARTIAL_ATTACKS
							// We need audio envelope key frames for this to work!!!

							// Start volumes part way up ramp so we end at correct time
							action.VolStart1 = (action.VolSust1 * trim) / action.VolAttack;
							action.VolStart2 = (action.VolSust2 * trim) / action.VolAttack;
#endif

							action.VolAttack -= trim;			// Shorten ramp to end at correct time
						}
						else
						{
							action.VolAttack = 0;		// Trimmed all of ramp away
						}

						// Adjust VolDecay for trimmed audio
						if (len < action.VolDecay)				// Need to adjust decay ramp?
						{
							// Start volumes part way down ramp so we end at correct time
							action.VolSust1 = (action.VolSust1 * len) / action.VolDecay;
							action.VolSust2 = (action.VolSust2 * len) / action.VolDecay;
							action.VolDecay = len;
						}
					}
				}
			}


			/**********************/
			/*** Video Trimming ***/
			/**********************/
			if (CAF_VIDEO & action.Flags)
			{
				gotime = action.GoClock;

				if ((gotime+action.VidFieldCount) <= sv->StartTime)		// Trim off all?
				{
					action.Flags &= ~CAF_VIDEO;									// (no video)

					// In case natural audio does not get trimmed out, bump goclock to
					// be correct for audio-only handling (start time for audio)
					action.GoClock += (action.AudStartField - action.VidStartField);
				}
				else if (gotime < sv->StartTime)									// Trim some?
				{
					trim = sv->StartTime - gotime;								// Amount to trim off

					action.VidStartField += trim;								// crop video to starttime

					len = action.VidFieldCount;
					len -= trim;													// Shorten duration

					if (len <= 0)													// Trimmed away everything
						action.Flags &= ~CAF_VIDEO;							// (no video)
					else
					{
						action.VidFieldCount = len;							// Save shortened

						action.GoClock = sv->StartTime;						// Start immediately
					}
				}
			}


			// Now adjust start time for partial plays
			action.GoClock -= sv->StartTime;
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

			// I will probably not use these anymore, but just in case
			action.TotalAudStart  = action.AudStartField;
			action.TotalAudLength = action.AudFieldCount;

			action.Volume = &volume;			// Link together
			action.ReturnTime = RT_STOPPED;
 
			// If still has audio and/or video, download it.  Otherwise, skip it
			if ((CAF_VIDEO | CAF_AUDIOL | CAF_AUDIOR) & action.Flags)
			{
				err = AddSeqClip(&action);
				DUMPUDECL("audiobits ",audiobits," \\");
				
   			//? what about the audio on env bit?
				if ((event->AE.Flags & 1) && (audiobits&AUDF_AudEnvEnabled))  //replace the 1 with the flag value when it get codedDEH!
				{
					err = SendEnvs2Clip(&(event->AE),event);
					DUMPUDECL("SendEnvs2Clip error ",err," \\");//DEH Need to send the audio envelope here!
				}
			}
			else
				err = FERR_OKAY;
		}
		else		// No FG, so must be black still
		{
			volume.Board = 0;
			volume.Flags = 0;
			volume.SCSIdrive = 0;
			volume.Path = NULL;		// No clip, just black

			// Clear all fields of this structure
			memset(&action, 0, sizeof(struct ClipAction));

			action.GoClock = event->Time;			// Time to start

			action.Channel = event->Channel;		// Video channel (NC for audio at this time)

			action.Flags = 0;							// Default flags

			if (tracktype == TRACK_FLYVID)
				action.Flags |= CAF_VIDEO;

			action.VidStartField = event->StartField;
			action.VidFieldCount = event->Duration;

			action.Volume = &volume;			// Link together
			action.ReturnTime = RT_STOPPED;

			// If in trim window, go ahead and download it
			if (action.GoClock >= sv->StartTime)
			{
				action.GoClock -= sv->StartTime;		// Adjust start time for partial plays
				err = AddSeqClip(&action);
				//DEH Dont Need to send the Audio envelope here this is just black filler.
			}
			else
				err = FERR_OKAY;
		}

		if (err != FERR_OKAY)
		{
			DUMPUDECL("AddSeq error ",err," ");
			DUMPUDECL("on event ",event->CurrentPosition,"\\");
			sv->FailFG = fg;		// Might be of interest to caller (where we failed)
			break;
		}
	}

	return(err);
}


//============================================================
// Send Audio envelope keys to flyer. 
//  	calls flyer.library/AddAudEKey(AUDEKEY)
//============================================================
SendEnvs2Clip(struct AudioEnv *aude,struct Event *EnvEvent)
{
	int err;

	UWORD i;
	LONG	TOffset;
	struct AEKey      *Akey;
   struct AudioEnv   *AudEnv;



		
	if (AudEnv = AllocMem(sizeof(struct AudioEnv),MEMF_PUBLIC|MEMF_CLEAR))
	{

		
		memcpy(AudEnv,aude,sizeof(struct AudioEnv));

		TOffset = EnvEvent->Time - AudEnv->AEKeys[0].GoTime;		


		// Adjust for start time 
		for(i=0;(i<AudEnv->Keysused);i++)
		{

			DUMPUDECW("\\Key #          = ",i,"\\");
			DUMPUDECW("Current pos    = ",EnvEvent->CurrentPosition,"\\");
			DUMPUDECL("aude.GoTimeA   = ",AudEnv->AEKeys[i].GoTime,"\\");
			AudEnv->AEKeys[i].GoTime += TOffset;
			DUMPUDECL("aude.GoTimeB   = ",AudEnv->AEKeys[i].GoTime,"\\");
			DUMPUDECL("aude.NumOfFlds = ",AudEnv->AEKeys[i].NumOfFlds,"\\");
			DUMPUDECL("Time           = ",EnvEvent->Time,"\\");
			DUMPUDECL("AudStart       = ",EnvEvent->AudStart,"\\");
			DUMPUDECL("AudLength      = ",EnvEvent->AudLength,"\\");
			DUMPUDECL("StartField     = ",EnvEvent->StartField,"\\");
			DUMPUDECL("Duration       = ",EnvEvent->Duration,"\\");
			DUMPUDECL("Extra          = ",EnvEvent->extra,"\\");
			AudEnv->AEKeys[i].GoTime += EnvEvent->extra;
			DUMPUDECL("aude.GoTimeC   = ",AudEnv->AEKeys[i].GoTime,"\\ \\");


		}

		err=AddAudEnv(0,AudEnv);

		FreeMem(AudEnv,sizeof(struct AudioEnv));	

	}

	return(err);
}


//	DUMPUDECW("Keys used ",aude->Keysused,"\\");
//	DUMPUDECW("AEI->AEKeys[1].VOL1",aude->AEKeys[1].VOL1,"\\");
//	DUMPUDECW("AEI->AEKeys[2].VOL1",aude->AEKeys[2].VOL1,"\\");
//	if(aude->Keysused>0)
//		for(i=1;(i<=aude->Keysused);i++)
//		{
//			err = AddAudEKey(&(aude->AEKeys[i]));
//			if (err) break;
//   	}




//=============================================================
// FindFlyerEventFromID
//		De-reference a Flyer event from the "UserID" sent to
//		the Flyer during download
//=============================================================
static struct Event *FindFlyerEventFromID(struct SeqVars *sv, ULONG userID)
{
	struct Event	*event;
	struct Track	*track;
	ULONG	ID;


	track = &sv->VideoTrack;
	ID = 0;

	for (event = (struct Event *)track->EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		ID++;

		if (ID == userID)
			return(event);
	}

	track = &sv->AudioTrack;
	ID = 0x8000;

	for (event = (struct Event *)track->EventList.lh_Head
	; event->Node.mln_Succ
	; event = (struct Event *)event->Node.mln_Succ)
	{
		ID++;

		if (ID == userID)
			return(event);
	}

	return(NULL);
}


//*********** Error Help Subroutines **************//

static BOOL DetectSwitcherCollision(struct SeqVars *sv, LONG time)
{
	if ((sv->SwitcherBusyTil) && (time <= sv->SwitcherBusyTil))
		return(TRUE);
	else
		return(FALSE);
}

static UWORD	FXunderErrors(struct	Event	*event)
{
	ULONG obj=0;

	if ((event) && (event->FG))			// Pointers could be NULL, ya never know
		obj = event->FG->ObjectType;

	if (obj == CT_KEY)
		return(SEQERR_KeyOverEffect);
	if ((obj == CT_SCROLL) || (obj == CT_CRAWL))
		return(SEQERR_ScrawlOverEffect);
	else
		return(SEQERR_OlayOverEffect);
}

static UWORD	SwitCollisionErrors(struct	Event	*event, struct ExtFastGadget *FG2)
{
	struct	ExtFastGadget	*fg1 = NULL;

	if (event)
		fg1 = event->FG;								// Pointers could be NULL, ya never know

	if (IsSuperVideo(fg1))							// First event is a superimposed type?
	{
		if (IsVideoSource(FG2))						// 2nd event is framestore, main, etc.?
			return(SEQERR_OverlaysOverNonFlyer);
	}

	return(SEQERR_SwitcherCollision);		// General switcher collision error
}


//*********** Sequence Building Helper Subroutines **************//


//=============================================================
// HandleAudioUnder
//		Auto-make split audio and match frame on 2nd crouton
//=============================================================
void HandleAudioUnder(struct EditWindow *Edit)
{
	struct ExtFastGadget *fg,*fg1,*fg2;
	int	state,inserts,insertsbrkt;
	LONG	adur,match,temp,instime,instimebrkt;
	char	*msg;


	DUMPMSG("AudioInsert");

	fg1 = fg2 = NULL;
	state = 0;
	instime = instimebrkt = 0;
	inserts = insertsbrkt = 0;

	for (fg=*PtrProject ; fg && (state<3) ; fg = GetNextGadget(fg))
	{
		switch (state)
		{
			case 0:		// Look for (first) highlighted Flyer clip
				if (((struct FastGadget *)fg)->FGDiff.FGNode.Status == EN_SELECTED)
				{
					if (fg->ObjectType != CT_VIDEO)		// Only works on Flyer clips
						state = 9;								// If wrong type, stop! Do nil
					else
					{
						fg1 = fg;								// Have our starting crouton
						state++;									// Now count insert time
					}
				}
				break;
			case 1:		// Measure all inserts, watch for match crouton
				// Is this our end crouton?
				if((fg->ObjectType == CT_VIDEO)
				&& (stricmp(fg1->FileName, fg->FileName)==0))
				{
					fg2 = fg;		// Grab this FG for later

					// Make secondary copies to scan with
					insertsbrkt = inserts+1;						// Include this crouton
					instimebrkt = instime+GetDuration(fg);		// Include this crouton
					state++;			// Scan for 2nd hilite (optional)
				}
				else if (IsVideoSource(fg))
				{
					instime += GetDuration(fg);		// Add to insert total time
					inserts++;
				}
				break;
			case 2:		// Look for possible 2nd hilite
				if (((struct FastGadget *)fg)->FGDiff.FGNode.Status == EN_SELECTED)
				{
					// Is this a matching crouton?
					if((fg->ObjectType == CT_VIDEO)
					&& (stricmp(fg1->FileName, fg->FileName)==0))
					{
						fg2 = fg;		// Grab *THIS* FG for end crouton
						instime = instimebrkt;	// Use optional data we've been collecting
						inserts = insertsbrkt;
					}
// Let's go ahead and allow default to work, in case careless highlites exist downstream
//					else
//						fg2 = NULL;			// Highlight wrong, don't use default one either

					state++;			// Do it! (or not)
				}
				else if (IsVideoSource(fg))
				{
					instimebrkt += GetDuration(fg);		// Add to insert total time (optional)
					insertsbrkt++;
				}
		}
	}

	if (state==9)		// Found a highlite, but wrong type
		msg = "Error -- Only works on Flyer clips";
	if (fg1==NULL)
		msg = "Error -- No croutons highlighted";
	else if (fg2==NULL)
		msg = "Error -- Matching crouton not found";
	else if (inserts==0)
		msg = "Error -- No inserts found";
	else
	{
		// Calculate fg1's new audio duration
		adur = GetStartField(fg1)+GetDuration(fg1)+instime-GetAudioStart(fg1);

		// Calculate fg2's match field #
		match = GetAudioStart(fg1)+adur;

		if (match >= GetRecFields(fg2))		// Can't reach match crouton?
			msg = "Error -- Clip too short to perform operation";
		else
		{
			PutAudioDuration(fg1,adur);		// Stretch out fg1's audio under insert(s)

			PutAudioDecay(fg1,0);				// (seamless)
			PutAudioAttack(fg2,0);

     			// Adjust A/V durations to leave out-points untouched
			// Match could go beyond original outpoint, ensure we don't go negative!
			temp = GetStartField(fg2)+GetDuration(fg2)-match;
			PutDuration(fg2,(temp>0)?temp:4);

			temp = GetAudioStart(fg2)+GetAudioDuration(fg2)-match;
			PutAudioDuration(fg2,(temp>0)?temp:4);

			// Now set in-points to seam up audio perfectly
			PutStartField(fg2,match);			// Match frame fg2 (Audio & Video)
			PutAudioStart(fg2,match);

			CalcRunningTime();		// Re-calculate sequence total time & put up in access window

			sprintf(pstr,"Auto Insert performed -- %ld clip(s) inserted into %ls",inserts,fg1->FileName);
			msg = pstr;
		}
	}

	ContinueRequest(Edit->Window,msg);		// Show what happened
}


#if 0
// This is only needed if 'total' is 9 minutes +
ULONG Frac32toFields(ULONG total, ULONG frac32)
{
	ULONG	res;
	int	pre,post;

	for (pre=16,post=15,res=total;  post>=0;  pre++,post--,res>>=1)
	{
		if (res < 32768)
			break;
	}

	res = ((frac32>>pre) * total) >> post;

	res = (res+1)/2;		// Round up/down

	return(res);
}
#endif

// end of sequence.c
@


2.135
log
@Fixed EditTo_FollowUp problem that was turning
framestores and still into framestorestills.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.134 1996/11/18 18:42:43 Holt Exp Holt $
d5 4
@


2.134
log
@added more support for envelope key downloading.
may have broken edit to music. seems to trash tags or somthing.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.133 1996/07/19 14:54:15 Holt Exp Holt $
d5 4
d3928 1
a3928 1
								// Okay, let's fix the previous video's outpoint to match (trim/extend)
d3934 1
a3934 1
									if ((fg->ObjectType = CT_STILL) && (fg->ObjectType = CT_FRAMESTORE))
d3937 1
d3939 3
a3941 1

d3945 3
a3947 1
									if (maxdur == 0) maxdur=999000; //? is this close to inf.
a3968 1
										// This next term accounts for difference in A/V start times
d3971 1
@


2.133
log
@finished up cfx.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.132 1996/07/15 18:30:11 Holt Exp Holt $
d5 3
d496 1
a496 1
#define SERDEBUG	1
d935 2
a936 2
			DUMPUDECL("reftime = ",reftime,"");
			DUMPUDECL("  delay = ",delay,"\\");
d1081 1
a1081 1
	DUMPUDECL ("~~~~~~~~ ERROR ",error," ~~~~~~~~\\");
d1156 4
a1159 4
	DUMPMSG("---------------------------");
	DUMPSTR(FG->FileName);
	DUMPMSG(" ");
	DUMPHEXIL("AudioOnBits=",(LONG)AudioOnBits,"\\");
d1164 3
a1166 3
	DUMPUDECL("Volume1=",(LONG)GetAudioVolume1(FG),"\\");
	DUMPUDECL("Volume2=",(LONG)GetAudioVolume2(FG),"\\");
	DUMPMSG("---------------------------");
d1376 1
a1376 1
		DUMPHEXIL("---------- Type ",objtype," ---------\\");
d1381 1
a1381 1
			DUMPHEXIL("*** Actual type is ",objtype," ***\\");
d1384 1
a1384 1
		DUMPUDECL("   TimeMode ",timemode,"\\");
d1446 1
a1446 1
				DUMPMSG	("***************** CONTROL *****************\n");
d1459 1
a1459 1
			DUMPUDECL("*** Final Time ",start,"\\");
d1537 1
a1537 1
				DUMPMSG	("-----------------  Control -----------------\n");
d1550 4
a1553 4
		DUMPUDECL("   Start ",start,"   ");
		DUMPUDECL("   Duration ",duration,"\\");
		DUMPUDECL("   VidTime ",vidtime,"   ");
		DUMPUDECL("   MaxTime ",maxtime,"\\");
d1557 1
a1557 1
	DUMPUDECL("*** Final MaxTime ",maxtime,"\\");
d1610 1
a1610 1
	DUMPUDECL ("Looking thru track ",trktype," for FG start time\\");
d1634 2
a1635 2
	DUMPUDECL ("cliptime = ",time,"\\");
	DUMPSDECL ("adj = ",adj,"\\");
d1643 1
a1643 1
	DUMPUDECL ("cliptime = ",time,"\\");
d1805 1
a1805 1
	DUMPMSG	("-------------- DoSeqPlay ----------------");
d1841 2
a1842 2
		DUMPMSG("--------------------------------------");
		DUMPUDECL("Crouton #",sv->Pos," = ");
d1854 1
a1854 1
//			DUMPHEXIL("*** Actual type is ",FGtype," ***\\");
d1862 1
a1862 1
			DUMPMSG("ChromaFX CROUTON");
d1864 1
a1864 1
			DUMPUDECL("**CRFX Durr: ",GetDuration(FG)," \\");
d1908 1
a1908 1
				DUMPUDECL("**CRFX: at ",gotime," \\");
d1989 1
a1989 1
//			DUMPUDECL("**CRFX Take: at ",event->Time," \\");
d2005 1
a2005 1
			DUMPUDECL("**CRFX Durr: ",GetDuration(FG)," \\");
d2011 1
a2011 1
			DUMPUDECL("**CRFX Remove: at ",event->Time," \\");
d2027 1
a2027 1
			DUMPMSG("ARexx CROUTON");
d2075 1
a2075 1
			DUMPMSG("AUDIO CROUTON");
d2099 1
a2099 1
					DUMPMSG("ADD IN EXTRA");
d2118 1
a2118 1
				DUMPUDECL("AudioStart = ",gotime,"\\");
d2168 1
a2168 1
			DUMPMSG("SCROLL/CRAWL CROUTON");
d2198 2
a2199 2
			DUMPUDECL("RefTime = ",reftime," ");
			DUMPUDECL("GoTime = ",gotime," \\");
d2249 1
a2249 1
			DUMPUDECL("Scroll/Crawl duration = ",event->Duration," ");
d2286 1
a2286 1
			DUMPMSG("KEY CROUTON or CRFX");
d2317 2
a2318 2
			DUMPUDECL("RefTime = ",reftime," ");
			DUMPUDECL("GoTime = ",gotime," \\");
d2381 1
a2381 1
			DUMPUDECL("**Key ToMain: at ",event->Time," \\");
d2402 1
a2402 1
			DUMPUDECL("**Key Remove: at ",event->Time," \\");
d2425 1
a2425 1
				DUMPMSG("FX TRANSITION CROUTON");
d2463 1
a2463 1
				DUMPMSG("EFFECT/OVERLAY CROUTON");
d2493 2
a2494 2
				DUMPUDECL("RefTime = ",reftime," ");
				DUMPUDECL("GoTime = ",gotime," \\");
d2585 1
a2585 1
				DUMPUDECL("**Olay ToMain: at ",event->Time," \\");
d2600 2
a2601 2
			DUMPSTR("VIDEO OR FLYERSTILL CROUTON  ");
			DUMPMSG((char *)FG->FileName);
d2656 1
a2656 1
				DUMPMSG("Cut under scroll/crawl!");
d2667 1
a2667 1
			DUMPUDECL("Assigned to channel ",sv->FlyChan,"\\");
d2675 1
a2675 1
//				DUMPUDECL	("Assume InPoint=",event->StartField,"\\");
d2716 1
a2716 1
			DUMPMSG("FRAMESTORE/VIDEOANIM/MAIN/IMAGE CROUTON");
d2760 2
a2761 2
//				DUMPUDECL("Prev Key End: ",KeyKill->Time,"  ");
//				DUMPUDECL("ProgTime: ",ProgTime,"  ");
d2842 2
a2843 2
			DUMPUDECL	("VIDEO time=",CurVidEvent->Time,"\\");
			DUMPUDECL	("Assume duration=",GetAdjVideoDuration(FG),"\\");
d2863 1
a2863 1
			DUMPMSG("Control CROUTON");
d2907 1
a2907 1
			DUMPMSG	("*** LOST ***");
d2936 1
a2936 1
			DUMPMSG("Unrecognized Crouton Type!");
d3036 1
a3036 1
			DUMPMSG("Cut under key/overlay!");
d3098 1
a3098 1
	DUMPMSG("******************************************");
d3208 1
a3208 1
		DUMPUDECB("NewSeq err = ",sv->AuxError,"\\");
d3215 1
a3215 1
			DUMPMSG("Downloading video track...");
d3219 1
a3219 1
				DUMPMSG("Downloading audio track...");
d3229 1
a3229 1
				DUMPSTR("Flyer is processing sequence...");
d3231 1
a3231 1
				DUMPUDECL ("(start=",sv->AuxError,") ");
d3234 1
a3234 1
					DUMPSTR("Waiting...");
d3239 1
a3239 1
							DUMPSTR("Aborting...");
d3241 1
a3241 1
							DUMPMSG("Aborted");
d3248 1
a3248 1
				DUMPUDECB("done (",sv->AuxError,")\\");
d3365 1
a3365 1
		DUMPUDECL ("Punched up first clip on ",sv->firstflychan,"\\");
d3370 1
a3370 1
		DUMPUDECL ("Punched up opposite of ",sv->firstflychan,"\\");
d3397 1
a3397 1
		DUMPMSG("*** Before ES_StartSeq1 ***");
d3400 1
a3400 1
		DUMPMSG("*** ReadySeq ***");
d3403 1
a3403 1
		DUMPMSG("*** Before ES_Stop1 ***");
d3409 1
a3409 1
		DUMPMSG	("No pre-SELECT's required");
d3423 2
a3424 2
//	DUMPMSG	("Play Sequence ...............");
//	DUMPMEM("Sequence=",(UBYTE *)Sequence,VidTrack.TrackMemSize);
d3430 1
a3430 1
//	DUMPMSG("Before ES_StartSeq2");
d3436 1
a3436 1
	DUMPMSG(">>>>>>>>>>>>>>>>>>>> Done <<<<<<<<<<<<<<<<<<<<<");
d3438 1
a3438 1
//	DUMPMSG("Before ES_Stop");
d3448 1
a3448 1
//	DUMPHEXIL("&SeqInfo=",(LONG)(&SeqInfo),"\\");
d3453 3
a3455 3
		DUMPHEXIL("ErrorEvent=",(LONG)(SeqInfo.ErrorEvent),"\\");
		DUMPHEXIL("FG=",(LONG)(SeqInfo.ErrorEvent->FG),"\\");
		DUMPHEXIL("ErrorMsg=",(LONG)(SeqInfo.ErrorMsg),"\\");
d3541 1
a3541 1
			DUMPMSG("Downloading audio track...");
d3547 1
a3547 1
				DUMPSTR("Flyer is processing sequence...");
d3549 1
a3549 1
				DUMPUDECB("done (",sv->AuxError,")\\");
d3610 1
a3610 1
	DUMPUDECL ("MusicBaseTime(FULL) = ",MusicBaseTime,"\\");
d3622 1
a3622 1
	DUMPMSG("11111111  Cut2Music  111111111");
d3656 1
a3656 1
		DUMPUDECL ("MasterVidTime = ",MasterVideoTime,"\\");
d3688 1
a3688 1
	DUMPMSG("LockDown");
d3694 1
a3694 1
//		DUMPHEXIL("FirstHilite=",(LONG)curfg,"\\");
d3701 2
a3702 2
			DUMPUDECL("MusicBaseTime = ",MusicBaseTime," ");
			DUMPUDECL("CurProgTime = ",GetCurProgTime()," ");
d3704 1
a3704 1
			DUMPUDECL("(time ",time,")\\");
d3711 1
a3711 1
					DUMPMSG("Rel!");
d3721 1
a3721 1
					DUMPMSG("Locked!");
d3736 1
a3736 1
				DUMPMSG("Locked!");
d3790 1
a3790 1
//							DUMPUDECL("(locked at ",time,")\\");
d3808 1
a3808 1
							DUMPMSG("Locked!");
d3810 1
a3810 1
							DUMPUDECL("(locked at ",time,")\\");
d3819 1
a3819 1
							DUMPMSG("Unlocked!");
d3859 1
a3859 1
	DUMPMSG("Fixing put seq?");
d3867 1
a3867 1
		DUMPHEXIL("fg=",(LONG)fg,"\\");
d3927 1
a3927 1
									DUMPUDECL("Fixing video from ",dur,"");
d3941 3
a3943 3
									DUMPUDECL(" GetRecFields ",GetRecFields(lastvid),"\\");
									DUMPUDECL(" GetStartField ",GetStartField(lastvid),"\\");
									DUMPUDECL(" Taking max dur into account ",maxdur,"\\");
d3949 1
a3949 1
									DUMPUDECL(" to ",dur,"\\");
d3967 1
a3967 1
										DUMPUDECL("Fixing audio from ",dur,"");
d3970 1
a3970 1
										DUMPUDECL(" to ",dur,"\\");
d4014 1
a4014 1
//		DUMPHEXIL("FG=",(LONG)FG,"\\");
d4042 1
a4042 1
	DUMPMSG("Trimming sequence...");
d4049 3
a4051 3
//		DUMPUDECL("t1=",event->Time," ");
//		DUMPUDECL("t2=",sv->StartTime," ");
//		DUMPUDECL("fl=",event->Flags2,"\\");
d4059 1
a4059 1
			DUMPMSG("Trimmed black");
d4070 1
a4070 1
	DUMPMSG("re-walk...");
d4091 3
a4093 3
		DUMPUDECL("t1=",event->Time," ");
		DUMPUDECL("t2=",sv->StartTime," ");
		DUMPUDECL("fl=",event->Flags2,"\\");
d4199 1
a4199 1
								DUMPMSG("Inserting a cut for trimmed-out FX");
d4238 1
a4238 1
					DUMPUDECL("++++++++FFC = ",event->Channel,"++++++++\\");
d4261 1
a4261 1
	DUMPMSG("******** TRIMMED SWITCHER LIST ***************");
d4265 1
a4265 1
	DUMPMSG("******************************************");
d4323 1
a4323 1
					DUMPUDECL("Hiliting ",event->CurrentPosition,"\\");
d4478 1
a4478 1
		DUMPSDECL("FX len=",fxlen,"\\");
d4488 2
a4489 2
			DUMPHEXIL("Alen=",alen," ");
			DUMPHEXIL("Blen=",blen,"\\");
d4494 2
a4495 2
			DUMPHEXIL("Aflds=",alen," ");
			DUMPHEXIL("Bflds=",blen,"\\");
d4499 1
a4499 1
				DUMPMSG("(overlap)");
d4509 1
a4509 1
				DUMPSDECL("Take@@ ",takefld,"\\");
d4524 1
a4524 1
				DUMPMSG("(non-overlap)");
d4546 1
a4546 1
		DUMPSDECL("Auto Effect at ",event->Time,"\\");
d4607 3
a4609 3
				DUMPUDECL("Here's why: EndOfPrevFX=",EndOfPrevEffect," ");
				DUMPUDECL("Fudge=",fudge," ");
				DUMPUDECL("EventTime=",event->Time,"\\");
d4645 1
a4645 1
				DUMPSDECL("Adding ",aextra," Aextra\\");
d4659 1
a4659 1
				DUMPUDECL("Previous duration changed to ",V1event->Duration,"\\");
d4664 3
a4666 3
					DUMPSDECL("Start@@ ",V1event->StartField," ");
					DUMPSDECL("AdjVdur=",GetAdjVideoDuration(V1FG)," ");
					DUMPSDECL("RecFlds=",GetRecFields(V1FG),"\\");
d4686 1
a4686 1
				DUMPSDECL("Adding ",bextra," Bextra\\");
d4690 2
a4691 2
				DUMPSDECL("V2sf ",V2event->StartField," ");
				DUMPSDECL("V2ad ",V2event->AudStart,"\\");
d4701 1
a4701 1
					DUMPMSG("Did it!");
d4713 1
a4713 1
					DUMPUDECL("InPoint changed to ",V2event->StartField,"\\");
d4868 1
a4868 1
		DUMPSDECL("Take VIDEO at ",event->Time,"\\");
d4901 1
a4901 1
		DUMPMSG("Need to insert black here");
d5028 1
a5028 1
		DUMPMSG("--- Creating Black ---");
d5080 1
a5080 1
	DUMPMSG("---HandlePlay---");
d5086 1
a5086 1
		DUMPMSG("Improper view to play seq");
d5095 2
a5096 2
//	DUMPHEXIL("Edit=",(LONG)Edit,"  ");
//	DUMPHEXIL("EditTop=",(LONG)EditTop,"\\");
d5106 1
a5106 1
		DUMPHEXIL("Qual = ",IntuiMsg->Qualifier,"\\");
d5119 1
a5119 1
			DUMPMSG("(Button)");
d5131 2
a5132 2
	DUMPUDECB("Partial = ",sv.partial," ");
	DUMPUDECB("Cut2Music = ",sv.cut2music,"\\");
d5143 4
a5146 4
	DUMPMSG("HandlePlay ---------------------------");
	DUMPHEXIL("CurFG=",(LONG)CurFG,"\\");
	DUMPHEXIL("SeqStartFG=",(LONG)SeqStartFG,"\\");
	DUMPHEXIL("FirstFG=",(LONG)firstFG,"\\");
d5158 2
a5159 2
//	DUMPUDECL ("starttime = ",sv.StartTime,"\\");
//	DUMPUDECL ("endtime = ",sv.EndTime,"\\");
d5176 1
a5176 1
		DUMPUDECL ("MusicBaseTime(1) = ",MusicBaseTime,"\\");
d5189 2
a5190 2
		DUMPUDECL ("starttime = ",sv.StartTime,"\\");
		DUMPUDECL ("endtime = ",sv.EndTime,"\\");
d5213 1
a5213 1
	DUMPMSG("Before FreeMems");
d5219 1
a5219 1
	DUMPMSG("After FreeMems");
d5251 1
a5251 1
	DUMPMSG("HandleStop()");
d5267 1
a5267 1
		DUMPMSG("Before HandleStop() sends ES_Stop");
d5269 1
a5269 1
		DUMPMSG("  After HandleStop() sent ES_Stop");
d5302 1
a5302 1
	DUMPUDECB("Preparing track type ",tracktype,"\\");
d5331 1
a5331 1
//		Dump contents of track (debugging only)
d5337 1
a5337 1
	DUMPMSG("******************************************");
d5341 1
a5341 1
		DUMPMSG("Switcher Track ==============================");
d5344 1
a5344 1
		DUMPMSG("Video Track ==============================");
d5347 1
a5347 1
		DUMPMSG("Audio Track ==============================");
d5361 1
a5361 1
//			DUMPSTR("Black>>> ");
d5363 1
a5363 1
		DUMPUDECW("t=",event->Time," ");
d5711 8
d5856 1
d5858 2
a5859 4
				DUMPUDECW("HERE ",event->AE.AEKeys[2].VOL1," BIGDEAL\\");

				//? what about the audio on env bit?
				if (event->AE.Flags & 1) //replace the 1 with the flag value when it get codedDEH!
d5861 2
a5862 2
					err = SendEnvs2Clip(&(event->AE));
					DUMPUDECL("SendEnvs2Clip error ",err," //");//DEH Need to send the audio envelope here!
d5921 1
a5921 1
SendEnvs2Clip(struct AudioEnv *aude)
d5924 1
d5926 4
a5929 1
	struct AEKey *Akey;
a5930 11
/*
	struct AudioEnv *AEI;
	AEI->AEKeys[1].GoTime = 100;
	AEI->AEKeys[1].NumOfFlds = 100;
	AEI->AEKeys[1].Flags = 100;
	AEI->AEKeys[1].VOL1 = 100;
	AEI->AEKeys[1].VOL2 = 100;
	AEI->AEKeys[1].PAN1 = 100;
	AEI->AEKeys[1].PAN2 = 100;
	err = AddAudEKey(&(AEI->AEKeys[1]));
*/	
a5931 2
	// need to read keyused and flags then send keys to 
	// flyer one at a time. 
d5933 7
a5939 1
	DUMPUDECW("Keys used ",aude->Keysused,"\\");
a5940 2
	DUMPUDECW("AEI->AEKeys[1].VOL1",aude->AEKeys[1].VOL1,"\\");
	DUMPUDECW("AEI->AEKeys[2].VOL1",aude->AEKeys[2].VOL1,"\\");
d5942 2
a5943 2
	if(aude->Keysused>0)
		for(i=1;(i<=aude->Keysused);i++)
a5944 3
			err = AddAudEKey(&(aude->AEKeys[i]));
			if (err) break;
   	}
d5946 14
d5962 8
d5974 9
a5982 1

@


2.132
log
@made many change to make cfx work in sequenceing.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.131 1996/06/26 10:30:12 Holt Exp Holt $
d5 3
d530 1
a530 1
#define CRFXPREROLLFUDGE	120	// Used by Chromafx croutons
d1770 1
a1770 1
	LONG ProgTime, gotime, reftime,seltime;
d1881 1
d1883 2
d1888 1
d1897 10
a1906 4
			// Calculate when ChromaFX should start
			gotime = GetRefTime(reftime,PrevVidFG,FG);
			DUMPUDECL("**CRFX: at ",gotime," \\");
			
d1932 21
a1952 2
				event->FGCcommand = FGC_TOPRVW;
				InsertSelect(&sv->SwitcherTrack,event);
d1994 6
a1999 1
			event->Time = GetRefTime(reftime,PrevVidFG,FG) + GetDuration(FG);
@


2.131
log
@comment out defines for audio envelope struct
they are defined in switcher/sinc/flyer.h
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.130 1996/06/25 17:10:08 Holt Exp Holt $
d5 4
d527 2
d533 1
d555 1
a555 1
	ULONG	Flags;
d558 2
a559 2
	UWORD PAN1;
	UWORD PAN2;
d566 1
a566 16
	struct AEKey AEKey01;
	struct AEKey AEKey02;
	struct AEKey AEKey03;
	struct AEKey AEKey04;
	struct AEKey AEKey05;
	struct AEKey AEKey06;
	struct AEKey AEKey07;
	struct AEKey AEKey08;
	struct AEKey AEKey09;
	struct AEKey AEKey10;
	struct AEKey AEKey11;
	struct AEKey AEKey12;
	struct AEKey AEKey13;
	struct AEKey AEKey14;
	struct AEKey AEKey15;
	struct AEKey AEKey16;
d579 1
a579 1
											//Qed items should occur.
d592 1
a592 1
	struct 	AudioEnv AE;			//AudioEnv for Event.
d892 6
a1583 1

d1587 1
d1767 1
a1767 1
	LONG ProgTime, gotime, reftime;
d1853 2
d1858 2
d1862 2
d1892 2
d1901 1
d1908 4
a1911 6
//			// CRFX select sets up on preview, so switch current source to PRVW, then take it
//			event->FG = PrevVidEvent->FG;
//			event->CurrentPosition=PrevVidEvent->CurrentPosition;
//			event->FGCcommand = FGC_TOPRVW;
//			event->Time = ProgTime+8;
//			DUMPUDECL("**CRFX Prev.Src ToPrvw: at ",event->Time," \\");
d1915 26
a1940 3
			event->FGCcommand = FGC_SELECT;
			event->Time = 0; 								// as soon as possible
			AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track
d1942 1
a1942 1
			// Get event for REMOVE
d1960 1
a1960 1
			event->FGCcommand = FGC_REMOVE;
d1963 4
d1983 2
d2093 2
d2640 3
d3354 2
a3355 1
	if ((sv->SwitcherTrack.EventCount) && (SeqInfo.CurSwitcherEvent->FGCcommand == FGC_SELECT))
d5334 2
d5803 1
a5803 1

d5806 1
d5808 10
d5851 1
d5870 48
d6108 1
a6108 1
			// Adjust A/V durations to leave out-points untouched
@


2.130
log
@made many changes to support audio envelopes
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.129 1996/04/29 10:32:45 Holt Exp Holt $
d5 3
d544 1
d576 2
@


2.129
log
@fixed problem with fixupafter cutto(again!!!)
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.128 1996/03/19 17:34:10 Holt Exp Holt $
d5 3
d483 1
a483 1
//#define SERDEBUG	1
d523 1
d539 34
d590 1
a590 1
	UBYTE		Channel;					// Used for Flyer video effects and takes
d594 1
d731 2
a733 1

d791 1
d1255 21
d1312 1
d1317 1
d1434 5
d1524 5
d2779 39
d5082 1
a5082 1
	PrepareTrack(&sv.SwitcherTrack,TRACK_SWITCHER);
d5302 2
a5303 2
			if (tracktype == TRACK_FLYVID)
			{
d5309 1
a5309 1
			}
d5518 1
d5520 1
@


2.128
log
@now keeps extra len for all type of video
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.127 1996/03/01 13:22:37 Holt Exp Holt $
d5 3
d3599 3
a3602 1
					case CT_STILL:
d3660 2
d3684 2
a3686 1
			case CT_STILL:
d3731 4
a3734 1
									maxdur = GetRecFields(lastvid) - GetStartField(lastvid);
@


2.127
log
@fixed BExtra of an Effect causing audio to be off after an audio clip
locked to the in point of the video after the effect.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.126 1995/12/26 18:18:23 Holt Exp Holt $
d5 4
d1942 1
d4473 3
d4522 3
@


2.126
log
@fixed cut to music so it will aline it points on colorframe boundrys.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.125 1995/12/20 15:34:04 Holt Exp Holt $
d5 3
d548 1
d877 2
d1497 3
d1510 1
a1510 1
			else
d1557 1
a1557 1

d1848 2
d1938 1
a1938 1
					reftime = PrevVidEvent->Time;
d1953 1
d4490 3
@


2.125
log
@fixed problem with duration of flyer stills comming out 0.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.124 1995/11/27 16:53:34 Flick Exp Holt $
d5 3
d3484 1
a3484 1
			time = GetCurProgTime() + MusicBaseTime;
@


2.124
log
@Added catch-all error for non-decoded sequencing errors
@
text
@d3 5
a7 2
* $Id: Sequence.c,v 2.123 1995/11/16 14:41:05 Flick Exp Flick $
* $Log: Sequence.c,v $
d3641 1
a3641 1
//		DUMPHEXIL("fg=",(LONG)fg,"\\");
d3702 2
d3705 11
a3715 1
									maxdur = GetRecFields(lastvid) - GetStartField(lastvid);
@


2.123
log
@Improved SCSI error trapping to be able to pinpoint the SCSI drive for
missing drives and for incomplete transfers, too.
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.122 1995/11/15 18:33:54 Flick Exp Flick $
d5 4
d3257 2
d3260 1
a3260 1
			error = SEQERR_FlyerDropped;
d3264 1
d3266 6
a3271 3
		event = FindFlyerEventFromID(sv, SeqInfo.FlyerUserID);
		if (event)
			FG = event->FG;
@


2.122
log
@Added trap/display for FERR_BADPARAM (4)
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.121 1995/11/14 18:25:16 Flick Exp Flick $
d5 3
d3110 1
a3110 1
			if (GetClrSeqError(0,0,&done,&drive,NULL) == FERR_BADSTATUS)
@


2.121
log
@Now traps/displays nice errors for Flyer SCSI errors 64 & 67
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.120 1995/11/10 04:38:26 Flick Exp Flick $
d5 3
d3078 6
@


2.120
log
@Now uses Flyer's GetClrSeqError method to get drive # for SCSI problem error
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.119 1995/11/09 17:53:46 Flick Exp Flick $
d5 3
d3078 3
a3080 1
		else if (sv->AuxError == FERR_BADSTATUS)	// Some SCSI error?
d3085 12
a3096 2
			// SCSI problem
			error = SYSERR_SCSIproblem;
@


2.119
log
@Added error message for 65 (bad status), including possible drive pinpointing
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.118 1995/10/17 17:26:15 Flick Exp Flick $
d5 3
d2968 2
d3077 3
d3082 6
a3087 2
			if ((act.Status & 0xFFFFFF00) == 0x44525600)
				sprintf(ErrorDetails,"   (Possibly related to drive F%c%d:)",'A'+(act.Status/8),act.Status%8);
d3274 2
@


2.118
log
@Auto-trim overlapping with locked crouton now detects when cannot trim, fails to play
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.117 1995/10/09 16:48:34 Flick Exp Flick $
d5 3
d2891 7
a2983 7
				struct FlyerVolume	fv;
				struct ClipAction		act;

				/* MUST Be initialized to zeroes */
				memset(&act,0,sizeof(act));
				memset(&fv,0,sizeof(fv));

d3068 11
@


2.117
log
@Now passing FG to all GetEvent(), although as it turns out I don't need this (yet?)
Fixed TimeBetweenFGs to know about Lost Croutons (CT_ERROR type)
Sequencer tries to insert black for these, will warn user when playing that some exist.
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.116 1995/10/06 16:13:59 Flick Exp Flick $
d5 5
d4655 12
a4666 2
			PutDuration(V1FG,V1event->Duration);					// Permanent fix
			PutAdjVideoDuration(V1FG,V1event->Duration);			// Permanent fix
@


2.116
log
@When unlocking croutons, now recalculates Current Time display too (as well as Project Time)
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.115 1995/10/05 18:41:36 Flick Exp Flick $
* $Log: sequence.c,v $
d525 1
d535 1
d647 1
d731 1
a731 1
static struct Event * GetEvent(void);
d1247 1
a1247 1
	ULONG	timemode;
d1258 9
a1266 1
		DUMPHEXIL("---------- Type ",fg->ObjectType," ---------\\");
d1270 1
a1270 1
		switch (fg->ObjectType)
d1343 1
a1343 1
		switch (fg->ObjectType)
d1652 1
a1652 1
	ULONG objtype;
d1658 1
d1681 1
a1681 1
//	if ((event = GetEvent())==NULL)
d1717 11
a1727 1
		switch(FG->ObjectType)
d1770 1
a1770 1
			if ((event = GetEvent())==NULL)
d1789 1
a1789 1
			if ((event = GetEvent())==NULL)
d1853 1
a1853 1
			if ((event = GetEvent())==NULL)
d2002 1
a2002 1
			if ((event = GetEvent())==NULL)
d2035 1
a2035 1
			if ((event = GetEvent())==NULL)
d2121 1
a2121 1
			if ((event = GetEvent())==NULL)
d2150 1
a2150 1
			if ((event = GetEvent())==NULL)
d2178 1
a2178 1
			if ((event = GetEvent())==NULL)
d2297 1
a2297 1
				switch(FG->ObjectType)
d2314 1
a2314 1
				if ((event = GetEvent())==NULL)
d2354 1
a2354 1
				if ((event = GetEvent())==NULL)
d2418 1
a2418 1
			if ((event = GetEvent())==NULL)
d2464 1
a2464 1
			if (FG->ObjectType == CT_VIDEO)
d2512 1
a2512 1
			if ((event = GetEvent())==NULL)
d2538 1
a2538 1
			if ((FG->ObjectType==CT_VIDEO) || (FG->ObjectType==CT_STILL))
d2567 1
a2567 1
			if ((FG->ObjectType==CT_VIDEO) && (HasAudio(FG)))	// Has natural audio enabled?
d2620 1
a2620 1
//			if (FG->ObjectType==CT_VIDEO)					// Special tests for Flyer video
d2657 30
d2822 1
a2822 1
		if ((event = GetEvent())==NULL)
d3887 1
a3887 1
								if (newevent = GetEvent())
d3968 18
d4032 1
d4129 1
a4129 1
		if ((event = GetEvent())==NULL)
d4142 1
a4142 1
		if ((event = GetEvent())==NULL)
d4518 1
a4518 1
		if ((event = GetEvent())==NULL)
d4688 1
a4688 1
		if ((event = GetEvent())==NULL)
d5067 3
d5080 1
a5080 1
static struct Event * GetEvent(void)
d5088 10
a5097 4
//	if (event==NULL)						// Failed?
//	{
//		DUMPMSG("No mem for event!");
//	}
d5255 1
a5255 1
		event = GetEvent();
d5306 2
d5314 2
a5315 1
		userID++;
@


2.115
log
@2 new sequencing errors for A/B head problems
Auto insert message more informative
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.114 1995/10/02 15:30:30 Flick Exp Flick $
d5 4
d3481 6
a3486 2
			if (lockem == FALSE)			// When unlocking things, better
				CalcRunningTime();		// re-calculate sequence running time
@


2.114
log
@Sequences TakeFrames that are not 50%, support for StopOnErr option during sequencing
Calculates Currrent & Project time correctly for FX that have non-overlapping A/B sources
Supports Automatic audio ramping w/ effects
Sequence processing is now abortable (puts up a requester now while processing)
@
text
@d3 8
a10 2
* $Id: Sequence.c,v 2.113 1995/09/28 10:19:10 Flick Exp Flick $
* $Log: Sequence.c,v $
d663 1
d981 1
a981 1
		sprintf(ErrorDetails,"   Alcatraz Meditation Number %d",sv->AuxError);
d2962 14
d5565 1
a5565 1
	DUMPMSG("AudioUnder");
d5670 2
a5671 1
			msg = "Auto Split complete";
@


2.113
log
@Now support TakeOffset tag in sequencing, removed crouton.lib hack, now navigates error croutons
into view properly on "inserted black" and "croutons overlap" errors.
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.112 1995/09/25 12:41:32 Flick Exp Flick $
d5 4
d405 1
d501 1
d554 1
d645 1
d658 3
d721 1
a721 1
static ULONG DownLoadFlyerTrack(struct SeqVars *sv,struct Track *track, UBYTE tracktype);
d773 1
d1281 19
a1299 1
					start = vidtime - GetNumFields(fg)/2;	// Improve when asym. FX supported!!!
d1372 14
a1385 1
					duration = 0;
a1637 1
	DisplayWaitSprite();
d1652 1
d1888 7
d2434 4
a2525 11
/*~~~~~~~~~~~~~~~ Prepare Transition/Cut ~~~~~~~~~~~~~~~~~~~~~~~~~*/

			if (!HandleTransition(
				sv,
				ProgTime,				// CutTime
				PrevVidEvent,			// V1
				EffectFG,				// FXFG (will be NULL for cut)
				EffectPos,				// FXpos (or -1 for cut)
				CurVidEvent))			// V2
					goto Failed;

d2571 13
d2814 1
d2817 1
d2888 4
d2893 1
a2893 1
			sv->AuxError = DownLoadFlyerTrack(sv,&sv->VideoTrack,TRACK_FLYVID);	// Send video events
d2897 1
a2897 1
				sv->AuxError = DownLoadFlyerTrack(sv,&sv->AudioTrack,TRACK_AUDIO);	// Send audio events
d2903 10
d2914 18
a2931 1
				sv->AuxError = EndSequence(0,1);				// Let Flyer grind on this for a while...
d2936 3
d2982 5
d3016 3
d3167 1
a3167 1
			sv->AuxError = DownLoadFlyerTrack(sv,&sv->AudioTrack,TRACK_AUDIO);	// Send audio events
d3198 2
d3598 3
d4059 1
d4079 1
a4079 1
			if ((fxlen-blen) <= alen)			// Sources overlap?
d4229 9
a4238 2
				// FXs can't extend previous video's audio! (we can now, but do we want to?)

d4269 13
a4281 2
				// For Flyer clips: extend V2's inpoint (round down to color frame)
				// FXs can't extend current video's audio! (we can now, but do we want to?)
d4283 1
a4631 39
#if 0
		// Get event for effect's TOMAIN
		if ((event = GetEvent())==NULL)
		{
			ReportSequenceError(sv,V2FG,V2pos,SEQERR_OutOfMemory,FALSE);
			return(FALSE);
		}
		event->FG = V2FG;
		event->CurrentPosition = V2pos;
		event->FGCcommand = FGC_TOMAIN;

		// If have V2 and it's Flyer video - set preview to Flyer output just before the AUTO
		if (V2event)
		{
			if ((V2FG->ObjectType==CT_VIDEO) || (V2FG->ObjectType==CT_VIDEO))
			{
				event->Flags1 |= FLAGS1F_SETCHAN;
				event->Channel = V2event->Channel;		// Get channel assigned to it
			}
		}
~~~~~~~~~~~~

		if (!HandleTransition(
			sv,
			time,								// CutTime
			V1event,							// V1
			NULL,								// FXFG (NULL for cut)
			-1,								// FXpos (not for cut)
			event))							// V2
	 			goto Abort;

	}
	else
	{
		// Need to have toaster insert black on non-Flyer systems!!!
	}
}
#endif

d4950 9
d5173 2
a5174 1
											UBYTE tracktype)
d5194 6
d5271 5
a5275 2
			action.VolAttack = GetAudioAttack(fg);
			action.VolDecay  = GetAudioDecay(fg);
@


2.112
log
@Added seq error for playing video clip from non-video drive
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.111 1995/09/19 12:18:38 Flick Exp Flick $
d5 3
d761 1
d3806 1
d3961 3
a3963 3
			/***** HACK! UNTIL CROUTONDEFS.a SETS THESE AS DEFAULTS!!!! *******/
			if ((alen == 0) && (blen == 0))
				alen = blen = 0xFFFFFFFF;
d3979 6
a3984 5
//				THIS FEATURE NOT CURRENTLY USED, AS NO ONE CAN SET THE TAG NON-0 YET
//				WHEN IMPLEMENTED DO NOT USE THE TAG_DELAY, AS IT IS USED FOR START
//				TIMES FOR NON_TRANSITIONAL EFFECTS!  MAKE A NEW TAG, i.e. TAG_OFFSET.
//				fxadvance = fxlen * (32767 - GetDelay(FXFG))/65534;
				takefld = fxlen/2;
d4398 3
a4400 1
			ew_QuickSelect(sv->EditTop,V1event->CurrentPosition);		// Hilite offender
@


2.111
log
@FX sequencing now supports A/BSourceLen tags
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.110 1995/09/13 13:10:49 Flick Exp Flick $
d5 3
d2877 7
@


2.110
log
@Added GetPrevGadget for putting up prev source on preview
Fixed bug when locking/unlocking multiple audio croutons from hotkeys
@
text
@d3 6
a8 2
* $Id: sequence.c,v 2.109 1995/08/31 16:16:40 Flick Exp Flick $
* $Log: sequence.c,v $
d753 2
d3872 2
a3873 2
	LONG	fxlen,fxadvance, fudge, V2end, temp;
	ULONG	error;
d3876 1
d3939 1
d3942 1
a3942 1
		if (V1event && V2FG)			// (Does not do this on black at end)
d3944 42
a3985 6
//			// Find offset into the effect to place the cut point
//			THIS FEATURE NOT CURRENTLY USED, AS NO ONE CAN SET THE TAG NON-0 YET
//			WHEN IMPLEMENTED DO NOT USE THE TAG_DELAY, AS IT IS USED FOR START
//			TIMES FOR NON_TRANSITIONAL EFFECTS!  MAKE A NEW TAG, i.e. TAG_OFFSET.
//			fxadvance = fxlen * (32767 - GetDelay(FXFG))/65534;
			fxadvance = fxlen/2;
d3987 1
a3987 2
			// ***!!! This time is bogus if it's a solid ANIM because it isn't centered on
			// a cut!!! Solid ANIMs have video time!!!
d3989 5
a3993 1
			event->Time = cuttime - fxadvance;		//Start early so cut point hits cuttime
d4099 1
a4099 1
		/*** Adjust V1/V2 in/out points to provide overlap needs for effect to occur ***/
d4102 11
a4112 2
			// Extend V1's outpoint (round up to color frame)
			// FXs can't extend previous video's audio! (we can now, but do we want to?)
d4114 16
a4129 15
			V1event->Duration = GetAdjVideoDuration(V1FG) + ROUNDUPTOFRAME(fxlen-fxadvance);
			PutAdjVideoDuration(V1FG, V1event->Duration);
			DUMPUDECL("Previous duration changed to ",V1event->Duration,"\\");

			// For Flyer video clips, check to see if V1 had enough video to make overlap
			if (V1FG->ObjectType==CT_VIDEO)
			{
				// Calculate how many fields short we are on trailing video
				temp = (V1event->StartField + GetAdjVideoDuration(V1FG)) - GetRecFields(V1FG);
				if (temp>0)
				{
					// Not enough trailing video. Effect ends after video
					sprintf(ErrorDetails,"   (Needs %d more frames)",temp/2);
					ReportSequenceError(sv,FXFG,FXpos,SEQERR_FXtrailingVideo,FALSE);
					return(FALSE);
d4133 9
a4141 1
			fxadvance = ROUNDUPTOFRAME(fxadvance);		// Do this for non-Flyer video too?
d4143 4
a4146 2
			// For Flyer clips: extend V2's inpoint (round down to color frame)
			// FXs can't extend current video's audio! (we can now, but do we want to?)
d4148 1
a4148 4
			if (V2FG->ObjectType==CT_VIDEO)
			{
				V2event->StartField -= fxadvance;
				PutAdjVideoStart(V2FG, V2event->StartField);
d4150 9
a4158 1
				DUMPUDECL("InPoint changed to ",V2event->StartField,"\\");
d4160 1
a4160 2
				// Check to see if V2 had enough video to make overlap
				if ((V2event->StartField) < 0)
d4162 1
a4162 4
					// Not enough leading video -- effect starts before video
					sprintf(ErrorDetails,"   (Needs %d more frames)",(-V2event->StartField)/2);
					ReportSequenceError(sv,FXFG,FXpos,SEQERR_FXleadingVideo,FALSE);
					return(FALSE);
d4164 3
a4166 1
			}
d4168 3
a4170 3
			if (V2FG->ObjectType==CT_STILL)
			{
				/*** Used to make a head if V1FG->FileName & V2FG->FileName came from same drive ***/
a4171 7

			// Start V2 earlier in sequence
			V2event->Time -= fxadvance;		// Could un-sort Flyer video events

			// Extend V2's duration because of the early start
			V2event->Duration = GetAdjVideoDuration(V2FG) + fxadvance;
			PutAdjVideoDuration(V2FG, V2event->Duration);
d5532 23
@


2.109
log
@Added error panel when Flyer detects a bad A/V head for a clip w/effect
Also does cleanup if user wishes
@
text
@d3 6
a8 2
* $Id: Sequence.c,v 2.108 1995/08/28 16:41:31 Flick Exp Flick $
* $Log: Sequence.c,v $
d1174 21
d3284 1
a3284 1
							curfg->SymbolFlags &= ~SYMF_LOCKED;		// No longer locked
@


2.108
log
@Reworked Audio Under split builder to support multiple inserts, optional hilite
of both ends ensures we grab all video between
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.107 1995/08/28 11:58:49 Flick Exp Flick $
d5 4
d2830 13
@


2.107
log
@Supports cuts-only under Scrolls/crawls/keys/overlays now! (Flyer stuff only)
New Audio-Under generator, switcher collision detection error reporting
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.106 1995/08/23 13:29:32 Flick Exp Flick $
d5 4
d5306 1
a5306 1
//		Auto-make split audio and match frame to 2nd crouton
d5310 3
a5312 3
	struct ExtFastGadget *fg,*fg1,*fg2,*fg3;
	int	state;
	LONG	adur,match,temp;
d5318 1
a5318 1
	fg1 = fg2 = fg3 = NULL;
d5320 2
d5331 1
a5331 1
						state = 9;								// If wrong type, do nil
d5335 1
a5335 1
						state++;
d5339 13
a5351 2
			case 1:		// Look for video to split audio underneath
				if (IsVideoSource(fg))
d5353 2
a5354 2
					fg2 = fg;
					state++;
d5357 2
a5358 2
			case 2:		// Get 2nd Flyer clip to match frame
				if (IsVideoSource(fg))
d5360 3
a5362 3
					if (fg->ObjectType != CT_VIDEO)		// Only works on Flyer clips
						state = 9;
					else
d5364 3
a5366 2
						fg3 = fg;
						state++;			// Ready to do it!
d5368 5
d5374 5
a5378 1
				break;
d5382 9
a5390 1
	if ((fg1) && (fg2) && (fg3))			// Unless everything just right, do nil
d5392 8
a5399 2
		if (stricmp(fg1->FileName, fg3->FileName))
			msg = "Error -- Flyer clips are mismatched";
d5402 1
a5402 10
			// Calculate fg1's new audio duration
			adur = GetStartField(fg1)+GetDuration(fg1)+GetDuration(fg2)-GetAudioStart(fg1);

			// Calculate fg3's match field #
			match = GetAudioStart(fg1)+adur;

			if((match < GetRecFields(fg1))		// Check both, in case different clips (?!?)
			&& (match < GetRecFields(fg3)))
			{
				PutAudioDuration(fg1,adur);		// Stretch out fg1's audio under fg2
d5404 2
a5405 2
				PutAudioDecay(fg1,0);				// (seamless)
				PutAudioAttack(fg3,0);
d5407 4
a5410 4
				// Adjust A/V durations to leave out-points untouched
				// Match could go beyond original outpoint, ensure we don't go negative!
				temp = GetStartField(fg3)+GetDuration(fg3)-match;
				PutDuration(fg3,(temp>0)?temp:4);
d5412 2
a5413 2
				temp = GetAudioStart(fg3)+GetAudioDuration(fg3)-match;
				PutAudioDuration(fg3,(temp>0)?temp:4);
d5415 3
a5417 3
				// Now set in-points to seam up audio perfectly
				PutStartField(fg3,match);			// Match frame fg3 (Audio & Video)
				PutAudioStart(fg3,match);
d5419 1
a5419 1
				CalcRunningTime();		// Re-calculate sequence total time & put up in access window
d5421 1
a5421 4
				msg = "Audio Under/Match Frame complete";
			}
			else
				msg = "Error -- Clip too short to perform operation";
a5422 7
	}
	else
	{
		if (state == 9)		// 9=special case for wrong crouton type
			msg = "Error -- Only works on Flyer clips";
		else
			msg = "Error -- All three components were not found";
@


2.106
log
@Added CTRL-stop panic hook into Flyer reset as insurance policy for 4.05
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.105 1995/08/18 17:17:10 Flick Exp Flick $
d5 3
a420 2
#define	COLLDETECT	0

d600 1
a600 1
	ULONG	SwitcherBusyTil;				// Timecode up to which switcher is busy doing something
d602 1
d649 1
a649 1
static void HiliteNewFG(struct EditWindow *Edit, struct ExtFastGadget *FG, LONG fgpos);
d652 3
d658 1
d690 3
d744 1
d838 1
d841 3
d851 1
d855 2
a856 1
								LONG fgpos)
d861 10
a870 2
	ew_QuickSelect(Edit,fgpos);			// Hilites crouton
	ew_NavigateNodeNum(Edit,fgpos);		// Navigates to it so it's visible
d872 2
a873 1
	Edit->ew_OptRender = FALSE;
d875 2
a876 2
	SendSwitcherReply(ES_SelectDefault,(SKellFG=NULL));
	CurFG=(struct FastGadget *)FG;
d896 37
a942 4
	// FG may be NULL of we don't want any hilited,
	// and fgpos might = -1 if we want the code to find the crouton
	HiliteNewFG(sv->EditTop,FG,fgpos);

d957 1
a957 1
	SetRunningTime(-1L);		// "???" display if possible
d1036 1
a1036 1
//		Returns TRUE if the FG is a video source crouton
d1044 26
a1069 10
	if
	(
			(objtype==CT_VIDEO)
		||	(objtype==CT_FRAMESTORE)
		||	(objtype==CT_IMAGE)
		||	(objtype==CT_VIDEOANIM)
		||	(objtype==CT_MAIN)
		||	(objtype==CT_STILL)
	)
		return(TRUE);
d1071 22
a1092 1
		return(FALSE);
d1196 2
a1197 1
					if (abstime > vidtime)			// Skip time forward to locked crouton?
d1538 1
d1540 1
a1540 1
	SetRunningTime(-1L);		// assume unable to calculate program time
d1599 2
a1600 1
		fudge = 0;			// None yet
d1638 1
a1638 2
#if COLLDETECT
			if (DetectSwitcherCollision(sv))
d1640 1
a1640 1
				error = SEQERR_SwitcherCollision;
a1642 1
#endif
d1689 1
a1689 1
//			Keep these to detect switcher event overlaps
d1863 5
d1929 2
a1930 2
//			Keep these to detect switcher event overlaps
			sv->SwitcherBusyTil = event->Time + event->Duration;
d1982 6
d2068 1
a2068 1
//			Keep these to detect switcher event overlaps
d2158 6
d2249 4
d2291 37
a2327 2
			event->Flags1 = FLAGS1F_SETCHAN;	// Indicate we need FX to this to set chan
			// Assign alternating channels to each clip/still
d2382 6
d2433 1
a2433 1
				EffectPos,				// FXpos (or -1 for nut)
d2515 4
d2520 1
d2534 2
d2537 1
d2586 41
d2631 1
a2631 1
		if (event)
d2666 3
a2668 3

	if (error)
		goto Failed;
a2689 1
#if COLLDETECT
d2691 3
a2693 5
	if (error == SEQERR_SwitcherCollision)
		ReportSequenceDualError(sv,FG,sv->Pos,FG2,sv->Pos2,error,FALSE);
	else
#endif
	if (error)
d2781 1
d2970 1
a2970 1
		HiliteNewFG(sv->EditTop,FG,-1);	//Hilite initially selected or abort crouton
d3991 1
a3991 1
		sv->SwitcherBusyTil = EndOfEffect;
d4076 1
a4076 1
	else
d4599 8
a4606 1
	DUMPMSG("Before HandleStop() sends ES_Stop");
d4608 6
a4613 1
	if (IntuiMsg && (IntuiMsg->Qualifier & IEQUALIFIER_CONTROL) && FlyerBase)
d4617 1
d4710 2
a4711 1
			DUMPSTR("Black>>> ");
d4728 2
d5255 150
@


2.105
log
@Oh yeah! Forgot that all tags reads are bypasses ES system now -- Much faster!
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.104 1995/08/18 17:12:05 Flick Exp Flick $
d5 3
d4396 6
a4401 2
	SendSwitcherReply(ES_Stop,NULL);	//clr bit 4 of TB_DisplayRenderMode
	DUMPMSG("  After HandleStop() sent ES_Stop");
d4403 2
a4404 1
	StopLiveEditing(FALSE);			// Handle wrap-up after editing to music/video
@


2.104
log
@Fixed sequencing of framestores/main w/FX just before play-from point
Added support for Flyer sequencing error detection (crippled at this point)
Added f'n to calc total sequence time (for the running time display)
Added ability to unlock audio crouton from outside panel (figures rel inpoint)
Editing2 now puts temporary lock symbol on audio croutons until done
Play buttons now stop an Editing2 session if stop not already pressed
Status message stays at top now throughout Editing2 session
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.103 1995/08/16 10:50:46 Flick Exp Flick $
d5 9
@


2.103
log
@Smarter queueing of keys so that any start time should work
No "ready to play" requester from ARexx PlayProject
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.102 1995/08/09 18:07:14 Flick Exp Flick $
d5 4
d508 5
a512 1
	STRPTR 			ErrorMsg;	//not usually used
d622 5
d630 2
a631 2
static LONG __regargs GetSimpleTagS(struct ExtFastGadget *FG, LONG tag);
static ULONG __regargs GetSimpleTagU(struct ExtFastGadget *FG, LONG tag);
d671 1
d674 5
d683 6
a688 4
static LONG __regargs GetSimpleTagS(struct ExtFastGadget *FG, LONG tag)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000 | tag;
d690 2
a691 2
	return((LONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d698 6
a703 4
static ULONG __regargs GetSimpleTagU(struct ExtFastGadget *FG, LONG tag)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000 | tag;
d705 2
a706 2
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d709 7
a715 7
#define	GetCroutonType(fg)		(GetSimpleTagU(fg,TAG_CroutonType))
#define	GetTimeMode(fg)			(GetSimpleTagU(fg,TAG_TimeMode))
#define	GetAudioOn(fg)				(GetSimpleTagU(fg,TAG_AudioOn))
#define	GetAudioVolume1(fg)		(GetSimpleTagU(fg,TAG_AudioVolume1))
#define	GetAudioVolume2(fg)		(GetSimpleTagU(fg,TAG_AudioVolume2))
#define	GetAudioPan1(fg)			(GetSimpleTagU(fg,TAG_AudioPan1))
#define	GetAudioPan2(fg)			(GetSimpleTagU(fg,TAG_AudioPan2))
d718 17
a734 17
#define	GetRecFields(fg)			(GetSimpleTagS(fg,TAG_RecFields))
#define	GetNumFields(fg)			(GetSimpleTagS(fg,TAG_NumFields))
#define	GetStartField(fg)			(GetSimpleTagS(fg,TAG_ClipStartField))
#define	GetDuration(fg)			(GetSimpleTagS(fg,TAG_Duration))
#define	GetDelay(fg)				(GetSimpleTagS(fg,TAG_Delay))
#define	GetAdjVideoStart(fg)		(GetSimpleTagS(fg,TAG_AdjustedVideoStart))
#define	GetAdjVideoDuration(fg)	(GetSimpleTagS(fg,TAG_AdjustedVideoDuration))
#define	GetFadeInDuration(fg)	(GetSimpleTagS(fg,TAG_FadeInDuration))
#define	GetFadeOutDuration(fg)	(GetSimpleTagS(fg,TAG_FadeOutDuration))
#define	GetFadeInVideo(fg)		(GetSimpleTagS(fg,TAG_FadeInVideo))
#define	GetAudioStart(fg)			(GetSimpleTagS(fg,TAG_AudioStart))
#define	GetAudioDuration(fg)		(GetSimpleTagS(fg,TAG_AudioDuration))
#define	GetAudioAttack(fg)		(GetSimpleTagS(fg,TAG_AudioAttack))
#define	GetAudioDecay(fg)			(GetSimpleTagS(fg,TAG_AudioDecay))
#define	GetSpeed(fg)				(GetSimpleTagS(fg,TAG_Speed))
#define	GetButtonLogic(fg)		(GetSimpleTagS(fg,TAG_ButtonELHlogic))
#define	GetLoopFlag(fg)			(GetSimpleTagS(fg,TAG_LoopAnims))
d887 1
a887 1
	SetRunningTime(-1L);
d1115 1
a1115 1
					start = 0;
d1125 3
d1186 1
a1186 1
					duration = GetDuration(fg);
d1313 13
d2685 1
a2685 1
	FG = SeqInfo.AbortedFG;		// Get FG for error/abort (or NULL)
d2700 1
a2700 1
	if (SeqInfo.ErrorEvent)
d2702 1
a2702 1
		// Does this if there was an error during the sequence.
d2709 1
a2709 1
			case	1:
d2716 14
a2729 1
			default:
d2731 3
d2735 8
d2749 1
d2827 1
a2827 1
	DisplayMessage("Editing to music");
d2888 1
a2888 1
	DisplayMessage("Editing to music");
d2955 3
a2957 1
					curfg->SymbolFlags &= ~SYMF_LOCKED;
d2990 1
a2990 1
		else
d3014 10
a3023 1
						if (!lockem)				// Lock only (no unlock yet from here)
d3025 1
d3070 3
d3075 1
d3091 2
d3103 12
d3200 2
d3245 1
a3245 1
	BOOL		killit;	//firstfg;
d3248 7
d3283 2
d3304 3
a3306 3
//		DUMPUDECL("t1=",event->Time," ");
//		DUMPUDECL("t2=",sv->StartTime," ");
//		DUMPUDECL("fl=",event->Flags2,"\\");
d3407 1
a3407 1
						if (FLAGS2F_FXIN & event->Flags2)
d3409 4
a3412 2
							//	Insert a TOMAIN for crouton at window start time (assume FX will be deleted)
							DUMPMSG("Inserting a cut for trimmed-out FX");
d3414 17
a3430 2
							// Get event for take's TAKE/TOMAIN
							if (newevent = GetEvent())
d3432 2
a3433 10
								newevent->FG = event->FG;
								newevent->CurrentPosition = event->CurrentPosition;										// If V1pos or V2pos
								newevent->FGCcommand = FGC_TOMAIN;
								newevent->Time = sv->StartTime;
								newevent->Duration = event->Duration - trim;

								AppendToTrack(&sv->SwitcherTrack,newevent);	// Tack on end of track
								Insert(&sv->SwitcherTrack.EventList,
									(struct Node *)newevent,		// my new node to insert
									(struct Node *)event);			// AFTER this node
d3436 2
a3437 5
						else		// Cut to video, just move cut time to window
						{
							event->Time += trim;
							event->Duration -= trim;	// Sequencer use only
						}
d4215 2
d4387 8
d4397 3
d4403 2
a4405 2

	return(Edit);
d4719 1
a4719 1
	ULONG	audiobits,err;
d4727 2
d4733 2
d4757 1
a4758 1

d4972 42
@


2.102
log
@Added support for sequencing non-transitional/overlay effects (+looping)
Fixed bug in TimeBetweenFGs: multiple scrawls/overlays in one clip -- was wrong
@
text
@d3 6
a8 2
* $Id: sequence.c,v 2.101 1995/08/09 14:13:25 Flick Exp Flick $
* $Log: sequence.c,v $
d384 1
d402 2
d423 9
d574 1
d579 2
d654 1
d1381 1
a1381 1
	struct Event *PrevVidEvent=NULL, *CurVidEvent, *KeyKill;
d1444 2
d1486 11
d1540 5
a1544 1
			KeyKill = event;
d1727 17
a1743 3
			// Wants a double-punch (take and scrawl at same time)?
			if (gotime < (reftime+ILBMPREROLLFUDGE))
				setchan = AppendSelect(&sv->SwitcherTrack,event);	// Insert near end of track
d1750 1
a1750 1
			// Get event for TOMAIN
d1758 3
d1767 3
a1769 3
//			if (setchan >= 0)
//				event->FGCcommand = FGC_TAKE;
//			else
d1777 4
a1829 20
//			// Wants a double-punch (take and key at same time)?
//			if (gotime == reftime)
//			{
//				event = (struct Event *)RemTail(&sv->SwitcherTrack.EventList);
//				if (event)
//				{
//					if ((event->FGCcommand == FGC_TOMAIN) && (FLAGS1F_SETCHAN & event->Flags1))
//					{
//						sv->SwitcherTrack.EventCount--;				// Killed previous event
//						setchan = event->Channel;		// Get channel to take to
//						FreeMem(event, sizeof(struct Event));
//					}
//					else
//					{
//						// Oops! Add back in
//						AddTail(&sv->SwitcherTrack.EventList, (struct Node *)event);
//					}
//				}
//			}

d1841 4
d1846 7
a1852 2
			if (gotime < (reftime+FRAMEPREROLLFUDGE))
				setchan = AppendSelect(&sv->SwitcherTrack,event);	// Insert near end of track
d1855 2
a1856 2
				AppendToTrack(&sv->SwitcherTrack,event);	// Tack on end of track
				setchan = -1;
d1867 1
a1867 1
			if (setchan >= 0)
a1906 1
			KeyKill = event;
d1908 6
d1921 2
a1922 1
// Transitional effects.  I really need new types for non-transitions!!!
d2000 1
a2000 13
				// Get event for SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv->Pos;
				event->FGCcommand = FGC_SELECT;
				event->Time = 0;	//as soon as possible
				AppendToTrack(&sv->SwitcherTrack,event);	// Add to track

				/*** Check that we have enough preload time ***/
d2016 36
a2051 1
				if (gotime < (reftime+fudge))
d2057 1
a2057 1
				// Get event for TOMAIN
d2065 13
a2077 1
				event->FGCcommand = FGC_TOMAIN;
d2202 13
a2214 12
			// Can't do takes under keys, so kill key when next event comes up (AC)
			if (PreviousTrack==CRTN_KEY)
			{
				DUMPUDECL("Prev Key End: ",KeyKill->Time,"  ");
				DUMPUDECL("ProgTime: ",ProgTime,"  ");

				if (KeyKill && KeyKill->Time > (ProgTime-fudge))
				{
					// Could this mess with event sort???
					KeyKill->Time=ProgTime-fudge; // a little margin.. necessary???
				}
			}
d2432 1
d2434 4
d2441 1
d2626 7
a2632 4
	DisplayNormalSprite();
	if (!BoolRequest(sv->EditTop->Window,">>> The project is ready to play <<<"))
		goto Abort;
	DisplayWaitSprite();
a2633 1

d3562 6
a3567 2
			// Find offset into the effect to place the cut point
			fxadvance = fxlen * (32767 - GetDelay(FXFG))/65534;
d3662 4
d4124 2
d4469 1
d4492 34
@


2.101
log
@Sequencing errors are now highlighted and then navigated into visible area
Sequencer now supports key options to fade or pop in/out
Fixed Stills bug in Flyer downloading code (was requesting >4 fields)
@
text
@d3 7
a9 2
* $Id: Sequence.c,v 2.100 1995/08/02 15:11:35 Flick Exp Flick $
* $Log: Sequence.c,v $
d447 2
d457 1
d516 1
d610 1
d690 2
d905 1
a905 1
	DUMPMSG("---------------------------\\");
d967 28
d1066 9
d1086 1
a1086 1
		lastvidtime = vidtime;
d1096 1
d1110 1
d1136 9
d1201 4
a1204 1
			adj = -2*60;			// Extra 2 seconds before transition
d1459 1
a1459 1
					error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
d1538 1
a1538 1
					error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
d1668 1
a1668 1
					error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
d1673 1
a1673 1
			// Find desired overlay start time
d1761 1
a1761 1
					error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
d1766 1
a1766 1
			// Find desired overlay start time
d1772 1
a1772 1
//			// Wants a double-punch (take and overlay at same time)?
d1803 1
a1803 1
			// Wants a double-punch (take and overlay at same time)?
d1854 1
a1855 1
				event->FGCcommand = FGC_REMOVE;		//Why not using this???
d1873 4
a1876 1
			DUMPMSG("FXANIM/ILBM/ALGO CROUTON");
d1878 1
a1878 1
//			takeneeded = FALSE;			// No implied TAKE on next video
d1881 5
a1885 5
//			if (!GetNextGadget(FG))
//			{
//				error = SEQERR_EffectAtEnd;	// Can't end sequence with an Effect.
//				break;
//			}
d1888 5
a1892 5
//			if (PreviousTrack==CRTN_NONE)
//			{
//				error = SEQERR_EffectAtStart;	// Can't start with an effect
//				break;
//			}
d1895 9
a1903 1
// 		case CT_VIDEOANIM:
d1905 8
a1912 1
			if (PreviousTrack==CRTN_TRANS)
d1914 66
a1979 3
				error = SEQERR_EffectAfterEffect;	// Can't sequence two Effects in a row
				break;
			}
d1981 13
a1993 1
/*?*/		//	error = SEQERR_EffectDuringKeying;	// Effect not allowed during keying.
d1995 1
a1995 2
			EffectFG = FG;
			EffectPos = sv->Pos;
d1997 2
a1998 3
//			PreviousFG = FG;
//			PreviousPos = sv->Pos;
			PreviousTrack = CRTN_TRANS;  //**!! NOT REALLY IF VIDEOANIM
d3173 1
a3173 1
					// Do all or none
@


2.100
log
@Handle error when Flyer can't locate a clip (with nice error panel now)
Added error detection for two video clips locked out of order
Added busy pointer on Lock/Unlock function (not on "live" version)
Fixed bug where "Processing..." stayed up after aborting a "fix this" req
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.99 1995/07/28 16:34:59 Flick Exp Flick $
d5 6
a371 1
#define KEY_FADE
d679 1
d768 1
a768 1
//		Hilites the given FG
d778 3
a780 1
	ew_QuickSelect(Edit,fgpos);
d792 1
a792 1
//		Hilite specified crouton (or not if FG is NULL)
d1764 2
a1765 3
				event->FGCcommand = FGC_TAKE;
#ifdef KEY_FADE
			else if(GetFadeInDuration(FG))
a1766 1
#endif
d1769 1
d1787 2
a1788 2
//#ifdef KEY_FADE
//			if(GetFadeInDuration(FG))
d1790 3
a1792 3
//			else
//#endif
//				event->FGCcommand = FGC_REMOVE;
d2322 1
d4367 10
a4376 2
			action.VidStartField = event->StartField;
			action.VidFieldCount = event->Duration;
@


2.99
log
@Fixed play-from on video to play from inpoint (not adjusted point) -- this
effectively removes any transition on that inpoint.  Also fixed which Flyer
channel is punched up on a play-from (logic was not quite right).
@
text
@d3 7
a9 2
* $Id: sequence.c,v 2.98 1995/07/20 16:39:35 Flick Exp Flick $
* $Log: sequence.c,v $
d533 1
d2186 3
d2291 1
a2291 1
		if (sv->AuxError == FERR_FULL)
d2298 1
a2298 1
		else if (sv->AuxError == FERR_NOAUDIOCHAN)
d2305 7
d2674 2
d2734 1
d3162 1
d3665 5
d3682 1
d4526 1
@


2.98
log
@Fixed bug - was not including trailing split audio in total program time
Would get trimmed off if ran past end of last video in project
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.97 1995/07/14 10:56:54 Flick Exp Flick $
d5 4
d1103 1
a1103 1
	LONG	time,bonus;
d1108 1
a1108 1
	bonus = 0;
d1118 1
d1127 1
a1127 1
			bonus = 2*60;			// Extra 2 seconds before transition
d1159 3
d1163 2
a1164 2
	if (time > bonus)
		return(time-bonus);
d1166 5
a1170 1
		return(time);
d3057 8
d4283 4
a4286 1
				if (tracktype == TRACK_FLYVID)
@


2.97
log
@Now does (optional) auto-fixup after editing to music/video
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.96 1995/07/13 13:11:10 Flick Exp Flick $
d5 3
d965 1
a965 1
	LONG	vidtime,lastvidtime,abstime,maxtime,duration,start;
d1030 8
d1073 3
a1075 2
		if ((start+duration) > maxtime)
			maxtime = (start+duration);
@


2.96
log
@HandleLockDown() now works, even if no CurFG (dropped crtn or select all)
HandlePlay() aborts unless EditTop is of type EW_PROJECT
Uses EditTop everywhere, rather than Edit (is sometimes bottom window)
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.95 1995/07/07 19:25:15 Flick Exp Flick $
d5 5
d373 1
a2592 2
					redraw = TRUE;
					break;
d2594 3
d2598 7
a2604 5
//				PutDelay(curfg,time);		// Set absolute start time
//				PutTimeMode(curfg,TIMEMODE_ABSTIME);
//				curfg->SymbolFlags |= SYMF_LOCKED;
//				redraw = TRUE;
//				break;
d2614 3
a2616 1
				PutTimeMode(curfg,TIMEMODE_ABSTIME);		// Lock video
d2698 110
d3629 2
a3630 1
			MPtr[2] =           " or \"cancel\" to leave it alone";
d3635 2
a3943 2
	EditingLive = FALSE;

d3946 7
@


2.95
log
@Editing foley to video uses TIMEMODE_RELINPT, no longer locks to PROG TIME
Corrected wording on ready window when ready to edit to video (not music)
Now navigates hilite +1 when starting editing to an audio/video clip
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.94 1995/07/06 18:24:49 Flick Exp Flick $
d5 5
d508 1
a508 1
	struct EditWindow *Edit;
d2324 1
a2324 1
	if (!BoolRequest(sv->Edit->Window,">>> The project is ready to play <<<"))
d2384 1
a2384 1
		HiliteNewFG(sv->Edit,FG,-1);	//Hilite initially selected or abort crouton
d2454 1
a2454 1
	if (!BoolRequest(sv->Edit->Window,">>> Ready to edit to music <<<"))
d2512 1
a2512 1
	if (!BoolRequest(sv->Edit->Window,
d2543 1
a2543 1
	NavigateRight(sv->Edit,0);				// Jump to next crouton for them (aint I nice)
d2561 8
a2568 1
	if (curfg=(struct ExtFastGadget *)CurFG)	// Must have a crouton hilited, or we bail out
d2687 32
d2990 1
a2990 1
				sv->Edit->ew_OptRender = FALSE;
d3502 1
a3502 1
			sv->Edit->ew_OptRender = FALSE;
d3653 8
d3663 1
a3663 1
	sv.Edit = Edit;
@


2.94
log
@Disabled debugging (oops!)
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.93 1995/07/06 18:22:38 Flick Exp Flick $
d5 3
d554 2
a555 1
BOOL	FoleyEditing;							// Live foley edits to video clip
d2472 1
a2472 1
	FoleyEditing = FALSE;
d2492 2
d2506 4
a2509 1
	if (!BoolRequest(sv->Edit->Window,">>> Ready to edit to music <<<"))
d2511 2
a2513 1

d2519 5
d2537 2
a2538 1
	FoleyEditing = FALSE;
a2559 2
//			if (FoleyEditing)

d2568 11
@


2.93
log
@Fixed potential redraw problem with multiple croutons w/ HandleLockDown()
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.92 1995/07/05 14:59:16 Flick Exp Flick $
d5 3
d342 1
a342 1
#define SERDEBUG	1
@


2.92
log
@Editing to music working better, got editing foley to video working
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.91 1995/06/28 18:11:52 Flick Exp Flick $
d5 3
d2589 2
a2635 2
					if (redraw)
						ew_ForceRedraw(Edit,GetProjNodeOrder(Edit,(struct FastGadget *)fg));
d2637 3
@


2.91
log
@Improved play-from to get actual time of highlighted event (after build)
Play-from a transition backs up 2 seconds if possible
Improved error reporting (especially for A/B full and no audio drive)
Cutting to Music finished and working quite well
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.90 1995/06/26 17:19:46 Flick Exp Flick $
d5 6
d351 1
d544 2
a545 1
BOOL	Cutting2Music = FALSE;
a1251 5
	/*** Setup and clear all tracks ***/
	PrepareTrack(&sv->SwitcherTrack,TRACK_SWITCHER);
	PrepareTrack(&sv->VideoTrack,TRACK_FLYVID);
	PrepareTrack(&sv->AudioTrack,TRACK_AUDIO);

d2156 1
a2156 1
	Cutting2Music = FALSE;
d2381 2
a2382 2
// CutToMusic
//		Interactive lock-down's to music
d2384 1
a2384 1
static void CutToMusic(struct SeqVars *sv)
d2388 1
a2388 1
	Cutting2Music = FALSE;
d2456 1
a2456 1
	// New lock-down hotkey (enabled when Cutting2Music == TRUE;
d2461 3
a2463 1
	Cutting2Music = TRUE;
d2465 54
d2526 1
a2526 1
void HandleLockDown(void)
d2528 1
a2528 1
	struct ExtFastGadget *fg;
d2530 1
d2534 1
a2534 1
	if (fg=(struct ExtFastGadget *)CurFG)	// Must have a crouton hilited, or we bail out
d2536 1
a2536 1
		if (Cutting2Music)
d2538 2
a2543 1
		}
d2545 1
a2545 4
		switch(fg->ObjectType)
		{
		case CT_AUDIO:
			if (GetTimeMode(fg) != TIMEMODE_ABSTIME)
d2547 20
a2566 7
				if (!Cutting2Music)
				{
					time = GetStartTimeInSequence((struct FastGadget *)fg);	// Lock where it's at now
					DUMPUDECL("(locked at ",time,")\\");
				}
				PutDelay(fg,time);		// Set absolute start time
				PutTimeMode(fg,TIMEMODE_ABSTIME);
d2568 15
a2582 1
			break;
d2584 1
a2584 7
		case CT_VIDEO:
		case CT_STILL:
		case CT_FRAMESTORE:
		case CT_VIDEOANIM:
		case CT_IMAGE:
		case CT_MAIN:
			if ((Cutting2Music) || (GetTimeMode(fg) != TIMEMODE_ABSTIME))
d2586 1
a2586 2
				DUMPMSG("Locked!");
				if (!Cutting2Music)
d2588 45
a2632 2
					time = GetStartTimeInSequence((struct FastGadget *)fg);	// Lock where it's at now
					DUMPUDECL("(locked at ",time,")\\");
a2633 7
				PutDelay(fg,time);						// Set absolute start time
				PutTimeMode(fg,TIMEMODE_ABSTIME);		// Lock video
			}
			else
			{
				DUMPMSG("Unlocked!");
				PutTimeMode(fg,TIMEMODE_RELCLIP);		// Unlock video
a2634 1
			break;
d3650 14
a3663 1
	if (BuildSeq(&sv,SeqStartFG))		// Build entire project
d3692 1
a3692 1
			CutToMusic(&sv);
d3734 1
a3734 1
	Cutting2Music = FALSE;
@


2.90
log
@Overhauled Play-From, builds entire project then trims it down
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.89 1995/06/20 23:48:24 Flick Exp Flick $
d5 3
d342 1
d497 1
d502 3
d508 1
d531 1
a531 1
extern char InternalErrorDetails[];
d537 2
d691 18
d711 4
d754 1
a754 1
//	DUMPUDECL ("~~~~~~~~ ERROR ",error," ~~~~~~~~\\");
d758 1
a758 1
		sprintf(InternalErrorDetails,"   Alcatraz Meditation Number %d",sv->AuxError);
d933 1
a933 1
	LONG	vidtime,abstime,maxtime,duration,start;
d937 1
a937 1
	vidtime = maxtime = 0;
d973 1
a973 1
				start = GetRefTime(vidtime,PrevVidFG,fg);
d977 1
a977 1
				start = 0;
d987 2
d997 1
d1002 1
d1028 1
d1036 3
a1038 2
		DUMPUDECL("   Start ",start,"\\");
		DUMPUDECL("   VidTime ",vidtime,"\\");
d1049 73
d1233 2
a1234 1
	LONG EndOfVideo, vstartfld, audlength, astartfld, fudge;
d1239 1
a1239 1
//	char *MPtr[3],scratch[80];
d1482 1
a1482 1
				// Trim audio event and add to audio track (trim to StartTime/EndTime)
d1931 35
a1965 30
				astartfld = GetAudioStart(FG);
				audlength = GetAudioDuration(FG);
				vstartfld = CurVidEvent->StartField;

				// Calculate when the audio should start
				gotime = CurVidEvent->Time + astartfld-vstartfld;

				// Ensure natural audio does not fall outside sequencing time period
				if ((gotime + audlength) <= sv->StartTime)		// No audio reaches start time?
					audlength = 0;
				else if (gotime >= sv->EndTime)					// No audio begins in time?
					audlength = 0;
				else
				{
					// If audio starts before start time, crop off front
					if (gotime < sv->StartTime)
					{
						astartfld += sv->StartTime - gotime;		// crop audio to starttime
						audlength -= sv->StartTime - gotime;		// shorten by same amount
						gotime = sv->StartTime;						// Start immediately
					}

					// If audio extends past end of sequence, crop off rear
					if ((gotime+audlength) > sv->EndTime)
						audlength = sv->EndTime - gotime;
				}

				// Stash trimmed natural audio parameters
				CurVidEvent->AudStart = astartfld;
				CurVidEvent->AudLength = audlength;
d2020 2
a2021 2
//		sprintf(scratch," Warning!  Sequencer inserted black at %d place(s) ",sv->InsMattes);
//		MPtr[0] = scratch;
d2086 3
a2122 2
	SetRunningTime(sv->SeqPlayTime);				// Put total time up (of part to play)

d2153 2
d2234 15
a2248 1
		if (sv->AuxError != FERR_OKAY)
d2256 11
a2266 2
	// Show Flyer output B (so FX from black to 1st video will work)
	FlyerChanOnMain(1);
d2378 150
d2535 1
a2535 1
	BOOL		killit;
d2563 2
d2576 7
d2761 1
a2761 1
	char *MPtr[3],scratch[80];
d2766 2
a2767 2
		sprintf(scratch," Warning!  Sequencer inserted black at %d place(s) ",sv->InsMattes);
		MPtr[0] = scratch;
d2807 16
d2869 1
a2869 1
	LONG	fxlen,fxadvance, fudge, V2end;
d3060 3
a3062 1
				if ((GetAdjVideoDuration(V1FG) + V1event->StartField) > GetRecFields(V1FG))
d3065 1
d3087 1
d3251 1
a3251 1
	LONG	endofprev;
d3253 2
d3301 47
a3459 1
	BOOL	partial;
d3462 9
a3470 1
	partial = FALSE;			// Assume play entire sequence
d3474 1
a3474 1
	if ((CurFG) && (IntuiMsg))
d3476 9
a3484 4
		if (((struct Gadget *)IntuiMsg->IAddress)->GadgetID == ID_PLAY_PART)
			partial = TRUE;
		else
			partial = FALSE;
d3486 2
a3487 2
		/* TAB/SHIFT-TAB detector */
		if (IntuiMsg->Class == IDCMP_RAWKEY)
d3489 4
a3492 2
			if (IntuiMsg->Qualifier&(IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
				partial = TRUE;
d3494 1
a3494 1
				partial = FALSE;
d3498 6
d3508 1
a3508 1
	if (partial)
a3517 7
	// Setup SeqVars structure
	memset(&sv, 0, sizeof(struct SeqVars));
	sv.Edit = Edit;
	sv.EditTop = EditTop;

//	DUMPHEXIL("Edit=",(LONG)Edit,"  ");
//	DUMPHEXIL("EditTop=",(LONG)EditTop,"\\");
d3521 10
a3530 6
	// Calculate times to clip our play within (SeqStartFG = time 0)
	if (partial)
		sv.StartTime = TimeBetweenFGs(SeqStartFG, firstFG);
	else
		sv.StartTime = 0;
	sv.EndTime = 0x7FFFFFFF;		// Don't clip end times
a3531 2
	DUMPUDECL ("starttime = ",sv.StartTime,"\\");
	DUMPUDECL ("endtime = ",sv.EndTime,"\\");
d3533 3
a3535 3
	/*** Calculate total running time from start crouton to end ***/
	sv.SeqTotalTime = TimeBetweenFGs(SeqStartFG,NULL);
	sv.SeqPlayTime = sv.SeqTotalTime - sv.StartTime;
d3539 16
a3554 1
		if (partial)
d3557 11
a3567 2
		if (DoWarnings(&sv))
			PlayCurSeq(&sv);
a3577 1
	DisplayMessage(NULL);			// Remove any message at top of screen
d3608 2
d3894 1
d3898 2
d3907 8
@


2.89
log
@Total overhaul!  Separate Switcher/Flyer/Audio tracks, downloads Flyer & Audio
tracks to Flyer to run in parallel.  Have lock-down and black insertion,
double-punch keys, dangling effects, and "prog time" audio all working well.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.88 1995/04/28 09:31:18 pfrench Exp Flick $
d5 5
d331 1
a331 1
extern BOOL Wait4LRMB(void);	/* toastsupport.a */
d335 1
d394 3
a396 1
#define FLAGS2B_MATTE		4		/* System-inserted matte */
d403 2
d483 1
a483 1
//	struct EditWindow *Edit;
d495 2
a503 4
//#define FGC_SELECT 2
//#define FGC_TOMAIN 33
//#define FGC_QUEUE 38

d545 1
a545 1
static LONG SequenceTotalVideoTime(struct ExtFastGadget *fg);
d547 6
a552 3
static struct ExtFastGadget *StartingVideoEvent(struct ExtFastGadget *firstFG);
static struct EditWindow *DoSeqPlay(struct EditWindow *Edit, struct IntuiMessage *IntuiMsg,
	struct ExtFastGadget *firstFG);
d557 1
a557 1
static BOOL AppendBlack(struct SeqVars *sv, LONG time, WORD flychan);
d569 1
a569 1
static ULONG DownLoadFlyerTrack(struct Track *track, UBYTE tracktype);
d646 4
a649 1
			time = reftime + delay - GetStartField(FGlastVid);
d721 2
d898 1
a898 2
	struct ExtFastGadget *fg;
	struct ExtFastGadget *PrevVidFG;
d900 1
a900 5
	LONG	vidtime,time,abstime,maxtime,endtime,duration;
	BOOL	checkabs;

//	if (EndFG == NULL)
//		return(0);
d904 1
a904 2
	fg = StartFG;
	vidtime = time = maxtime = 0;
d906 1
a906 1
	while (fg && (fg != EndFG))
d913 1
a913 4
		abstime = 0;

		checkabs = FALSE;

d921 1
d923 3
d928 25
a952 2
				if (abstime > vidtime)			// Skip time forward to locked crouton?
					vidtime = abstime;
d954 8
a961 3
				vidtime += GetDuration(fg);
				time = vidtime;
				PrevVidFG = fg;
d965 1
a965 1
				vidtime += GetNumFields(fg);
a968 1
				time = GetRefTime(vidtime,PrevVidFG,fg);
a969 1
				checkabs = TRUE;
a972 1
				time = GetRefTime(vidtime,PrevVidFG,fg);
a973 1
//				checkabs = TRUE;
d977 1
a977 3
				time = GetRefTime(vidtime,PrevVidFG,fg);
				duration = 0;
//				checkabs = TRUE;
d983 1
a983 3
				time = GetRefTime(vidtime,PrevVidFG,fg);
				duration = 0;			//???
//				checkabs = TRUE;
a986 1
				time = GetRefTime(vidtime,PrevVidFG,fg);
a987 1
//				checkabs = TRUE;
d994 3
a996 14
		if (checkabs)
		{
			// Also include absolute non-video stuff in total program time
			if (timemode==TIMEMODE_ABSTIME)
			{
				endtime = GetDelay(fg) + duration;
				if (endtime > maxtime)
					maxtime = endtime;
			}
		}

		// Include latest video in total program time
		if (time > maxtime)
			maxtime = time;
d998 1
a998 1
		DUMPUDECL("   Time ",time,"\\");
a999 1
		DUMPUDECL("   AbsTime ",abstime,"\\");
a1000 3

//		fg = (struct ExtFastGadget *)(fg->FG.NextGadget);
		fg = GetNextGadget(fg);
d1003 3
a1005 10
	if (EndFG)
	{
		DUMPUDECL("*** Final Time ",time,"\\");
		return(time);			// Start time of FG
	}
	else
	{
		DUMPUDECL("*** Final MaxTime ",maxtime,"\\");
		return(maxtime);		// Total program time
	}
d1016 1
a1016 1
	struct ExtFastGadget	*first;
d1019 2
a1020 2
	if (PtrProject && (first = *PtrProject))
		return(TimeBetweenFGs(first, (struct ExtFastGadget *)FG));
d1027 2
a1028 2
// SequenceTotalVideoTime
//		Video Duration from current crouton upto end of Sequence.
d1031 8
a1038 12
static LONG SequenceTotalVideoTime(struct ExtFastGadget *fg)
{
	if (SeqStartFG==NULL)	//GLOBAL
		return(0L);

	// If no specific start crouton, start at beginning of active portion
	if (fg==NULL)
		fg = SeqStartFG;

//	return(TotalVideoTime(fg, NULL, TRUE));
	return(TimeBetweenFGs(fg, NULL));
}
d1075 12
a1086 12
static struct ExtFastGadget *StartingVideoEvent(struct ExtFastGadget *firstFG)
{
	struct ExtFastGadget *StartFG, *FG, *VidFG=NULL;

/*** Start from previous video event (if not currently on one) ***/
	if (SeqStartFG)	//GLOBAL
	{
		if (firstFG)
			StartFG=(struct ExtFastGadget *)firstFG;
		else
			StartFG = SeqStartFG;

d1102 4
a1105 4
		return(StartFG);
	}
	return(NULL);
}
d1109 3
a1111 2
// DoSeqPlay
//		This is the big one!
d1113 2
a1114 3
static struct EditWindow *DoSeqPlay(	struct EditWindow *Edit,
													struct IntuiMessage *IntuiMsg,
													struct ExtFastGadget *firstFG)
a1115 2
	struct SeqVars sv;
	struct PlaySeqInfo SeqInfo;
d1118 1
a1118 1
	struct ExtFastGadget *FG, *FG2, *PrevVidFG, *EffectFG;
d1120 1
a1120 1
	LONG totalrunningtime,ProgTime,PrevProgTime, gotime, reftime;
d1122 1
a1122 1
	UWORD PreviousTrack=CRTN_NONE;
d1124 1
a1124 2
	UWORD	error;
	BOOL	flag;
d1126 1
a1126 1
	char *MPtr[3],scratch[80];
a1128 10
	// Setup SeqVars structure
	memset(&sv, 0, sizeof(struct SeqVars));
//	sv.Edit = Edit;
	sv.EditTop = EditTop;

//	DUMPHEXIL("Edit=",(LONG)Edit,"  ");
//	DUMPHEXIL("EditTop=",(LONG)EditTop,"\\");

	Edit->ew_OptRender = TRUE;    // ???

d1132 3
a1134 3
	PrepareTrack(&sv.SwitcherTrack,TRACK_SWITCHER);
	PrepareTrack(&sv.VideoTrack,TRACK_FLYVID);
	PrepareTrack(&sv.AudioTrack,TRACK_AUDIO);
d1137 1
a1137 1
	sv.Pos = 0;
d1140 2
a1141 2
	if ((!firstFG) && (!SeqStartFG))
		return(Edit);
d1145 2
a1146 11
	/*** Locate the most recent video event at or before start crouton ***/
	if (!(FG=StartingVideoEvent(firstFG)))
	{
		// Can't sequence, no previous video events
/*?*/	error = SEQERR_NeedsPrevVideo;
		FG = (struct ExtFastGadget *)CurFG;
		sv.Pos = -1;									// Find it for me
		goto Abort;
	}

//	if (GetNumberOfCroutons(&CroutonCount, FG))		// Count crouton types (got some?)
d1148 6
d1155 1
a1155 5
//			// Not enough memory to play this sequence!
//			error = SEQERR_OutOfMemory;
//			FG = (struct ExtFastGadget *)CurFG;
//			sv.Pos = -1;
//			goto Abort;
d1157 1
d1159 11
a1169 1
		DUMPMSG	("-------------- DoSeqPlay ----------------");
d1171 1
a1171 2
		// Select internal default effect (fade)
		SendSwitcherReply(ES_SelectDefault,NULL);
a1172 3
		// Put up matte black if showing a Flyer video output
		// This is no longer needed, as the sequence processing glitch is gone
//		Main2Blank();
d1174 3
a1176 2
		// Send abort to Flyer/abort previous sequence(???)
		SendSwitcherReply(ES_Stop,NULL);
d1178 2
a1179 2
		/*** Calculate total running time from start crouton to end ***/
		totalrunningtime = SequenceTotalVideoTime(firstFG);
d1181 4
a1184 1
		DisplayMessage("Processing Sequence");
d1186 4
a1189 11
//		// Do a take right at the beginning
//		if ((event = GetEvent())==NULL)
//		{
//			error = SEQERR_OutOfMemory;
//			goto Abort;
//		}
//		event->FG = SeqStartFG;
//		event->CurrentPosition = 0;
//		event->FGCcommand = FGC_TOMAIN;
//		event->Time = 0;
//		AppendToTrack(&sv.SwitcherTrack,event);		// Tack on end of track
d1191 1
a1191 1
		sv.FlyChan = 0;
d1193 4
a1196 3
//***********************************************************************
//********* Pre-Q previous events that occured before Sequence point
//***********************************************************************
d1198 2
a1199 1
		FG2 = SeqStartFG;
d1201 5
a1205 3
		// Calculate times to clip our play within (relative to start of total project)
		sv.StartTime = TimeBetweenFGs(FG2, FG);
		sv.EndTime = sv.StartTime + totalrunningtime;
d1207 5
a1211 2
		DUMPUDECL ("starttime = ",sv.StartTime,"\\");
		DUMPUDECL ("endtime = ",sv.EndTime,"\\");
d1213 3
a1215 6
		ProgTime = PrevProgTime = 0;
		PrevVidFG = NULL;

		while(FG2 != FG)
		{
			switch(FG2->ObjectType)
d1217 1
a1217 2
			case CT_AUDIO:
				DUMPMSG("Pre-Q Audio");
d1219 1
a1219 1
				if (HasAudio(FG2) && PrevVidFG)
d1221 4
a1224 2
					// Calculate when the audio should start
					gotime = GetRefTime(PrevProgTime,PrevVidFG,FG2);
d1226 4
a1229 8
					// Trim audio event and add to audio track (trim to StartTime/EndTime)
					DoAudioCrouton(
						&sv,
						FG2,				// FastGadget
						gotime,			// Desired start time
						sv.Pos				// Crouton position
					);
				}
d1231 7
d1239 5
a1243 3
			case CT_VIDEO:
				// Our goal here is to watch for video clips that might have audio
				// that extends past the start time
d1245 30
a1274 1
				// Should we also play a fragment of the video if it extends as well???
d1276 3
a1278 2
				vstartfld = GetStartField(FG2);
				astartfld = GetAudioStart(FG2);
d1280 3
a1282 27
				if (HasAudio(FG2))
				{
					// Calculate when the natural audio should start
					gotime = ProgTime + astartfld - vstartfld;

					// Trim audio event and add to audio track (trim to StartTime/EndTime)
					DoAudioCrouton(
						&sv,
						FG2,				// FastGadget
						gotime,			// Desired start time
						sv.Pos				// Crouton position
					);

				}

			case CT_FRAMESTORE:
			case CT_VIDEOANIM:
			case CT_MAIN:
			case CT_IMAGE:
			case CT_STILL:
					PrevVidFG = FG2;						// Audio clips may reference this
					PrevProgTime = ProgTime;		// Ditto

					if (FG2->ObjectType != CT_VIDEOANIM)
						ProgTime += GetDuration(FG2);
					else
						ProgTime += GetNumFields(FG2);
d1284 1
d1286 3
a1288 10
// These are too hard to start mid-transition, so I won't!!!
//			case CT_REXX:
//			case CT_KEY:		//Could maybe do this one?
//			case CT_SCROLL:
//			case CT_CRAWL:
//			case CT_KEYEDANIM:
//			case CT_FXCR:
//			case CT_CONTROL:

			default:
d1292 3
a1294 24
			FG2 = (struct ExtFastGadget *)(FG2->FG.NextGadget);
			sv.Pos++;
		}

//****************************************************************
//********* Q events that occured at or after Sequence point
//****************************************************************

		ProgTime = 0;
		PrevVidFG = NULL;

		// Signify that we'll need a take to start sequence, unless we get an effect
		EffectFG = NULL;
		EffectPos = -1;
//		takeneeded = TRUE;

		while (FG)
		{
			DUMPMSG("--------------------------------------");
			DUMPUDECL("Crouton #",sv.Pos," = ");

			fudge = 0;			// None yet

			switch(FG->ObjectType)
d1296 1
a1296 5
			case CT_FXCR:
				DUMPMSG("ChromaFX CROUTON");

				// Funny, this only does a select, no TOMAIN, and it -of course- doesn't
				// have any remove
d1298 1
a1298 1
				if (PreviousTrack==CRTN_NONE)
d1300 1
a1300 1
					error = SEQERR_CrFXAtStart;	// Can't start with ChromaFX
d1303 1
d1305 4
a1308 67
				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_CrFXAfterEffect;	// ChromaFX can't follow Effects croutons
					break;
				}

				if (PrevVidEvent)
					reftime = PrevVidEvent->Time;
				else
				{
					reftime = 0;		// Meaningless, but at least consistent

					if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
					{
						error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
						break;
					}
				}

				// Get event for SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
//				// CRFX select sets up on preview, so switch current source to PRVW, then take it
//				event->FG = PrevVidEvent->FG;
//				event->CurrentPosition=PrevVidEvent->CurrentPosition;
//				event->FGCcommand = FGC_TOPRVW;
//				event->Time = ProgTime+8;
//				DUMPUDECL("**CRFX Prev.Src ToPrvw: at ",event->Time," \\");

				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				event->FGCcommand = FGC_SELECT;
				event->Time = 0; 								// as soon as possible
				AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track

				// Get event for REMOVE
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
//				event->FG = PrevVidEvent->FG;
//				event->CurrentPosition=PrevVidEvent->CurrentPosition;
////			event->FG = FG;
////			event->CurrentPosition=sv.Pos;
//				event->FGCcommand = FGC_TAKE;
//				event->Time = GetRefTime(reftime,PrevVidFG,FG);
//				DUMPUDECL("**CRFX Take: at ",event->Time," \\");

				// Remove Key Event, this MUST have its time adjusted if another event
				// happens before it is due to end... AC
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				event->FGCcommand = FGC_REMOVE;
				// Set default duration, though should be shortened if another event steps on it
				event->Time = GetRefTime(reftime,PrevVidFG,FG) + GetDuration(FG);
				AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track

				DUMPUDECL("**CRFX Remove: at ",event->Time," \\");
				KeyKill = event;

//				PreviousFG = FG;
//				PreviousPos = sv.Pos;
				PreviousTrack = CRTN_KEY;
d1310 13
d1325 2
a1326 2
			case CT_REXX:
				DUMPMSG("ARexx CROUTON");
d1328 3
a1330 1
				if (PreviousTrack==CRTN_NONE)
d1332 1
a1332 1
					error = SEQERR_ARexxAtStart;		// Can't start with Arexx
d1336 11
a1346 5
				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_ARexxAfterEffect;	// Arexx cannot follow Effects croutons
					break;
				}
d1349 1
d1351 2
d1359 1
a1359 1
						error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
d1364 2
a1365 13
				// Get event for SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				event->FGCcommand = FGC_SELECT;
				// ARexx will start at this time
				event->Time = GetRefTime(reftime,PrevVidFG,FG);
				event->TimeTolerance = AREXXTOLERANCE;		// Allow for some error !!!
				AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track
d1367 1
a1367 4
//				PreviousFG = FG;
//				PreviousPos = sv.Pos;
				PreviousTrack = CRTN_AREXX;
				break;
d1369 7
a1375 3
//----------------------------------------------------------------------
			case CT_AUDIO:
				DUMPMSG("AUDIO CROUTON");
d1377 3
a1379 9
				if (HasAudio(FG))		// Audio Volume might be zero
				{
					if (!FlyerBase)
					{
						error = SEQERR_AudioNeedsFlyer;	// Can't play audio without a Flyer
						break;
					}

//					if (PreviousTrack==CRTN_NONE)
d1381 2
a1382 1
//						error = SEQERR_AudioAtStart;		// Can't start with audio clip
d1386 2
a1387 1
//					if (PreviousTrack==CRTN_TRANS)
d1389 2
a1390 1
//						error = SEQERR_AudioAfterEffect;	// Audio Clips cannot follow Effects
d1394 2
a1395 8
					if (PrevVidEvent)
					{
						reftime = PrevVidEvent->Time;
//						reftime = PrevVidTime;
					}
					else
					{
						reftime = 0;		// Meaningless, but at least consistent
d1397 4
a1400 6
						if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
						{
							error = SEQERR_AudioNeedsVideo;	// Needs video to ref to
							break;
						}
					}
d1402 1
a1402 2
					// Calculate when the audio should start
					gotime = GetRefTime(reftime,PrevVidFG,FG);
d1404 5
a1408 7
					// Trim audio event and add to audio track (trim to StartTime/EndTime)
					event = DoAudioCrouton(
						&sv,
						FG,				// FastGadget
						gotime,			// Desired start time
						sv.Pos				// Crouton position
					);
d1410 5
a1414 8
//					if (event)
//					{
//						if (event->Time < PreviousEndOfEffect)
//						{
//							//Please put this clip after an earlier video event
///*?*/					error = SEQERR_AudioUnsorted;
//							break;
//						}
d1416 3
a1418 16
//***!! This check isn't really important unless we want to keep the croutons in order!
//						if (event->Time < PreviousAudioStartTime)
//						{
//							//Audio crouton should be moved earlier in the project
///*?*/					error = SEQERR_AudioUnsorted;
//							break;
//						}

//						PreviousAudioStartTime = event->Time;	// NOT CURRENTLY USED!
//					}

//					PreviousFG = FG;
//					PreviousPos = sv.Pos;
					PreviousTrack = CRTN_AUDIO;
				}

d1420 1
d1422 5
a1426 5
//----------------------------------------------------------------------
			case CT_SCROLL:
			case CT_CRAWL:
			case CT_KEYEDANIM:
				DUMPMSG("SCROLL/CRAWL CROUTON");
d1428 1
a1428 1
				if (PreviousTrack==CRTN_NONE)
d1430 1
a1430 1
					error = SEQERR_KeyAtStart;		// Can't start with a CG page
d1433 1
d1435 2
a1436 5
				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_KeyAfterEffect;	// CG pages cannot follow Effects croutons
					break;
				}
d1438 2
a1439 5
				if (PrevVidEvent)
					reftime = PrevVidEvent->Time;
				else
				{
					reftime = 0;		// Meaningless, but at least consistent
a1440 6
					if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
					{
						error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
						break;
					}
				}
d1442 18
a1459 2
				// Find desired overlay start time
				gotime = GetRefTime(reftime,PrevVidFG,FG);
d1461 13
a1473 2
				DUMPUDECL("RefTime = ",reftime," ");
				DUMPUDECL("GoTime = ",gotime," \\");
d1475 4
d1480 8
a1487 18
				// Get event for SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				event->FGCcommand = FGC_SELECT;
				event->Time = 0;								//as soon as possible
				// Wants a double-punch (take and overlay at same time)?
				if (gotime < (reftime+ILBMPREROLLFUDGE))
					setchan = AppendSelect(&sv.SwitcherTrack,event);	// Insert near end of track
				else
				{
					AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track
					setchan = -1;
				}
d1489 1
a1489 13
				// Get event for TOMAIN
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				if (setchan >= 0)
				{
					event->Channel = setchan;
					event->Flags1 |= FLAGS1F_SETCHAN;
				}
d1491 2
a1492 4
//				if (setchan >= 0)
//					event->FGCcommand = FGC_TAKE;
//				else
					event->FGCcommand = FGC_TOMAIN;
d1494 5
a1498 4
				event->TimeTolerance = SCRAWLKEYANIMTOLERANCE;		//allow for some error !!!
				// 1st field of scroll/crawl/key will start at this time
				event->Time = gotime;
				AppendToTrack(&sv.SwitcherTrack,event);			// Tack on end of track
d1500 1
a1500 3
//				PreviousFG = FG;
//				PreviousPos=sv.Pos;
				PreviousTrack=CRTN_SCRAWL;
d1502 3
d1506 1
d1508 5
a1512 2
//----------------------------------------------------------------------
			case CT_KEY:
a1513 5
///*?*/		error = SEQERR_KeyedUnsorted;			// Keyed crouton in wrong order.  Move earlier in the project.
///*?*/		error = SEQERR_KeyedDuringEffect;	// Keyed crouton can't start until previous Effect has finshed.
///*?*/		error = SEQERR_KeyedTooSoon;			// Keyed crouton can't start before the clip.  Use a later start time.
///*?*/		error = SEQERR_KeyedStartBad;			// Keyed crouton can't start after the clip.  Use an earlier start time.
///*?*/		error = SEQERR_KeyedOverlapsKey;		// Keyed crouton can't start until previous Key has finished.
d1515 5
a1519 1
				DUMPMSG("KEY CROUTON or CRFX");
d1521 1
a1521 1
				if (PreviousTrack==CRTN_NONE)
d1523 1
a1523 1
					error = SEQERR_KeyedAtStart;	// Can't start with key
d1526 1
d1528 2
a1529 5
				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_KeyedAfterEffect;	// Key pages cannot follow effects
					break;
				}
d1531 2
d1534 5
a1538 21
				if (PrevVidEvent)
					reftime = PrevVidEvent->Time;
				else
				{
					reftime = 0;		// Meaningless, but at least consistent

					if (GetTimeMode(FG)!=TIMEMODE_ABSTIME)
					{
						error = SEQERR_OlayNeedsVideo;	// Needs video to ref to
						break;
					}
				}

				// Find desired overlay start time
				gotime = GetRefTime(reftime,PrevVidFG,FG);

				DUMPUDECL("RefTime = ",reftime," ");
				DUMPUDECL("GoTime = ",gotime," \\");

//				// Wants a double-punch (take and overlay at same time)?
//				if (gotime == reftime)
d1540 7
a1546 2
//					event = (struct Event *)RemTail(&sv.SwitcherTrack.EventList);
//					if (event)
d1548 2
a1549 11
//						if ((event->FGCcommand == FGC_TOMAIN) && (FLAGS1F_SETCHAN & event->Flags1))
//						{
//							sv.SwitcherTrack.EventCount--;				// Killed previous event
//							setchan = event->Channel;		// Get channel to take to
//							FreeMem(event, sizeof(struct Event));
//						}
//						else
//						{
//							// Oops! Add back in
//							AddTail(&sv.SwitcherTrack.EventList, (struct Node *)event);
//						}
d1552 1
d1554 10
a1563 10
				// Get event for SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				event->FGCcommand = FGC_SELECT;
				event->Time = 0;	//as soon as possible
d1565 8
a1572 8
				// Wants a double-punch (take and overlay at same time)?
				if (gotime < (reftime+FRAMEPREROLLFUDGE))
					setchan = AppendSelect(&sv.SwitcherTrack,event);	// Insert near end of track
				else
				{
					AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track
					setchan = -1;
				}
d1574 13
a1586 13
				// Get event for AUTO/TOMAIN
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				if (setchan >= 0)
				{
					event->Channel = setchan;
					event->Flags1 |= FLAGS1F_SETCHAN;
				}
d1588 2
a1589 2
				if (setchan >= 0)
					event->FGCcommand = FGC_TAKE;
d1591 2
a1592 2
				else if(GetFadeInDuration(FG))
					event->FGCcommand = FGC_AUTO;
d1594 6
a1599 5
				else
					event->FGCcommand = FGC_TOMAIN;
				// 1st field of key will start at this time
				event->Time = gotime;
				AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track
d1601 1
a1601 1
				DUMPUDECL("**Key ToMain: at ",event->Time," \\");
d1603 10
a1612 10
				// Get event for REMOVE
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				// Remove Key Event, this MUST have its time reset, if another event happens
				// before it is due to end
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
d1614 3
a1616 3
//				if(GetFadeInDuration(FG))
					event->FGCcommand = FGC_AUTO;
//				else
d1618 10
a1627 3
//					event->FGCcommand = FGC_REMOVE;
				event->Time = GetRefTime(reftime,PrevVidFG,FG) + GetDuration(FG);
				AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track
d1629 1
a1629 6
				DUMPUDECL("**Key Remove: at ",event->Time," \\");
				KeyKill = event;

//				PreviousFG = FG;
//				PreviousPos = sv.Pos;
				PreviousTrack = CRTN_KEY;
a1630 2
				break;

d1633 4
a1636 4
			case CT_FXANIM:
			case CT_FXILBM:
			case CT_FXALGO:
				DUMPMSG("FXANIM/ILBM/ALGO CROUTON");
d1638 1
a1638 1
//				takeneeded = FALSE;			// No implied TAKE on next video
d1641 5
a1645 5
//				if (!GetNextGadget(FG))
//				{
//					error = SEQERR_EffectAtEnd;	// Can't end sequence with an Effect.
//					break;
//				}
d1648 5
a1652 5
//				if (PreviousTrack==CRTN_NONE)
//				{
//					error = SEQERR_EffectAtStart;	// Can't start with an effect
//					break;
//				}
d1655 1
a1655 1
// 			case CT_VIDEOANIM:
d1657 5
a1661 5
				if (PreviousTrack==CRTN_TRANS)
				{
					error = SEQERR_EffectAfterEffect;	// Can't sequence two Effects in a row
					break;
				}
d1663 1
a1663 1
/*?*/			//	error = SEQERR_EffectDuringKeying;	// Effect not allowed during keying.
d1665 2
a1666 2
				EffectFG = FG;
				EffectPos = sv.Pos;
d1668 4
a1671 4
//				PreviousFG = FG;
//				PreviousPos = sv.Pos;
				PreviousTrack = CRTN_TRANS;  //**!! NOT REALLY IF VIDEOANIM
				break;
d1675 12
a1686 2
			case CT_VIDEO:
			case CT_STILL:
d1688 4
a1691 2
				DUMPSTR("VIDEO OR FLYERSTILL CROUTON  ");
				DUMPMSG((char *)FG->FileName);
d1693 2
a1694 1
				if (!FlyerBase)
d1696 2
a1697 3
					// Can't play video clips without a Flyer
					error = SEQERR_VideoNeedsFlyer;
					break;
d1699 1
d1701 11
a1711 4
				// If this is locked down, move to that time
				if (GetTimeMode(FG) == TIMEMODE_ABSTIME)
				{
					ProgTime = GetDelay(FG);
d1713 4
a1716 7
					// If previous video does not reach here, insert black
					if (PrevVidEvent)
					{
						if (!MaybeInsertBlack(&sv,PrevVidEvent,ProgTime))
							goto Abort;
					}
				}
d1718 2
a1719 11
				// Get event for video SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
				event->Flags1 = FLAGS1F_SETCHAN;	// Indicate we need FX to this to set chan
				// Assign alternating channels to each clip/still
				event->Channel = sv.FlyChan;
				DUMPUDECL("Assigned to channel ",sv.FlyChan,"\\");
				sv.FlyChan = 1-sv.FlyChan;
d1721 1
a1721 4
				if (FG->ObjectType == CT_VIDEO)
				{
					event->StartField = GetStartField(FG);
					PutAdjVideoStart(FG,event->StartField);
d1723 1
a1723 2
//					DUMPUDECL	("Assume InPoint=",event->StartField,"\\");
				}
d1725 2
a1726 1
				fudge = VIDEOPREROLLFUDGE;
d1728 1
a1728 1
//				FinalClip=event;		// UNUSED NOW
a1729 2
				// This assumes a Take to bring in this video.  If this actually transitions
				// in, then some values must be adjusted.
d1731 5
a1735 1
				goto VideoMerge;		// Continue with logic for FrameStores et.al.
d1737 2
a1738 4

			case CT_FRAMESTORE:
				// If this is locked down, move to that time
				if (GetTimeMode(FG) == TIMEMODE_ABSTIME)
d1740 2
a1741 8
					ProgTime = GetDelay(FG);

					// If previous video does not reach here, insert black
					if (PrevVidEvent)
					{
						if (!MaybeInsertBlack(&sv,PrevVidEvent,ProgTime))
							goto Abort;
					}
d1743 1
d1745 2
a1746 2
			case CT_VIDEOANIM:		//**!! DOES THIS REALLY BELONG HERE????
			case CT_IMAGE:
d1748 1
a1748 1
				fudge = FRAMEPREROLLFUDGE;
d1750 1
a1750 1
			case CT_MAIN:
d1752 1
a1752 1
				DUMPMSG("FRAMESTORE/VIDEOANIM/MAIN/IMAGE CROUTON");
d1756 6
a1761 6
				// Get event for SELECT
				if ((event = GetEvent())==NULL)
				{
					error = SEQERR_OutOfMemory;
					break;
				}
d1765 16
a1780 11
				// 1st field of video will start at this time (assuming Cut)
				event->Time = ProgTime;
				event->FG = FG;
				event->CurrentPosition = sv.Pos;
				event->FGCcommand = FGC_SELECT;

//				CurVidFG = FG;

				// This assumed value can be altered later if there are video transitions
				event->Duration = GetDuration(FG);
				PutAdjVideoDuration(FG,event->Duration);
d1782 2
a1783 4
				if ((FG->ObjectType==CT_VIDEO) || (FG->ObjectType==CT_STILL))
					SortIntoTrack(&sv.VideoTrack,event);		// Flyer: Sort by time into track
				else
					AppendToTrack(&sv.SwitcherTrack,event);	// Switcher: Tack on end of track
a1784 2
				CurVidEvent = event;
				EndOfVideo = ProgTime + GetDuration(FG);  // Field after the video
d1786 5
d1792 1
a1792 2
				// Can't do takes under keys, so kill key when next event comes up (AC)
				if (PreviousTrack==CRTN_KEY)
d1794 2
a1795 8
					DUMPUDECL("Prev Key End: ",KeyKill->Time,"  ");
					DUMPUDECL("ProgTime: ",ProgTime,"  ");

					if (KeyKill && KeyKill->Time > (ProgTime-fudge))
					{
						// Could this mess with event sort???
						KeyKill->Time=ProgTime-fudge; // a little margin.. necessary???
					}
d1797 1
d1802 8
a1809 8
				if (!HandleTransition(
					&sv,
					ProgTime,			// CutTime
					PrevVidEvent,			// V1
					EffectFG,				// FXFG (will be NULL for cut)
					EffectPos,				// FXpos (or -1 for nut)
					CurVidEvent))			// V2
			 			goto Abort;
d1816 15
a1830 1
				if ((FG->ObjectType==CT_VIDEO) && (HasAudio(FG)))	// Has natural audio enabled?
d1832 2
a1833 13
					astartfld = GetAudioStart(FG);
					audlength = GetAudioDuration(FG);
					vstartfld = CurVidEvent->StartField;

					// Calculate when the audio should start
					gotime = CurVidEvent->Time + astartfld-vstartfld;

					// Ensure natural audio does not fall outside sequencing time period
					if ((gotime + audlength) <= sv.StartTime)		// No audio reaches start time?
						audlength = 0;
					else if (gotime >= sv.EndTime)					// No audio begins in time?
						audlength = 0;
					else
d1835 3
a1837 11
						// If audio starts before start time, crop off front
						if (gotime < sv.StartTime)
						{
							astartfld += sv.StartTime - gotime;		// crop audio to starttime
							audlength -= sv.StartTime - gotime;		// shorten by same amount
							gotime = sv.StartTime;						// Start immediately
						}

						// If audio extends past end of sequence, crop off rear
						if ((gotime+audlength) > sv.EndTime)
							audlength = sv.EndTime - gotime;
d1840 3
a1842 3
					// Stash trimmed natural audio parameters
					CurVidEvent->AudStart = astartfld;
					CurVidEvent->AudLength = audlength;
d1845 5
d1851 5
a1855 1
//				if (FG->ObjectType==CT_VIDEO)					// Special tests for Flyer video
d1857 3
a1859 8
//This makes no sense, since clips should never have a length of 0
//					/*** Check for minimum Video clip length ***/
//					if (GetAdjVideoDuration(FG) < 4)
//					{
//						error = SEQERR_ShortVideo;		// Can't sequence clips this short
//						FG = FG;
//						break;
//					}
d1861 1
d1864 2
a1865 2
				DUMPUDECL	("VIDEO time=",CurVidEvent->Time,"\\");
 				DUMPUDECL	("Assume duration=",GetAdjVideoDuration(FG),"\\");
d1867 1
a1867 1
				ProgTime = EndOfVideo;
d1869 2
a1870 2
				PrevVidEvent	= CurVidEvent;
				PrevVidFG		= FG;
d1872 8
a1879 8
//				PreviousFG		= FG;
//				PreviousPos		= sv.Pos;
				PreviousTrack	= CRTN_VIDEO;

				// Destroy knowledge of effect, implies we need a take if no effect appears
				EffectFG = NULL;
				EffectPos = -1;
//				takeneeded = TRUE;			// If no effect comes along, imply a TAKE
d1881 1
a1881 1
				break;
d1884 6
a1889 1
			default:
d1891 3
a1893 2
				//	Don't recognize this content in a sequence.
				break;
d1895 2
a1896 1
			} // END OF SWITCH
a1897 3
			// If an error code was reported, stop analyzing
			if (error)
				break;
d1899 43
a1941 2
			FG = GetNextGadget(FG);
			sv.Pos++;
a1942 1
		} // END OF WHILE
d1944 6
d1951 1
a1951 2
		/*** Warn user if sequencer inserted black anywhere ***/
		if ((!error) && (sv.InsMattes > 0))
d1953 1
a1953 4
			sprintf(scratch," Warning!  Sequencer inserted black at %d place(s) ",sv.InsMattes);
			MPtr[0] = scratch;
			MPtr[1] = " in this project due to locked video.";
			MPtr[2] = " Select \"cancel\" to abort and highlight each";
d1955 7
a1961 2
			// Put up warning requester, check proceed or cancel
			if (!SeqRequest(&sv,MPtr,3))
d1963 19
a1981 1
				// User cancelled
a1982 1
				flag = FALSE;
d1984 2
a1985 18
				/*** Walk thru list of events and hilite each that caused black insertion ***/
				for (event = (struct Event *)sv.VideoTrack.EventList.lh_Head
				; event->Node.mln_Succ
				; event = (struct Event *)event->Node.mln_Succ)
				{
					if ((FLAGS2F_MATTE & event->Flags2) && (event->CurrentPosition >= 0))
					{
		 				DUMPUDECL("Hiliting ",event->CurrentPosition,"\\");
						// Hilite this crouton
						if (!flag)
						{
							ew_QuickSelect(sv.EditTop,event->CurrentPosition);		// First one
							flag = TRUE;
						}
						else
							ew_MultiSelect(sv.EditTop,event->CurrentPosition);		// all others
					}
				}
d1987 2
a1988 5
				if (flag)
				{
					Edit->ew_OptRender = FALSE;
					UpdateAllDisplay();
				}
a1989 3
				goto Abort;
			}
		}
d1991 1
d1993 1
a1993 5
		// Unless an error occurred, put final transition at end
		if (!error)
		{
			// Create a black event to cut/transition to
			event = CreateBlack(&sv,ProgTime,sv.FlyChan);
d1995 3
a1997 3
			if (event)
			{
				sv.FlyChan = 1-sv.FlyChan;					// Alternate channels
d1999 2
a2000 12
				if (!HandleTransition(
					&sv,
					ProgTime,			// CutTime
					PrevVidEvent,			// V1
					EffectFG,				// FXFG (will be NULL for cut)
					EffectPos,				// FXpos (or -1 for cut)
					event))					// V2 (has no FG associated with it!)
				{
					goto Abort;
				}
			}
		}
d2002 1
a2002 14
		/*** Make "wait" event to take us to the end of the total project ***/
		if (!error)
		{
			if ((event = GetEvent())==NULL)
				error = SEQERR_OutOfMemory;
			else
			{
				event->FG = NULL;
				event->Flags1 = FLAGS1F_WAIT4TIME;		// Control event = wait for time
//				event->Time = ProgTime;						// Time = end of project
				event->Time = totalrunningtime;			// Time = end of project
				AppendToTrack(&sv.SwitcherTrack,event);	// Tack on end of track
			}
		}
d2004 1
a2005 2
		if (error)
			goto Abort;
d2007 1
d2009 3
a2011 3
//**********************************************************
//************** Start of post processing ******************
//**********************************************************
d2013 2
a2014 19
//*** No longer instruct Flyer about Head definition/creation, we let it do that now ***
//		sv.AuxError = SendSwitcherReply(ES_EndHeadList,NULL);
//		DUMPHEXIL("EndHeadList error=",sv.AuxError,"\\");
//		if(sv.AuxError == 9)		// Tie into FERR_NOAUDIOCHAN!
//		{
//			// Unable to create heads of strip audio
///*?*/	error = SEQERR_NoAudioDrive;
//			FG = (struct ExtFastGadget *)CurFG;
//			sv.Pos = -1;							// Find it for me
//			goto Abort;
//		}
//		else if (sv.AuxError)		// Will be FERR_FULL ($21) when full, handle any other non-0 as well!
//		{
//			// Unable to create heads of strip audio
///*?*/	error = SEQERR_ABrollFull;
//			FG = (struct ExtFastGadget *)CurFG;
//			sv.Pos = -1;					// Find it for me
//			goto Abort;
//		}
d2017 9
a2025 2
//		if (FinalClip)
//			FinalClip->Flags1 |= FLAGS1F_LASTEVENT;
d2027 2
d2030 3
a2032 1
#ifdef	SERDEBUG
d2034 2
a2035 1
		// Dump contents of each track
d2037 3
a2039 3
		ListTrack(&sv.SwitcherTrack,TRACK_SWITCHER);
		ListTrack(&sv.VideoTrack,TRACK_FLYVID);
		ListTrack(&sv.AudioTrack,TRACK_AUDIO);
d2041 19
a2059 2
		DUMPMSG("******************************************");
#endif
d2061 3
a2063 3
//		if (sv.AudioTrack.EventList)
//		{
//			sv.AudioTrack.EventPtr->FG = NULL;		// Put an end on it
d2066 6
a2071 6
//			DUMPMSG("---- Unsorted AudEvents ----");
//			for (sv.Pos=0 ; sv.Pos<sv.AudioTrack.EventCount ; sv.Pos++)
//			{
//				DUMPMEM("AudEvent",(UBYTE *)(sv.AudioTrack.EventList+sv.Pos),sizeof(struct Event));
//			}
//			DUMPMSG("**************************************");
d2074 2
a2075 2
//			// Sort events by time
//			SortEvents(sv.AudioTrack.EventList,(ULONG)sv.AudioTrack.EventCount);
d2079 6
a2084 6
//			DUMPMSG("---- Sorted AudEvents ----");
//			for (sv.Pos=0 ; sv.Pos<sv.AudioTrack.EventCount ; sv.Pos++)
//			{
//				DUMPMEM("AudEvent",(UBYTE *)(sv.AudioTrack.EventList+sv.Pos),sizeof(struct Event));
//			}
//			DUMPMSG("**************************************");
d2086 1
a2086 1
//		}
d2088 5
a2092 5
		SetRunningTime(totalrunningtime);				// Put total time up


		// Download Flyer events to Flyer
		if (FlyerBase)
d2094 3
a2096 2
			sv.AuxError = NewSequence(0);				// Prepare Flyer for sequence download
			if (sv.AuxError==FERR_OKAY)					// Can we proceed to download?
d2098 2
a2099 17
				DUMPMSG("Downloading video track...");
				sv.AuxError = DownLoadFlyerTrack(&sv.VideoTrack,TRACK_FLYVID);	// Send video events
				if (sv.AuxError==FERR_OKAY)
				{
					DUMPMSG("Downloading audio track...");
					sv.AuxError = DownLoadFlyerTrack(&sv.AudioTrack,TRACK_AUDIO);	// Send audio events
				}

				// Should we allow Flyer to process the sequence?
				if (sv.AuxError == FERR_OKAY)
				{
					DUMPSTR("Flyer is processing sequence...");
					sv.AuxError = EndSequence(0,1);				// Let Flyer grind on this for a while...
					DUMPUDECB("done (",sv.AuxError,")\\");
				}
				else
					EndSequence(0,0);					// Abort download
d2102 2
a2103 1
			if (sv.AuxError != FERR_OKAY)
d2105 3
a2107 2
				error = SEQERR_InternalFlyer;
				goto Abort;
d2109 8
d2118 5
d2125 3
a2127 3
		/*********************************************
		*** Prepare the SeqInfo structure for play ***
		*********************************************/
d2129 2
a2130 2
		// Clear all fields of this structure
		memset(&SeqInfo, 0, sizeof(struct PlaySeqInfo));
d2132 2
a2133 2
		SeqInfo.CurSwitcherEvent = (struct Event *)sv.SwitcherTrack.EventList.lh_Head;
		SeqInfo.TimeAtSequenceEnd = totalrunningtime;
d2136 4
a2139 4
		/*************************************************************
		*** If first switcher events are SELECTs, preroll them now ***
		*** Then put interface back up and wait for start          ***
		*************************************************************/
d2141 4
a2144 4
		if ((sv.SwitcherTrack.EventCount) && (SeqInfo.CurSwitcherEvent->FGCcommand == FGC_SELECT))
		{
			DUMPMSG("*** Before ES_StartSeq1 ***");
			SendSwitcherReply(ES_StartSeq,NULL);
d2146 2
a2147 2
			DUMPMSG("*** ReadySeq ***");
			ReadySeq(&SeqInfo);			// Get ready to play (do 1st switcher select)
d2149 8
a2156 8
			DUMPMSG("*** Before ES_Stop1 ***");
			SendSwitcherReply(ES_Stop,NULL);
			UpdateAllDisplay();
		}
		else
		{
			DUMPMSG	("No pre-SELECT's required");
		}
d2158 2
a2159 2
		DisplayMessage(NULL);		// Remove message from strip
		DisplayRunningTime();		// Restore running time
d2161 4
a2164 5
		DisplayNormalSprite();
//		if (!ErrorMessageBoolRequest(Edit->Window,PlayReadyMessage))
		if (!BoolRequest(Edit->Window,">>> The project is ready to play <<<"))
			goto Abort;
		DisplayWaitSprite();
d2167 2
a2168 2
//		DUMPMSG	("Play Sequence ...............");
//		DUMPMEM("Sequence=",(UBYTE *)Sequence,VidTrack.TrackMemSize);
d2171 10
a2180 5
		// Get ready to start sequence.  This does some toaster setup and syncs
		// The toaster clock to the Flyer field clock.
		// Also sets bit 4 of TB_DisplayRenderMode (how intuitive!)
//		DUMPMSG("Before ES_StartSeq2");
		SendSwitcherReply(ES_StartSeq,NULL);
d2182 2
a2183 4
		/* succ = */
			PlaySeq(&SeqInfo);		// Returns success flag
		FG = SeqInfo.AbortedFG;		// Get FG for error/abort (or NULL)
		DUMPMSG(">>>>>>>>>>>>>>>>>>>> Done <<<<<<<<<<<<<<<<<<<<<");
a2184 2
//		DUMPMSG("Before ES_Stop");
		SendSwitcherReply(ES_Stop,NULL);		//Clr bit 4 of TB_DisplayRenderMode
d2188 1
a2188 1
		if (ToasterBase)
d2190 55
a2244 1
			CurrentDir(GetBootLock((struct ToasterBase *)ToasterBase));
d2246 8
a2253 1
//		DUMPHEXIL("&SeqInfo=",(LONG)(&SeqInfo),"\\");
d2255 2
a2256 1
		if (SeqInfo.ErrorEvent)
d2258 62
a2319 4
			// Does this if there was an error during the sequence.
			DUMPHEXIL("ErrorEvent=",(LONG)(SeqInfo.ErrorEvent),"\\");
			DUMPHEXIL("FG=",(LONG)(SeqInfo.ErrorEvent->FG),"\\");
			DUMPHEXIL("ErrorMsg=",(LONG)(SeqInfo.ErrorMsg),"\\");
d2321 96
a2416 1
			switch(SeqInfo.ErrorNum)
d2418 2
a2419 6
				case	1:
				// Queue error, time already passed.
				error = SEQERR_EventLate;
				FG = SeqInfo.ErrorEvent->FG;
				sv.Pos = -1;							// Find it for me (don't know)
				break;
d2421 1
a2421 2
				default:
				break;
d2423 1
a2423 1
			// Goes to "Abort"
d2425 45
a2469 1
		else
d2471 1
a2471 4
			// If PlaySeq returned no FG (success or aborted before any processed)
			// then keep the same crouton hilited as when we started
			if (!FG)
				FG = (struct ExtFastGadget *)CurFG;
d2473 20
a2492 3
			HiliteNewFG(Edit,FG,-1);	//Hilite initially selected or abort crouton
		}
//	}
d2494 5
a2498 1
Abort:
d2500 2
a2501 4
	// If stopped due to some error, put up the requester now
	if (error)
	{
		ReportSequenceError(&sv,FG,sv.Pos,error,FALSE);
d2504 2
a2505 1
	DUMPMSG("Before FreeMems");
a2506 3
	FreeTrack(&sv.SwitcherTrack);
	FreeTrack(&sv.VideoTrack);
	FreeTrack(&sv.AudioTrack);
d2508 7
a2514 1
	DUMPMSG("After FreeMems");
d2516 6
a2521 2
	DisplayMessage(NULL);			// Remove any message at top of screen
	DisplayNormalSprite();
d2523 6
a2528 1
	return(Edit);
d2719 2
a2720 1
			V2end = cuttime + GetDuration(V2FG);  // Field after the video
d2893 1
d2898 2
d2922 1
a2922 1
static BOOL MaybeInsertBlack(	struct SeqVars *sv,
d2929 1
d2935 2
d2952 3
a2954 1
				return(FALSE);
d2956 1
a2956 1
			sv->FlyChan = 1 - sv->FlyChan;
d2958 12
a2969 11
			if (!HandleTransition(
				sv,
				endofprev,				// CutTime
				V1event,			// V1
//				(PreviousTrack==CRTN_TRANS) ? PreviousFG:NULL,	// FXFG (NULL for cut)
				NULL,
//				PreviousPos,			// FXpos
				-1,
				event))					// V2 (has no FG associated with it!)
			{
				return(FALSE);
d2972 3
d3027 1
a3027 1
static BOOL AppendBlack(	struct SeqVars *sv,
d3035 1
a3035 1
		return(TRUE);
d3037 1
a3037 1
		return(FALSE);
d3063 1
a3063 1
			&sv,
d3086 1
a3086 1
	struct EditWindow *RetEdit;
d3088 2
a3089 1
	UWORD	gadID;
d3091 5
a3095 2
	/* Must check for NULL here, as ARexx calls don't provide an IntuiMsg */
	if (IntuiMsg)
d3097 4
a3100 1
		gadID = ((struct Gadget *)IntuiMsg->IAddress)->GadgetID;
d3106 1
a3106 1
				gadID = ID_PLAY_PART;
d3108 1
a3108 1
				gadID = ID_VCR_PLAY;
a3110 2
	else
		gadID = ID_VCR_PLAY;		// Assume this for ARexx "play project" command
d3113 1
a3113 1
	// If not, is equivalent to *PtrProject
a3114 1
	//(SeqStartFG might be NULL if none)
d3116 1
a3116 1
	if (gadID == ID_PLAY_PART)
d3126 43
a3168 1
	RetEdit = DoSeqPlay(Edit,IntuiMsg,firstFG);
d3170 1
a3170 1
	return(RetEdit);
d3283 2
a3413 1

d3433 1
a3433 22
	// First check for entire audio portion falling outside clip region
	if ((gotime + audlength) <= sv->StartTime)		// No audio reaches start time?
		audlength = 0;
	else if (gotime >= sv->EndTime)					// No audio begins in time?
		audlength = 0;
	else
	{
		// If audio starts before start time, crop off front
		if (gotime < sv->StartTime)
		{
			astartfld += sv->StartTime - gotime;		// crop audio to starttime
			audlength -= sv->StartTime - gotime;		// shorten by same amount
			gotime = sv->StartTime;						// Start immediately
		}

		// If audio extends past end of sequence, crop off rear
		if ((gotime+audlength) > sv->EndTime)
			audlength = sv->EndTime - gotime;
	}


	// Any audio left that we should play?
d3448 1
a3448 1
			event->Time = gotime - sv->StartTime;		// When to roll
d3470 1
d3472 3
a3474 1
static ULONG DownLoadFlyerTrack(struct Track *track, UBYTE tracktype)
d3481 1
a3538 4
			// I will probably not use these anymore, but just in case
			action.TotalAudStart  = event->AudStart;
			action.TotalAudLength = event->AudLength;

d3542 111
d3656 5
a3660 1
			err = AddSeqClip(&action);
d3687 8
a3694 1
			err = AddSeqClip(&action);
@


2.88
log
@Added Wait4RMB message so queued play works
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.87 1995/04/21 14:10:03 Flick Exp $
d5 3
d307 2
d322 1
a322 1
//#define SERDEBUG	1
d325 36
a360 1
extern VOID Wait4RMB(void);	/* toastsupport.a */
a361 1
BPTR __asm GetBootLock(register __a0 struct ToasterBase *);
d365 1
d367 2
a372 3
	LONG		StartField;				//1st field of Video or Split Audio chunk.
	WORD		FGCcommand;				//FGC_SELECT, FGC_QUEUE or FGC_TOMAIN
	UWORD 	CurrentPosition;		//Current Position within sequence
d374 4
d380 2
d384 5
a388 3
#define FLAGS1B_LASTEVENT	0
#define FLAGS1B_LOOP			1
#define FLAGS1B_WAIT4GPI	2
d390 3
a392 1
#define FLAGS1F_LASTEVENT	(1<<FLAGS1B_LASTEVENT)
d394 2
a395 1
#define FLAGS1F_WAIT4GPI	(1<<FLAGS1B_WAIT4GPI)
a396 3
//------------------------
struct PlaySequenceCmd
{
d409 1
a409 2
	struct Event *FirstVideoEvent;	//Requires busy waits for ToMains or Selects
	struct Event *FirstAudioEvent;	//No busy waits required
d411 5
d419 2
a420 1
	struct Event	*ErrorEvent;		//-> Error event
d425 10
d436 1
a436 1
// The following are used to index into the TrackCount structure
d438 12
a449 9
#define TRACK_START		0	// marks no previous track = start of sequence
#define TRACK_VIDEO		1  // main video output = CLIP, MAIN, FRAM, VIDA, RGBA, STIL These have video time.
#define TRACK_AUDIO		2  // audio event
#define TRACK_TRANS		3	// transitional effects ANIM/ILBM/ALGO (can only be followed by a video event)
#define TRACK_EFFECT		4  // non-transition effects that don't take over the machine, e.g. ChromaFX
#define TRACK_KEY			5  // overlayed video track for Keyed Frames, don't take over machine
#define TRACK_FX			6  // Keyed Things that take over the machine, SCROLL/CRAWL/KEYA
#define TRACK_AREXX		7
#define TRACK_CONTROL	8	// Sequence & Switcher control
d455 33
a487 11
struct TrackCount
{
	ULONG	Start;	// ignored for now
	ULONG	Video;	// main video output = CLIP, MAIN, FRAM, VIDA, RGBA, STIL These have video time.
	ULONG	Audio;	// audio event
	ULONG	Trans;	// transitional effects ANIM/ILBM/ALGO (can only be followed by a video event)
	ULONG	Effect;	// non-transition effects that don't take over the machine, e.g. ChromaFX
	ULONG	Key;		// overlayed video track for Keyed Frames, don't take over machine
	ULONG FX;		// Keyed Things that take over the machine, SCROLL/CRAWL/KEYA
	ULONG ARexx;	//
	ULONG Control;	// Sequence & Switcher control
d492 3
a494 3
#define FGC_SELECT 2
#define FGC_TOMAIN 33
#define FGC_QUEUE 38
d496 2
d501 3
a503 1
extern struct FastGadget *CurFG, *SKellFG;
d513 2
a514 50
extern char *ErrMsg0[];
extern char *ErrMsg1[];
extern char *ErrMsg2[];
extern char *ErrMsg3[];
extern char *ErrMsg4[];
extern char *ErrMsg5[];
extern char *ErrMsg6[];
extern char *ErrMsg7[];
extern char *ErrMsg8[];
extern char *ErrMsg9[];
extern char *ErrMsg10[];
extern char *ErrMsg11[];
extern char *ErrMsg12[];
extern char *ErrMsg13[];
extern char *ErrMsg14[];
extern char *ErrMsg15[];
extern char *ErrMsg16[];
extern char *ErrMsg17[];
extern char *ErrMsg18[];
extern char *ErrMsg19[];
extern char *ErrMsg20[];
extern char *ErrMsg21[];
extern char *ErrMsg22[];
extern char *ErrMsg23[];
extern char *ErrMsg24[];
extern char *ErrMsg25[];
extern char *ErrMsg26[];
extern char *ErrMsg27[];
extern char *ErrMsg28[];
extern char *ErrMsg29[];
extern char *ErrMsg30[];
extern char *ErrMsg31[];
extern char *ErrMsg32[];
extern char *ErrMsg33[];
extern char *ErrMsg34[];
extern char *ErrMsg35[];
extern char *ErrMsg36[];
extern char *ErrMsg37[];
extern char *ErrMsg38[];
extern char *ErrMsg39[];
extern char *ErrMsg40[];
extern char *ErrMsg41[];
extern char *ErrMsg42[];
extern char *ErrMsg43[];
extern char *ErrMsg44[];
//extern char *ErrMsg45[];
//extern char *ErrMsg46[];
//extern char *ErrMsg47[];
//extern char *ErrMsg48[];
//extern char *ErrMsg49[];
d516 1
a516 2
VOID DisplayWaitSprite(VOID);
VOID DisplayNormalSprite(VOID);
d518 2
a519 3
struct ExtFastGadget *  __asm PlaySequence(register __a0 struct PlaySequenceCmd *);
extern LONG ew_QuickSelect( struct EditWindow *Edit, LONG nodenum );
extern void	Main2Blank();
d521 38
a558 4
static void HiliteNewFG(struct EditWindow *Edit, struct ExtFastGadget *FG, LONG fg_num );
static void ReportSequenceError(struct EditWindow *Edit, struct ExtFastGadget *FG, LONG fg_num, char *Text[]);
static ULONG MakeClipHeadR(char *name, ULONG VidStart, ULONG VidFields, ULONG AudStart, ULONG AudFields);
static struct ExtFastGadget *FirstFG=NULL, *SeqStartFG=NULL;  // Where to start sequence
a559 6
//*******************************************************************
//struct FlyerVolumes * __regargs GetVolumeTable()
//{
//	ESparams1.Data1=0;
//	return((struct FlyerVolumes *)SendSwitcherReply(ES_BuildVolumeTable,&ESparams1));
//}
d561 5
a565 2
//*******************************************************************
ULONG __regargs GetNumFields(struct ExtFastGadget *FG)
d568 3
a570 2
	ESparams2.Data2=0x80000000|TAG_NumFields;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
a572 7
//*******************************************************************
ULONG __regargs GetDuration(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_Duration;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d574 5
a578 2
//*******************************************************************
ULONG __regargs GetFadeInDuration(struct ExtFastGadget *FG)
d581 1
a581 3
	ESparams2.Data2=0x80000000|TAG_FadeInDuration;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
a582 5
//*******************************************************************
ULONG __regargs GetFadeOutDuration(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_FadeOutDuration;
d586 24
a609 7
//*******************************************************************
ULONG __regargs GetAdjustedVideoDuration(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AdjustedVideoDuration;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d611 7
a617 4
//*******************************************************************
BOOL __regargs PutAdjustedVideoDuration(struct ExtFastGadget *FG, LONG value)
{
	BOOL	result;
a618 7
	ESparams2.Data1=ESparams3.Data1=(LONG)FG;
	ESparams2.Data2=ESparams3.Data2=0x80000000|TAG_AdjustedVideoDuration;
	ESparams3.Data3=value;
	result = (BOOL)SendSwitcherReply(ES_PutValue,&ESparams3);
	SendSwitcherReply(ES_UnSavable,&ESparams2);
	return(result);
}
d620 7
a626 2
//*******************************************************************
ULONG __regargs GetAudioDuration(struct ExtFastGadget *FG)
d628 1
a628 4
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AudioDuration;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d630 1
a630 7
//*******************************************************************
ULONG __regargs GetAudioOn(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AudioOn;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d632 13
a644 6
//*******************************************************************
ULONG __regargs GetAudioVolume1(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AudioVolume1;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
a646 7
//*******************************************************************
ULONG __regargs GetAudioVolume2(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AudioVolume2;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d648 5
a652 2
//*******************************************************************
ULONG __regargs GetRecFields(struct ExtFastGadget *FG)
d654 1
a654 4
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_RecFields;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d656 3
a658 7
//*******************************************************************
ULONG __regargs GetTimeMode(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_TimeMode;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d660 3
a662 6
//*******************************************************************
ULONG __regargs GetDelay(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_Delay;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
a664 7
//*******************************************************************
ULONG __regargs GetCroutonType(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_CroutonType;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d666 2
a667 4
//*******************************************************************
ULONG __regargs GetOverlayDelay(struct ExtFastGadget *FGlastVid, struct ExtFastGadget *FG)
{
	ULONG OurDelay;
a668 1
	OurDelay=GetDelay(FG);
a669 3
	if(GetTimeMode(FG)) OurDelay+=GetStartField(FGlastVid);
	return(OurDelay);
}
d671 8
a678 2
//*******************************************************************
BOOL __regargs GetFadeInVideo(struct ExtFastGadget *FG)
d680 2
a681 4
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_FadeInVideo;
	return((BOOL)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d683 2
a684 7
//*******************************************************************
ULONG __regargs GetStartField(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_ClipStartField;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d686 2
a687 7
//*******************************************************************
ULONG __regargs GetAudioStart(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AudioStart;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
}
d689 1
a689 6
//*******************************************************************
ULONG __regargs GetAdjustedVideoStart(struct ExtFastGadget *FG)
{
	ESparams2.Data1=(LONG)FG;
	ESparams2.Data2=0x80000000|TAG_AdjustedVideoStart;
	return((ULONG)SendSwitcherReply(ES_GetValue,&ESparams2));
a691 4
//*******************************************************************
BOOL __regargs PutAdjustedVideoStart(struct ExtFastGadget *FG, LONG value)
{
	BOOL	result;
d693 25
a717 7
	ESparams2.Data1=ESparams3.Data1=(LONG)FG;
	ESparams2.Data2=ESparams3.Data2=0x80000000|TAG_AdjustedVideoStart;
	ESparams3.Data3=value;
	result = (BOOL)SendSwitcherReply(ES_PutValue,&ESparams3);
	SendSwitcherReply(ES_UnSavable,&ESparams2);
	return(result);
}
d719 12
a730 12
//*******************************************************************
static ULONG MakeClipHeadR(char *name, ULONG VidStart, ULONG VidFields, ULONG AudStart, ULONG AudFields)
{

#ifdef	SERDEBUG
	DUMPSTR("\\MakeClipHeadR( ");
	DUMPSTR(name);
	DUMPMSG(" )");

	if(VidFields) {
		DUMPUDECL( " VIDEO Head = ",VidStart," ");
		DUMPUDECL( "for ",VidFields," fields\\");
d733 1
a733 5
	if(AudFields) {
		DUMPUDECL( " AUDIO Head = ",AudStart," ");
		DUMPUDECL( "for ",AudFields," fields\\\\");
	}
#endif
d735 1
a735 6
	ESparams5.Data1=(LONG)name;
	ESparams5.Data2=(LONG)VidStart;
	ESparams5.Data3=(LONG)VidFields;
	ESparams5.Data4=(LONG)AudStart;
	ESparams5.Data5=(LONG)AudFields;
	return((ULONG)SendSwitcherReply(ES_MakeClipHead,&ESparams5));
a737 17
//*******************************************************************
// Because I can't do an FX immediately after a Take, and because some FX
// may need a ChangeIS(), or require other setup/load time, and because some
// FX need some cleanup time, I won't allow FX to be butted together.
// And even Takes can only occur at 15 times/sec.
// I don't need to check for Takes any faster, because we won't support
// video durations of < 4 fields.

#define FXPREROLLFUDGE 	   8	// For AlgoFX, (ANIMs & ILBMs require much more time!)
#define ANIMPREROLLFUDGE  90  // Used for ANIMFX, KeyedANIMs and VideoANIMs
#define ILBMPREROLLFUDGE  45	// Used by ILBMfx, Scrolls, Crawls
#define FRAMEPREROLLFUDGE 90	// Used by FrameStores, ChromaFX & Keyed Stills
#define RGBPREROLLFUDGE   120
#define VIDEOPREROLLFUDGE 20	// Used for clips & flyerstills

#define SCRAWLKEYANIMTOLERANCE 4 //allow for some error on keyed things
#define AREXXTOLERANCE 8 			//allow for some error on keyed things
d739 3
a741 3
#define ROUNDTOFRAME(n) (((n)+3)&~3)


d743 1
a743 1
static void HiliteNewFG(struct EditWindow *Edit, struct ExtFastGadget *FG, LONG fg_num )
d745 6
a750 2
	/* neg fg_num implies to find it yourself */
	if ( FG && (fg_num < 0) )
d752 1
a752 1
		fg_num = GetProjNodeOrder(Edit,(struct FastGadget *)FG);
d754 1
a754 8
	ew_QuickSelect(Edit,fg_num);
	Edit->ew_OptRender = FALSE;

	SendSwitcherReply(ES_SelectDefault,(SKellFG=NULL));
	CurFG=(struct FastGadget *)FG;

	UpdateAllDisplay();
}
d756 3
a758 3
//=============================================================
static void ReportSequenceError(struct EditWindow *Edit, struct ExtFastGadget *FG, LONG fg_num, char *Text[])
{
d760 5
a764 2
// FG may be NULL of you don't want any hilited,
// and fg_num might = -1 if you want the code to find the crouton
d766 1
a766 1
	HiliteNewFG(Edit,FG,fg_num);
d768 1
a768 3
	DisplayNormalSprite();
	ErrorMessageRequest(Edit->Window,Text);
	SetRunningTime(-1L);
d772 1
d774 5
a778 2
// Returns TRUE if the clip has audio enabled and non-zero volume in either channel.
BOOL HasAudio(struct ExtFastGadget *FG)
d788 4
a791 4
	DUMPHEXIL("1<<AUDB_Channel1Recorded & AudioOnBits=",(LONG)(1<<AUDB_Channel1Recorded) & AudioOnBits,"\\");
	DUMPHEXIL("1<<AUDB_Channel2Recorded & AudioOnBits=",(LONG)(1<<AUDB_Channel2Recorded) & AudioOnBits,"\\");
	DUMPHEXIL("1<<AUDB_Channel1Enabled & AudioOnBits=",(LONG)(1<<AUDB_Channel1Enabled) & AudioOnBits,"\\");
	DUMPHEXIL("1<<AUDB_Channel2Enabled & AudioOnBits=",(LONG)(1<<AUDB_Channel2Enabled) & AudioOnBits,"\\");
d796 12
a807 2
	return((BOOL)( (((1<<AUDB_Channel1Recorded) & AudioOnBits) && ((1<<AUDB_Channel1Enabled) & AudioOnBits) && GetAudioVolume1(FG))
	            || (((1<<AUDB_Channel2Recorded) & AudioOnBits) && ((1<<AUDB_Channel2Enabled) & AudioOnBits) && GetAudioVolume2(FG)) ));
a808 2
//	return((BOOL)!( (!(AUDB_Channel1Recorded & AudioOnBits) || !(AUDB_Channel1Enabled & AudioOnBits) || !GetAudioVolume1(FG))
//	             && (!(AUDB_Channel2Recorded & AudioOnBits) || !(AUDB_Channel2Enabled & AudioOnBits) || !GetAudioVolume2(FG)) ));
d810 3
a812 2
}

d814 1
a814 2
// Returns TRUE if the FG is a video source
BOOL IsVideoSource(struct ExtFastGadget *FG)
d821 8
a828 8
   (
      (objtype==CT_VIDEO)
	 ||(objtype==CT_FRAMESTORE)
	 ||(objtype==CT_IMAGE)
	 ||(objtype==CT_VIDEOANIM)
	 ||(objtype==CT_MAIN)
	 ||(objtype==CT_STILL)
   )
a833 17
/****** Sequence/QuickSortArray **************************************
*
*   NAME
*	QuickSortArray
*
*   SYNOPSIS
*
* VOID QuickSortArray(
*	void *array,
*	ULONG NumberOfElements,
*	ULONG ElementSize,
*	int (* CompareElements)(void *ElementA, void *ElementB))
*
* FUNCTION
* 	CompareElements() returns: if <0, A<B; if =0, A=B; if >0, A>B
*
******************************************************************/
d835 5
a839 5
VOID QuickSortArray(
	register void *array,
	register ULONG NumberOfElements,
	register ULONG ElementSize,
	register int (*	CompareElements)(void *ElementA, void *ElementB))
d841 11
a851 3
// This is a SAS Library function
	qsort(array,NumberOfElements,ElementSize,CompareElements);
	return;
a853 12
/****** Sequence/EventTimeCompare ***************************************
*
*   NAME
*	EventTimeCompare
*
*   SYNOPSIS
*	int EventTimeCompare(void *ElementA, void *LONG ElementB)
*
*   FUNCTION
* 	Returns: if <0, A<B; if =0, A=B; if >0, A>B
*
*********************************************************************/
d855 5
a859 1
int EventTimeCompare(void *ElementA, void *ElementB)
d861 10
a870 1
	return((((struct Event *)ElementA)->Time)-(((struct Event *)ElementB)->Time));
d874 16
a889 9
/****** Sequence/SortEvents ***************************************
*
*   NAME
*	SortEvents
*
*   SYNOPSIS
*	SortEvents(struct Event *Events, ULONG NumberOfEvents)
*
*********************************************************************/
d891 1
a891 5
void	SortEvents(struct Event *Events, ULONG NumberOfEvents)
{
	QuickSortArray((void *)Events,NumberOfEvents,sizeof(struct Event),EventTimeCompare);
	return;
}
d893 2
a894 5
//*********************************************
BOOL IsStop(struct ExtFastGadget *FG)
{
	BOOL endflag=FALSE;
	ULONG type;
d896 1
a896 1
	if(FG->ObjectType == CT_CONTROL)
d898 90
a987 1
		type=GetCroutonType(FG);
d989 9
a997 1
		if((type==CROUTONTYPE_STOP) || (type==CROUTONTYPE_RESTART)) endflag=TRUE;
d999 11
d1011 5
a1015 1
	return(endflag);
d1018 7
a1024 2
//*******************************************************************
struct ExtFastGadget *GetNextGadget(struct ExtFastGadget *FG)
d1026 2
a1027 1
	struct ExtFastGadget *NextFG;
d1029 3
a1031 2
	if(NextFG = (struct ExtFastGadget *)(FG->FG.NextGadget))
		if(IsStop(NextFG)) NextFG=NULL;
d1033 2
a1034 1
	return(NextFG);
d1037 4
d1042 1
a1042 2
// Finds 1st previous starting event after any STOPs/LOOPs
struct ExtFastGadget *StartingSequenceEvent()
d1044 1
a1044 1
	struct ExtFastGadget *StartFG, *FG, *InitialFG=NULL;
d1046 2
a1047 3

/* Start from previous video event (if not currently on one) */
	if(PtrProject && (FG=StartFG=InitialFG=*PtrProject))
d1049 4
a1052 1
		if(FirstFG) StartFG=(struct ExtFastGadget *)FirstFG;
d1054 2
a1055 1
		while( FG && (FG!=StartFG))
d1057 2
a1058 2
			if(!InitialFG) InitialFG=FG;
			if(IsStop(FG)) InitialFG=NULL;
d1060 2
a1061 1
			FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
d1064 1
a1064 1
	return(InitialFG);
d1067 6
a1072 5
//*******************************************************************
// Find the total video duration upto a given FG.
//
// If EndFG=NULL, then it goes to the start of the linked list = 0 time;
ULONG VideoStartTime(struct ExtFastGadget *StartFG, struct ExtFastGadget *EndFG)
d1074 1
a1074 1
	ULONG	Duration=0;
d1076 2
a1077 1
	while((StartFG != EndFG) && EndFG)
d1079 24
a1102 9
			switch(StartFG->ObjectType)
			{
				case CT_VIDEO:
				case CT_FRAMESTORE:
				case CT_MAIN:
				case CT_IMAGE:
				case CT_STILL:
					Duration += GetDuration(StartFG);
					break;
a1103 3
				case CT_VIDEOANIM:
					Duration +=GetNumFields(StartFG);
					break;
d1105 28
a1132 3
				default:
					break;
			}
d1134 2
a1135 2
			StartFG = (struct ExtFastGadget *)(StartFG->FG.NextGadget);
	}
d1137 1
a1137 2
	return(Duration);
}
d1139 1
a1139 7
//*******************************************************************
// Video Duration from start of Sequence to current crouton.
// This is used to calculate the time to put in the panels CurrentTime indicator.
//
ULONG SequenceVideoStartTime()
{
	struct ExtFastGadget *FG;
d1141 11
a1151 4
	if (FG=SeqStartFG)	//GLOBAL
		return(VideoStartTime(FG, (struct ExtFastGadget *)FirstFG));	//If FirstFG=NULL, then returns 0.
	else return(0L);
}
d1153 1
a1153 8
//*******************************************************************
// Find the total video duration between, and including, two FGs.
//
// If EndFG=NULL, then it goes to the end of the linked list.
ULONG TotalVideoTime(struct ExtFastGadget *StartFG, struct ExtFastGadget *EndFG)
{
	ULONG	Duration=0;
	UWORD	LastFlag=FALSE;
d1155 2
a1156 1
	do
d1158 9
a1166 1
			if(StartFG==EndFG) LastFlag=TRUE;
d1168 8
a1175 9
			switch(StartFG->ObjectType)
			{
				case CT_VIDEO:
				case CT_FRAMESTORE:
				case CT_MAIN:
				case CT_IMAGE:
				case CT_STILL:
					Duration += GetDuration(StartFG);
					break;
d1177 2
a1178 3
				case CT_VIDEOANIM:
					Duration +=GetNumFields(StartFG);
					break;
d1180 3
a1182 3
				default:
					break;
			}
d1184 2
a1185 4
			StartFG = GetNextGadget(StartFG);
	}while(!LastFlag && StartFG);
	return(Duration);
}
d1187 2
a1188 7
//*******************************************************************
// Video Duration from current crouton upto end of Sequence.
// This is used to calculate the time to put in the ProgramTime indicator.
//
ULONG SequenceTotalVideoTime()
{
	struct ExtFastGadget *FG;
d1190 1
a1190 3
	if (FG=SeqStartFG)	//GLOBAL
	{
		if(FirstFG) FG=(struct ExtFastGadget *)FirstFG;
d1192 11
a1202 4
		return(TotalVideoTime(FG, NULL));
	}
	else return(0L);
}
d1204 1
a1204 2
//=============================================================
// Returns FALSE if no croutons
d1206 3
a1208 5
BOOL GetNumberOfCroutons(struct TrackCount *Count, struct ExtFastGadget *StartFG)
{
	struct ExtFastGadget *FG, *PreviousVideoFG=NULL;
	LONG astart, vstart, aduration;
	ULONG	CurrentTime=0, PreviousTime=0, StartTime, PreviousStartField=0;
d1210 1
a1210 6
	Count->Video=0;	// main video output = CLIP, MAIN, FRAM, VIDA, RGBA, STIL These have video time.
	Count->Audio=0;	// audio event
	Count->Trans=0;	// transitional effects ANIM/ILBM/ALGO (can only be followed by a video event)
	Count->Effect=0;	// non-transition effects that don't take over the machine, e.g. ChromaFX
	Count->Key=0;		// overlayed video track for Keyed Frames, don't take over machine
	Count->FX=0;		// Keyed Things that take over the machine, SCROLL/CRAWL/KEYA
d1212 3
a1214 2
	Count->ARexx=0;	// Only requires FGC_SELECT
	Count->Control=0;	// Sequence & Switcher control. Only requires FGC_SELECT
d1216 2
a1217 1
	FG=SeqStartFG;		//GLOBAL
d1219 2
a1220 3
	if (FG && StartFG)
	{
		StartTime=VideoStartTime(FG, StartFG);
d1222 1
a1222 2
/* Check for previous audio that might reach the requested start point */
		while(FG != StartFG)
d1224 1
a1224 1
			switch(FG->ObjectType)
d1226 31
a1256 5
				case CT_AUDIO:
					if(HasAudio(FG) && PreviousVideoFG &&
						 ((PreviousTime+GetOverlayDelay(PreviousVideoFG,FG)+GetAudioDuration(FG)-PreviousStartField) > StartTime))
					Count->Audio++;
					break;
d1258 7
a1264 2
// The following cases cover all the known types of Video sources
				case CT_VIDEO:
d1266 1
a1266 4
				if(HasAudio(FG) &&
						(((astart=GetAudioStart(FG))+(aduration=GetAudioDuration(FG))) > ((PreviousStartField=GetStartField(FG))+GetDuration(FG))) &&
						((CurrentTime+astart+aduration-PreviousStartField) > StartTime))
					Count->Audio++;
d1268 13
a1280 8
				case CT_FRAMESTORE:
				case CT_VIDEOANIM:
				case CT_MAIN:
				case CT_IMAGE:
				case CT_STILL:
						if((FG->ObjectType) != CT_VIDEO) PreviousStartField=0;
						PreviousVideoFG=FG;
						PreviousTime=CurrentTime;
d1282 8
a1289 3
						if(FG->ObjectType != CT_VIDEOANIM) CurrentTime+=GetDuration(FG);
							else CurrentTime+=GetNumFields(FG);
					break;
d1291 2
a1292 2
				default:
					break;
d1295 2
a1296 1
			FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
d1299 13
a1311 2
//------------------------------------
		do
d1313 5
d1320 9
a1328 3
/*  Move down to key...
				case CT_FXCR:
					Count->Effect++;
d1330 5
a1334 3
*/
				case CT_CONTROL:		//Not currently used for any events
					Count->Control++;
d1336 14
d1351 4
a1354 2
				case CT_REXX:
					Count->ARexx++;
d1356 13
d1370 4
a1373 3
				case CT_FXCR:
				case CT_KEY:
					Count->Key++;
d1375 25
d1401 7
a1407 4
				case CT_SCROLL:
				case CT_CRAWL:
				case CT_KEYEDANIM:
					Count->FX++;
d1409 1
d1411 3
a1413 2
				case CT_AUDIO:
					if(HasAudio(FG)) Count->Audio++;
d1415 14
d1430 4
a1433 4
				case CT_FXANIM:
				case CT_FXILBM:
				case CT_FXALGO:
					Count->Trans++;
d1435 13
d1449 3
a1451 2
// The following cases cover all the known types of Video sources
				case CT_VIDEO:
d1453 1
a1453 3
// Some of these audio events may not be used if FX cause Video heads
// to be longer than the split audio heads.
				if(HasAudio(FG))
d1455 5
a1459 2
					if((astart=GetAudioStart(FG)) < (vstart=GetStartField(FG)))
						Count->Audio++;
d1461 5
a1465 3
					if((astart+GetAudioDuration(FG)) > (vstart+GetDuration(FG)))
						Count->Audio++;
				}
d1467 5
a1471 7
				case CT_FRAMESTORE:
				case CT_VIDEOANIM:
				case CT_MAIN:
				case CT_IMAGE:
				case CT_STILL:
					Count->Video++;
					break;
d1473 8
a1480 3
				default:
					break;
			}
d1482 6
a1487 2
			FG = GetNextGadget(FG);
		}while(FG);
d1489 2
a1490 4
		return(TRUE);
	}
	return(FALSE);
}
d1492 16
a1507 4
//=============================================================
void CropAudioToVideo(ULONG vidstart, ULONG vidlength, ULONG *audstart, ULONG *audlength)
{
	ULONG	audin, audout, vidout;
d1509 7
a1515 3
	audin=*audstart;
	audout=audin+(*audlength);
	vidout=vidstart+(vidlength);
d1517 2
a1518 5
	if((audout < vidstart)||(audin > vidout)) *audstart=*audlength=0;
	else
	{
		if(audin < vidstart) audin=vidstart;
		if(audout > vidout) audout=vidout;
d1520 4
a1523 4
		*audstart=audin;
		*audlength=audout-audin;
	}
}
d1525 1
a1525 2
//=============================================================
// Finds the most recent video event
d1527 5
a1531 3
struct ExtFastGadget *StartingVideoEvent()
{
	struct ExtFastGadget *StartFG, *FG, *VidFG=NULL;
d1533 5
a1537 4
/* Start from previous video event (if not currently on one) */
	if(FG=StartFG=SeqStartFG)	//GLOBAL
	{
		if(FirstFG) StartFG=(struct ExtFastGadget *)FirstFG;
d1539 5
a1543 4
		while( FG && FG!=StartFG )
		{
			if(IsVideoSource(FG)) VidFG=FG;
			else if(IsStop(FG)) VidFG=NULL;
d1545 5
a1549 2
			FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
		}
d1551 6
a1556 5
		if(IsVideoSource(FG)) VidFG=FG;
		return(VidFG);
	}
	return(NULL);
}
d1558 2
d1561 2
a1562 4
//=============================================================
struct EditWindow *SeqHandlePlay(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
{
a1563 26
// The following variables would be better handled with an array
// of structures that contained these pointers and values.  Oh well.
	struct Event *VidSequence=NULL,
					 *AudSequence=NULL;

	ULONG 		  VidSeqMemSize,
		   		  AudSeqMemSize;

	struct Event *VidEvent=NULL,
					 *AudEvent=NULL;

	UWORD			  VidCount=0,
					  AudCount=0;

	LONG CurrentField=0;
	struct ExtFastGadget *FG, *FG2, *PreviousFG=NULL, *PreVidFG=NULL, *CurVidFG;
	struct Event *PreviousVideo=NULL, *CurrentVideo, *FinalClip=NULL, *EventPtr, *KeyKill;
	ULONG  FXadvance, EndOfEffect=0, EndOfVideo;
	LONG vidlength, audlength, vidstart, audstart, audend, vidend, headsize, endcrop;
	LONG fudge,headerr;
   ULONG PreviousEndOfEffect=0, PreviousAudioStartTime=0;
	ULONG	CurrentTime=0, PreviousTime=0, StartTime, PreviousStartField=0;
	UWORD	PreviousTrack=TRACK_START, PreviousEffect=EFFECT_TAKE, PreviousCount;
	UWORD count=0;
	struct TrackCount CroutonCount;
	struct	ClipInfo * ci;
d1565 18
a1582 1
	struct PlaySequenceCmd SequenceCmd={0,0,0,0,0,0};
d1584 13
a1596 1
	Edit->ew_OptRender = TRUE;    //????????
d1598 13
a1610 2
	DisplayWaitSprite();
	SetRunningTime(-1L);		// assume unable to calculate program time
d1612 1
a1612 2
	if(!(FG=StartingVideoEvent()))
		ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,-1,ErrMsg30); //Can't sequence, no previous video events
d1614 2
a1615 23
	if(FG && GetNumberOfCroutons(&CroutonCount, FG))
	{
		if(
			   (VidSequence = SafeAllocMem((VidSeqMemSize=sizeof(struct Event)*
			   ((
				  CroutonCount.Key	// ChromaFX,Keys (SELECT, AUTO, REMOVE)
				)*3
				+(
				  CroutonCount.FX		// Scrolls,Crawls,KeyedAnims (SELECT & TOMAIN)
				 +CroutonCount.Trans		// FXANIM,FXILBM,FXALGO
				 +CroutonCount.Video	// VIDEO,FRAMESTORE,VIDEOANIM,MAIN,IMAGE,STILL (may only require SELECT)
				)*2
				+(
				  CroutonCount.ARexx		//only needs SELECT
//				 +CroutonCount.Effect	//only need SELECT because take or SwitcherFX brings in ChromaFX
//				 +CroutonCount.Control	//only needs SELECT  NOT USED FOR EVENTS
				)
				+1)),MEMF_CLEAR))
		   &&
				((CroutonCount.Audio==0) ||
				(AudSequence = SafeAllocMem((AudSeqMemSize=sizeof(struct Event) * (CroutonCount.Audio+1)),MEMF_CLEAR)))
		  )
		{
d1617 5
a1621 1
			DUMPMSG	("-------------- HandlePlay ----------------");
d1623 1
a1623 3
			SendSwitcherReply(ES_SelectDefault,NULL);
			Main2Blank();
			SendSwitcherReply(ES_Stop,NULL);
d1625 5
a1629 2
			SequenceCmd.FirstVideoEvent = VidEvent 	= VidSequence;		// assume 1st crouton is selected
			SequenceCmd.FirstAudioEvent = AudEvent 	= AudSequence;
d1631 5
a1635 1
// all other SequenceCmd fields should be zero
a1636 1
			DisplayMessage("Processing Sequence");
d1638 5
d1644 6
a1649 1
			SendSwitcherReply(ES_StartHeadList,NULL);
d1651 2
a1652 3
//****************************************************************
//****************************************************************
// ********* Pre-Q previous events that occured before Sequence point
d1654 2
a1655 1
			SequenceCmd.TimeAtSequenceEnd=SequenceTotalVideoTime();
d1657 19
a1675 1
			FG2=SeqStartFG;
d1677 19
a1695 1
			StartTime=VideoStartTime(FG2, FG);
d1697 9
a1705 3
			while((FG2 != FG) && VidEvent)
			{
				switch(FG2->ObjectType)
d1707 3
a1709 2
					case CT_AUDIO:
					DUMPMSG("Case Audio ^^^^^^^^^^^^^^^^^^^^^");
d1711 11
a1721 5
					if(HasAudio(FG2) && PreVidFG &&
						 ((headsize=(PreviousTime+GetOverlayDelay(PreVidFG,FG2)+(audlength=GetAudioDuration(FG2))-PreviousStartField-StartTime)) > 0))
					{
						DUMPSDECL("headsize=",headsize,"\\");
						DUMPSDECL("audlength=",audlength,"\\");
d1723 1
a1723 1
						endcrop=headsize-SequenceCmd.TimeAtSequenceEnd;
d1725 25
a1749 1
						DUMPSDECL("endcrop=",endcrop,"\\");
d1751 1
a1751 1
						if(endcrop < 0) endcrop =0;	// doesn't go beyond sequence end
d1753 6
a1758 1
						DUMPSDECL("endcrop2=",endcrop,"\\");
d1760 1
a1760 6
						if(headsize < audlength) audstart=GetAudioStart(FG2)+audlength-headsize; // crop audio to starttime
						else  // audio all after start time (big delay time)
						{
							audstart=GetAudioStart(FG2);
							headsize=audlength;
						}
d1762 6
a1767 2
						DUMPSDECL("audstart=",audstart,"\\");
						DUMPSDECL("headsize2=",headsize,"\\");
d1769 6
a1774 1
						headsize-=endcrop;
d1776 2
a1777 1
						DUMPSDECL("headsize3=",headsize,"\\");
d1779 3
a1781 25
						if(headsize>0)	//else it's all beyond end of sequence
						{
							if(!(ci=DHD_ClipInfo((char *)FG2->FileName)) || (ci->Fields != GetValue((struct FastGadget *)FG2,TAG(RecFields))))
							{
								ReportSequenceError(Edit,FG2,count,ErrMsg41); //File not found!
								VidEvent=NULL;
								break;
							}

							if(MakeClipHeadR((char *)FG2->FileName, 0L, 0L, audstart, headsize))
							{
								ReportSequenceError(Edit,FG2,count,ErrMsg24); //Unable to create Audio clip on audio drive.
								VidEvent=NULL;
								break;
							}

							AudEvent->StartField=audstart;
							AudEvent->Time = 0;
							AudEvent->FG = FG2;
							AudEvent->CurrentPosition=count;
							AudEvent->FGCcommand = FGC_SELECT;
							AudEvent++;
							AudCount++;
						}
					}
d1783 3
d1787 2
a1788 13
				case CT_VIDEO:
					// Audio-only clips overlaid on this may need this figure, depending
					// on "lock to" param, in order to cue up audio that preceeds the
					// start point when playing from a crouton... JMF added
					PreviousStartField = GetStartField(FG2);

					if(HasAudio(FG2) &&
						(((audstart=GetAudioStart(FG2))+(audlength=GetAudioDuration(FG2)))
                       > (PreviousStartField+GetDuration(FG2))) &&
						((headsize=(CurrentTime+audstart+audlength-PreviousStartField-StartTime)) > 0))
					{
						endcrop=headsize-SequenceCmd.TimeAtSequenceEnd;
						if(endcrop < 0) endcrop =0;	// doesn't go beyond sequence end
d1790 4
a1793 6
						if(headsize < audlength) audstart=GetAudioStart(FG2)+audlength-headsize; // crop audio to starttime
						else  // audio all after start time (audio in is beyond video out)
						{
							audstart=GetAudioStart(FG2);
							headsize=audlength;
						}
a1794 1
						headsize-=endcrop;
d1796 3
a1798 26
						if(headsize>0)	//else it's all beyond end of sequence
						{
							if(!(ci=DHD_ClipInfo((char *)FG2->FileName)) || (ci->Fields != GetValue((struct FastGadget *)FG2,TAG(RecFields))))
							{
								ReportSequenceError(Edit,FG2,count,ErrMsg41); //File not found!
								VidEvent=NULL;
								break;
							}


							if(MakeClipHeadR((char *)FG2->FileName, 0L, 0L, audstart, headsize))
							{
								ReportSequenceError(Edit,FG2,count,ErrMsg28); //Unable to create Audio clip on audio drive.
								VidEvent=NULL;
								break;
							}

							AudEvent->StartField=audstart;
							AudEvent->Time = 0;
							AudEvent->FG = FG2;
							AudEvent->CurrentPosition=count;
							AudEvent->FGCcommand = FGC_SELECT;
							AudEvent++;
							AudCount++;
						}
					}
d1800 2
a1801 8
				case CT_FRAMESTORE:
				case CT_VIDEOANIM:
				case CT_MAIN:
				case CT_IMAGE:
				case CT_STILL:
						if((FG2->ObjectType) != CT_VIDEO) PreviousStartField=0;
						PreVidFG=FG2;
						PreviousTime=CurrentTime;
d1803 4
a1806 2
						if(FG2->ObjectType != CT_VIDEOANIM) CurrentTime+=GetDuration(FG2);
							else CurrentTime+=GetNumFields(FG2);
d1808 6
d1815 7
a1821 8
// These are too hard to start mid-transition, so I won't!!!
//				case CT_REXX:
//				case CT_KEY:		//Could maybe do this one?
//				case CT_SCROLL:
//				case CT_CRAWL:
//				case CT_KEYEDANIM:
//				case CT_FXCR:
//				case CT_CONTROL:
d1823 4
a1826 1
				default:
d1829 5
d1835 4
a1838 3
				FG2 = (struct ExtFastGadget *)(FG2->FG.NextGadget);
				count++;
			}
d1840 2
a1841 3
//****************************************************************
//****************************************************************
//********* Q events that occured at or after Sequence point
d1843 1
a1843 1
			PreVidFG = NULL;
d1845 1
a1845 2
		   while (FG && VidEvent)
			{
d1847 2
a1848 2
				DUMPMSG("--------------------------------------");
				DUMPUDECL("Crouton #",count," = ");
d1850 1
a1850 3
				switch(FG->ObjectType)
				{
//----------------------------------------------------------------------
a1851 2
		case CT_FXCR:
			DUMPMSG("ChromaFX CROUTON");
d1853 5
a1857 1
// Funny, this only does a select, no TOMAIN, and it -of course- doesn't have any remove
d1859 7
a1865 55
			if(PreviousTrack==TRACK_START) {
				ReportSequenceError(Edit,FG,count,ErrMsg0); //ChromaFX not allowed here.  Please start with a video event.
				VidEvent=NULL;
				break;
			}
			if(PreviousTrack==TRACK_TRANS) {
				ReportSequenceError(Edit,FG,count,ErrMsg0); //ChromaFX pages must not be placed after Effects croutons
				VidEvent=NULL;
				break;
			}
/*
// CRFX select sets up on preview, so switch current source to PRVW, then take it
			VidEvent->FG = PreviousVideo->FG;
			VidEvent->CurrentPosition=PreviousVideo->CurrentPosition;
			VidEvent->FGCcommand = FGC_TOPRVW;
			VidEvent->Time = CurrentField+8;
			DUMPUDECL("**CRFX Prev.Src ToPrvw: at ",VidEvent->Time," \\");
			VidEvent++;
			VidCount++;
 */
			VidEvent->FG = FG;
			VidEvent->CurrentPosition=count;
			VidEvent->FGCcommand = FGC_SELECT;
			VidEvent->Time = 0; 						//as soon as possible
			VidEvent++;
			VidCount++;
/*
			VidEvent->FG = PreviousVideo->FG;
			VidEvent->CurrentPosition=PreviousVideo->CurrentPosition;
//			VidEvent->FG = FG;
//			VidEvent->CurrentPosition=count;
			VidEvent->FGCcommand = FGC_TAKE;
			VidEvent->Time = (PreviousVideo->Time)+GetOverlayDelay(PreVidFG,FG)-(PreviousVideo->StartField);
			DUMPUDECL("**CRFX Take: at ",VidEvent->Time," \\");
			VidEvent++;
			VidCount++;
 */
			VidEvent->FG = FG;  // Remove Key Event, this MUST have its time
			VidEvent->CurrentPosition=count;  // reset, if another event happens before it is
			VidEvent->FGCcommand = FGC_REMOVE;  // due to end... AC
			VidEvent->Time = (PreviousVideo->Time)
						+GetOverlayDelay(PreVidFG,FG)
						-(PreviousVideo->StartField) + GetDuration(FG);
			DUMPUDECL("**CRFX Remove: at ",VidEvent->Time," \\");
			KeyKill=VidEvent;
			VidEvent++;
			VidCount++;

			PreviousFG=FG;
			PreviousCount=count;
			PreviousTrack=TRACK_KEY;
			break;

		case CT_REXX:
			DUMPMSG("ARexx CROUTON");
d1867 2
a1868 5
			if(PreviousTrack==TRACK_START) {
				ReportSequenceError(Edit,FG,count,ErrMsg42); //Arexx not allowed here.  Please start with a video event.
				VidEvent=NULL;
				break;
			}
d1870 1
a1870 5
			if(PreviousTrack==TRACK_TRANS) {
				ReportSequenceError(Edit,FG,count,ErrMsg43); //Arexx pages must not be placed after Effects croutons
				VidEvent=NULL;
				break;
			}
d1872 1
a1872 7
			VidEvent->FG = FG;
			VidEvent->CurrentPosition=count;
			VidEvent->FGCcommand = FGC_SELECT;
			VidEvent->Time = (PreviousVideo->Time)+GetOverlayDelay(PreVidFG,FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
			VidEvent->TimeTolerance = AREXXTOLERANCE;		//allow for some error !!!!!!
			VidEvent++;
			VidCount++;
d1874 1
a1874 4
			PreviousFG=FG;
		   PreviousCount=count;
			PreviousTrack=TRACK_AREXX;
			break;
d1876 1
a1876 2
		case CT_AUDIO:
			DUMPMSG("AUDIO CROUTON");
d1878 4
a1881 5
			if(HasAudio(FG))	// Audio Volume might be zero
			{
				if(PreviousTrack==TRACK_START) {
					ReportSequenceError(Edit,FG,count,ErrMsg8); //Audio clips not allowed here.  Please start with a video event.
					VidEvent=NULL;
d1885 1
a1885 5
				if(PreviousTrack==TRACK_TRANS) {
					ReportSequenceError(Edit,FG,count,ErrMsg9); //Audio Clips must not be placed after Effects
					VidEvent=NULL;
					break;
				}
d1887 11
a1897 1
				audlength = GetAudioDuration(FG);
d1899 4
a1902 7
// Marty removed this, as Flyer can now handle any length audio clips
//				if(audlength < 12)
//				{
//					ReportSequenceError(Edit,FG,count,ErrMsg31); //Audio clips must be >12 fields
//					VidEvent=NULL;
//					break;
//				}
d1904 2
a1905 2
				AudEvent->StartField=audstart=GetAudioStart(FG);
				AudEvent->Time = (PreviousVideo->Time)+GetOverlayDelay(PreVidFG,FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
a1906 2
//				DUMPSDECL	("1 AudEvent->Time",AudEvent->Time,"\\");
//				DUMPSDECL	("1 audlength",audlength,"\\");
d1908 2
a1909 2
// Crop to beginning of sequence
				if((AudEvent->Time) < 0)
d1911 9
a1920 3
					AudEvent->StartField-=(AudEvent->Time);
					audlength+=(AudEvent->Time);	//might end up negative!
					AudEvent->Time=0;
d1922 1
a1922 2
//				DUMPSDECL	("2 AudEvent->StartField",AudEvent->StartField,"\\");
//				DUMPSDECL	("2 audlength",audlength,"\\");
d1924 8
a1931 1
				}
d1933 1
a1933 2
// Crop to end of sequence if necessary
				if((audlength > 0) && ((audlength+AudEvent->Time) > SequenceCmd.TimeAtSequenceEnd)) audlength = SequenceCmd.TimeAtSequenceEnd-(AudEvent->Time);
d1935 2
a1936 1
//				DUMPSDECL	("3 audlength",audlength,"\\");
d1938 1
a1938 2
// Only Q audio if actually occurs during this sequence.
				if(audlength > 0)
d1940 13
a1952 1
					if(!(ci=DHD_ClipInfo((char *)FG->FileName)) || (ci->Fields != GetValue((struct FastGadget *)FG,TAG(RecFields))))
d1954 11
a1964 3
						ReportSequenceError(Edit,FG,count,ErrMsg41); //File not found!
						VidEvent=NULL;
						break;
d1967 5
a1971 9
					AudEvent->FG = FG;
					AudEvent->CurrentPosition=count;
					AudEvent->FGCcommand = FGC_SELECT;

					if((AudEvent->Time) < PreviousEndOfEffect) {
						ReportSequenceError(Edit,FG,count,ErrMsg10); //Please put this clip after an earlier video event.
						VidEvent=NULL;
						break;
					}
d1973 8
a1980 4
//***!! This check isn't really important unless we want to keep the croutons in order!
//					if((AudEvent->Time)< PreviousAudioStartTime) {
//						ReportSequenceError(Edit,FG,count,ErrMsg10); //Audio crouton should be moved earlier in the project.
//						VidEvent=NULL;
d1983 1
a1984 6
					if(MakeClipHeadR((char *)FG->FileName, 0L, 0L, AudEvent->StartField, audlength))
					{
						ReportSequenceError(Edit,FG,count,ErrMsg24); //Unable to create Audio clip on audio drive.
						VidEvent=NULL;
						break;
					}
d1986 2
a1987 14
					PreviousAudioStartTime = AudEvent->Time;	// NOT CURRENTLY USED!
					PreviousFG=FG;
					PreviousCount=count;
					PreviousTrack=TRACK_AUDIO;
					AudEvent++;
					AudCount++;

					if (!FlyerBase) {
						ReportSequenceError(Edit,FG,count,ErrMsg11); //Can't play audio clips without a Flyer.
						VidEvent=NULL;
						break;
					}
				}
			}
d1989 1
a1989 1
			break;
d1991 2
d1994 8
a2001 4
		case CT_SCROLL:
		case CT_CRAWL:
		case CT_KEYEDANIM:
			DUMPMSG("SCROLL/CRAWL CROUTON");
a2002 3
			if(PreviousTrack==TRACK_START) {
				ReportSequenceError(Edit,FG,count,ErrMsg38); //CG page not allowed here.  Please start with a video event.
				VidEvent=NULL;
d2004 3
a2006 1
			}
d2008 1
a2008 3
			if(PreviousTrack==TRACK_TRANS) {
				ReportSequenceError(Edit,FG,count,ErrMsg39); //CG pages must not be placed after Effects croutons
				VidEvent=NULL;
a2009 1
			}
d2011 1
a2011 6
			VidEvent->FG = FG;
			VidEvent->CurrentPosition=count;
			VidEvent->FGCcommand = FGC_SELECT;
			VidEvent->Time = 0;	//as soon as possible
			VidEvent++;
			VidCount++;
d2013 3
a2015 5
			VidEvent->FG = FG;
			VidEvent->CurrentPosition=count;
			VidEvent->FGCcommand = FGC_TOMAIN;
			VidEvent->TimeTolerance = SCRAWLKEYANIMTOLERANCE;		//allow for some error !!!!!!
			VidEvent->Time = (PreviousVideo->Time)+GetOverlayDelay(PreVidFG,FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
d2017 2
a2018 5
			PreviousFG=FG;
		   PreviousCount=count;
			PreviousTrack=TRACK_FX;
			VidEvent++;
			VidCount++;
d2020 1
a2020 3
			break;
//----------------------------------------------------------------------
		case CT_KEY:
a2021 6
//	ReportSequenceError(Edit,FG,count,ErrMsg18); //Keyed crouton in wrong order.  Move earlier in the project.
//	ReportSequenceError(Edit,FG,count,ErrMsg19); //Keyed crouton can't start until previous Effect has finshed.
//	ReportSequenceError(Edit,FG,count,ErrMsg20); //Keyed crouton can't start before the clip.  Use a later start time.
//	ReportSequenceError(Edit,FG,count,ErrMsg21); //Keyed crouton can't start after the clip.  Use an earlier start time.
//	ReportSequenceError(Edit,FG,count,ErrMsg22); //Keyed crouton can't start until previous Key has finished.
			DUMPMSG("KEY CROUTON or CRFX");
d2023 7
a2029 5
			if(PreviousTrack==TRACK_START) {
				ReportSequenceError(Edit,FG,count,ErrMsg17); //Key not allowed here.  Please start with a video event.
				VidEvent=NULL;
				break;
			}
d2031 4
a2034 5
			if(PreviousTrack==TRACK_TRANS) {
				ReportSequenceError(Edit,FG,count,ErrMsg23); //Key pages must not be placed after Effects croutons
				VidEvent=NULL;
				break;
			}
d2036 1
a2036 6
			VidEvent->FG = FG;
			VidEvent->CurrentPosition=count;
			VidEvent->FGCcommand = FGC_SELECT;
			VidEvent->Time = 0;	//as soon as possible
			VidEvent++;
			VidCount++;
d2038 18
a2055 12
			VidEvent->FG = FG;
			VidEvent->CurrentPosition=count;
#ifdef KEY_FADE
			if(GetFadeInDuration(FG))
				VidEvent->FGCcommand = FGC_AUTO;
			else
#endif
				VidEvent->FGCcommand = FGC_TOMAIN;
			VidEvent->Time = (PreviousVideo->Time)+GetOverlayDelay(PreVidFG,FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
			DUMPUDECL("**Key ToMain: at ",VidEvent->Time," \\");
			VidEvent++;
			VidCount++;
d2057 5
a2061 19
			VidEvent->FG = FG;  // Remove Key Event, this MUST have its time
			VidEvent->CurrentPosition=count;  // reset, if another event happens before it is
//#ifdef KEY_FADE
//			if(GetFadeInDuration(FG))
				VidEvent->FGCcommand = FGC_AUTO;
//			else
//#endif
//				VidEvent->FGCcommand = FGC_REMOVE;  // due to end... AC
			VidEvent->Time = (PreviousVideo->Time)
						+GetOverlayDelay(PreVidFG,FG)
						-(PreviousVideo->StartField) + GetDuration(FG);
			DUMPUDECL("**Key Remove: at ",VidEvent->Time," \\");
			KeyKill=VidEvent;
			VidEvent++;
			VidCount++;

			PreviousFG=FG;
			PreviousCount=count;
			PreviousTrack=TRACK_KEY;
d2063 3
a2065 1
			break;
a2066 6
//----------------------------------------------------------------------
// Transitional effects.  I really need new types for non-transitions!!!
		case CT_FXANIM:
		case CT_FXILBM:
		case CT_FXALGO:
			DUMPMSG("FXANIM/ILBM/ALGO CROUTON");
d2068 5
d2074 3
a2076 6
// This error is bogus if it's a solid ANIM
			if (!GetNextGadget(FG)) {
					ReportSequenceError(Edit,FG,count,ErrMsg6); //Can't end sequence with an Effect.
					VidEvent=NULL;
					break;
			}
d2078 10
a2087 5
// This error is bogus if it's a solid ANIM
			if(PreviousTrack==TRACK_START) {
					ReportSequenceError(Edit,FG,count,ErrMsg12); //Effects not allowed here.  Please start with a video event.
					VidEvent=NULL;
					break;
d2089 1
d2091 12
a2102 7
// FALL THRU
// 		case CT_VIDEOANIM:

			if(PreviousTrack==TRACK_TRANS) {
					ReportSequenceError(Edit,FG,count,ErrMsg7); //Can't sequence two Effects in a row.
					VidEvent=NULL;
					break;
d2104 1
a2105 1
//	ReportSequenceError(Edit,FG,count,ErrMsg16); //Effect not allowed during keying.
d2107 2
a2108 4
			PreviousFG=FG;
			PreviousCount=count;
			PreviousTrack=TRACK_TRANS;  //**!! NOT REALLY IF VIDEOANIM
			break;
d2111 3
a2113 5
//----------------------------------------------------------------------
		case CT_VIDEO:
				VidEvent->StartField=GetStartField(FG);
				PutAdjustedVideoStart(FG,VidEvent->StartField);
				FinalClip=VidEvent;
d2115 19
a2133 1
//				DUMPUDECL	("Assume InPoint=",VidEvent->StartField,"\\");
a2134 6
		case CT_STILL:
				DUMPSTR("VIDEO OR FLYERSTILL CROUTON  ");
				DUMPMSG((char *)FG->FileName);
				fudge=VIDEOPREROLLFUDGE;
// This assumes a Take to bring in this video.  If this actually transitions
// in, then some values must be adjusted.
d2136 2
a2137 6
				if(!(ci=DHD_ClipInfo((char *)FG->FileName)) )
				{
					ReportSequenceError(Edit,FG,count,ErrMsg41); //File not found!
					VidEvent=NULL;
					break;
				}
a2138 1
				FinalClip=VidEvent;
d2140 1
a2140 1
// fall thru the same logic as FrameStores
d2142 1
a2142 5
		case CT_FRAMESTORE:
		case CT_VIDEOANIM:		//**!! DOES THIS REALLY BELONG HERE????
		case CT_IMAGE:
				if(!fudge) fudge=FRAMEPREROLLFUDGE;
		case CT_MAIN:
d2144 3
a2146 1
//TAG_AdjustedVideoStart=VidEvent->StartField=0 for FRAMSTORE/VIDEOANIM/MAIN/IMAGE/FLYERSTILL croutons
d2148 2
a2149 1
				if (FG->ObjectType != CT_VIDEO) { DUMPMSG("FRAMESTORE/VIDEOANIM/MAIN/IMAGE CROUTON"); }
d2151 26
a2176 4
				VidEvent->Time = CurrentField;	//=1st field of video will start at this time (assuming Cut)
				VidEvent->FG = CurVidFG= FG;
				VidEvent->CurrentPosition=count;
				VidEvent->FGCcommand = FGC_SELECT;
d2178 1
a2178 2
// This assumed value can be altered later if there are video transions.
				PutAdjustedVideoDuration(FG,GetDuration(FG));
a2179 4
				CurrentVideo = VidEvent;
				EndOfVideo= CurrentField+GetDuration(FG);  //=field after the video
				VidEvent++;
				VidCount++;
d2181 13
a2193 1
				PreviousEndOfEffect=EndOfEffect;
d2195 10
d2206 6
d2214 3
a2216 4
// Can't do takes under keys, so kill key when next event comes up AC
				if(PreviousTrack==TRACK_KEY) {
					DUMPUDECL("Prev Key End: ",KeyKill->Time,"  ");
					DUMPUDECL("CurrentField: ",CurrentField,"  ");
d2218 2
a2219 2
					if(KeyKill && KeyKill->Time>(CurrentField-fudge))
						KeyKill->Time=CurrentField-fudge; // a little margin.. necessary???
d2221 2
a2222 1
				}
d2225 4
d2230 4
d2235 2
a2236 5
//---------------------------------
				if(PreviousTrack==TRACK_TRANS) {
// Previous Crouton is a Transition, so do an AUTO
// to bring in the new video.
// This implies some previous video source also.
d2238 8
a2245 6
					VidEvent->FG = PreviousFG;
					VidEvent->CurrentPosition=PreviousCount;
					VidEvent->FGCcommand = FGC_SELECT;
					VidEvent->Time = 0;	//as soon as possible
					VidEvent++;
					VidCount++;
d2247 2
a2248 3
					VidEvent->FG = PreviousFG;
					VidEvent->CurrentPosition=PreviousCount;
					VidEvent->FGCcommand = FGC_TOMAIN;
d2250 5
a2254 2
// ***!!! This time is bogus if it's a solid ANIM because it isn't centered on a cut!!!!
// ***!!! Solid ANIMs have video time!!!
a2255 1
					VidEvent->Time = CurrentField-(FXadvance=((vidlength=GetNumFields(PreviousFG))*(32767-GetDelay(PreviousFG))/65534)); //-0 -> -vidlength
d2257 2
a2258 1
					DUMPSDECL("Auto Previous FX at ",VidEvent->Time,"\\");
a2259 7
// Prevent this Transition from occuring too close to previous Takes/Autos.
// Allow time for this Transition FX to load and/or the Flyer to Q.
					switch(PreviousFG->ObjectType)
					{
//						case	CT_FXILBM:
//							fudge=ILBMPREROLLFUDGE;	//Flyer can be Qing while this loads
//						break;
d2261 5
a2265 3
						case	CT_FXANIM:
							fudge=ANIMPREROLLFUDGE;	//Flyer can be Qing while this loads
						break;
d2267 4
a2270 4
						case	CT_FXALGO:	//Flyer Qing is longer than this FX preroll
							if(((CurVidFG->ObjectType)==CT_VIDEO) || ((CurVidFG->ObjectType)==CT_STILL) ) fudge=VIDEOPREROLLFUDGE; // > 8 fields
								else fudge=FXPREROLLFUDGE;
							break;
d2272 2
a2273 4
						default:
							fudge=FXPREROLLFUDGE;
						break;
					}
d2275 5
a2279 3
					switch(CurVidFG->ObjectType)
					{
						case	CT_FRAMESTORE:
d2281 1
a2281 6
// If any following ChromaFX (can't transition in VideoANIMs, Scrawls, Keys etc...)
// have a Delay of 0, then we need to add these load times also!! ****!!!!
//
						case  CT_KEY:
						case CT_FXILBM:
						case	CT_FXCR:
d2283 6
a2288 2
							fudge+=FRAMEPREROLLFUDGE;
						break;
d2290 8
a2297 3
						case	CT_IMAGE:
							fudge+=RGBPREROLLFUDGE;
						break;
d2299 11
a2309 3
						default:
						 break;
					}
d2311 3
a2313 4
					if((VidEvent->Time) < (EndOfEffect+fudge)) {
						if(PreviousEffect==EFFECT_TAKE)
							ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg1); //Can't sequence. Effect starts too early.
							else ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg2); //Effect starts too soon after previous effect.
d2315 1
a2315 3
						VidEvent=NULL;
						break;
					}
d2317 5
a2321 5
					if((EndOfEffect=(VidEvent->Time)+vidlength) > EndOfVideo) {
						ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg3); //Effect ends too late.
						VidEvent=NULL;
						break;
					}
d2323 1
a2323 12
// Extend previous videos outpoint (round up to color frame)
// FXs can't extend previous video's audio!
					PutAdjustedVideoDuration(PreVidFG, GetAdjustedVideoDuration(PreVidFG) + ROUNDTOFRAME(vidlength-FXadvance));
 					DUMPUDECL	("Previous duration changed to=",(LONG)GetAdjustedVideoDuration(PreVidFG),"\\");

					if (PreVidFG->ObjectType==CT_VIDEO) {
							if ((GetAdjustedVideoDuration(PreVidFG)+(PreviousVideo->StartField)) > GetRecFields(PreVidFG)) {
							ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg4); //Effect can not end after previous clip.
							VidEvent=NULL;
							break;
						}
					}
d2325 3
a2327 1
					FXadvance = ROUNDTOFRAME(FXadvance);
d2329 1
a2329 6
// Extend current videos inpoint (round down to color frame)
// FXs can't extend currents video's audio!
					if (CurVidFG->ObjectType==CT_VIDEO)
					{
						CurrentVideo->StartField -= FXadvance;
						PutAdjustedVideoStart(CurVidFG, CurrentVideo->StartField);
d2331 2
a2332 1
 						DUMPUDECL	("InPoint changed to=",CurrentVideo->StartField,"\\");
d2334 2
a2335 5
						if ((CurrentVideo->StartField) < 0) {
							ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg5); //Effect can not start before following clip.
							VidEvent=NULL;
							break;
						}
a2336 21
						if (((PreVidFG->ObjectType == CT_VIDEO) ||(PreVidFG->ObjectType == CT_STILL)) && SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(CurVidFG->FileName)))
						{
// Sending out our Video+Audio Head here!
							vidstart=CurrentVideo->StartField;
							audstart=audlength=0;

							if(HasAudio(CurVidFG))
							{
								audstart=GetAudioStart(CurVidFG);
								audlength=GetAudioDuration(CurVidFG);
								CropAudioToVideo((ULONG)vidstart,(ULONG)vidlength,(ULONG *)(&audstart),(ULONG *)(&audlength));
							}

							if(MakeClipHeadR((char *)CurVidFG->FileName, vidstart, vidlength, audstart, audlength))
							{
								ReportSequenceError(Edit,FG,count,ErrMsg13); //Unable to do AB roll. Not enough Flyer space.
								VidEvent=NULL;
								break;
							}
						}
					}
d2338 22
a2359 13
					if (CurVidFG->ObjectType==CT_STILL)
					{
						if (((PreVidFG->ObjectType == CT_VIDEO) ||(PreVidFG->ObjectType == CT_STILL)) && SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(CurVidFG->FileName)))
						{
// Sending out our FlyerStill as a Head!
							if(MakeClipHeadR((char *)CurVidFG->FileName, 0L, 4L, 0L, 0L))
							{
								ReportSequenceError(Edit,FG,count,ErrMsg13); //Unable to do AB roll. Not enough Flyer space.
								VidEvent=NULL;
								break;
							}
						}
					}
d2361 1
a2361 1
					CurrentVideo->Time -= FXadvance;
d2363 2
a2364 2
// Extend the current video because of the early lead in
					PutAdjustedVideoDuration(CurVidFG, GetAdjustedVideoDuration(CurVidFG) + FXadvance);
d2366 5
a2370 7
					PreviousEffect=EFFECT_TRANS;
				}
//************************************************************
				else	{
// Previous Crouton is not an Transition, so do a TAKE
// Prevent this Take from occuring too close to previous Takes/Autos.
// Allow time for this new Video source to load and/or the Flyer to Q.
d2372 5
a2376 5
					if(PreviousVideo)
					{
						switch(CurVidFG->ObjectType)
						{
							case	CT_FRAMESTORE:
d2378 3
a2380 5
// If any following Scrolls, Crawls, KeyedANIMs, KeyedStills, or ChromaFX
// have a Delay of 0, then we need to add these load times also!! ****!!!!
							case	CT_FXILBM:
							case	CT_FXCR:
							case	CT_KEY:
d2382 4
a2385 2
								fudge=FRAMEPREROLLFUDGE;
							break;
a2386 3
							case	CT_IMAGE:
								fudge=RGBPREROLLFUDGE;
							break;
d2388 11
a2398 3
							case	CT_VIDEOANIM:
								fudge=ANIMPREROLLFUDGE;
							break;
a2399 4
							case	CT_VIDEO:
							case	CT_STILL:
								fudge=VIDEOPREROLLFUDGE;
							break;
d2401 9
a2409 4
							default:
								fudge=0;
							break;
						}
d2411 9
a2419 6
						if(CurrentField < (EndOfEffect+fudge)) {
							ReportSequenceError(Edit,CurVidFG,count,ErrMsg37); //Can't sequence. Not enough preroll time to start video event.
							VidEvent=NULL;
							break;
						}
					}
d2421 1
a2421 8
/******************** DISABLE THIS CODE ***!!!!!**************
// Sending out minimal 4 to 20 field Head
// This code needs to also respect FlyerStills **!!
					if ((CurVidFG->ObjectType==CT_VIDEO) && PreviousVideo &&
						 (PreVidFG->ObjectType == CT_VIDEO) &&
                    SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(CurVidFG->FileName)))
					{
						if((vidlength=GetAdjustedVideoDuration(CurVidFG))>20) vidlength=20;
d2423 5
a2427 2
						vidstart=CurrentVideo->StartField;
						audstart=audlength=0;
d2429 2
a2430 5
						if(HasAudio(CurVidFG))
						{
							audstart=vidstart;
							audlength=vidlength;
						}
d2432 10
a2441 8
						if(MakeClipHeadR((char *)CurVidFG->FileName, vidstart, vidlength, audstart, audlength))
						{
							ReportSequenceError(Edit,FG,count,ErrMsg25);  //Unable to do cut. Not enough Flyer space.
							VidEvent=NULL;
							break;
						}
					}
******************************************************/
d2443 1
a2443 4
					VidEvent->FG = FG;
					VidEvent->CurrentPosition=count;
					VidEvent->FGCcommand = FGC_TOMAIN;
					VidEvent->Time = CurrentField;
d2445 1
a2445 1
					DUMPSDECL("Take VIDEO at ",VidEvent->Time,"\\");
a2446 3
					EndOfEffect=CurrentField;
					PreviousEffect=EFFECT_TAKE;
				}
d2448 4
a2451 3
//-------------------------------------------------------------------
				if(CurVidFG->ObjectType==CT_VIDEO)
				{
d2453 6
a2458 4
// Handle our leading audio if we're a Video with leading audio
					if (HasAudio(CurVidFG) &&
					     ((audstart=GetAudioStart(CurVidFG)) < (vidstart=CurrentVideo->StartField)))
					{
d2460 3
a2462 2
// At this point, we know there's some leading audio, though it might all
// occur long before any video.
d2464 3
a2466 3
// Crop end to beginning of video.
					   if((audstart+(audlength=GetAudioDuration(FG))) > vidstart)
							audlength=vidstart-audstart;
d2468 4
a2471 1
						AudEvent->Time = (CurrentVideo->Time)+audstart-vidstart;  //1st field of audio will start at this time
d2473 6
a2478 7
// Crop to beginning of sequence
						if((AudEvent->Time) < 0)
						{
							audstart-=(AudEvent->Time);
							audlength+=(AudEvent->Time);	//might end up negative!
							AudEvent->Time=0;
						}
d2480 2
a2481 4
// Only Q audio if it actually occurs during the sequence.
						if(audlength > 0)
						{
							AudEvent->StartField=audstart;
d2483 5
a2487 10
							AudEvent->FG = CurVidFG;
							AudEvent->CurrentPosition=count;
							AudEvent->FGCcommand = FGC_SELECT;

							if(MakeClipHeadR((char *)CurVidFG->FileName, 0L, 0L, AudEvent->StartField, audlength))
							{
								ReportSequenceError(Edit,CurVidFG,count,ErrMsg27); //Unable to create Audio clip on audio drive.
								VidEvent=NULL;
								break;
							}
d2489 3
a2491 4
							AudEvent++;
							AudCount++;
						}
					}
d2493 3
a2495 6
/********************/
//Check for minimum Video clip length
					if (GetAdjustedVideoDuration(CurVidFG) < 20)
					{
						ReportSequenceError(Edit,CurVidFG,count,ErrMsg29);  //Can't sequence clips that are this short
						VidEvent=NULL;
a2496 2
					}
/********************/
d2498 2
d2501 1
d2503 6
a2508 8
				if((CurVidFG->ObjectType==CT_VIDEO) || (CurVidFG->ObjectType==CT_STILL))
				{
					if (!FlyerBase) {
						ReportSequenceError(Edit,FG,count,ErrMsg14); //Can't play video clips without a Flyer.
						VidEvent=NULL;
						break;
					}
				}
d2510 4
a2513 15
//-------------------------------------------------------------------
// Handle previous videos trailing audio if it was a Video with trailing audio
				if ( PreVidFG && (PreVidFG->ObjectType==CT_VIDEO) &&
					  HasAudio(PreVidFG) &&
				    (
						(audend=
						(audstart=GetAudioStart(PreVidFG))+
                  (audlength=GetAudioDuration(PreVidFG)) )
						 >
						(vidend=
						(vidstart=PreviousVideo->StartField)+
                  (vidlength=GetAdjustedVideoDuration(PreVidFG)) )
					 )
					)
 				{
d2515 4
a2518 2
// At this point, we know there's some tailing audio, though it might all
// occur long after any video.
d2520 1
a2520 6
// Crop start to end of video.
				   if(audstart < vidend)
					{
						audlength=audend-vidend;
						audstart=vidend;
					}
d2522 10
a2531 2
					AudEvent->Time = (PreviousVideo->Time)+audstart-vidstart;  //1st field of audio will start at this time
					AudEvent->StartField=audstart;
d2533 5
a2537 3
					AudEvent->FG = PreVidFG;
					AudEvent->CurrentPosition=PreviousVideo->CurrentPosition;
					AudEvent->FGCcommand = FGC_SELECT;
d2539 3
a2541 2
// Crop audio heads to end of video sequence
					if((audlength+AudEvent->Time) > SequenceCmd.TimeAtSequenceEnd) audlength = SequenceCmd.TimeAtSequenceEnd-(AudEvent->Time);
d2543 8
a2550 12
// Only Q audio if it actually occurs during the sequence.
					if(audlength > 0)
					{
						if(MakeClipHeadR((char *)PreVidFG->FileName, 0L, 0L, AudEvent->StartField,audlength))
						{
							ReportSequenceError(Edit,PreVidFG,AudEvent->CurrentPosition,ErrMsg28); //Unable to create Audio clip on audio drive.
							VidEvent=NULL;
							break;
						}
						AudEvent++;
						AudCount++;
					}
d2552 1
d2554 1
a2554 14
//-----------
				DUMPUDECL	("VIDEO time=",(LONG)CurrentVideo->Time,"\\");
 				DUMPUDECL	("Assume duration=",(LONG)GetAdjustedVideoDuration(CurVidFG),"\\");

				CurrentField=EndOfVideo;

				PreviousVideo = CurrentVideo;
				PreVidFG=CurVidFG;

				PreviousFG=FG;
				PreviousCount=count;
				PreviousTrack=TRACK_VIDEO;
				VidEvent++;
				VidCount++;
d2556 2
a2557 1
				break;
d2559 4
a2562 4
//----------
		default:
				//	Don't recognize this content in a sequence.
				break;
d2564 1
a2564 1
				} // END OF SWITCH
d2566 8
a2573 6
				FG = GetNextGadget(FG);
				count++;

			} // END OF WHILE

//**********************************************************
d2575 1
a2575 3
			headerr = SendSwitcherReply(ES_EndHeadList,NULL);
			DUMPHEXIL("EndHeadList error=",headerr,"\\");
			if(headerr == 9)		// Tie into FERR_NOAUDIOCHAN!
d2577 1
a2577 2
				ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,-1,ErrMsg44); //Unable to create heads of strip audio
				VidEvent=NULL;
d2579 3
a2581 5
			else if (headerr)		// Will be FERR_FULL ($21) when full, handle any other non-0 as well!
			{
				ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,-1,ErrMsg36); //Unable to create heads of strip audio
				VidEvent=NULL;
			}
d2583 9
a2591 1
//*** If any Trailing audio extends past end, then it will be cropped!!!!
d2593 2
a2594 4
			if(VidEvent)  // (VidEvent= error flag)
			{
				VidEvent->FG = NULL;
				VidEvent->Time = CurrentField;  //field just after the last field of sequence
d2596 9
a2604 1
				if(FinalClip) FinalClip->Flags1 |= FLAGS1F_LASTEVENT;
a2605 2
// This is only used in the debug stuff, but I put it here to stop the Event non used warning.
				EventPtr = VidSequence;		//Event = temporary pointer
d2607 6
a2612 1
#ifdef	SERDEBUG
d2614 6
a2619 2
				DUMPMSG("******************************************");
				DUMPMSG("Video Events =============================");
d2621 2
a2622 22
				while(EventPtr->FG)
				{
					DUMPSTR(EventPtr->FG->FileName);
					DUMPUDECB(": #",(UBYTE)(EventPtr->CurrentPosition)," ");
					DUMPUDECL("Time=",EventPtr->Time," ");
					DUMPUDECW("StrtFld=",(UWORD)(EventPtr->StartField)," ");
					DUMPUDECW("FGC=",EventPtr->FGCcommand,"\\");
					EventPtr++;
				}

				if(EventPtr=AudSequence) {
					DUMPMSG("Audio EventPtrs =============================");
					while(EventPtr->FG)
					{
						DUMPSTR(EventPtr->FG->FileName);
						DUMPUDECB(": #",(UBYTE)(EventPtr->CurrentPosition)," ");
						DUMPUDECL("Time=",EventPtr->Time," ");
						DUMPUDECW("StrtFld=",(UWORD)(EventPtr->StartField)," ");
						DUMPUDECW("FGC=",EventPtr->FGCcommand,"\\");
						EventPtr++;
					}
				}
d2624 3
d2628 3
a2630 2
				DUMPMSG("*****************************");
#endif
d2632 4
a2635 3
				if(AudSequence)
				{
					AudEvent->FG = NULL;
d2637 4
a2640 5
					DUMPMSG("**************************************************");
					for(count=0; count<AudCount; count++)
					{
						DUMPMEM("Unsorted AudEvent",(UBYTE *)(AudSequence+count),sizeof(struct Event));
					}
d2642 8
a2649 1
					SortEvents(AudSequence,(ULONG)AudCount);
d2651 25
a2675 5
					DUMPMSG("**************************************");
					for(count=0; count<AudCount; count++)
					{
						DUMPMEM("Sorted AudEvent",(UBYTE *)(AudSequence+count),sizeof(struct Event));
					}
d2677 9
a2685 1
				}
d2687 11
a2697 1
				SetRunningTime(CurrentField);
d2699 9
d2709 1
a2709 2
				DisplayMessage("Press Right Mouse Button To Play Sequence");
				Wait4RMB();
d2711 1
d2713 3
a2715 5
//				DUMPMSG	("Play Sequence ...............");
//				DUMPMEM("Sequence=",(UBYTE *)Sequence,VidSeqMemSize);
//				DUMPMSG("Before ES_StartSeq sends ES_StartSeq");
					SendSwitcherReply(ES_StartSeq,NULL);	//set bit 4 of TB_DisplayRenderMode
//				DUMPMSG("  After ES_StartSeq sent ES_StartSeq");
d2717 2
a2718 1
				FG=PlaySequence(&SequenceCmd);  // Non NULL if error or abort occured
a2719 3
//				DUMPMSG("Before ES_Stop() sends ES_Stop");
					SendSwitcherReply(ES_Stop,NULL);		//set bit 4 of TB_DisplayRenderMode
//				DUMPMSG("  After ES_Stop() sent ES_Stop");
d2721 10
a2730 5
// some effects leave us with a bogus lock
#ifndef FINAL_CODE
				if (ToasterBase)
#endif
					CurrentDir(GetBootLock((struct ToasterBase *)ToasterBase));
d2732 1
a2732 1
				DUMPHEXIL("&SequenceCmd=",(LONG)(&SequenceCmd),"\\");
d2734 1
a2734 6
				if(SequenceCmd.ErrorEvent)
				{
// Does this if there was an error during the sequence.
					DUMPHEXIL("ErrorEvent=",(LONG)(SequenceCmd.ErrorEvent),"\\");
					DUMPHEXIL("FG=",(LONG)(SequenceCmd.ErrorEvent->FG),"\\");
					DUMPHEXIL("ErrorMsg=",(LONG)(SequenceCmd.ErrorMsg),"\\");
d2736 4
a2739 5
					switch(SequenceCmd.ErrorNum)
					{
						case	1:
						ReportSequenceError(Edit,SequenceCmd.ErrorEvent->FG,-1,ErrMsg40); //Queue error, time already passed.
						break;
d2741 28
a2768 3
						default:
						break;
					}
d2770 2
a2771 4
				}
				else
				{
					if(!FG) FG = (struct ExtFastGadget *)CurFG;	// Does this if abort or it finished OK.
a2772 2
					HiliteNewFG(Edit,FG,-1);	//hilite initially selected or abort crouton
				}
d2774 8
a2781 2
			} // if test on Event flag to see if any sequence errors were detected.
//-----------------------------------------------------------
d2783 4
a2786 2
		}
		else
d2788 2
a2789 2
			ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,-1,ErrMsg15); //Not enough memory to play this sequence!
			VidEvent=NULL;
d2792 40
a2831 1
		DUMPMSG("Before FreeMems");
d2833 10
a2842 2
		if(VidSequence)		FreeMem(VidSequence, VidSeqMemSize);
		if(AudSequence)		FreeMem(AudSequence, AudSeqMemSize);
d2844 10
a2853 1
		DUMPMSG("After FreeMems");
d2855 8
a2862 1
	}	// if Test on FG & Project pointers
d2864 5
a2868 2
	DisplayNormalSprite();
	return(Edit);
d2870 2
d2873 4
a2876 2
//*******************************************************************
// Wrapper for SeqHandlePlay() so that Shift will do play from any point
d2880 1
d2889 2
a2890 1
		if (IntuiMsg->Class == IDCMP_RAWKEY) {
d2900 4
a2903 8

// (Old SHIFT-TAB code)
//	/* SHIFT-PLAY same as ID_PLAY_PART button */
//	if ( (IntuiMsg->Qualifier&(IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT))
//	&& (gadID==ID_PLAY_PART) )
//		FirstFG=(struct ExtFastGadget *)CurFG;
//	else
//		FirstFG=NULL;
d2905 2
a2906 5
	FirstFG=(struct ExtFastGadget *)CurFG;
	SeqStartFG=StartingSequenceEvent();	//Uses FirstFG, SeqStartFG might be NULL if none

	if (gadID==ID_PLAY_PART)
		FirstFG=(struct ExtFastGadget *)CurFG;
d2908 1
a2908 1
		FirstFG=SeqStartFG;
a2909 1
#ifdef	SERDEBUG
d2913 135
a3047 1
	DUMPHEXIL("FirstFG=",(LONG)FirstFG,"\\");
d3050 19
a3068 2
	RetEdit=SeqHandlePlay(Edit,IntuiMsg);
	return(RetEdit);
d3071 6
a3076 2
//*******************************************************************
BOOL SameFlyerVolumes(char *name1, char *name2)
d3078 18
a3095 3
	do
	 if(*name1 != *name2++) return(FALSE);
	while(*name1++ != ':');
d3097 1
a3097 1
	return(TRUE);
d3100 6
a3105 2
//*******************************************************************
BOOL DriveType(char *name1)
d3107 3
a3109 1
//	UBYTE *OurFlyerDrives;
d3111 1
a3111 1
	return(TRUE);
d3115 6
a3120 3
//*******************************************************************
struct EditWindow *HandleRewind(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
d3122 109
a3230 1
	return(Edit);
d3233 6
a3238 3
//*******************************************************************
struct EditWindow *HandleStop(
	struct EditWindow *Edit,struct IntuiMessage *IntuiMsg)
d3240 111
a3350 5
	DUMPMSG("Before HandleStop() sends ES_Stop");
//	DHD_Abort(0);
	SendSwitcherReply(ES_Stop,NULL);	//clr bit 4 of TB_DisplayRenderMode
	DUMPMSG("  After HandleStop() sent ES_Stop");
	return(Edit);
@


2.87
log
@Fixed play audio bug (audlength), more HandlePlay() cleanup
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.86 1995/04/21 02:05:34 Flick Exp Flick $
d5 3
d320 2
d1271 3
d2308 6
a2313 1
				DUMPMSG	("Play Sequence ...............");
@


2.86
log
@Fixed pre-Q audio alignment bug for "play from crouton".  Improved Flyer head
error handling.  More improvements to HandlePlay() for ARexx
@
text
@@


2.85
log
@Cleaned up event table allocation, removed 12 field audio minimum
@
text
@@


2.84
log
@*** empty log message ***
@
text
@@


2.83
log
@Fixed enforcer hits in strange create/play/drop/play seq
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.82 1995/04/18 16:51:50 Flick Exp pfrench $
d5 3
d303 1
a303 1
//#define KEY_FADE
d1685 2
a1686 2
#ifdef KEY_FADE
			if(GetFadeInDuration(FG))
d1688 3
a1690 3
			else
#endif
				VidEvent->FGCcommand = FGC_REMOVE;  // due to end... AC
@


2.82
log
@Re-added SHIFT-TAB hotkey, fixed hit when using ARexx PROJ_PLAY
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.81 1995/03/16 16:02:07 CACHELIN4000 Exp Flick $
d5 3
d594 1
a594 1
	ULONG OurDelay;	
d845 1
a845 1
	BOOL endflag=FALSE;	
d847 1
a847 1
	
d850 2
a851 2
		type=GetCroutonType(FG);			
		
d881 1
a881 1
		while(FG!=StartFG)
d1161 1
a1161 1
		while(FG!=StartFG)
@


2.81
log
@Support keys, attempt at ChromaFX
@
text
@@


2.80
log
@Remove RecFields check on flyerstills
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.79 1995/02/23 15:20:56 CACHELIN4000 Exp CACHELIN4000 $
d5 3
d294 1
d485 16
d1055 1
d1059 1
a1059 1

d1068 1
d1191 1
a1191 1
	struct Event *PreviousVideo=NULL, *CurrentVideo, *FinalClip=NULL, *EventPtr;
d1218 1
a1218 1
				 +CroutonCount.Key
d1220 2
a1221 1
				 )*2
d1412 1
a1412 11
//			if(PreviousTrack==TRACK_START) {
//				ReportSequenceError(Edit,FG,count,ErrMsg0); //ChromaFX not allowed here.  Please start with a video event.
//				VidEvent=NULL;
//				break;
//			}

//			if(PreviousTrack==TRACK_TRANS) {
//				ReportSequenceError(Edit,FG,count,ErrMsg0); //ChromaFX pages must not be placed after Effects croutons
//				VidEvent=NULL;
//				break;
//			}
d1414 20
d1440 21
d1463 2
a1464 2
		   PreviousCount=count;
			PreviousTrack=TRACK_EFFECT;
d1634 1
d1640 1
a1640 1
			DUMPMSG("KEY CROUTON");
d1663 6
a1668 1
			VidEvent->FGCcommand = FGC_TOMAIN;
d1670 19
d1691 1
a1691 1
		   PreviousCount=count;
a1692 2
			VidEvent++;
			VidCount++;
d1746 1
a1746 1

d1763 2
a1765 1
		case CT_IMAGE:
d1786 16
d1830 3
a1832 3
						case	CT_FXILBM:
							fudge=ILBMPREROLLFUDGE;	//Flyer can be Qing while this loads
						break;
d1856 1
a1957 3



d1972 1
@


2.79
log
@Reverse logic in test of PART_PLAY button
@
text
@d3 1
a3 1
* $Id: Sequence.c,v 2.78 1995/02/19 18:19:06 Kell Exp CACHELIN4000 $
d5 3
d1667 2
a1668 1
				DUMPMSG("VIDEO OR FLYERSTILL CROUTON");
d1673 1
a1673 1
				if(!(ci=DHD_ClipInfo((char *)FG->FileName)) || (ci->Fields != GetValue((struct FastGadget *)FG,TAG(RecFields))))
@


2.78
log
@Support for putting up a Key, FlyerStills, ToasterMain, ChromaFX, ARexx, Stop, Delay vs StartTime
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.77 1995/02/19 01:19:20 Kell Exp Kell $
* $Log: sequence.c,v $
d2250 2
a2251 1
	if(Playboy->GadgetID==ID_PLAY_PART) FirstFG=SeqStartFG;
@


2.77
log
@Changed CT_FLYERSTILL to CT_STILL
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.76 1995/02/18 23:49:01 Kell Exp Kell $
d5 3
d305 7
d430 2
a431 2
//extern char *ErrMsg42[];
//extern char *ErrMsg43[];
d449 1
a449 1
static struct ExtFastGadget *FirstFG=NULL;  // Where to start sequence
d536 8
d552 19
d659 1
d810 50
d902 1
a902 1
	if (PtrProject && (FG=*PtrProject))
d938 1
a938 1
			StartFG = (struct ExtFastGadget *)(StartFG->FG.NextGadget);
d951 1
a951 1
	if (PtrProject && (FG=*PtrProject))
d979 3
a981 1
	if (PtrProject && (FG=*PtrProject) && StartFG)
d992 1
a992 1
						 ((PreviousTime+GetDelay(FG)+GetAudioDuration(FG)-PreviousStartField) > StartTime))
d1033 1
a1033 1
				case CT_CONTROL:
d1087 1
a1087 1
			FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
d1116 2
d1123 1
a1123 1
	if(PtrProject && (FG=StartFG=*PtrProject))
d1130 2
d1141 1
a1189 1
				 +CroutonCount.Effect // may only need SELECT if wipe brings in ChromaFX
d1193 1
d1195 1
a1195 1
				 +CroutonCount.Control	//only needs SELECT
d1222 1
a1222 1
			FG2=*PtrProject;
d1234 1
a1234 1
						 ((headsize=(PreviousTime+GetDelay(FG2)+(audlength=GetAudioDuration(FG2))-PreviousStartField-StartTime)) > 0))
d1380 55
d1460 1
a1460 1
				AudEvent->Time = (PreviousVideo->Time)+GetDelay(FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
d1563 1
a1563 1
			VidEvent->Time = (PreviousVideo->Time)+GetDelay(FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
a1573 1
//	ReportSequenceError(Edit,FG,count,ErrMsg17); //Keyed crouton not allowed here.  Please start with a video event.
d1579 32
a1610 1
//	ReportSequenceError(Edit,FG,count,ErrMsg23); //Keyed crouton must not be placed after Effect croutons
d1622 1
a1622 1
			if (!FG->FG.NextGadget) {
d1754 2
a1755 1
//						case	CT_FXCR:
d1873 2
a1874 3
//
//						case	CT_FXCR:
//						case	CT_KEY:
d2084 1
a2084 1
				FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
d2104 1
a2104 1
				if(FinalClip) FinalClip->Flags1=1;
d2239 10
a2248 4
	if(Playboy->GadgetID==ID_PLAY_PART)
		FirstFG=(struct ExtFastGadget *)CurFG;
	else
		FirstFG=NULL;
@


2.76
log
@Support of FlyerStills in sequencing.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.75 1995/02/10 20:26:38 Kell Exp Kell $
d5 3
d701 1
a701 1
	 ||(objtype==CT_FLYERSTILL)
d788 1
a788 1
				case CT_FLYERSTILL:
d838 1
a838 1
				case CT_FLYERSTILL:
d918 1
a918 1
				case CT_FLYERSTILL:
d989 1
a989 1
				case CT_FLYERSTILL:
d1243 1
a1243 1
				case CT_FLYERSTILL:
d1480 1
a1480 1
		case CT_FLYERSTILL:
d1558 1
a1558 1
							if(((CurVidFG->ObjectType)==CT_VIDEO) || ((CurVidFG->ObjectType)==CT_FLYERSTILL) ) fudge=VIDEOPREROLLFUDGE; // > 8 fields
d1632 1
a1632 1
						if (((PreVidFG->ObjectType == CT_VIDEO) ||(PreVidFG->ObjectType == CT_FLYERSTILL)) && SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(CurVidFG->FileName)))
d1654 1
a1654 1
					if (CurVidFG->ObjectType==CT_FLYERSTILL)
d1656 1
a1656 1
						if (((PreVidFG->ObjectType == CT_VIDEO) ||(PreVidFG->ObjectType == CT_FLYERSTILL)) && SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(CurVidFG->FileName)))
d1708 1
a1708 1
							case	CT_FLYERSTILL:
d1821 1
a1821 1
				if((CurVidFG->ObjectType==CT_VIDEO) || (CurVidFG->ObjectType==CT_FLYERSTILL))
@


2.75
log
@Now sequencing checks to make sure clips have not been deleted or re-recored since the project was loaded/created.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.74 1995/02/09 21:36:50 Kell Exp Kell $
d5 3
d698 1
a698 1
	/* ||(objtype==CT_FLYERSTILL) */
d785 1
a785 1
				/* case CT_FLYERSTILL: */
d835 1
a835 1
				/* case CT_FLYERSTILL: */
d915 1
a915 1
				/* case CT_FLYERSTILL: */
d986 1
a986 1
				/* case CT_FLYERSTILL: */
d1240 1
a1240 1
				/* case CT_FLYERSTILL: */
d1471 3
a1473 1
				DUMPMSG("VIDEO CROUTON");
d1475 5
a1489 2
				VidEvent->StartField=GetStartField(FG);
				PutAdjustedVideoStart(FG,VidEvent->StartField);
a1491 2
//				DUMPUDECL	("Assume InPoint=",VidEvent->StartField,"\\");

a1497 1
		/* case CT_FLYERSTILL: */
d1501 1
a1501 1
				if (FG->ObjectType != CT_VIDEO) { DUMPMSG("FRAMESTORE/VIDEOANIM/MAIN/IMAGE/FLYERSTILL CROUTON"); }
d1555 1
a1555 1
							if(((CurVidFG->ObjectType)==CT_VIDEO)/* || ((CurVidFG->ObjectType)==CT_FLYERSTILL)*/ ) fudge=VIDEOPREROLLFUDGE; // > 8 fields
a1601 1

d1616 2
a1617 2
					if (CurVidFG->ObjectType==CT_VIDEO) {

d1629 1
a1629 2
// Sending out Head here!
						if ((PreVidFG->ObjectType == CT_VIDEO) && SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(CurVidFG->FileName)))
d1631 1
d1651 14
d1666 2
d1672 4
a1675 1
//---------------------------------
d1705 1
a1705 1
							/* case	CT_FLYERSTILL: */
d1723 1
d1816 4
@


2.74
log
@Scrolls now have a Tolerance value on wait4time().
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.73 1995/02/09 20:44:57 Kell Exp Kell $
d5 3
d264 1
d413 1
a413 1
//extern char *ErrMsg41[];
d1071 1
d1162 7
d1208 8
d1330 7
d1472 7
@


2.73
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.72 1995/02/09 20:22:28 pfrench Exp Kell $
d5 3
d287 1
a289 2
	UBYTE		Flags3;
	UBYTE		Flags4;
d611 2
d1379 1
@


2.72
log
@fixed redraw bug when sequence ends or is aborted.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.71 1995/02/09 19:47:00 pfrench Exp pfrench $
d5 3
a1035 1
				Edit->ew_OptRender = TRUE;
d1065 2
@


2.71
log
@removed references to flyerstill file type as croutonlib
doesn't support it anywhere.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.70 1995/02/09 18:51:51 Kell Exp pfrench $
d5 4
d618 1
a629 3
//***!!! This currently isn't showing the Error crouton as hilited until
// after the user hits "continue"

a634 2
	Edit->ew_OptRender = FALSE;

d1033 1
a1935 3
//					HiliteNewFG(Edit,SequenceCmd.ErrorEvent->FG,-1);	//hilite initially selected or abort crouton
//					RefreshEdit();

a1951 1
					RefreshEdit();
@


2.70
log
@Now reports errors from sequences that failed during run time.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.69 1995/02/09 09:33:19 Kell Exp Kell $
d5 3
d230 1
a230 1
* Confidental and Proprietary. All rights reserved. 
d321 1
a321 1
#define TRACK_CONTROL	8	// Sequence & Switcher control                                                
d324 1
a324 1
#define EFFECT_TRANS		1	// marks previous effect as a transition                                       
d337 1
a337 1
	ULONG Control;	// Sequence & Switcher control                                                
d571 1
a571 1
	} 
d576 1
a576 1
	} 
d602 1
a602 1
#define ROUNDTOFRAME(n) (((n)+3)&~3)	
d629 1
a629 1
// and fg_num might = -1 if you want the code to find the crouton 
d674 1
a674 1
	
d684 1
a684 1
	 ||(objtype==CT_FLYERSTILL)
d686 3
a688 3

	return(TRUE);
	else return(FALSE);
d693 1
a693 1
*   NAME   
d715 1
a715 1
// This is a SAS Library function 
d735 1
a735 1
	return((((struct Event *)ElementA)->Time)-(((struct Event *)ElementB)->Time));	
d771 1
a771 1
				case CT_FLYERSTILL:
d821 1
a821 1
				case CT_FLYERSTILL:
d866 1
a866 1
	Count->Trans=0;	// transitional effects ANIM/ILBM/ALGO (can only be followed by a video event)	
d869 1
a869 1
	Count->FX=0;		// Keyed Things that take over the machine, SCROLL/CRAWL/KEYA	
d872 1
a872 1
	Count->Control=0;	// Sequence & Switcher control. Only requires FGC_SELECT 
d886 1
a886 1
					Count->Audio++;				
d892 1
a892 1
				if(HasAudio(FG) && 
d895 2
a896 2
					Count->Audio++;				
		
d901 1
a901 1
				case CT_FLYERSTILL:
d905 2
a906 2
	
						if(FG->ObjectType != CT_VIDEOANIM) CurrentTime+=GetDuration(FG);	
d909 1
a909 1
		
d931 1
a931 1
					Count->ARexx++;				
d935 1
a935 1
					Count->Key++;				
d941 1
a941 1
					Count->FX++;				
d945 1
a945 1
					if(HasAudio(FG)) Count->Audio++;				
d951 1
a951 1
					Count->Trans++;				
d962 1
a962 1
						Count->Audio++;				
d966 1
a966 1
				}				
d972 2
a973 2
				case CT_FLYERSTILL:
					Count->Video++;				
d996 2
a997 2
	
	if((audout < vidstart)||(audin > vidout)) *audstart=*audlength=0;	
d999 1
a999 1
	{	
d1084 1
a1084 1
				(AudSequence = SafeAllocMem((AudSeqMemSize=sizeof(struct Event) * (CroutonCount.Audio+1)),MEMF_CLEAR))) 
d1100 1
a1100 1
		
d1106 1
a1106 1
 
d1108 1
a1108 1
	
d1125 1
a1125 1
	
d1168 1
a1168 1
					if(HasAudio(FG2) && 
d1203 1
a1203 1
		
d1208 1
a1208 1
				case CT_FLYERSTILL:
d1213 1
a1213 1
						if(FG2->ObjectType != CT_VIDEOANIM) CurrentTime+=GetDuration(FG2);	
d1240 1
a1240 1
		   while (FG && VidEvent) 
d1245 1
a1245 1
	
d1252 1
a1252 1
		
d1266 1
a1266 1
			
d1279 1
a1279 1
				
d1283 1
a1283 1
			
d1287 1
a1287 1
				
d1300 1
a1300 1
				{				
d1339 1
a1339 1
	
d1347 1
a1347 1
	
d1378 1
a1378 1
			break;	
d1448 1
a1448 1
		case CT_FLYERSTILL:
d1458 1
a1458 1
  
d1496 1
a1496 1
					{	
d1506 1
a1506 1
							if(((CurVidFG->ObjectType)==CT_VIDEO) || ((CurVidFG->ObjectType)==CT_FLYERSTILL)) fudge=VIDEOPREROLLFUDGE; // > 8 fields
d1516 1
a1516 1
					{	
d1530 1
a1530 1
		
d1569 1
a1569 1
				
d1580 1
a1580 1
					
d1586 1
a1586 1
	
d1613 1
a1613 1
	
d1617 1
a1617 1
						{	
d1632 1
a1632 1
	
d1638 1
a1638 1
							case	CT_FLYERSTILL:
d1641 1
a1641 1
	
d1646 1
a1646 1
	
d1661 1
a1661 1
					
d1695 1
a1695 1
// Handle our leading audio if we're a Video with leading audio 
d1699 1
a1699 1
						
d1719 1
a1719 1
						{				
d1770 1
a1770 1
					
d1787 1
a1787 1
				
d1793 2
a1794 2
					{				
						if(MakeClipHeadR((char *)PreVidFG->FileName, 0L, 0L, AudEvent->StartField,audlength)) 
d1803 1
a1803 1
				}	
d1826 1
a1826 1
	
d1845 1
a1845 1
			{     
d1850 1
a1850 1
		
d1865 1
a1865 1
					DUMPUDECW("FGC=",EventPtr->FGCcommand,"\\");					
d1868 1
a1868 1
		
d1877 1
a1877 1
						DUMPUDECW("FGC=",EventPtr->FGCcommand,"\\");					
d1907 1
a1907 1
			
d1934 2
a1935 2
				
//					HiliteNewFG(Edit,SequenceCmd.ErrorEvent->FG,-1);	//hilite initially selected or abort crouton 
d1953 1
a1953 1
					HiliteNewFG(Edit,FG,-1);	//hilite initially selected or abort crouton 
d1999 1
a1999 1
	do 
@


2.69
log
@Added various new types of content.  Got Scrawls to sort of work.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.68 1995/02/06 14:41:30 pfrench Exp Kell $
d5 3
d304 1
a304 1
	STRPTR 			ErrorMsg;	
d394 3
a396 3
//extern char *ErrMsg38[];
//extern char *ErrMsg39[];
//extern char *ErrMsg40[];
d630 2
d1346 1
a1346 1
				ReportSequenceError(Edit,FG,count,ErrMsg0); //CG page not allowed here.  Please start with a video event.
d1352 1
a1352 1
				ReportSequenceError(Edit,FG,count,ErrMsg0); //CG pages must not be placed after Effects croutons
d1931 9
d1941 4
a1944 2
//****!!!! THIS NEEDS TO BE CHANGED BECAUSE THIS ISN'T A STANDARD ERROR MESSAGE
					ReportSequenceError(Edit,SequenceCmd.ErrorEvent->FG,-1,ErrMsg0); //SequenceCmd.ErrorMs
d1948 2
a1949 2
// Does this if abort or it finished OK.
					if(!FG) FG = (struct ExtFastGadget *)CurFG;
d1951 1
a1952 1
				RefreshEdit();
@


2.68
log
@Fixed tiny bug in determining play/continue ("=" vs. "==")
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.67 1995/01/12 12:04:59 CACHELIN4000 Exp pfrench $
d5 3
d269 1
a269 1
	WORD		FGCcommand;				//FGC_SELECT or FGC_TOMAIN
d281 14
a294 2
	struct Event *FirstVideoEvent;	/* includes FX */
	struct Event *FirstAudioEvent;
d301 1
a301 1
	STRPTR 			ErrorMsg;
d303 1
d305 28
d334 1
d338 1
d589 6
a594 5
#define FXPREROLLFUDGE 	   8	// ANIMs & ILBMs require much more time!
#define ANIMPREROLLFUDGE  90
#define ILBMPREROLLFUDGE  45
#define FRAMEPREROLLFUDGE 90
#define VIDEOPREROLLFUDGE 20
d669 10
a678 3
	if((objtype==CT_VIDEO) ||
		(objtype==CT_FRAMESTORE) ||
		(objtype==CT_CONTROL))
a759 1
				case CT_CONTROL:
d761 3
d767 4
a809 1
				case CT_CONTROL:
d811 3
d817 4
d856 9
a864 5
	Count->Trans=0;
	Count->Effect=0;
	Count->Video=0;
	Count->Key=0;
	Count->Audio=0;
a867 1

d881 1
a888 1
				case CT_CONTROL:
d890 4
d897 3
a899 1
						CurrentTime+=GetDuration(FG);	
d901 1
a901 1

d914 22
d946 1
a959 1
				case CT_CONTROL:
d961 4
d1026 15
d1043 2
a1044 3
	struct Event *Event=NULL, *AudEvent, *Sequence=NULL, *AudSequence=NULL;
	struct Event *PreviousVideo=NULL, *CurrentVideo, *FinalClip=NULL;
	ULONG SeqMemSize, AudSeqMemSize, FXadvance, EndOfEffect=0, EndOfVideo;
d1050 1
a1050 1
	UWORD count=0, audcount=0;
d1053 1
a1053 1
	struct PlaySequenceCmd SequenceCmd={0,0,0,0,0};
d1063 15
a1077 5
		if((Sequence = SafeAllocMem((SeqMemSize=sizeof(struct Event)*
			((CroutonCount.Trans)+(CroutonCount.Video)*2+1) ),MEMF_CLEAR))

			&& ((CroutonCount.Audio==0) ||
				(AudSequence = SafeAllocMem((AudSeqMemSize=sizeof(struct Event) * (CroutonCount.Audio+1)),MEMF_CLEAR))) )
d1086 3
a1088 2
			SequenceCmd.FirstVideoEvent = Event = Sequence;		// assume 1st crouton is selected
			SequenceCmd.FirstAudioEvent= AudEvent = AudSequence;
d1093 3
a1096 1
//------------------------------------
d1103 1
a1103 1
			while((FG2 != FG) && Event)
d1107 1
a1107 1
				case CT_AUDIO:
d1143 1
a1143 1
								Event=NULL;
d1153 1
a1153 1
							audcount++;
d1182 1
a1182 1
								Event=NULL;
d1192 1
a1192 1
							audcount++;
a1195 1
				case CT_CONTROL:
d1197 4
d1204 3
a1206 1
						CurrentTime+=GetDuration(FG2);	
d1209 9
d1226 3
a1228 1
//------------------------------------
d1232 1
a1232 1
		   while (FG && Event) 
d1249 1
a1249 1
					Event=NULL;
d1255 1
a1255 1
					Event=NULL;
d1262 1
a1262 1
					Event=NULL;
d1299 1
a1299 1
						Event=NULL;
d1306 1
a1306 1
//						Event=NULL;
d1313 1
a1313 1
						Event=NULL;
d1319 1
d1322 1
a1322 1
					audcount++;
d1326 1
a1326 1
						Event=NULL;
d1333 6
d1340 31
d1390 1
d1393 1
a1393 1
					Event=NULL;
d1397 1
d1400 1
a1400 1
					Event=NULL;
d1404 3
d1409 1
a1409 1
					Event=NULL;
d1417 1
a1417 1
			PreviousTrack=TRACK_TRANS;
d1428 3
a1430 3
				Event->StartField=GetStartField(FG);
				PutAdjustedVideoStart(FG,Event->StartField);
				FinalClip=Event;
d1432 1
a1432 1
//				DUMPUDECL	("Assume InPoint=",Event->StartField,"\\");
a1435 1
		case CT_CONTROL:
d1437 13
a1449 9

//TAG_AdjustedVideoStart=Event->StartField=0 for FRAMSTORE/CONTROL croutons

				if (FG->ObjectType != CT_VIDEO) { DUMPMSG("CONTROL/FRAMESTORE CROUTON"); }

				Event->Time = CurrentField;	//=1st field of video will start at this time (assuming Cut)
				Event->FG = CurVidFG= FG;
				Event->CurrentPosition=count;
				Event->FGCcommand = FGC_SELECT;
d1454 1
a1454 1
				CurrentVideo = Event;
d1456 2
a1457 1
				Event++;
d1467 13
a1479 10
					Event->FG = PreviousFG;
					Event->CurrentPosition=PreviousCount;
					Event->FGCcommand = FGC_SELECT;
					Event->Time = 0;	//as soon as possible
					Event++;

					Event->FG = PreviousFG;
					Event->CurrentPosition=PreviousCount;
					Event->FGCcommand = FGC_TOMAIN;
					Event->Time = CurrentField-(FXadvance=((vidlength=GetNumFields(PreviousFG))*(32767-GetDelay(PreviousFG))/65534)); //-0 -> -vidlength
d1481 1
a1481 1
					DUMPSDECL("Auto Previous FX at ",Event->Time,"\\");
d1483 4
d1490 1
a1490 1
							fudge=ILBMPREROLLFUDGE;
d1494 1
a1494 1
							fudge=ANIMPREROLLFUDGE;
d1497 2
a1498 2
						case	CT_FXALGO:
							if((CurVidFG->ObjectType)==CT_VIDEO) fudge=VIDEOPREROLLFUDGE; // > 8 fields
d1507 19
a1525 1
					if((CurVidFG->ObjectType)==CT_FRAMESTORE)	fudge+=FRAMEPREROLLFUDGE; 
d1527 1
a1527 1
					if((Event->Time) < (EndOfEffect+fudge)) {
d1532 1
a1532 1
						Event=NULL;
d1536 1
a1536 1
					if((EndOfEffect=(Event->Time)+vidlength) > EndOfVideo) {
d1538 1
a1538 1
						Event=NULL;
d1551 1
a1551 1
							Event=NULL;
d1569 1
a1569 1
							Event=NULL;
d1589 1
a1589 1
								Event=NULL;
d1603 2
d1611 7
d1620 4
d1625 4
d1630 1
d1641 1
a1641 1
							Event=NULL;
d1666 1
a1666 1
							Event=NULL;
d1672 4
a1675 4
					Event->FG = FG;
					Event->CurrentPosition=count;
					Event->FGCcommand = FGC_TOMAIN;
					Event->Time = CurrentField;
d1677 1
a1677 1
					DUMPSDECL("Take VIDEO at ",Event->Time,"\\");
d1721 1
a1721 1
								Event=NULL;
d1726 1
a1726 1
							audcount++;
d1735 1
a1735 1
						Event=NULL;
d1742 1
a1742 1
						Event=NULL;
d1789 1
a1789 1
							Event=NULL;
d1793 1
a1793 1
						audcount++;
a1802 2
				Event++;
				PreviousFG=FG;
d1805 3
d1809 2
d1831 1
a1831 1
				Event=NULL;
d1836 1
a1836 1
			if(Event)  // (Event= error flag)
d1838 2
a1839 2
				Event->FG = NULL;
				Event->Time = CurrentField;  //field just after the last field of sequence
d1843 3
a1846 1
				Event = Sequence;
d1848 2
a1849 1
				DUMPMSG("*****************************");
d1851 1
a1851 1
				while(Event->FG)
d1853 6
a1858 6
					DUMPSTR(Event->FG->FileName);
					DUMPUDECB(": #",(UBYTE)(Event->CurrentPosition)," ");
					DUMPUDECL("Time=",Event->Time," ");
					DUMPUDECW("StrtFld=",(UWORD)(Event->StartField)," ");
					DUMPUDECW("FGC=",Event->FGCcommand,"\\");					
					Event++;
d1861 3
a1863 3
				if(Event=AudSequence) {
					DUMPMSG("=============================");
					while(Event->FG)
d1865 6
a1870 6
						DUMPSTR(Event->FG->FileName);
						DUMPUDECB(": #",(UBYTE)(Event->CurrentPosition)," ");
						DUMPUDECL("Time=",Event->Time," ");
						DUMPUDECW("StrtFld=",(UWORD)(Event->StartField)," ");
						DUMPUDECW("FGC=",Event->FGCcommand,"\\");					
						Event++;
d1874 1
d1883 1
a1883 1
					for(count=0; count<audcount; count++)
d1888 1
a1888 1
					SortEvents(AudSequence,(ULONG)audcount);
d1891 1
a1891 1
					for(count=0; count<audcount; count++)
d1901 1
a1901 1
//				DUMPMEM("Sequence=",(UBYTE *)Sequence,SeqMemSize);
d1945 1
a1945 1
			Event=NULL;
d1948 6
a1953 2
		if(Sequence) FreeMem(Sequence, SeqMemSize);
		if(AudSequence) FreeMem(AudSequence, AudSeqMemSize);
@


2.67
log
@Add support for PLAY_PART button in HAndlePlay()
@
text
@d3 5
a7 2
* $Id: Sequence.c,v 2.66 1995/01/06 22:19:48 Kell Exp CACHELIN4000 $
* $Log: Sequence.c,v $
d1724 1
a1724 1
	if(Playboy->GadgetID=ID_PLAY_PART)
@


2.66
log
@Flyer preroll now 20 fields
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.65 1995/01/06 22:12:13 Kell Exp Kell $
* $Log: sequence.c,v $
d1718 4
a1721 1
	if( (IntuiMsg->Qualifier&(IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT)) )
@


2.65
log
@Don't require addional Flyer preroll if long FX loading is required.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.64 1995/01/06 21:23:59 Kell Exp Kell $
d5 3
d541 1
a541 1
#define VIDEOPREROLLFUDGE 24
@


2.64
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.63 1995/01/06 21:11:02 Kell Exp Kell $
d5 3
d1291 4
d1300 1
a1300 13
					switch(CurVidFG->ObjectType)
					{	
						case	CT_FRAMESTORE:
							fudge+=FRAMEPREROLLFUDGE;
						break;

						case	CT_VIDEO:
							fudge+=VIDEOPREROLLFUDGE;
						break;

						default:
						break;
					}
@


2.63
log
@Now hilites correct crouton before sequence errors are reported.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.62 1995/01/06 20:44:36 Kell Exp Kell $
d5 3
d1691 1
@


2.62
log
@Fixed bug involving preload time of 1st video event.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.61 1995/01/06 20:33:20 Kell Exp Kell $
d5 3
d549 2
a1687 2

				RefreshEdit();
@


2.61
log
@Fixed Qing previous audio during sequence from any point.
New error checking that forces minimum load/Q times for clips/frames/anims/ilbm/algos.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.60 1995/01/04 23:28:21 Kell Exp Kell $
d5 4
d1375 23
a1397 20

					switch(CurVidFG->ObjectType)
					{	
						case	CT_FRAMESTORE:
							fudge=FRAMEPREROLLFUDGE;
						break;

						case	CT_VIDEO:
							fudge=VIDEOPREROLLFUDGE;
						break;

						default:
							fudge=0;
						break;
					}

					if(CurrentField < (EndOfEffect+fudge)) {
						ReportSequenceError(Edit,CurVidFG,count,ErrMsg37); //Can't sequence. Not enough preroll time to start video event.
						Event=NULL;
						break;
@


2.60
log
@Using signed integers for most things now, to avoid sign mistakes on unsigned numbers.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.59 1995/01/04 16:34:59 Kell Exp Kell $
d5 3
d322 1
a322 1
//extern char *ErrMsg37[];
d521 5
a525 1
#define FXPREROLLFUDGE 	8	// ANIMs & ILBMs require much more time!
d907 1
d956 2
d961 7
a967 1
						endcrop=headsize+StartTime-SequenceCmd.TimeAtSequenceEnd;
d970 2
d979 3
d984 2
d1013 1
a1013 1
						endcrop=headsize+StartTime-SequenceCmd.TimeAtSequenceEnd;
d1265 29
a1293 1
					if((Event->Time) < (EndOfEffect+FXPREROLLFUDGE)) {
d1295 1
d1371 21
@


2.59
log
@Fixed missing Left Audio during seqencing bug.
Now crops unused audio (beyond sequence end) before making heads.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.58 1994/12/31 10:22:09 Kell Exp Kell $
d5 4
d756 1
a756 1
	ULONG astart, vstart, aduration;
d899 1
a899 1
	ULONG vidlength, audlength, vidstart, audstart, audend, vidend, headsize, endcrop;
d1078 3
d1088 4
d1097 2
d1299 1
a1299 1
								CropAudioToVideo(vidstart,vidlength,&audstart,&audlength);
@


2.58
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.57 1994/12/31 10:08:22 Kell Exp Kell $
d5 3
d252 2
d559 14
a572 2
	return((BOOL)( ((AUDB_Channel1Recorded & AudioOnBits) && (AUDB_Channel1Enabled & AudioOnBits) && GetAudioVolume1(FG))
	            || ((AUDB_Channel2Recorded & AudioOnBits) && (AUDB_Channel2Enabled & AudioOnBits) && GetAudioVolume2(FG)) ));
d695 1
a695 1
		return(VideoStartTime(FG, (struct ExtFastGadget *)CurFG));	//If CurFG=NULL, then returns 0.
d895 1
a895 1
	ULONG vidlength, audlength, vidstart, audstart, audend, vidend, headsize;
d933 2
d947 5
a951 1
						if(MakeClipHeadR((char *)FG2->FileName, 0L, 0L, (audstart=GetAudioStart(FG2)+audlength-headsize), headsize))
d953 2
a954 3
							ReportSequenceError(Edit,FG2,count,ErrMsg24); //Unable to create Audio clip on audio drive.
							Event=NULL;
							break;
d957 19
a975 7
						AudEvent->StartField=audstart;
						AudEvent->Time = 0;
						AudEvent->FG = FG2;
						AudEvent->CurrentPosition=count;
						AudEvent->FGCcommand = FGC_SELECT;
						AudEvent++;
						audcount++;
d986 5
a990 1
						if(MakeClipHeadR((char *)FG2->FileName, 0L, 0L, (audstart=GetAudioStart(FG2)+audlength-headsize), headsize))
d992 2
a993 3
							ReportSequenceError(Edit,FG2,count,ErrMsg28); //Unable to create Audio clip on audio drive.
							Event=NULL;
							break;
d996 19
a1014 7
						AudEvent->StartField=audstart;
						AudEvent->Time = 0;
						AudEvent->FG = FG2;
						AudEvent->CurrentPosition=count;
						AudEvent->FGCcommand = FGC_SELECT;
						AudEvent++;
						audcount++;
d1083 4
a1086 1
// Only Q audio if it actually occurs during the sequence.
a1105 1
//** This error will never occur because the Flyer can't fail until the EndHeadList() call.
a1288 1
//** This error will never occur because the Flyer can't fail until the EndHeadList() call.
a1323 1
//** This error will never occur because the Flyer can't fail until the EndHeadList() call.
a1372 1

a1378 1
//** This error will never occur because the Flyer can't fail until the EndHeadList() call.
d1441 14
a1454 6
//** This error will never occur because the Flyer can't fail until the EndHeadList() call.
					if(MakeClipHeadR((char *)PreVidFG->FileName, 0L, 0L, AudEvent->StartField,audlength)) 
					{
						ReportSequenceError(Edit,PreVidFG,AudEvent->CurrentPosition,ErrMsg28); //Unable to create Audio clip on audio drive.
						Event=NULL;
						break;
d1456 1
a1456 4

					AudEvent++;
					audcount++;
				}
d1553 1
a1553 1

@


2.57
log
@Re-enabled the 20 field clip check.  Removed their short heads though.
Now supports MATTE at end of flyerclips at end of Sequence only.
Now can pre-Q audio that happens before sequence point.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.56 1994/12/31 06:35:53 Kell Exp Kell $
d5 5
@


2.56
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.55 1994/12/30 13:38:37 Kell Exp Kell $
d5 3
d231 4
d869 3
a871 2
	struct ExtFastGadget *FG, *PreviousFG=NULL, *PreVidFG=NULL, *CurVidFG;
	struct Event *Event=NULL, *AudEvent, *Sequence=NULL, *AudSequence=NULL, *PreviousVideo=NULL, *CurrentVideo;
d873 1
a873 1
	ULONG vidlength, audlength, vidstart, audstart, audend, vidend;
d875 1
d909 74
d1127 1
d1252 1
a1252 1
/******************** DISABLE THIS CODE ***!!!!!**************/
d1277 1
a1277 1
/******************************************************/
d1339 1
d1347 1
d1441 2
@


2.55
log
@New QuickSort.  Re-anabled heads on cuts only.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.54 1994/12/29 19:33:32 CACHELIN4000 Exp Kell $
d5 3
d323 7
@


2.54
log
@Add Wrapper f'n HandlePlay() for renamed SeqHandlePlay(), FirstFG is CurFG or NULL
depending hwether full or partial sequence is desired (shift-Play)
@
text
@d3 6
a8 2
* $Id: Sequence.c,v 2.53 1994/12/28 18:01:16 Kell Exp CACHELIN4000 $
* $Log: Sequence.c,v $
d189 1
a554 72
/****** Sequence/QSA **************************************
*
*   NAME   
*	QSA
*
*   SYNOPSIS
*
* VOID QSA(
*	void *array,
*	LONG MinElement,
*	LONG MaxElement,
*	int (* CompareElements)(void *array, LONG ElementA, LONG ElementB),
*	void (* SwapElements)(void *array, LONG ElementA, LONG ElementB))
*
*   FUNCTION
* 	CompareElements() returns: if <0, A<B; if =0, A=B; if >0, A>B
*
******************************************************************/
VOID QSA(
	register void *array,
	register LONG MinElement,
	register LONG MaxElement,
	register int (* CompareElements)(void *array, LONG ElementA, LONG ElementB),
	register	void (* SwapElements)(void *array, LONG ElementA, LONG ElementB))
{

	LONG I,J;

	if((I = MaxElement-MinElement) <= 0) return;

	if (I == 1)
	{
		if (CompareElements(array, MinElement, MaxElement) > 0)
			SwapElements(array, MinElement, MaxElement);
		return;
	}

	I = MinElement+1; 	// start at R2
	J = MaxElement;  		// start at MaxElement

// partition array into two
	do 
	{

// go right until RI belongs in right subgroup after partition
		while (CompareElements(array, MinElement,I) > 0)
		{
			I++;
			if (I >= MaxElement) break;
		}

// go left until RJ belongs in left subgroup
		while (CompareElements(array, MinElement,J) < 0)
		{
			J--;
			if (J <= MinElement) break;
		}

		if (I<J) SwapElements(array,I,J);
	} while (I<J);

// complete partitioning at J: J now correct
	SwapElements(array,MinElement,J);

// do left and right partitions (if they are non-empty)
	if (MinElement < (J-1))
		 QSA(array,MinElement,J-1,CompareElements,SwapElements);

	if ((J+1) < MaxElement)
		QSA(array,J+1,MaxElement,CompareElements,SwapElements);
}

d565 2
a566 2
*	int (* CompareElements)(void *array, LONG ElementA, LONG ElementB),
*	void (* SwapElements)(void *array, LONG ElementA, LONG ElementB))
d576 2
a577 2
	register int (*	CompareElements)(void *array, LONG ElementA, LONG ElementB),
	register	void (* SwapElements)(void *array, LONG ElementA, LONG ElementB))
d579 2
a580 1
	if (NumberOfElements > 1) QSA(array,0,(LONG)(NumberOfElements-1),CompareElements,SwapElements);
d590 1
a590 1
*	int EventTimeCompare(void *array, LONG ElementA, LONG ElementB )
d597 1
a597 1
int EventTimeCompare(void *array, LONG ElementA, LONG ElementB)
d599 1
a599 8
	struct Event *Event;
	LONG StartTimeA, StartTimeB;

	Event = (struct Event *)array;
	StartTimeA= (Event+ElementA)->Time;
	StartTimeB= (Event+ElementB)->Time;

	return(StartTimeA-StartTimeB);	
a601 25
/****** Sequence/EventSwap ***************************************
*
*   NAME
*	EventSwap
*
*   SYNOPSIS
*	void EventSwap(void *array, LONG ElementA, LONG ElementB )
*
*   FUNCTION
*
*********************************************************************/

void EventSwap(void *array, LONG ElementA, LONG ElementB)
{
	struct Event *Event1, *Event2, EventTemp;

	Event1 = ((struct Event *)array)+ElementA;
	Event2 = ((struct Event *)array)+ElementB;
	
	EventTemp = *Event1;
	*Event1=*Event2;
	*Event2=EventTemp;

	return;
}
d615 1
a615 1
	QuickSortArray((void *)Events,NumberOfEvents,EventTimeCompare,EventSwap);
d1158 1
a1158 1
/******************** DISABLE THIS CODE **************
d1183 1
a1183 1
******************************************************/
d1380 7
d1388 7
d1457 1
a1460 1
	struct FastGadget *PreviousFG=NULL;
d1463 1
a1463 1
		FirstFG=CurFG;
@


2.53
log
@Now goes to Matte black at sequence start if necessary.
Doesn't now recalculate SeqeunceVideoStartTime over and over and over.
@
text
@d3 6
a8 2
* $Id: sequence.c,v 2.52 1994/12/27 22:35:38 Kell Exp Kell $
* $Log: sequence.c,v $
d228 1
a228 1
	
d248 1
d314 1
a314 1

d755 1
a755 1
	else return(0L);	
d798 1
a798 1
		if(CurFG) FG=(struct ExtFastGadget *)CurFG;
d802 1
a802 1
	else return(0L);	
d931 2
a932 2
		if(CurFG) StartFG=(struct ExtFastGadget *)CurFG;
			
d935 1
a935 1
			if(IsVideoSource(FG)) VidFG=FG;	
d937 2
a938 2
		}	
	
d946 1
a946 1
struct EditWindow *HandlePlay(
d972 1
a972 1
			&& ((CroutonCount.Audio==0) || 
d1539 13
@


2.52
log
@New split audio stuff calculations.  Works better in "Seq. from any point"
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.51 1994/12/23 07:18:52 Kell Exp Kell $
d5 3
d304 1
d818 2
a822 2
			StartTime=SequenceVideoStartTime();	

d973 2
d1424 2
a1425 1
//-----------------------------------------------------------
a1477 2
				SendSwitcherReply(ES_SelectDefault,NULL);

a1478 1

a1479 1

@


2.51
log
@Now aborts Flyer stuff before making any heads.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.50 1994/12/16 20:02:58 pfrench Exp Kell $
d5 3
d219 1
a219 2
	struct Event *FirstEvent;
	struct Event *StartEvent;
d238 3
d275 20
d499 3
d526 15
d708 88
d799 1
a799 1
BOOL GetNumberOfCroutons(struct TrackCount *Count)
d801 3
a803 2
	struct ExtFastGadget *FG;
	ULONG astart, vstart;
d811 1
a811 1
	if (PtrProject && (FG=*PtrProject))
d813 37
d855 1
a855 1
					Count->Audio++;				
d867 5
a871 3
// to be longer that the split audio heads.
				if((astart=GetAudioStart(FG)) < (vstart=GetStartField(FG)))
					Count->Audio++;				
d873 3
a875 2
				if((astart+GetAudioDuration(FG)) > (vstart+GetDuration(FG)))
					Count->Audio++;				
d895 42
d944 1
a944 1
	ULONG vidlength, audlength, vidstart, audstart;
d952 7
a958 1
	if(GetNumberOfCroutons(&CroutonCount))
a968 1
			DisplayWaitSprite();
d971 1
a971 1
			SequenceCmd.StartEvent= SequenceCmd.FirstEvent = Event = Sequence;		// assume 1st crouton is selected
d976 1
a976 3

			FG=*PtrProject;

a981 3

// CurFG is a global that ->currently selected crouton.
				if(FG == (struct ExtFastGadget *)CurFG) SequenceCmd.StartEvent=Event;
d1004 3
a1006 7
				AudEvent->Time = (PreviousVideo->Time)+GetDelay(FG)-(PreviousVideo->StartField);  //1st field of audio will start at this time
				AudEvent->FG = FG;
				AudEvent->CurrentPosition=count;
				AudEvent->FGCcommand = FGC_SELECT;

				if((AudEvent->Time) < PreviousEndOfEffect) {
					ReportSequenceError(Edit,FG,count,ErrMsg10); //Please put this clip after an earlier video event.
d1011 2
a1012 6
//***!! This check isn't really important unless we want to keep the croutons in order!
//				if((AudEvent->Time)< PreviousAudioStartTime) {
//					ReportSequenceError(Edit,FG,count,ErrMsg10); //Audio crouton should be moved earlier in the project.
//					Event=NULL;
//					break;
//				}
d1014 2
a1015 1
				if(MakeClipHeadR((char *)FG->FileName, 0L, 0L, GetAudioStart(FG), GetAudioDuration(FG)))
d1017 4
a1020 3
					ReportSequenceError(Edit,FG,count,ErrMsg24); //Unable to create Audio clip on audio drive.
					Event=NULL;
					break;
d1023 33
a1055 5
				PreviousAudioStartTime = AudEvent->Time;
				PreviousFG=FG;
				PreviousTrack=TRACK_AUDIO;
				AudEvent++;
				audcount++;
d1057 5
a1061 4
				if (!FlyerBase) {
					ReportSequenceError(Edit,FG,count,ErrMsg11); //Can't play audio clips without a Flyer.
					Event=NULL;
					break;
a1062 1

a1118 2
//***IF CURRENTFIELD = 0, then can't allow leading Audio!!!

a1121 2
//***Keep track of Trailing audio end

d1200 1
a1200 1
					if (FG->ObjectType==CT_VIDEO) {
d1214 1
a1214 1
						if ((PreVidFG->ObjectType == CT_VIDEO) && SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(FG->FileName)))
d1218 1
a1218 1

d1221 3
a1223 2
								audstart=vidstart;
								audlength=vidlength;
d1226 2
a1227 1
							if(MakeClipHeadR((char *)FG->FileName, vidstart, vidlength, audstart, audlength))
d1247 1
a1247 1
					if ((FG->ObjectType==CT_VIDEO) && PreviousVideo &&
d1249 1
a1249 1
                    SameFlyerVolumes((char *)(PreVidFG->FileName),(char *)(FG->FileName)))
d1262 2
a1263 1
						if(MakeClipHeadR((char *)FG->FileName, vidstart, vidlength, audstart, audlength))
a1271 3
				


a1281 1
//---------------------------------
d1283 2
a1284 2
//Check for minimum Video clip length
				if ((CurVidFG->ObjectType==CT_VIDEO) && (GetAdjustedVideoDuration(CurVidFG) < 20))
d1286 45
a1330 4
					ReportSequenceError(Edit,CurVidFG,count,ErrMsg29);  //Can't sequence clips that are this short
					Event=NULL;
					break;
				}
d1332 2
a1333 11
// Handle our leading audio if we're a Video with leading audio
				if ( (CurVidFG->ObjectType==CT_VIDEO) && HasAudio(CurVidFG) &&
				     (GetAudioStart(CurVidFG) < GetAdjustedVideoStart(CurVidFG)) )
				{
					AudEvent->StartField=GetAudioStart(CurVidFG);
					AudEvent->Time = (CurrentVideo->Time)+((AudEvent->StartField)-(CurrentVideo->StartField));  //1st field of audio will start at this time
					AudEvent->FG = CurVidFG;
					AudEvent->CurrentPosition=count;
					AudEvent->FGCcommand = FGC_SELECT;
				
					if((AudEvent->Time)<0) 
d1335 1
a1335 1
						ReportSequenceError(Edit,CurVidFG,count,ErrMsg26);  //Unable to start audio before 1st video event
d1340 2
a1341 3
					if(MakeClipHeadR((char *)CurVidFG->FileName, 0L, 0L, AudEvent->StartField, (CurrentVideo->StartField)-(AudEvent->StartField)))
					{
						ReportSequenceError(Edit,CurVidFG,count,ErrMsg27); //Unable to create Audio clip on audio drive.
a1344 3

					AudEvent++;
					audcount++;
d1347 1
d1349 27
a1375 8
				if ( PreVidFG && (PreVidFG->ObjectType==CT_VIDEO) && HasAudio(PreVidFG) &&
				    ( (GetAudioStart(PreVidFG)+
                   GetAudioDuration(PreVidFG)) >
						(GetAdjustedVideoStart(PreVidFG)+
                   GetAdjustedVideoDuration(PreVidFG)) )) 
  				{
					AudEvent->Time = (PreviousVideo->Time)+GetAdjustedVideoDuration(PreVidFG);  //1st field of audio will start at this time
					AudEvent->StartField=(PreviousVideo->StartField)+GetAdjustedVideoDuration(PreVidFG);
d1380 2
a1381 2
					if(MakeClipHeadR((char *)PreVidFG->FileName, 0L, 0L, AudEvent->StartField, 
						GetAudioStart(PreVidFG)+GetAudioDuration(PreVidFG)-(AudEvent->StartField)))
d1392 1
a1403 6
				if (!FlyerBase && (FG->ObjectType==CT_VIDEO)) {
					ReportSequenceError(Edit,FG,count,ErrMsg14); //Can't play video clips without a Flyer.
					Event=NULL;
					break;
				}

d1419 5
a1423 1
			SendSwitcherReply(ES_EndHeadList,NULL);
d1425 1
a1425 1
//***!! IF any Trailing audio extends past end, then Error!!!!
a1516 1
			DisplayNormalSprite();
d1529 1
d1542 9
@


2.50
log
@Had to rename function with same name as flyer lvo
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.49 1994/12/06 18:59:53 Kell Exp pfrench $
d5 3
d750 1
@


2.49
log
@Removed 4 field head for cuts only.  Now video clips must be >= 20 fields long.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.48 1994/12/05 22:23:45 Kell Exp Kell $
d5 3
d276 1
d410 1
a410 1
ULONG	MakeClipHead(char *name, ULONG VidStart, ULONG VidFields, ULONG AudStart, ULONG AudFields)
d414 1
a414 1
	DUMPSTR("\\MakeClipHead( ");
d804 1
a804 1
				if(MakeClipHead((char *)FG->FileName, 0L, 0L, GetAudioStart(FG), GetAudioDuration(FG)))
d989 1
a989 1
							if(MakeClipHead((char *)FG->FileName, vidstart, vidlength, audstart, audlength))
d1024 1
a1024 1
						if(MakeClipHead((char *)FG->FileName, vidstart, vidlength, audstart, audlength))
d1073 1
a1073 1
					if(MakeClipHead((char *)CurVidFG->FileName, 0L, 0L, AudEvent->StartField, (CurrentVideo->StartField)-(AudEvent->StartField)))
d1097 1
a1097 1
					if(MakeClipHead((char *)PreVidFG->FileName, 0L, 0L, AudEvent->StartField, 
@


2.48
log
@Fixed Enforcer hit.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.47 1994/12/03 06:08:22 Kell Exp Kell $
d5 3
d263 1
d976 1
a977 1
							vidstart=CurrentVideo->StartField;
d979 1
a979 1
							if(HasAudio(PreVidFG))
d1003 2
a1004 1
// Sending out minimal 4 field Head
d1009 12
a1020 1
						if(MakeClipHead((char *)FG->FileName, (ULONG)(CurrentVideo->StartField), 4L, (ULONG)(CurrentVideo->StartField), 4L))
d1027 1
d1029 3
d1043 8
@


2.47
log
@Now supports Split Audio.  Has more than one event table.
Also, some Event items are now stored as Tag items.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.46 1994/11/18 10:47:31 Kell Exp Kell $
d5 4
d1053 1
a1053 1
				if ( (PreVidFG->ObjectType==CT_VIDEO) && HasAudio(PreVidFG) &&
@


2.46
log
@Work on error messages.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.45 1994/11/11 14:37:28 pfrench Exp Kell $
d5 3
d187 1
d189 8
a196 8
	struct ExtFastGadget *FG;	//->the crouton, NULL if last Event
	LONG FGCtime;		//time FG CMD should take effect, or = total time if last Event
	WORD FGCcommand;	//FGC_SELECT or FGC_TOMAIN
	UWORD CurrentPosition;		//Current Position within sequence

	LONG Duration;		//Length of Video event (FRAM, CLIP, etc.)				
	LONG StartTime;	//Video source start time (FRAM, CLIP, etc.)
	LONG StartPoint;	//Video clip adjusted inpoint
d224 1
d248 8
d284 21
d377 21
d400 3
a402 1
	DUMPSTR("MakeClipHead( ");
d404 13
a416 1
	DUMPSTR(" )");
d602 2
a603 2
	StartTimeA= (Event+ElementA)->StartTime;
	StartTimeB= (Event+ElementB)->StartTime;
d682 2
d712 1
a712 1
	struct ExtFastGadget *FG, *PreviousFG=NULL;
d714 2
a715 1
	ULONG SeqMemSize, AudSeqMemSize, length, FXadvance, EndOfEffect=0, EndOfVideo;
d717 2
a718 1
	UWORD	PreviousTrack=TRACK_START, PreviousEffect=EFFECT_TAKE, PreviousCount, count=0;
d752 1
a752 1

a756 2
//***!!!! THIS AUDIO STUFF NEEDS SOME WORK SO AUDIO CLIPS THAT NEED TO
//START DURING TRANSITIONS, CAN BE QUEUED BEFORE THE FX TAKES OVER. !!!!
d774 1
a774 2
				AudEvent->StartPoint = GetAudioStart(FG);
				AudEvent->StartTime = (PreviousVideo->StartTime)+GetDelay(FG)-(PreviousVideo->StartPoint);  //1st field of audio will start at this time
a777 2
				AudEvent->FGCtime = 0;			//as soon as possible;
				AudEvent->Duration = GetAudioDuration(FG);
d779 1
a779 1
				if((AudEvent->StartTime) < PreviousEndOfEffect) {
d786 1
a786 1
//				if((AudEvent->StartTime)< PreviousAudioStartTime) {
d792 8
a799 1
				PreviousAudioStartTime = AudEvent->StartTime;
d803 1
d869 2
a870 1
				Event->StartPoint = GetStartField(FG);
d874 1
a874 1
				DUMPUDECL	("Assume InPoint=",(LONG)(Event->StartPoint),"\\");
d880 2
a881 2
				
// Event->StartPoint=0 for FRAMSTORE/CONTROL croutons
d885 2
a886 2
				Event->StartTime = CurrentField;	//=1st field of video will start at this time (assuming Cut)
				Event->FG = FG;
d889 3
a891 2
				Event->FGCtime = 0;			//as soon as possible;
  				Event->Duration = GetDuration(FG);
d894 1
a894 1
				EndOfVideo= CurrentField+(Event->Duration);  //=field after the video
d908 1
a908 1
					Event->FGCtime = 0;	//as soon as possible
d914 1
a914 1
					Event->FGCtime = CurrentField-(FXadvance=((length=GetNumFields(PreviousFG))*(32767-GetDelay(PreviousFG))/65534)); //-0 -> -length
d916 1
a916 1
					DUMPSDECL("Auto Previous FX at ",Event->FGCtime,"\\");
d918 1
a918 1
					if((Event->FGCtime) < (EndOfEffect+FXPREROLLFUDGE)) {
a923 2


d928 1
a928 1
					if((EndOfEffect=(Event->FGCtime)+length) > EndOfVideo) {
d935 2
a936 1
					PreviousVideo->Duration += ROUNDTOFRAME(length-FXadvance);
d938 1
a938 1
 					DUMPUDECL	("Previous duration changed to=",(LONG)PreviousVideo->Duration,"\\");
d940 2
a941 4
					if (PreviousVideo->FG->ObjectType==CT_VIDEO) {

//***!!! What about extending previous videos AUDIO????
						if (((PreviousVideo->Duration)+(PreviousVideo->StartPoint)) > GetRecFields(PreviousVideo->FG)) {
d951 1
d953 3
a955 1
						CurrentVideo->StartPoint -= FXadvance;
d957 1
a957 1
//***!!! What about extending current videos AUDIO????
d959 1
a959 3
 						DUMPUDECL	("InPoint changed to=",(LONG)CurrentVideo->StartPoint,"\\");

						if ((CurrentVideo->StartPoint) < 0) {
d966 12
a977 3
//***!!! DON'T MAKE AUDIO PART OF HEAD IF AUDIO ISN'T BEING USED!!
						if ((PreviousVideo->FG->ObjectType == CT_VIDEO) && SameFlyerVolumes((char *)(PreviousVideo->FG->FileName),(char *)(FG->FileName)))
							if(MakeClipHead((char *)FG->FileName, (ULONG)CurrentVideo->StartPoint, (ULONG)length, (ULONG)CurrentVideo->StartPoint, (ULONG)length))
d979 1
a979 1
								ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg13); //Unable to do AB roll. Not enough Flyer space.
d983 1
d986 2
a987 2
					CurrentVideo->StartTime -= FXadvance;
					CurrentVideo->Duration += FXadvance;
d995 13
d1011 1
a1011 1
					Event->FGCtime = CurrentField;
d1013 1
a1013 1
					DUMPSDECL("Take VIDEO at ",Event->FGCtime,"\\");
d1020 52
a1071 2
				DUMPUDECL	("VIDEO starttime=",(LONG)CurrentVideo->StartTime,"\\");
 				DUMPUDECL	("Assume duration=",(LONG)(CurrentVideo->Duration),"\\");
d1073 3
d1081 1
d1107 1
a1107 1
//***IF any Trailing audio extends past end, then Error!!!!
d1112 32
a1143 1
				Event->FGCtime = CurrentField;  //field just after the last field of sequence
d1148 1
a1148 1
					SortEvents(AudSequence,CroutonCount.Audio);
@


2.45
log
@Moved refreshedit call to after last fastgadget selection
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.44 1994/11/10 17:04:20 pfrench Exp pfrench $
d5 3
d740 9
a748 9
//		case CT_KEY:
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton not allowed here.  Please start with a video event.
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton in wrong order.  Move earlier in the project.
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton can't start until previous Effect has finshed.
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton can't start before the clip.  Use a later start time.
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton can't start after the clip.  Use an earlier start time.
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton can't start until previous Key has finished.
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Keyed crouton must not be placed after Effect croutons
//			break;
d765 1
a765 1
					ReportSequenceError(Edit,FG,count,ErrMsg0 /***!!!****/); //Effects not allowed here.  Please start with a video event.
d776 1
a776 1
//	ReportSequenceError(Edit,FG,count,ErrMsg0); //Effect not allowed during keying.
d894 1
a894 1
								ReportSequenceError(Edit,PreviousFG,PreviousCount,ErrMsg0 /***!!!****/); //Unable to do AB roll. Not enough Flyer space.
d931 2
a932 2
				if (!FlyerBase) {
					ReportSequenceError(Edit,FG,count,ErrMsg0 /***!!!****/); //Can't play video clips without a Flyer.
d1019 1
a1019 1
			ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,-1,ErrMsg0 /***!!!****/); //Not enough memory to play this sequence!
@


2.44
log
@Made for quicker highlighting of next crouton (proof)
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.43 1994/11/09 20:11:57 Kell Exp pfrench $
d5 3
a987 2
				RefreshEdit();

d1006 2
@


2.43
log
@New sequence error messages, using the errors.c file.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.42 1994/11/09 14:50:09 Kell Exp Kell $
d5 3
d242 4
d364 1
a364 1
void	HiliteNewFG(struct EditWindow *Edit, struct ExtFastGadget *FG)
d366 6
a371 2
	ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
	if(FG) ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
d378 1
a378 1
void	ReportSequenceError(struct EditWindow *Edit, struct ExtFastGadget *FG, char *Text[])
d384 1
a384 1
	HiliteNewFG(Edit,FG);
d686 1
a686 1
					ReportSequenceError(Edit,FG,ErrMsg8); //Audio clips not allowed here.  Please start with a video event.
d692 1
a692 1
					ReportSequenceError(Edit,FG,ErrMsg9); //Audio Clips must not be placed after Effects
d706 1
a706 1
					ReportSequenceError(Edit,FG,ErrMsg10); //Please put this clip after an earlier video event.
d713 1
a713 1
//					ReportSequenceError(Edit,FG,ErrMsg10); //Audio crouton should be moved earlier in the project.
d724 1
a724 1
					ReportSequenceError(Edit,FG,ErrMsg11); //Can't play audio clips without a Flyer.
d735 7
a741 7
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton not allowed here.  Please start with a video event.
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton in wrong order.  Move earlier in the project.
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton can't start until previous Effect has finshed.
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton can't start before the clip.  Use a later start time.
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton can't start after the clip.  Use an earlier start time.
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton can't start until previous Key has finished.
//	ReportSequenceError(Edit,FG,ErrMsg0); //Keyed crouton must not be placed after Effect croutons
d753 1
a753 1
					ReportSequenceError(Edit,FG,ErrMsg6); //Can't end sequence with an Effect.
d759 1
a759 1
					ReportSequenceError(Edit,FG,ErrMsg0 /***!!!****/); //Effects not allowed here.  Please start with a video event.
d765 1
a765 1
					ReportSequenceError(Edit,FG,ErrMsg7); //Can't sequence two Effects in a row.
d770 1
a770 1
//	ReportSequenceError(Edit,FG,ErrMsg0); //Effect not allowed during keying.
d837 2
a838 2
							ReportSequenceError(Edit,PreviousFG,ErrMsg1); //Can't sequence. Effect starts too early.
							else ReportSequenceError(Edit,PreviousFG,ErrMsg2); //Effect starts too soon after previous effect.
d847 1
a847 1
						ReportSequenceError(Edit,PreviousFG,ErrMsg3); //Effect ends too late.
d861 1
a861 1
							ReportSequenceError(Edit,PreviousFG,ErrMsg4); //Effect can not end after previous clip.
d878 1
a878 1
							ReportSequenceError(Edit,PreviousFG,ErrMsg5); //Effect can not start before following clip.
d888 1
a888 1
								ReportSequenceError(Edit,PreviousFG,ErrMsg0 /***!!!****/); //Unable to do AB roll. Not enough Flyer space.
d926 1
a926 1
					ReportSequenceError(Edit,FG,ErrMsg0 /***!!!****/); //Can't play video clips without a Flyer.
d997 1
a997 1
					ReportSequenceError(Edit,SequenceCmd.ErrorEvent->FG,ErrMsg0); //SequenceCmd.ErrorMs
d1003 1
a1003 1
					HiliteNewFG(Edit,FG);	//hilite initially selected or abort crouton 
d1013 1
a1013 1
			ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,ErrMsg0 /***!!!****/); //Not enough memory to play this sequence!
@


2.42
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.41 1994/11/09 14:37:34 Kell Exp Kell $
d5 3
d213 1
d215 19
d675 1
a675 1
//					ReportSequenceError(Edit,FG,"Audio clips not allowed here.  Please start with a video event.");
d681 1
a681 1
//					ReportSequenceError(Edit,FG,"Audio Clips must not be placed after Effects");
d695 1
a695 1
//					ReportSequenceError(Edit,FG,"Please put this clip after an earlier video event.");
d702 1
a702 1
////					ReportSequenceError(Edit,FG,"Audio crouton should be moved earlier in the project.");
d713 1
a713 1
//					ReportSequenceError(Edit,FG,"Can't play audio clips without a Flyer.");
d724 7
a730 7
////	ReportSequenceError(Edit,FG,"Keyed crouton not allowed here.  Please start with a video event.");
//	ReportSequenceError(Edit,FG,"Keyed crouton in wrong order.  Move earlier in the project.");
//	ReportSequenceError(Edit,FG,"Keyed crouton can't start until previous Effect has finshed.");
//	ReportSequenceError(Edit,FG,"Keyed crouton can't start before the clip.  Use a later start time.");
//	ReportSequenceError(Edit,FG,"Keyed crouton can't start after the clip.  Use an earlier start time.");
//	ReportSequenceError(Edit,FG,"Keyed crouton can't start until previous Key has finished.");
//	ReportSequenceError(Edit,FG,"Keyed crouton must not be placed after Effect croutons");
d742 1
a742 1
//					ReportSequenceError(Edit,FG,"Can't end sequence with an Effect.");
d748 1
a748 1
//					ReportSequenceError(Edit,FG,"Effects not allowed here.  Please start with a video event.");
d754 1
a754 1
//					ReportSequenceError(Edit,FG,"Can't sequence two Effects in a row.");
d759 1
a759 1
////	ReportSequenceError(Edit,FG,"Effect not allowed during keying.");
a770 4
//***!!!!
//		ReportSequenceError(Edit,FG,ErrMsg1);


d825 3
a827 4
//***!! FIX THIS
//						if(PreviousEffect==EFFECT_TAKE)
//							ReportSequenceError(Edit,PreviousFG,"Can't sequence. Effect starts too early.");
//							else ReportSequenceError(Edit,PreviousFG,"Effect starts too soon after previous effect.");
d836 1
a836 1
//						ReportSequenceError(Edit,PreviousFG,"Effect ends too late.");
d850 1
a850 1
//							ReportSequenceError(Edit,PreviousFG,"Effect can not end after previous clip.");
d867 1
a867 1
//							ReportSequenceError(Edit,PreviousFG,"Effect can not start before following clip.");
d877 1
a877 1
//								ReportSequenceError(Edit,PreviousFG,"Unable to do AB roll. Not enough Flyer space.");
d915 1
a915 1
//					ReportSequenceError(Edit,FG,"Can't play video clips without a Flyer.");
d985 2
a986 1
//					ReportSequenceError(Edit,SequenceCmd.ErrorEvent->FG,SequenceCmd.ErrorMsg);
d1002 1
a1002 1
//			ReportSequenceError(Edit,(struct ExtFastGadget *)CurFG,"Not enough memory to play this sequence!");
@


2.41
log
@Most ReportSequenceError messages disabled !!!!!!
New stand alone audio stuff which uses it's own event table.
Stuff to sort the audio event table.
Now has fields in the event table to indicated crouton position.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.40 1994/11/04 16:33:18 Kell Exp Kell $
d5 6
d749 1
a749 1
		ReportSequenceError(Edit,FG,ErrMsg1);
@


2.40
log
@Added initial support for stand alone audio clips when sequencing.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.39 1994/11/04 03:08:12 Kell Exp Kell $
d5 3
d170 1
a170 2

	WORD Extra;
d183 1
d204 2
d237 24
d269 1
a269 1
LONG __regargs GetDelay(struct ExtFastGadget *FG)
d273 1
a273 1
	return(SendSwitcherReply(ES_GetValue,&ESparams2));
d285 1
a285 1
BOOL __regargs GetStartField(struct ExtFastGadget *FG)
d289 1
a289 1
	return((BOOL)SendSwitcherReply(ES_GetValue,&ESparams2));
d293 1
a293 1
BOOL __regargs GetAudioStart(struct ExtFastGadget *FG)
d297 1
a297 1
	return((BOOL)SendSwitcherReply(ES_GetValue,&ESparams2));
d338 1
a338 1
void	ReportSequenceError(struct EditWindow *Edit, struct ExtFastGadget *FG, unsigned char *Text)
d347 1
a347 1
	ContinueRequest(Edit->Window,Text);
d351 239
d596 2
a597 2
	struct Event *Event, *Sequence, *StartEvent, *PreviousVideo=NULL, *CurrentVideo;
	ULONG SeqMemSize, length, FXadvance, EndOfEffect=0, EndOfVideo;
d599 2
a600 1
	UWORD	PreviousTrack=TRACK_START, PreviousEffect=EFFECT_TAKE, count=0;
d604 10
a613 1
// Allocate more than enough space for at least 2 commands per crouton.
d615 1
a615 4
	if (PtrProject && (FG=*PtrProject) && (Sequence = SafeAllocMem((SeqMemSize=sizeof(struct Event) * ((SingleListLength((struct FastGadget *)FG)*2)+10)),MEMF_CLEAR)) ) 
	{
	
	Event = StartEvent = Sequence;	// assume 1st crouton is selected
d617 3
a619 1
	DisplayWaitSprite();
d621 1
a621 1
	DUMPMSG	("-------------- HandlePlay ----------------");
d623 1
a623 1
	SendSwitcherReply(ES_StartHeadList,NULL);
d625 2
a626 1
	while (FG && Event) {
d628 2
a629 3
		DUMPMSG("--------------------------------------");
		DUMPUDECL("Crouton #",count," = ");
		count++;
d632 1
a632 1
		if(FG == (struct ExtFastGadget *)CurFG) StartEvent=Event;
d634 2
a635 1
		switch(FG->ObjectType) {
d643 4
a646 2
			if (!FlyerBase) {
					ReportSequenceError(Edit,FG,"Can't play audio clips without a Flyer.");
d649 1
a649 1
			}
d651 2
a652 2
			if(PreviousTrack==TRACK_START) {
					ReportSequenceError(Edit,FG,"Can't start sequence with an audio clip.");
d655 1
a655 7
			}

			if(PreviousTrack==TRACK_TRANS) {
					ReportSequenceError(Edit,FG,"Audio Clip croutons can not be placed after effects.");
					Event=NULL;
					break;
			}
d657 7
a663 6
			Event->StartPoint = GetAudioStart(FG);
			Event->StartTime = (PreviousVideo->StartTime)+GetDelay(FG)-(PreviousVideo->StartPoint);  //1st field of audio will start at this time
			Event->FG = FG;
			Event->FGCcommand = FGC_SELECT;
			Event->FGCtime = 0;			//as soon as possible;
			Event->Duration = GetAudioDuration(FG);
d665 2
a666 2
			if((Event->StartTime) < PreviousEndOfEffect) {
					ReportSequenceError(Edit,FG,"Please put this clip after an earlier video event.");
d669 1
a669 1
			}
d672 2
a673 2
//			if((Event->StartTime)< PreviousAudioStartTime) {
//					ReportSequenceError(Edit,FG,"Audio crouton should be moved earlier in the project.");
d676 1
a676 1
//			}
d678 10
a687 3
			PreviousAudioStartTime = Event->StartTime;
			PreviousFG=FG;
			PreviousTrack=TRACK_AUDIO;
d689 2
a690 1
			Event++;
d694 11
d713 1
a713 1
					ReportSequenceError(Edit,FG,"Can't end sequence with an Effect.");
d719 1
a719 1
					ReportSequenceError(Edit,FG,"Can't start sequence with an Effect.");
d725 1
a725 1
					ReportSequenceError(Edit,FG,"Can't sequence two Effects in a row.");
d730 1
d733 1
d742 3
a744 5
				if (!FlyerBase) {
					ReportSequenceError(Edit,FG,"Can't play video clips without a Flyer.");
					Event=NULL;
					break;
				}
d749 2
d753 2
d768 1
d786 1
d792 1
a798 3
						if(PreviousEffect==EFFECT_TAKE)
							ReportSequenceError(Edit,PreviousFG,"Can't sequence. Effect starts too early.");
							else ReportSequenceError(Edit,PreviousFG,"Effect starts too soon after previous effect.");
d800 7
d812 1
a812 1
						ReportSequenceError(Edit,PreviousFG,"Effect ends too late.");
d823 2
d826 1
a826 1
							ReportSequenceError(Edit,PreviousFG,"Effect can not end after previous clip.");
d838 2
d843 1
a843 1
							ReportSequenceError(Edit,PreviousFG,"Effect can not start before following clip.");
d853 1
a853 1
								ReportSequenceError(Edit,PreviousFG,"Unable to do AB roll. Not enough Flyer space.");
d869 1
d889 7
d903 1
a903 3
		} // END OF SWITCH

		FG = (struct ExtFastGadget *)(FG->FG.NextGadget);
d905 2
a906 1
	} // END OF WHILE
d908 1
a909 1

d911 1
a911 3
	if(Event) {      // (Event= error flag)
		Event->FG = NULL;
		Event->FGCtime = CurrentField;  //field just after the last field of sequence
d913 1
a913 1
		SetRunningTime(CurrentField);
d915 10
a924 1
		SendSwitcherReply(ES_EndHeadList,NULL);
d926 1
a926 1
		SendSwitcherReply(ES_SelectDefault,NULL);
d928 1
a928 1
		DUMPMSG	("Play Sequence ...............");
d930 1
a930 1
//	DUMPMEM("Sequence=",(UBYTE *)Sequence,SeqMemSize);
d932 1
a932 3
//	DUMPMSG("Before ES_StartSeq sends ES_StartSeq");
		SendSwitcherReply(ES_StartSeq,NULL);	//set bit 4 of TB_DisplayRenderMode
//	DUMPMSG("  After ES_StartSeq sent ES_StartSeq");
d934 3
a936 3
		SequenceCmd.FirstEvent=Sequence;
		SequenceCmd.StartEvent=StartEvent;
// all other SequenceCmd fields should be zero
d938 1
a938 1
	FG=PlaySequence(&SequenceCmd);  // Non NULL if error or abort occured
d940 3
a942 3
//	DUMPMSG("Before ES_Stop() sends ES_Stop");
		SendSwitcherReply(ES_Stop,NULL);		//set bit 4 of TB_DisplayRenderMode
//	DUMPMSG("  After ES_Stop() sent ES_Stop");
d946 1
a946 1
		if (ToasterBase)
d948 1
d950 1
a950 1
		CurrentDir(GetBootLock((struct ToasterBase *)ToasterBase));
d952 1
a952 1
		RefreshEdit();
d954 15
a968 1
		DUMPHEXIL("&SequenceCmd=",(LONG)(&SequenceCmd),"\\");
d970 2
a971 5
		if(SequenceCmd.ErrorEvent) {
// Does this if there was an error during the sequence.
			DUMPHEXIL("ErrorEvent=",(LONG)(SequenceCmd.ErrorEvent),"\\");
			DUMPHEXIL("FG=",(LONG)(SequenceCmd.ErrorEvent->FG),"\\");
			DUMPHEXIL("ErrorMsg=",(LONG)(SequenceCmd.ErrorMsg),"\\");
d973 1
a973 1
			ReportSequenceError(Edit,SequenceCmd.ErrorEvent->FG,SequenceCmd.ErrorMsg);
d977 2
a978 4

// Does this if abort or it finished OK.
			if(!FG) FG = (struct ExtFastGadget *)CurFG;
			HiliteNewFG(Edit,FG);	//hilite initially selected or abort crouton 
d981 2
a982 7
	} // if test on Event flag to see if any sequence errors were detected.
//-----------------------------------------------------------



	FreeMem(Sequence, SeqMemSize);
	DisplayNormalSprite();
d984 1
a984 1
 }	// if Test on FG & Project pointers
@


2.39
log
@Beginnings of CT_AUDIO handling.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.38 1994/11/03 15:51:44 Kell Exp Kell $
d5 3
d224 8
d264 8
d330 1
d359 3
d363 1
a363 1
			DUMPMSG("FXANIM/ILBM/ALGO CROUTON");
d365 44
a408 1
		break;
d464 2
d468 1
a468 1
				Event->StartTime = CurrentField;	//=1st field of video will start at this time
d477 2
@


2.38
log
@Error checking on MakeClipHead.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.37 1994/11/02 05:37:23 Kell Exp Kell $
d5 3
d338 6
a343 1

@


2.37
log
@Fixed bugs with errors during Sequence analysis or during sequencing or abort showing more than one crouton hilited.  And it now does a select default before and after sequencing.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.36 1994/10/26 14:59:40 Kell Exp Kell $
d5 3
d464 6
a469 1
							MakeClipHead((char *)FG->FileName, (ULONG)CurrentVideo->StartPoint, (ULONG)length, (ULONG)CurrentVideo->StartPoint, (ULONG)length);
@


2.36
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.35 1994/10/23 16:32:01 CACHELIN4000 Exp Kell $
d5 3
d187 1
a187 1
extern struct FastGadget *CurFG;
d274 10
d286 7
a292 2
	ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
	ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
d506 3
d517 2
d523 1
a523 1
	DUMPMSG("Before HandlePlay() sends ES_StartSeq");
d525 1
a525 1
	DUMPMSG("  After HandlePlay() sent ES_StartSeq");
d531 1
a531 2
	if(FG=PlaySequence(&SequenceCmd)) 
		CurFG=(struct FastGadget *)FG;	//hilite abort crouton 
d533 1
a533 1
	DUMPMSG("Before HandlePlay() sends ES_Stop");
d535 1
a535 1
	DUMPMSG("  After HandlePlay() sent ES_Stop");
d549 1
d556 2
d559 5
d565 3
@


2.35
log
@Change line 438 over phone from skell....get rid of FXAdvance
@
text
@d3 5
a7 2
* $Id: Sequence.c,v 2.34 94/10/12 18:16:09 Kell Exp Locker: CACHELIN4000 $
* $Log:	Sequence.c,v $
d441 1
a441 1
//						if (FXadvance && (PreviousVideo->FG->ObjectType == CT_VIDEO) && SameFlyerVolumes((char *)(PreviousVideo->FG->FileName),(char *)(FG->FileName)))
@


2.34
log
@Now doesn't make video heads unless same volume on both clips.
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.33 1994/10/05 02:42:20 Kell Exp Kell $
* $Log: sequence.c,v $
d438 3
a440 2
						if (FXadvance && (PreviousVideo->FG->ObjectType == CT_VIDEO) && SameFlyerVolumes((char *)(PreviousVideo->FG->FileName),(char *)(FG->FileName)))
							MakeClipHead((char *)FG->FileName, (ULONG)CurrentVideo->StartPoint, (ULONG)FXadvance, (ULONG)CurrentVideo->StartPoint, (ULONG)FXadvance);
@


2.33
log
@Better Sequencing Debugs
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.32 1994/09/29 15:39:28 Kell Exp Kell $
d5 3
d395 1
a395 1
							else ReportSequenceError(Edit,FG,"Effect starts too soon after previous effect.");
d435 1
a435 1
						if ((PreviousVideo->FG->ObjectType == CT_VIDEO) && FXadvance)
d535 10
@


2.32
log
@First time actually doing true A/B with heads.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.31 1994/09/28 18:50:47 Kell Exp Kell $
d5 3
d297 3
a299 2
		count++;	// currently "count" isn't used by anything!!!
		DUMPUDECW("*************** COUNT=",(WORD)count,"\\");
a310 1

d340 2
d353 2
d359 2
a360 1
				DUMPMSG("VIDEO/CONTROL/FRAMESTORE CROUTON");
a365 1

a367 2
 				DUMPUDECL	("FGC_SELECT: VIDEO duration",(LONG)Event->Duration,"\\");

d374 2
a375 1
// use a transition to bring in the new video
a377 2
					DUMPMSG("Previous track was transition. So SELECT FX");

d387 1
a387 1
					DUMPSDECL("Auto FX at ",Event->FGCtime,"\\");
d407 2
d423 2
d433 1
a433 1
							MakeClipHead((char *)(((struct ExtFastGadget *)(CurrentVideo->FG))->FileName), (ULONG)(CurrentVideo->StartPoint), (ULONG)FXadvance, (ULONG)(CurrentVideo->StartPoint), (ULONG)FXadvance);
a439 2

					DUMPUDECL("Transition EndOfEffect",EndOfEffect,"\\");
d443 1
a443 1
					DUMPMSG("Previous track not transition, So TAKE VIDEO.");
a452 2

					DUMPUDECL("VIDEO EndOfEffect",EndOfEffect,"\\");
d456 3
a486 1
		DUMPMSG	("");
@


2.31
log
@Some debugs added for sequencing.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.30 1994/09/25 16:40:45 Kell Exp Kell $
d5 3
d175 1
d180 1
a180 1
BOOL __asm PlaySequence(register __a0 struct PlaySequenceCmd *);
d232 14
d290 2
d297 3
a354 4

// CurFG is a global that ->currently selected crouton.
				if(FG == (struct ExtFastGadget *)CurFG) StartEvent=Event;

a373 3
// CurFG is a global that ->currently selected crouton.
					if(PreviousFG ==(struct ExtFastGadget *)CurFG) StartEvent=Event-1;	//->Video Event thats after the Transition

d422 4
a425 3

//****!!!!*** SEND OUT HEAD HERE!!!! = -FXadvance

d477 1
d492 2
a493 2
//**!!! Why is this DHD abort stuff here???
	if(PlaySequence(&SequenceCmd))	DHD_Abort(0); //***!!! what if no flyer clips???
d496 1
a496 1
		SendSwitcherReply(ES_Stop,NULL);	//clr bit 4 of TB_DisplayRenderMode
@


2.30
log
@Changed ES_StopSeq to ES_Stop
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.29 1994/09/23 19:35:59 Kell Exp Kell $
d5 3
d144 1
a144 1
	LONG StartTime;	//Video clip start time
d259 1
a259 1
	struct PlaySequenceCmd SequenceCmd;
d285 1
a285 1
			DUMPMSG("EFFECT CROUTON");
a322 1
				Event->StartTime = CurrentField;	//=1st field of video will start at this time
d329 3
a331 1
				DUMPMSG("FGC_SELECT VIDEO");
d342 1
a342 1
 				DUMPUDECL	("VIDEO duration",(LONG)Event->Duration,"\\");
d407 1
a407 1
						CurrentVideo->StartTime -= FXadvance;
a408 2
//****!!!!*** SEND OUT HEAD HERE!!!!

d411 1
d416 1
a416 1
//					DUMPUDECL("Transition EndOfEffect",EndOfEffect,"\\");
d431 1
a431 1
//					DUMPUDECL("VIDEO EndOfEffect",EndOfEffect,"\\");
d466 1
a466 1
//	DUMPMSG("Before HandlePlay() sends ES_StartSeq");
d468 1
a468 1
//	DUMPMSG("  After HandlePlay() sent ES_StartSeq");
d475 1
a475 1
//		if(PlaySequence(&SequenceCmd))	DHD_Abort(0); //***!!! what if no flyer clips???
d477 1
a477 1
//	DUMPMSG("Before HandlePlay() sends ES_Stop");
d479 1
a479 1
//	DUMPMSG("  After HandlePlay() sent ES_Stop");
d490 9
a498 1
		if(SequenceCmd.ErrorEvent) ReportSequenceError(Edit,SequenceCmd.ErrorEvent->FG,SequenceCmd.ErrorMsg);
@


2.29
log
@More work to Sequence generation code.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.28 1994/09/23 10:47:49 Kell Exp Kell $
d5 3
d472 1
a472 1
		if(PlaySequence(&SequenceCmd))	DHD_Abort(0); //***!!! what if no flyer clips???
d474 3
a476 3
//	DUMPMSG("Before HandlePlay() sends ES_StopSeq");
		SendSwitcherReply(ES_StopSeq,NULL);	//clr bit 4 of TB_DisplayRenderMode
//	DUMPMSG("  After HandlePlay() sent ES_StopSeq");
d510 4
a513 4
	DUMPMSG("Before HandleStop() sends ES_StopSeq");
	DHD_Abort(0);
	SendSwitcherReply(ES_StopSeq,NULL);	//clr bit 4 of TB_DisplayRenderMode
	DUMPMSG("  After HandleStop() sent ES_StopSeq");
@


2.28
log
@More frame accurate.  Better error reporting.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.27 1994/09/22 05:08:12 Kell Exp Kell $
d5 3
d131 4
a134 3
	struct ExtFastGadget *FG;	// NULL if last Event
	LONG Field;
	WORD MsgType;	// FGC_SELECT or FGC_TOMAIN
d136 17
a152 3
	LONG StartTime;	// = play time for sequences
	LONG StartPoint;
	LONG Duration;						
d154 2
d163 1
d170 1
a170 1
BOOL __asm PlaySequence(register __a0 struct Event *First);
d172 1
d240 1
a240 1
//	SetRunningTime(-1L);
d249 1
a249 1
	struct Event *Event, *Sequence, *PreviousVideo=NULL, *CurrentVideo;
d253 1
a253 1
	if ((!PtrProject) || (!(FG = *PtrProject))) goto Exit;
a255 2
	SeqMemSize = (sizeof(struct Event) * ((SingleListLength((struct FastGadget *)FG)*2)+10));
	if (!(Sequence = SafeAllocMem(SeqMemSize,MEMF_CLEAR))) goto Exit;
d257 4
a260 1
	Event = Sequence;
a265 2
//***!!!!*** ON ERRORS STASH TOTAL RUNNING TIME = -1!!!!

d301 1
d303 1
a303 1
		break;
d326 3
d330 2
a331 2
				Event->MsgType = FGC_SELECT;
				Event->Field = 0;			//as soon as possible;
d348 3
d352 2
a353 2
					Event->MsgType = FGC_SELECT;
					Event->Field = 0;	//as soon as possible
d357 2
a358 2
					Event->MsgType = FGC_TOMAIN;
					Event->Field = CurrentField-(FXadvance=((length=GetNumFields(PreviousFG))*(32767-GetDelay(PreviousFG))/65534)); //-0 -> -length
d360 1
a360 1
					DUMPSDECL("Auto FX at ",Event->Field,"\\");
d362 1
a362 1
					if((Event->Field) < (EndOfEffect+FXPREROLLFUDGE)) {
d371 1
a371 1
					if((EndOfEffect=(Event->Field)+length) > EndOfVideo) {
d417 2
a418 2
					Event->MsgType = FGC_TOMAIN;
					Event->Field = CurrentField;
d420 1
a420 1
					DUMPSDECL("Take VIDEO at ",Event->Field,"\\");
d432 1
d437 5
a443 1
		PreviousFG=FG;
d448 3
a450 2
	Event->FG = NULL;
	Event->Field = CurrentField;  //field just after the last field of sequence
d452 1
a453 2
//***!!!!*** STASH TOTAL RUNNING TIME = CURRENTFIELD!!!!
//	SetRunningTime(CurrentField);
d455 2
a457 3
	DUMPMSG	("Play Sequence ...............");
	DUMPMSG	("");

d461 1
a461 1
	SendSwitcherReply(ES_StartSeq,NULL);	//set bit 4 of TB_DisplayRenderMode
d464 6
a469 1
	if(PlaySequence(Sequence))	DHD_Abort(0);
d472 1
a472 1
	SendSwitcherReply(ES_StopSeq,NULL);	//clr bit 4 of TB_DisplayRenderMode
d477 1
a477 1
	if (ToasterBase)
d479 1
d482 3
a484 1
	RefreshEdit();
d486 2
a487 1
Free:
d491 2
a492 1
Exit:
@


2.27
log
@Reworked the Sequencing code that creates the event commands.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.26 1994/08/30 10:49:20 Kell Exp Kell $
d5 3
d209 13
d243 1
a243 1
	while (FG) {
d245 2
d262 3
a264 4
					ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
					ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
					ContinueRequest(Edit->Window,"Can't end sequence with an Effect.");
					goto Free;
d268 3
a270 4
					ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
					ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
					ContinueRequest(Edit->Window,"Can't start sequence with an Effect.");
					goto Free;
d274 3
a276 4
					ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
					ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
					ContinueRequest(Edit->Window,"Can't sequence two Effects in a row.");
					goto Free;
d287 3
a289 4
					ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
					ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
					ContinueRequest(Edit->Window,"Can't play video clips without a Flyer.");
					goto Free;
d316 1
d335 3
a337 2
						ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
						ChangeStatusNode(Edit,(struct EditNode *)PreviousFG,EN_SELECTED); // Select Problem Child
d339 2
a340 4
						if(PreviousEffect==EFFECT_TAKE)
							ContinueRequest(Edit->Window,"Can't sequence. Effect starts too early.");
							else ContinueRequest(Edit->Window,"Effect starts too soon after previous effect.");
						goto Free;
d344 3
a346 4
						ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
						ChangeStatusNode(Edit,(struct EditNode *)PreviousFG,EN_SELECTED); // Select Problem Child
						ContinueRequest(Edit->Window,"Effect ends too late.");
						goto Free;
d349 3
a351 1
// Extend previous videos outpoint
a352 3

						PreviousVideo->Duration += (length-FXadvance);

d354 3
a356 4
							ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
							ChangeStatusNode(Edit,(struct EditNode *)PreviousFG,EN_SELECTED); // Select Problem Child
							ContinueRequest(Edit->Window,"Effect can not end after previous clip.");
							goto Free;
d360 3
a362 1
// Extend current videos inpoint
d365 1
a365 1
						
d367 3
a369 4
							ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
							ChangeStatusNode(Edit,(struct EditNode *)PreviousFG,EN_SELECTED); // Select Problem Child
							ContinueRequest(Edit->Window,"Effect can not start before following clip.");
							goto Free;
d373 3
a375 1
						CurrentVideo->Duration += FXadvance;
d378 2
d384 1
d399 1
a406 1
		}
d408 2
d412 2
a413 1
	}
d416 6
a421 1
	Event->Field = CurrentField;
@


2.26
log
@Changed SendSwitcherReply calls to work with new ESParams structures.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.25 1994/08/27 15:56:56 CACHELIN4000 Exp Kell $
d5 3
d165 8
d197 8
a204 1
#define FXSIZEFUDGE 8
d210 1
a210 1
	struct ExtFastGadget *FG, *PreviousFG;
d212 2
a213 2
	ULONG SeqMemSize, length, EndOfEffect=0, EndOfVideo;
	UWORD	PreviousTrack=TRACK_START, count=0;
d229 1
a229 1
		count++;
a263 6
// Hack so effects always start at end of clips ****!!!!*****
			DUMPUDECL	("old duration",(LONG)PreviousVideo->Duration,"\\");

			PreviousVideo->Duration += GetNumFields(FG);

			DUMPUDECL	("new duration",(LONG)PreviousVideo->Duration,"\\");
a265 1
			PreviousFG=FG;
d277 7
d288 1
a288 1
				DUMPMSG("SELECTQ VIDEO");
d292 1
a292 1
				Event->Field = 0;	//as soon as possible;
d294 1
a294 3
				Event->StartTime = CurrentField;
				Event->StartPoint = GetStartField(FG);	 // was GetStartPoint!!!!
				Event->Duration = GetDuration(FG);
d296 2
d299 1
a299 5

   			DUMPUDECL	("Selectq VIDEO duration",(LONG)Event->Duration,"\\");

				EndOfVideo= CurrentField+(Event->Duration);

d304 1
a304 1
					DUMPMSG("Previous track was transition. So SELECTQ FX");
d306 2
a312 1
						length=GetNumFields(PreviousFG);
d315 1
a315 1
					Event->Field = CurrentField-((length-((GetDelay(PreviousFG)*length)/32768))/2);
d319 11
a329 1
					if((Event->Field) < EndOfEffect) {
d331 2
a332 2
						ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
						ContinueRequest(Edit->Window,"Can't sequence. Effect starts too early.");
d336 30
a365 1
					EndOfEffect=(Event->Field)+length+FXSIZEFUDGE;
d369 1
a369 2
// use the built in fades/take to bring in the video
					DUMPMSG("Previous track not transition, So AUTO VIDEO.");
a370 3
// Hack so effects always start at end of clips ****!!!!*****
					if (PreviousVideo && GetFadeInVideo(FG)) PreviousVideo->Duration += GetNumFields(FG);

d375 1
a375 1
					DUMPSDECL("Auto VIDEO at ",Event->Field,"\\");
d378 1
a378 1
					if(GetFadeInVideo(FG))	EndOfEffect+=(GetNumFields(FG)+FXSIZEFUDGE);
d380 1
a380 1
//					DUMPUDECL("FRAMSTORE EndOfEffect",EndOfEffect,"\\");
a384 7
				if(EndOfEffect > CurrentField) {
					ChangeStatusList(Edit,EN_NOT_STATUS,EN_NORMAL); // de-select all
					ChangeStatusNode(Edit,(struct EditNode *)FG,EN_SELECTED); // Select Problem Child
					ContinueRequest(Edit->Window,"Can't sequence. Effect ends too late.");
					goto Free;
				}

a387 1
				PreviousFG=FG;
d391 1
@


2.25
log
@Add HandleStop function for Project Stop Gadget
@
text
@d3 5
a7 2
* $Id: Sequence.c,v 2.24 94/08/26 21:49:10 Kell Exp Locker: CACHELIN4000 $
* $Log:	Sequence.c,v $
d138 2
d148 3
a150 1
	return((ULONG)SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_NumFields,0));
d156 3
a158 1
	return((ULONG)SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_Duration,0));
d164 3
a166 1
	return(SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_Delay,0));
d172 3
a174 1
	return((BOOL)SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_FadeInVideo,0));
d180 3
a182 1
	return((BOOL)SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_ClipStartField,0));
d361 1
a361 1
	SendSwitcherReply(ES_StartSeq,NULL,NULL,NULL);	//set bit 4 of TB_DisplayRenderMode
d367 1
a367 1
	SendSwitcherReply(ES_StopSeq,NULL,NULL,NULL);	//clr bit 4 of TB_DisplayRenderMode
d399 1
a399 1
	SendSwitcherReply(ES_StopSeq,NULL,NULL,NULL);	//clr bit 4 of TB_DisplayRenderMode
@


2.24
log
@Removed working with some obsolete Flyer tag items
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.23 1994/06/04 02:28:58 Kell Exp Kell $
* $Log: sequence.c,v $
d377 12
@


2.23
log
@Now using FGC_SELECT and FGC_TOMAIN (instead of SELECTQ / AUTO) when sequencing.
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.22 94/03/29 18:48:30 Kell Exp Locker: Kell $
* $Log:	sequence.c,v $
d162 1
a162 1
ULONG __regargs GetStartPoint(struct ExtFastGadget *FG)
d164 1
a164 1
	return((ULONG)SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_ClipStartPoint,0));
d259 1
a259 1
				Event->StartPoint = GetStartPoint(FG);
@


2.22
log
@Sequencing fixed for NAB.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.21 94/03/20 04:00:41 CACHELIN4000 Exp Locker: Kell $
d5 3
d115 1
a115 1
	WORD MsgType;	// FGC_SELECTQ or FGC_AUTO
d122 2
a123 2
#define FGC_SELECTQ 8
#define FGC_AUTO 4
d252 1
a252 1
				Event->MsgType = FGC_SELECTQ;
d272 1
a272 1
					Event->MsgType = FGC_SELECTQ;
d278 1
a278 1
					Event->MsgType = FGC_AUTO;
d301 1
a301 1
					Event->MsgType = FGC_AUTO;
@


2.21
log
@Select Error crouton... see ChangeStatusList()
@
text
@d3 5
a7 2
* $Id: Sequence.c,v 2.20 94/03/19 13:16:02 Kell Exp Locker: CACHELIN4000 $
* $Log:	Sequence.c,v $
d110 2
a111 2
	struct ExtFastGadget *FG;
	LONG Field;		// -1 is end of table	= FGC command time
d126 4
a129 1
VOID __asm PlaySequence(register __a0 struct Event *First);
d150 14
d169 2
a170 2
	struct Event *Event, *Sequence;
	ULONG SeqMemSize, length, EndOfEffect=0;
d176 1
a176 1
	SeqMemSize = (sizeof(struct Event) * ((SingleListLength((struct FastGadget *)FG)*2)+1));
d181 4
d198 1
a198 1
			DUMPHEXIL("FX FG->ObjectType",(LONG)(FG->ObjectType),"\\");
a201 1
					ContinueRequest(Edit->Window,"Can't end sequence with an Effect.");
d204 1
a208 1
					ContinueRequest(Edit->Window,"Can't start sequence with an Effect.");
d211 1
a215 1
					ContinueRequest(Edit->Window,"Can't sequence two Effects in a row.");
d218 1
d223 5
a227 3
			Event--;
			Event->Duration += GetNumFields(FG);
			Event++;
d237 2
d246 1
a246 2
				DUMPHEXIL("VID FG->ObjectType",(LONG)(FG->ObjectType),"\\");
				DUMPMSG("Select FRAME");
d251 1
d253 9
d266 1
a266 2
				DUMPMSG("Previous track was transition");
				DUMPMSG("Select FX");
d273 1
a275 2

					length=GetNumFields(PreviousFG);
d278 1
a278 1
					DUMPSDECL("Auto FX at",Event->Field,"\\");
d287 2
a288 2
					EndOfEffect=(Event->Field)+length;
					DUMPUDECL("Transition EndOfEffect",EndOfEffect,"\\");
d292 4
a295 2
				DUMPMSG("Previous track not transition");
				DUMPMSG("Auto FRAME");
d301 1
a301 1
					DUMPSDECL("Auto FRAME at",Event->Field,"\\");
d303 4
a306 2
					EndOfEffect=CurrentField+GetNumFields(FG);
					DUMPUDECL("FRAMSTORE EndOfEffect",EndOfEffect,"\\");
d309 1
a309 3
				Event->Duration = GetDuration(FG);
				CurrentField+= Event->Duration;
				DUMPUDECL("New CurrentField=",CurrentField,"\\");
d319 1
d328 2
a329 1
	Event->Field = -1;
d331 2
a332 1
  	DUMPMEM("Sequence=",(UBYTE *)Sequence,SeqMemSize);
d334 3
a336 1
	DUMPMSG("Before HandlePlay() sends ES_StartSeq");
d338 1
a338 1
	DUMPMSG("  After HandlePlay() sent ES_StartSeq");
d340 1
a340 1
	PlaySequence(Sequence);
d342 1
a342 1
	DUMPMSG("Before HandlePlay() sends ES_StopSeq");
d344 1
a344 1
	DUMPMSG("  After HandlePlay() sent ES_StopSeq");
d356 2
@


2.20
log
@New sequences the new Control crouton type.
@
text
@d3 5
a7 2
* $Id: sequence.c,v 2.19 94/03/19 09:10:49 Kell Exp Locker: Kell $
* $Log:	sequence.c,v $
d164 1
a164 1
		DUMPUDECW("*************** COUNT=",(WORD)count,"\\");		
d179 2
d183 1
a183 1
	
d186 2
d193 2
d202 1
a202 1
			
d227 1
a227 1
				if(PreviousTrack==TRACK_TRANS) {				
d246 2
d259 1
a259 1
	
d266 1
a266 1
					EndOfEffect=CurrentField+GetNumFields(FG);				
d269 1
a269 1
				
d273 1
a273 1
	
d275 2
@


2.19
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.18 94/03/18 18:08:17 Kell Exp Locker: Kell $
d5 3
d207 1
@


2.18
log
@Now supports lenthening clips for duration of transitions
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.17 94/03/18 09:26:53 Kell Exp Locker: Kell $
d5 3
@


2.17
log
@Better timing on DHD clips.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.16 94/03/18 04:44:47 Kell Exp Locker: Kell $
d5 3
d99 1
a99 1
	LONG Field;		// -1 is end of table	= command time
d102 3
a104 1
	LONG StartTime;	// = play time for sequences						
d183 5
a233 1
					Event++;
a244 1
					Event++;
d252 2
a253 1
				CurrentField+=GetDuration(FG);
d261 1
@


2.16
log
@Renamed Flier to Flyer
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.15 94/03/17 09:49:24 Kell Exp Locker: Kell $
d5 3
d96 1
a96 1
	LONG Field;		// -1 is end of table
d99 1
a99 1
	LONG LExtra;
d198 1
@


2.15
log
@Working logic for sequencing Frames and FX.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.14 94/03/16 17:36:32 Kell Exp Locker: Kell $
d5 3
d104 1
a104 1
extern struct Library 	 *FlierBase;
d182 2
a183 2
				if (!FlierBase) {
					ContinueRequest(Edit->Window,"Can't play video clips without a Flier.");
@


2.14
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.13 94/03/16 16:56:17 Kell Exp Locker: Kell $
d5 3
d131 1
a131 1
	UWORD	PreviousTrack=TRACK_START;
d142 4
d153 4
d186 3
d196 2
d209 2
a210 1
					Event++;
d217 1
d219 1
d223 3
a225 1
		
d231 2
d234 1
d238 2
a239 2

/****************
a243 1
***************/
d247 1
a247 1
		break;
@


2.13
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.11 94/03/16 14:19:37 Kell Exp Locker: Kell $
d5 3
a190 1
// THIS NEEDS SOME WORK & ERROR CHECKING
d192 1
a192 1
					Event->Field = CurrentField-(length-((GetDelay(PreviousFG)*length/32768)/2));
a194 1
/*************************
a198 1
************************/
@


2.12
log
@Checks added for effects starting/ending too early/late
Checks for Flier when trying Video sequencing
@
text
@d193 1
d198 1
d215 1
d220 1
@


2.11
log
@New code.  Total rewrite.
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.10 94/03/16 11:49:55 Kell Exp Locker: Kell $
d5 3
d95 1
d100 7
a106 1
LONG __regargs GetNumFields(struct ExtFastGadget *FG)
d108 1
a108 1
	return(SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_NumFields,0));
d112 1
a112 1
LONG __regargs GetDuration(struct ExtFastGadget *FG)
d114 1
a114 1
	return(SendSwitcherReply(ES_GetValue,(LONG)FG,0x80000000|TAG_Duration,0));
d124 1
a124 1
	ULONG SeqMemSize;
d144 1
a144 1
					ContinueRequest(Edit->Window,"Can't end sequence with an Effect");
d149 1
a149 1
					ContinueRequest(Edit->Window,"Can't start sequence with an Effect");
d154 1
a154 1
					ContinueRequest(Edit->Window,"Can't sequence two Effects in a row");
a163 1
		case CT_FRAMESTORE:
d165 5
d171 1
d189 2
a190 1
					Event->Field = CurrentField-(GetNumFields(PreviousFG)/2);
d192 7
d207 2
a208 1
				
d212 6
@


2.10
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.9 94/03/16 11:48:19 Kell Exp Locker: Kell $
d5 3
d60 2
a76 2
#define END_BLACK 60

a78 3
enum { DEF_FADE, DEF_TAKE, DEF_BLACK };
struct FastGadget **DefaultFG = NULL;

d80 1
a80 1
	struct FastGadget *FG;
d90 2
a91 3
extern struct FastGadget **PtrProject;
extern struct SmartString *BottomPath;
extern struct Library *ToasterBase;
d93 1
a93 3
struct Event *Sequence=NULL;
UWORD SeqLength=0;
ULONG SeqMemSize=0;
d95 5
a99 1
VOID __asm PlaySequence(register __a0 struct Event *First);
d102 1
a102 1
LONG __regargs GetFieldLen(struct FastGadget *FG)
d104 1
a104 18
	LONG A = 69;
/*
	switch(((struct ExtFastGadget *)FG)->FCountMode & 0x3) {
		case 0x3: // slow
			A = ((struct ExtFastGadget *)FG)->SlowFCount;
			break;
		case 0x0: // medium
			A = ((struct ExtFastGadget *)FG)->MedFCount;
			break;
		case 0x1: // fast
			A = ((struct ExtFastGadget *)FG)->FastFCount;
			break;
		case 0x2: // variable
			A = ((struct ExtFastGadget *)FG)->FCountMode;
			A = (A & 0xfffc) >> 2;
	}
*/
	return(A);
d111 11
a121 4
	LONG CurField=0,OverLen,LastOverLen=0;
	struct FastGadget *First,*FG,*LastOverlap=NULL,*LastVideo=NULL;
	struct Event *Event;
	char *C;
a122 5
	if ((!PtrProject) || (!(First = *PtrProject))) goto Exit;
	SeqLength = SingleListLength(First);
	SeqMemSize = (sizeof(struct Event) * (SeqLength+1) * 3);
	if (!(Sequence = SafeAllocMem(SeqMemSize,MEMF_CLEAR)))
		goto Exit;
d124 1
a124 1
	FG = First;
d126 15
a140 6
		switch(FG->Flags2) {
//*****************************************
		case CR_Overlap:
			if (LastOverlap) {
				ContinueRequest(Edit->Window,"Error: two effects in a row.");
				goto Free;
a141 9
			LastOverlap = FG;
		break;

//*****************************************
		case CR_VidEvent:
		VidEvent:
			if (LastVideo) {
				if (!LastOverlap) LastOverlap = DefaultFG[DEF_TAKE];
				OverLen = GetFieldLen(LastOverlap);
d143 2
a144 4
// AAR -- FRZLOOP 
#ifdef FRZLOOP
				if ((OverLen > LastVideo->FieldCount) ||
					(OverLen > FG->FieldCount)) {
					ContinueRequest(Edit->Window,"Not enough video for effect");
d146 1
a146 2
				}
#endif
d148 3
a150 4
				Event->FG = FG;
				Event->MsgType = FGC_SELECTQ;
				Event->Field = CurField;
				Event++;
a151 4
				Event->FG = LastOverlap;
				Event->MsgType = FGC_SELECTQ;
				Event->Field = CurField;
				Event++;
d153 3
a155 7
				Event->FG = LastOverlap;
				Event->MsgType = FGC_AUTO;
//!!!!!!!!				Event->Field = CurField + (LastVideo->FieldCount - OverLen);
				Event++;
	
//!!!!!!!!				CurField += LastVideo->FieldCount - LastOverLen;
				LastOverLen = OverLen;
a156 3
// if no previous video (first video event), start (take) it at seq start
			} else {
				if (!LastOverlap) LastOverlap = DefaultFG[DEF_TAKE];
d159 1
a159 1
				Event->Field = CurField;
d162 10
a171 4
				Event->FG = LastOverlap;
				Event->MsgType = FGC_SELECTQ;
				Event->Field = CurField;
				Event++;
d173 17
a189 9
				Event->FG = LastOverlap;
				Event->MsgType = FGC_AUTO;
				Event->Field = CurField;
				Event++;
	
				// CurField += FG->FieldCount;
			}
			LastVideo = FG;
			LastOverlap = NULL;
a190 3

//*****************************************
		//case CR_Other:
d193 1
a193 1
		FG = FG->NextGadget;
a195 9
// if end with effect (instead of video), use black as final video event
#ifdef ASDFG
	if (LastOverlap) {
		FG = DefaultFG[DEF_BLACK];
		FG->FieldCount = GetFieldLen(LastOverlap) + END_BLACK;
		goto VidEvent;
	}
#endif

d198 1
a198 6
	if ((C=GetCString(BottomPath)) && (C[0] == 'r'))
	{
	   DUMPMEM("Sequence=",(UBYTE *)Sequence,SeqMemSize);
		DUMPMSG("Before HandlePlay() sends ES_StartSeq");
		SendSwitcherReply(ES_StartSeq,NULL,NULL,NULL);
	}
d200 2
d203 1
d205 1
d207 1
a207 1
	SendSwitcherReply(ES_StopSeq,NULL,NULL,NULL);
d215 1
a218 1
	Event->Field = -1;
@


2.9
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.7 94/03/16 11:38:44 Kell Exp Locker: Kell $
d5 3
d177 1
a177 1
				Event->Field = CurField + (LastVideo->FieldCount - OverLen);
@


2.8
log
@*** empty log message ***
@
text
@d177 1
a177 1
				CurField += LastVideo->FieldCount - LastOverLen;
@


2.7
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.6 94/03/15 22:17:40 Kell Exp Locker: Kell $
d5 3
d154 1
a154 1
/*******************
d160 1
a160 2
*******************\

@


2.6
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.5 94/03/13 07:48:56 Kell Exp Locker: Kell $
d5 3
d150 2
d157 2
@


2.5
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.4 94/03/11 09:32:28 Kell Exp Locker: Kell $
d5 3
@


2.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
* $Id: sequence.c,v 2.3 94/03/05 21:03:53 CACHELIN4000 Exp Locker: Kell $
d5 3
d57 1
a57 1
#define SERDEBUG	1
d211 1
d213 3
a216 2
	DUMPMSG("Before HandlePlay() sends ES_StartSeq");
	SendSwitcherReply(ES_StartSeq,NULL,NULL,NULL);
@


2.3
log
@*** empty log message ***
@
text
@Binary files sequence.c and t:,RCSt1A70a64d0 differ
@


2.2
log
@*** empty log message ***
@
text
@Binary files sequence.c and t:,RCSt1A710dc80 differ
@


2.1
log
@*** empty log message ***
@
text
@Binary files Sequence.c and t:,RCSt1A70c3480 differ
@


2.0
log
@FirstCheckIn
@
text
@Binary files Sequence.c and t:,RCSt1A70c0270 differ
@
